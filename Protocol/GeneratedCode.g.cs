// Auto-generated code
// <auto-generated>This is auto-generated code by DIS. Do not modify.</auto-generated>
#pragma warning disable CS1591
namespace Skyline.DataMiner.CICD.Models.Protocol.Enums
{
    using System;

    ///<summary>
    /// Specifies the type of item on which the action is performed.
    ///</summary>
public enum EnumActionOn
    {
        Command,
        Group,
        Pair,
        Parameter,
        Protocol,
        Response,
        Timer
    }

    public static partial class EnumActionOnConverter
    {
        public static EnumActionOn? Convert(string input)
        {
            if (String.Equals(input, "command", StringComparison.OrdinalIgnoreCase))
                return EnumActionOn.Command;
            else if (String.Equals(input, "group", StringComparison.OrdinalIgnoreCase))
                return EnumActionOn.Group;
            else if (String.Equals(input, "pair", StringComparison.OrdinalIgnoreCase))
                return EnumActionOn.Pair;
            else if (String.Equals(input, "parameter", StringComparison.OrdinalIgnoreCase))
                return EnumActionOn.Parameter;
            else if (String.Equals(input, "protocol", StringComparison.OrdinalIgnoreCase))
                return EnumActionOn.Protocol;
            else if (String.Equals(input, "response", StringComparison.OrdinalIgnoreCase))
                return EnumActionOn.Response;
            else if (String.Equals(input, "timer", StringComparison.OrdinalIgnoreCase))
                return EnumActionOn.Timer;
            return null;
        }

        public static string ConvertBack(EnumActionOn? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumActionOn.Command:
                    return "command";
                case EnumActionOn.Group:
                    return "group";
                case EnumActionOn.Pair:
                    return "pair";
                case EnumActionOn.Parameter:
                    return "parameter";
                case EnumActionOn.Protocol:
                    return "protocol";
                case EnumActionOn.Response:
                    return "response";
                case EnumActionOn.Timer:
                    return "timer";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the action type.
    ///</summary>
public enum EnumActionType
    {
        AddToExecute,
        Aggregate,
        Append,
        AppendData,
        ChangeLength,
        Clear,
        ClearLengthInfo,
        ClearOnDisplay,
        Close,
        Copy,
        CopyReverse,
        Crc,
        CreateElement,
        Execute,
        ExecuteNext,
        ExecuteOne,
        ExecuteOneTop,
        ExecuteOneNow,
        ForceExecute,
        Go,
        Increment,
        Length,
        Lock,
        Make,
        Merge,
        Multiply,
        Normalize,
        Open,
        Pow,
        PriorityLock,
        PriorityUnlock,
        Read,
        ReadFile,
        ReadStuffing,
        Replace,
        ReplaceData,
        ///<summary>
        /// Reschedules the timer groups.
        /// Feature introduced in DataMiner 8.5.3 (RN 9189).
        ///</summary>
Reschedule,
        RestartTimer,
        Reverse,
        RunActions,
        Save,
        Set,
        SetAndGetWithWait,
        SetInfo,
        SetNext,
        SetWithWait,
        Sleep,
        Start,
        Stop,
        StopCurrentGroup,
        Stuffing,
        SwapColumn,
        Timeout,
        Unlock,
        Wmi
    }

    public static partial class EnumActionTypeConverter
    {
        public static EnumActionType? Convert(string input)
        {
            if (String.Equals(input, "add to execute", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.AddToExecute;
            else if (String.Equals(input, "aggregate", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Aggregate;
            else if (String.Equals(input, "append", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Append;
            else if (String.Equals(input, "append data", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.AppendData;
            else if (String.Equals(input, "change length", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ChangeLength;
            else if (String.Equals(input, "clear", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Clear;
            else if (String.Equals(input, "clear length info", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ClearLengthInfo;
            else if (String.Equals(input, "clear on display", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ClearOnDisplay;
            else if (String.Equals(input, "close", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Close;
            else if (String.Equals(input, "copy", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Copy;
            else if (String.Equals(input, "copy reverse", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.CopyReverse;
            else if (String.Equals(input, "crc", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Crc;
            else if (String.Equals(input, "create element", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.CreateElement;
            else if (String.Equals(input, "execute", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Execute;
            else if (String.Equals(input, "execute next", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ExecuteNext;
            else if (String.Equals(input, "execute one", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ExecuteOne;
            else if (String.Equals(input, "execute one top", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ExecuteOneTop;
            else if (String.Equals(input, "execute one now", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ExecuteOneNow;
            else if (String.Equals(input, "force execute", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ForceExecute;
            else if (String.Equals(input, "go", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Go;
            else if (String.Equals(input, "increment", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Increment;
            else if (String.Equals(input, "length", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Length;
            else if (String.Equals(input, "lock", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Lock;
            else if (String.Equals(input, "make", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Make;
            else if (String.Equals(input, "merge", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Merge;
            else if (String.Equals(input, "multiply", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Multiply;
            else if (String.Equals(input, "normalize", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Normalize;
            else if (String.Equals(input, "open", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Open;
            else if (String.Equals(input, "pow", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Pow;
            else if (String.Equals(input, "priority lock", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.PriorityLock;
            else if (String.Equals(input, "priority unlock", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.PriorityUnlock;
            else if (String.Equals(input, "read", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Read;
            else if (String.Equals(input, "read file", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ReadFile;
            else if (String.Equals(input, "read stuffing", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ReadStuffing;
            else if (String.Equals(input, "replace", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Replace;
            else if (String.Equals(input, "replace data", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.ReplaceData;
            else if (String.Equals(input, "reschedule", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Reschedule;
            else if (String.Equals(input, "restart timer", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.RestartTimer;
            else if (String.Equals(input, "reverse", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Reverse;
            else if (String.Equals(input, "run actions", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.RunActions;
            else if (String.Equals(input, "save", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Save;
            else if (String.Equals(input, "set", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Set;
            else if (String.Equals(input, "set and get with wait", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.SetAndGetWithWait;
            else if (String.Equals(input, "set info", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.SetInfo;
            else if (String.Equals(input, "set next", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.SetNext;
            else if (String.Equals(input, "set with wait", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.SetWithWait;
            else if (String.Equals(input, "sleep", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Sleep;
            else if (String.Equals(input, "start", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Start;
            else if (String.Equals(input, "stop", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Stop;
            else if (String.Equals(input, "stop current group", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.StopCurrentGroup;
            else if (String.Equals(input, "stuffing", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Stuffing;
            else if (String.Equals(input, "swap column", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.SwapColumn;
            else if (String.Equals(input, "timeout", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Timeout;
            else if (String.Equals(input, "unlock", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Unlock;
            else if (String.Equals(input, "wmi", StringComparison.OrdinalIgnoreCase))
                return EnumActionType.Wmi;
            return null;
        }

        public static string ConvertBack(EnumActionType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumActionType.AddToExecute:
                    return "add to execute";
                case EnumActionType.Aggregate:
                    return "aggregate";
                case EnumActionType.Append:
                    return "append";
                case EnumActionType.AppendData:
                    return "append data";
                case EnumActionType.ChangeLength:
                    return "change length";
                case EnumActionType.Clear:
                    return "clear";
                case EnumActionType.ClearLengthInfo:
                    return "clear length info";
                case EnumActionType.ClearOnDisplay:
                    return "clear on display";
                case EnumActionType.Close:
                    return "close";
                case EnumActionType.Copy:
                    return "copy";
                case EnumActionType.CopyReverse:
                    return "copy reverse";
                case EnumActionType.Crc:
                    return "crc";
                case EnumActionType.CreateElement:
                    return "create element";
                case EnumActionType.Execute:
                    return "execute";
                case EnumActionType.ExecuteNext:
                    return "execute next";
                case EnumActionType.ExecuteOne:
                    return "execute one";
                case EnumActionType.ExecuteOneTop:
                    return "execute one top";
                case EnumActionType.ExecuteOneNow:
                    return "execute one now";
                case EnumActionType.ForceExecute:
                    return "force execute";
                case EnumActionType.Go:
                    return "go";
                case EnumActionType.Increment:
                    return "increment";
                case EnumActionType.Length:
                    return "length";
                case EnumActionType.Lock:
                    return "lock";
                case EnumActionType.Make:
                    return "make";
                case EnumActionType.Merge:
                    return "merge";
                case EnumActionType.Multiply:
                    return "multiply";
                case EnumActionType.Normalize:
                    return "normalize";
                case EnumActionType.Open:
                    return "open";
                case EnumActionType.Pow:
                    return "pow";
                case EnumActionType.PriorityLock:
                    return "priority lock";
                case EnumActionType.PriorityUnlock:
                    return "priority unlock";
                case EnumActionType.Read:
                    return "read";
                case EnumActionType.ReadFile:
                    return "read file";
                case EnumActionType.ReadStuffing:
                    return "read stuffing";
                case EnumActionType.Replace:
                    return "replace";
                case EnumActionType.ReplaceData:
                    return "replace data";
                case EnumActionType.Reschedule:
                    return "reschedule";
                case EnumActionType.RestartTimer:
                    return "restart timer";
                case EnumActionType.Reverse:
                    return "reverse";
                case EnumActionType.RunActions:
                    return "run actions";
                case EnumActionType.Save:
                    return "save";
                case EnumActionType.Set:
                    return "set";
                case EnumActionType.SetAndGetWithWait:
                    return "set and get with wait";
                case EnumActionType.SetInfo:
                    return "set info";
                case EnumActionType.SetNext:
                    return "set next";
                case EnumActionType.SetWithWait:
                    return "set with wait";
                case EnumActionType.Sleep:
                    return "sleep";
                case EnumActionType.Start:
                    return "start";
                case EnumActionType.Stop:
                    return "stop";
                case EnumActionType.StopCurrentGroup:
                    return "stop current group";
                case EnumActionType.Stuffing:
                    return "stuffing";
                case EnumActionType.SwapColumn:
                    return "swap column";
                case EnumActionType.Timeout:
                    return "timeout";
                case EnumActionType.Unlock:
                    return "unlock";
                case EnumActionType.Wmi:
                    return "wmi";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the chains filter layout.
    ///</summary>
public enum EnumChainsFilters
    {
        ///<summary>
        /// Horizontal filter layout (Default).
        ///</summary>
Horizontal,
        ///<summary>
        /// Vertical filter layout.
        ///</summary>
Vertical
    }

    public static partial class EnumChainsFiltersConverter
    {
        public static EnumChainsFilters? Convert(string input)
        {
            if (String.Equals(input, "horizontal", StringComparison.OrdinalIgnoreCase))
                return EnumChainsFilters.Horizontal;
            else if (String.Equals(input, "vertical", StringComparison.OrdinalIgnoreCase))
                return EnumChainsFilters.Vertical;
            return null;
        }

        public static string ConvertBack(EnumChainsFilters? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumChainsFilters.Horizontal:
                    return "horizontal";
                case EnumChainsFilters.Vertical:
                    return "vertical";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the column option type.
    ///</summary>
public enum EnumColumnOptionType
    {
        ///<summary>
        /// Auto-incremented value.
        ///</summary>
Autoincrement,
        ///<summary>
        /// Concatenates the values of the columns specified in the values attribute.
        ///</summary>
Concatenation,
        ///<summary>
        /// Indicates that the content of the column will be managed in the protocol.
        ///</summary>
Custom,
        ///<summary>
        /// DataMiner will automatically fill in this column with the display key.
        ///</summary>
Displaykey,
        ///<summary>
        /// Used when retrieving SNMP or WMI tables. It contains the row number.
        ///</summary>
Index,
        ///<summary>
        /// This type is used in the following situations:
        /// - To populate a column with a call to DataMiner using NotifyProtocol type 220 call (NT_FILL_ARRAY_WITH_COLUMN)
        /// - To perform a merge action.
        /// - To perform an aggregate action.
        /// -  To perform a swap action.
        /// 
        ///</summary>
Retrieved,
        ///<summary>
        /// Represents an SNMP column.
        ///</summary>
Snmp,
        ///<summary>
        /// The state column is a column that can be used when retrieving SNMP or WMI tables, or tables consisting of retrieved columns. When, for example, a row is removed between two get operations, this cell will be set to “deleted”.
        /// Possible values for this cell are: Updated (1), Equal (2), New (3), Deleted (4), Recreated (5)
        /// With this column type, you can extend the options attribute with the value “delete”. If you do so, deleted rows will be automatically removed from the dynamic table. When you do not specify the “delete” option, deleted rows will stay in the table.
        ///</summary>
State,
        ///<summary>
        /// If a direct view column containing primary keys is of type “viewTableKey”, then those primary keys will be added a ‘DataMinerAgentID_ElementID_’ prefix referring to the source element that supplied the data.
        /// This allows to retrieve the correct data from a direct view table if the tables in the source elements do not have unique primary keys.
        /// Feature introduced in DataMiner 9.0.0 (RN 13582).
        ///</summary>
ViewTableKey
    }

    public static partial class EnumColumnOptionTypeConverter
    {
        public static EnumColumnOptionType? Convert(string input)
        {
            if (String.Equals(input, "autoincrement", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.Autoincrement;
            else if (String.Equals(input, "concatenation", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.Concatenation;
            else if (String.Equals(input, "custom", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.Custom;
            else if (String.Equals(input, "displaykey", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.Displaykey;
            else if (String.Equals(input, "index", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.Index;
            else if (String.Equals(input, "retrieved", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.Retrieved;
            else if (String.Equals(input, "snmp", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.Snmp;
            else if (String.Equals(input, "state", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.State;
            else if (String.Equals(input, "viewTableKey", StringComparison.OrdinalIgnoreCase))
                return EnumColumnOptionType.ViewTableKey;
            return null;
        }

        public static string ConvertBack(EnumColumnOptionType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumColumnOptionType.Autoincrement:
                    return "autoincrement";
                case EnumColumnOptionType.Concatenation:
                    return "concatenation";
                case EnumColumnOptionType.Custom:
                    return "custom";
                case EnumColumnOptionType.Displaykey:
                    return "displaykey";
                case EnumColumnOptionType.Index:
                    return "index";
                case EnumColumnOptionType.Retrieved:
                    return "retrieved";
                case EnumColumnOptionType.Snmp:
                    return "snmp";
                case EnumColumnOptionType.State:
                    return "state";
                case EnumColumnOptionType.ViewTableKey:
                    return "viewTableKey";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the KPI value alignment.
    ///</summary>
public enum EnumCpeAlignment
    {
        ///<summary>
        /// Aligns the KPI value to the left.
        ///</summary>
Left,
        ///<summary>
        /// Centers the KPI value.
        ///</summary>
Center,
        ///<summary>
        /// Aligns the KPI value to the right (default).
        ///</summary>
Right
    }

    public static partial class EnumCpeAlignmentConverter
    {
        public static EnumCpeAlignment? Convert(string input)
        {
            if (String.Equals(input, "left", StringComparison.OrdinalIgnoreCase))
                return EnumCpeAlignment.Left;
            else if (String.Equals(input, "center", StringComparison.OrdinalIgnoreCase))
                return EnumCpeAlignment.Center;
            else if (String.Equals(input, "right", StringComparison.OrdinalIgnoreCase))
                return EnumCpeAlignment.Right;
            return null;
        }

        public static string ConvertBack(EnumCpeAlignment? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumCpeAlignment.Left:
                    return "left";
                case EnumCpeAlignment.Center:
                    return "center";
                case EnumCpeAlignment.Right:
                    return "right";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the period used for database partitioning.
    ///</summary>
public enum EnumDatabasePartition
    {
        ///<summary>
        /// Hour
        ///</summary>
Hour,
        ///<summary>
        /// Day
        ///</summary>
Day,
        ///<summary>
        /// Month
        ///</summary>
Month,
        ///<summary>
        /// Year
        ///</summary>
Year,
        ///<summary>
        /// Infinite (Elastic only)
        ///</summary>
Infinite
    }

    public static partial class EnumDatabasePartitionConverter
    {
        public static EnumDatabasePartition? Convert(string input)
        {
            if (String.Equals(input, "hour", StringComparison.OrdinalIgnoreCase))
                return EnumDatabasePartition.Hour;
            else if (String.Equals(input, "day", StringComparison.OrdinalIgnoreCase))
                return EnumDatabasePartition.Day;
            else if (String.Equals(input, "month", StringComparison.OrdinalIgnoreCase))
                return EnumDatabasePartition.Month;
            else if (String.Equals(input, "year", StringComparison.OrdinalIgnoreCase))
                return EnumDatabasePartition.Year;
            else if (String.Equals(input, "infinite", StringComparison.OrdinalIgnoreCase))
                return EnumDatabasePartition.Infinite;
            return null;
        }

        public static string ConvertBack(EnumDatabasePartition? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumDatabasePartition.Hour:
                    return "hour";
                case EnumDatabasePartition.Day:
                    return "day";
                case EnumDatabasePartition.Month:
                    return "month";
                case EnumDatabasePartition.Year:
                    return "year";
                case EnumDatabasePartition.Infinite:
                    return "infinite";
                default:
                    return null;
            }
        }
    }

    public enum EnumDiscreteValue
    {
        ///<summary>
        /// Makes it possible to run a DLL at the click of a button.
        ///</summary>
Dll,
        ///<summary>
        /// Used for buttons that open a URL, an element card, a view card or a service card.
        ///</summary>
Open,
        ///<summary>
        /// When used for buttons that set one or more session variables (which can be used in Visio drawings) to a particular value.
        ///</summary>
Setvar
    }

    public static partial class EnumDiscreteValueConverter
    {
        public static EnumDiscreteValue? Convert(string input)
        {
            if (String.Equals(input, "dll", StringComparison.OrdinalIgnoreCase))
                return EnumDiscreteValue.Dll;
            else if (String.Equals(input, "open", StringComparison.OrdinalIgnoreCase))
                return EnumDiscreteValue.Open;
            else if (String.Equals(input, "setvar", StringComparison.OrdinalIgnoreCase))
                return EnumDiscreteValue.Setvar;
            return null;
        }

        public static string ConvertBack(EnumDiscreteValue? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumDiscreteValue.Dll:
                    return "dll";
                case EnumDiscreteValue.Open:
                    return "open";
                case EnumDiscreteValue.Setvar:
                    return "setvar";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the display type.
    ///</summary>
public enum EnumDisplayType
    {
        ///<summary>
        /// In System Display, the View menu will have an option called "CPE Manager Overview".
        ///</summary>
ElementManager,
        ///<summary>
        /// An extra, fully functional "Spectrum Analyzer" page will be added to the element.
        ///</summary>
SpectrumAnalyzer
    }

    public static partial class EnumDisplayTypeConverter
    {
        public static EnumDisplayType? Convert(string input)
        {
            if (String.Equals(input, "element manager", StringComparison.OrdinalIgnoreCase))
                return EnumDisplayType.ElementManager;
            else if (String.Equals(input, "spectrum analyzer", StringComparison.OrdinalIgnoreCase))
                return EnumDisplayType.SpectrumAnalyzer;
            return null;
        }

        public static string ConvertBack(EnumDisplayType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumDisplayType.ElementManager:
                    return "element manager";
                case EnumDisplayType.SpectrumAnalyzer:
                    return "spectrum analyzer";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the encoding.
    ///</summary>
public enum EnumEncoding
    {
        ///<summary>
        /// ACSII encoding
        ///</summary>
Ascii,
        ///<summary>
        /// Unicode encoding
        ///</summary>
Unicode
    }

    public static partial class EnumEncodingConverter
    {
        public static EnumEncoding? Convert(string input)
        {
            if (String.Equals(input, "ascii", StringComparison.OrdinalIgnoreCase))
                return EnumEncoding.Ascii;
            else if (String.Equals(input, "unicode", StringComparison.OrdinalIgnoreCase))
                return EnumEncoding.Unicode;
            return null;
        }

        public static string ConvertBack(EnumEncoding? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumEncoding.Ascii:
                    return "ascii";
                case EnumEncoding.Unicode:
                    return "unicode";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the general parameter group type.
    ///</summary>
public enum EnumGeneralParameterGroupType
    {
        ///<summary>
        /// Communication parameters
        ///</summary>
Communication,
        ///<summary>
        /// DCF parameters
        ///</summary>
Dcf,
        ///<summary>
        /// Replication parameters
        ///</summary>
Replication,
        ///<summary>
        /// Verification parameters
        ///</summary>
Verification
    }

    public static partial class EnumGeneralParameterGroupTypeConverter
    {
        public static EnumGeneralParameterGroupType? Convert(string input)
        {
            if (String.Equals(input, "communication", StringComparison.OrdinalIgnoreCase))
                return EnumGeneralParameterGroupType.Communication;
            else if (String.Equals(input, "dcf", StringComparison.OrdinalIgnoreCase))
                return EnumGeneralParameterGroupType.Dcf;
            else if (String.Equals(input, "replication", StringComparison.OrdinalIgnoreCase))
                return EnumGeneralParameterGroupType.Replication;
            else if (String.Equals(input, "verification", StringComparison.OrdinalIgnoreCase))
                return EnumGeneralParameterGroupType.Verification;
            return null;
        }

        public static string ConvertBack(EnumGeneralParameterGroupType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumGeneralParameterGroupType.Communication:
                    return "communication";
                case EnumGeneralParameterGroupType.Dcf:
                    return "dcf";
                case EnumGeneralParameterGroupType.Replication:
                    return "replication";
                case EnumGeneralParameterGroupType.Verification:
                    return "verification";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the group type.
    ///</summary>
public enum EnumGroupType
    {
        ///<summary>
        /// The group will be executed at once and run the action.
        ///</summary>
Action,
        ///<summary>
        /// The group will be added to the queue, awaiting execution. On execution, the parameters in the group will be retrieved.
        ///</summary>
Poll,
        ///<summary>
        /// The group will be added to the queue, awaiting execution. On execution, the action will be run.
        ///</summary>
PollAction,
        ///<summary>
        /// The group will be added to the queue, awaiting execution. On execution the trigger will be fired.
        ///</summary>
PollTrigger,
        ///<summary>
        /// The group will be executed at once and fire the trigger.
        ///</summary>
Trigger
    }

    public static partial class EnumGroupTypeConverter
    {
        public static EnumGroupType? Convert(string input)
        {
            if (String.Equals(input, "action", StringComparison.OrdinalIgnoreCase))
                return EnumGroupType.Action;
            else if (String.Equals(input, "poll", StringComparison.OrdinalIgnoreCase))
                return EnumGroupType.Poll;
            else if (String.Equals(input, "poll action", StringComparison.OrdinalIgnoreCase))
                return EnumGroupType.PollAction;
            else if (String.Equals(input, "poll trigger", StringComparison.OrdinalIgnoreCase))
                return EnumGroupType.PollTrigger;
            else if (String.Equals(input, "trigger", StringComparison.OrdinalIgnoreCase))
                return EnumGroupType.Trigger;
            return null;
        }

        public static string ConvertBack(EnumGroupType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumGroupType.Action:
                    return "action";
                case EnumGroupType.Poll:
                    return "poll";
                case EnumGroupType.PollAction:
                    return "poll action";
                case EnumGroupType.PollTrigger:
                    return "poll trigger";
                case EnumGroupType.Trigger:
                    return "trigger";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of headers that can only appear in HTTP responses.
    ///</summary>
public enum EnumHttpRequestHeader
    {
        ///<summary>
        /// The A-IM request-header field is similar to Accept, but restricts the instance-manipulations (section 10.1) that are acceptable in the response.  As specified in section 10.5.2, a response may be the result of applying multiple instance-manipulations (RFC 3229).
        ///</summary>
AIM,
        ///<summary>
        /// Indicates which content types (expressed as MIME types) the client is able to understand.
        ///</summary>
Accept,
        ///<summary>
        /// Indicates which character set the client is able to understand.
        ///</summary>
AcceptCharset,
        ///<summary>
        /// Indicates that the user agent wants to access a past state of an Original Resource.
        ///</summary>
AcceptDatetime,
        ///<summary>
        /// Indicates which content encoding, usually a compression algorithm, the client is able to understand.
        ///</summary>
AcceptEncoding,
        ///<summary>
        /// Can be used by a user agent to give information about the presence or absence of certain features in the feature set of the current request.  Servers can use this information when running a remote variant selection algorithm (RFC 2295).
        ///</summary>
AcceptFeatures,
        ///<summary>
        /// Indicates which languages the client is able to understand, and which locale variant is preferred.
        ///</summary>
AcceptLanguage,
        ///<summary>
        /// Used when issuing a preflight request to let the server know which HTTP headers will be used when the actual request is made.
        ///</summary>
AccessControlRequestHeaders,
        ///<summary>
        /// Used when issuing a preflight request to let the server know which HTTP method will be used when the actual request is made. This header is necessary as the preflight request is always an OPTIONS and doesn't use the same method as the actual request.
        ///</summary>
AccessControlRequestMethod,
        ///<summary>
        /// Lists the set of methods support by a resource.
        ///</summary>
Allow,
        ///<summary>
        /// Clients include the ALPN header field in an HTTP CONNECT request to indicate the application-layer protocol that a client intends to use within the tunnel, or a set of protocols that might be used within the tunnel (RFC 7639).
        ///</summary>
ALPN,
        ///<summary>
        /// The optional Apply-To-Redirect-Ref header can be used on any request to a redirect reference resource.  When it is present and set to "T", the request MUST be applied to the reference resource itself, and a 3xx response MUST NOT be returned (RFC 4437).
        ///</summary>
ApplyToRedirectRef,
        ///<summary>
        /// Contains the credentials to authenticate a user agent with a server, usually after the server has responded with a 401 Unauthorized status and the WWW-Authenticate header.
        ///</summary>
Authorization,
        ///<summary>
        /// (RFC 2774).
        ///</summary>
CMan,
        ///<summary>
        /// Specifies directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.
        ///</summary>
CacheControl,
        ///<summary>
        /// The "CalDAV-Timezones" request header field provides a way for a client to indicate to the server whether it wants "VTIMEZONE" components returned in any iCalendar data that is part of the HTTP response. The value "T" indicates that the client wants time zone data returned; the value "F" indicates that it does not.(RFC 7809).
        ///</summary>
CalDAVTimezones,
        ///<summary>
        /// Allows a client to specify exactly what options it is asking about, and which allows a server to specify exactly what subset of those options are supported.
        ///</summary>
Compliance,
        ///<summary>
        /// Controls whether or not the network connection stays open after the current transaction finishes. If the value sent is keep-alive, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.
        ///</summary>
Connection,
        ///<summary>
        /// The Content-Base entity-header field may be used to specify the base URI for resolving relative URLs within the entity. This header field is described as Base in RFC 1808, which is expected to be revised (RFC 2068).
        ///</summary>
ContentBase,
        ///<summary>
        /// In a regular HTTP response, the Content-Disposition response header is a header indicating if the content is expected to be displayed inline in the browser, that is, as a Web page or as part of a Web page, or as an attachment, that is downloaded and saved locally.
        /// In a multipart/form-data body, the HTTP Content-Disposition general header is a header that can be used on the subpart of a multipart body to give information about the field it applies to.
        ///</summary>
ContentDisposition,
        ///<summary>
        /// Used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body.
        ///</summary>
ContentEncoding,
        ///<summary>
        /// Used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.
        ///</summary>
ContentLanguage,
        ///<summary>
        /// Indicates the size of the entity-body, in bytes, sent to the recipient.
        ///</summary>
ContentLength,
        ///<summary>
        /// Indicates an alternate location for the returned data.
        ///</summary>
ContentLocation,
        ///<summary>
        /// An MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body (RFC 2616).
        ///</summary>
ContentMD5,
        ///<summary>
        /// Indicates the media type of the resource.
        ///</summary>
ContentType,
        ///<summary>
        /// Contains stored HTTP cookies previously sent by the server with the Set-Cookie header.
        ///</summary>
Cookie,
        ///<summary>
        /// (obsolete) Advises the server that the user agent understands "new-style" cookies.
        ///</summary>
Cookie2,
        ///<summary>
        /// Contains the date and time at which the message was originated.
        ///</summary>
Date,
        ///<summary>
        /// The Depth request header is used with methods executed on resources that could potentially have internal members to indicate whether the method is to be applied only to the resource ("Depth: 0"), to the resource and its internal members only ("Depth: 1"), or the resource and all its members ("Depth: infinity") (RFC 4918).
        ///</summary>
Depth,
        ///<summary>
        /// The Destination request header specifies the URI that identifies a destination resource for methods such as COPY and MOVE, which take two URIs as parameters (RFC 4918).
        ///</summary>
Destination,
        ///<summary>
        /// Indicates expectations that need to be fulfilled by the server in order to properly handle the request.
        ///</summary>
Expect,
        ///<summary>
        /// Contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.
        ///</summary>
Forwarded,
        ///<summary>
        /// Contains an Internet email address for a human user who controls the requesting user agent.
        ///</summary>
From,
        ///<summary>
        /// Non-standard header field used by Microsoft applications and load-balancers
        ///</summary>
FrontEndHttps,
        ///<summary>
        /// Specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.
        ///</summary>
Host,
        ///<summary>
        /// A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly one HTTP2-Settings header field. The HTTP2-Settings header field is a connection-specific header field that includes parameters that govern the HTTP/2 connection, provided in anticipation of the server accepting the request to upgrade. A server MUST NOT upgrade the connection to HTTP/2 if this header field is not present or if more than one is present. A server MUST NOT send this header field (RFC 7540).
        ///</summary>
HTTP2Settings,
        ///<summary>
        /// The If request header is intended to have similar functionality to the If-Match header defined in Section 14.24 of [RFC2616].  However, the If header handles any state token as well as ETags.  A typical example of a state token is a lock token, and lock tokens are the only state tokens defined in this specification. (RFC 4918)
        ///</summary>
If,
        ///<summary>
        /// For GET and HEAD methods, the server will send back the requested resource only if it matches one of the listed ETags. For PUT and other non-safe methods, it will only upload the resource in this case.
        ///</summary>
IfMatch,
        ///<summary>
        /// The server will send back the requested resource, with a 200 status, only if it has been last modified after the given date.
        ///</summary>
IfModifiedSince,
        ///<summary>
        /// For GET and HEAD methods, the server will send back the requested resource, with a 200 status, only if it doesn't have an ETag matching the given ones. For other methods, the request will be processed only if the eventually existing resource's ETag doesn't match any of the values listed.
        ///</summary>
IfNoneMatch,
        ///<summary>
        /// If the condition is fulfilled, the range request will be issued and the server sends back a 206 Partial Content answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a 200 OK status.
        ///</summary>
IfRange,
        ///<summary>
        /// The If-Schedule-Tag-Match request header field is used with a method to make it conditional.  Clients can set this header to the value returned in the Schedule-Tag response header, or the CALDAV:schedule-tag property, of a scheduling object resource previously retrieved from the server to avoid overwriting "consequential" changes to the scheduling object resource (RFC 6638).
        ///</summary>
IfScheduleTagMatch,
        ///<summary>
        /// The server will send back the requested resource, or accept it in the case of a POST or another non-safe method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a 412 (Precondition Failed) error.
        ///</summary>
IfUnmodifiedSince,
        ///<summary>
        /// Allows the sender to hint about how the connection may be used and to set a timeout and a maximum amount of requests.
        ///</summary>
KeepAlive,
        ///<summary>
        /// For certain methods (e.g. GET, PROPFIND), if the request-URL identifies a version-controlled resource, a label can be specified in a Label request header to cause the method to be applied to the version selected by that label from the version history of that version-controlled resource (RFC 3253).
        ///</summary>
Label,
        ///<summary>
        /// The Lock-Token request header is used with the UNLOCK method to identify the lock to be removed.  The lock token in the Lock-Token request header MUST identify a lock that contains the resource identified by Request-URI as a member (RFC 4918).
        ///</summary>
LockToken,
        ///<summary>
        /// RFC 2774
        ///</summary>
Man,
        ///<summary>
        /// The Max-Forwards request-header field may be used with the TRACE method (section 14.31) to limit the number of proxies or gateways that can forward the request to the next inbound server. This can be useful when the client is attempting to trace a request chain which appears to be failing or looping in mid-chain (RFC 2068).
        ///</summary>
MaxForwards,
        ///<summary>
        /// Can contain directives for any content negotiation process initiated by the request. (RFC 2295).
        ///</summary>
Negotiate,
        ///<summary>
        /// A non-compliance-option listed in a Non-Compliance response-header field indicates that the proxy server named by the proxy-host value does not support the listed compliance-option.  The set of non-compliance options SHOULD be a subset of the compliance-options listed in a Compliance header field of the forwarded message.
        ///</summary>
NonCompliance,
        ///<summary>
        /// RFC 2774
        ///</summary>
Opt,
        ///<summary>
        /// The Optional request-header allows a client to declare itself to support WIRE (https://tools.ietf.org/html/draft-girod-w3-id-res-ext-00).
        ///</summary>
Optional,
        ///<summary>
        /// When a collection is created, the client MAY request that it be ordered and specify the semantics of the ordering by using the new Ordering-Type header (defined below) with a MKCOL request (RFC 3648).
        ///</summary>
OrderingType,
        ///<summary>
        /// Indicates where a fetch originates from.
        ///</summary>
Origin,
        ///<summary>
        /// The Overwrite request header specifies whether the server should overwrite a resource mapped to the destination URL during a COPY or MOVE (RFC 4918).
        ///</summary>
Overwrite,
        ///<summary>
        /// When a new member is added to a collection with a client-maintained ordering (for example, with PUT, COPY, or MKCOL), its position in the ordering can be set with the new Position header (RFC 3648).
        ///</summary>
Position,
        ///<summary>
        /// An implementation-specific header that may have various effects along the request-response chain.
        ///</summary>
Pragma,
        ///<summary>
        /// The Prefer request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request (RFC 7240).
        ///</summary>
Prefer,
        ///<summary>
        /// Used in implementation of OPS Over HTTP (https://www.w3.org/TR/NOTE-OPS-OverHTTP).
        ///</summary>
ProfileObject,
        ///<summary>
        /// PICS 1.1 Label Distribution - Label Syntax and Communication Protocols (https://www.w3.org/standards/history/REC-PICS-labels).
        ///</summary>
ProtocolRequest,
        ///<summary>
        /// Contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a 407 Proxy Authentication Required status and the Proxy-Authenticate header.
        ///</summary>
ProxyAuthorization,
        ///<summary>
        /// The proxy features header is used by a proxy sending data to a server. It specifies the features supported by the specified proxy. (https://www.w3.org/TR/WD-proxy).
        ///</summary>
ProxyFeatures,
        ///<summary>
        /// Indicates the part of a document that the server should return.
        ///</summary>
Range,
        ///<summary>
        /// Contains the address of the previous web page from which a link to the currently requested page was followed.
        ///</summary>
Referer,
        ///<summary>
        /// The Resolution-Hint request-header can be used by a client to supply a resolution hint to the resolver (https://tools.ietf.org/html/draft-girod-w3-id-res-ext-00).
        ///</summary>
ResolutionHint,
        ///<summary>
        /// The Schedule-Reply request header is used by a client to indicate to a server whether or not a scheduling operation ought to occur when an "Attendee" deletes a scheduling object resource.  In particular, it controls whether a reply scheduling message is sent to the "Organizer" as a result of the removal (RFC 6638).
        ///</summary>
ScheduleReply,
        ///<summary>
        /// The Sec-WebSocket-Key header field is used in the WebSocket opening handshake.  It is sent from the client to the server to provide part of the information used by the server to prove that it received a valid WebSocket opening handshake.  This helps ensure that the server does not accept connections from non-WebSocket clients (e.g., HTTP clients) that are being abused to send data to unsuspecting WebSocket servers (RFC 6455).
        ///</summary>
SecWebSocketKey,
        ///<summary>
        /// The SOAPAction HTTP request header field can be used to indicate the intent of the SOAP HTTP request. The value is a URI identifying the intent. SOAP places no restrictions on the format or specificity of the URI or that it is resolvable. An HTTP client MUST use this header field when issuing a SOAP HTTP Request (Simple Object Access Protocol (SOAP) 1.1).
        ///</summary>
SoapAction,
        ///<summary>
        /// The SubOK request header field is used to provide directives from an end-client to a proxy cache regarding the possible substitution of an instance body from a cached response for one resource instance for the instance body of the resource instance specified by the client's request (https://tools.ietf.org/html/draft-mogul-http-dupsup-00).
        ///</summary>
SubOK,
        ///<summary>
        /// The Surrogate-Capabilities request header allows surrogates to advertise their capabilities with capability tokens. Capability tokens indicate sets of operations (e.g., caching, processing) that a surrogate is willing to perform (https://www.w3.org/TR/edge-arch/).
        ///</summary>
SurrogateCapability,
        ///<summary>
        /// Specifies the transfer encodings the user agent is willing to accept.
        ///</summary>
TE,
        ///<summary>
        /// Used with WebDAV. Clients may include Timeout headers in their LOCK requests.  However, the server is not required to honor or even consider these requests. Clients MUST NOT submit a Timeout request header with any method other than a LOCK method (RFC 4918).
        ///</summary>
Timeout,
        ///<summary>
        /// Specifies the form of encoding used to safely transfer the entity to the user.
        ///</summary>
TransferEncoding,
        ///<summary>
        /// Sends a signal to the server expressing the client’s preference for an encrypted and authenticated response, and that it can successfully handle the upgrade-insecure-requests CSP directive.
        ///</summary>
UpgradeInsecureRequests,
        ///<summary>
        /// Contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.
        ///</summary>
UserAgent,
        ///<summary>
        /// Gets added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers.
        ///</summary>
Via,
        ///<summary>
        /// Contains information about possible problems with the status of the message. More than one Warning header may appear in a response.
        ///</summary>
Warning,
        ///<summary>
        /// Allows easier parsing of the MakeModel/Firmware that is usually found in the User-Agent String of AT&amp;T Devices
        ///</summary>
XATTDevcieId,
        ///<summary>
        /// Header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer.
        ///</summary>
XForwardedFor,
        ///<summary>
        /// Header for identifying the original host requested by the client in the Host HTTP request header.
        ///</summary>
XForwardedHost,
        ///<summary>
        /// Header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.
        ///</summary>
XForwardedProto,
        ///<summary>
        /// Links to an XML file on the Internet with a full description and details about the device currently connecting.
        ///</summary>
XWapProfile
    }

    public static partial class EnumHttpRequestHeaderConverter
    {
        public static EnumHttpRequestHeader? Convert(string input)
        {
            if (String.Equals(input, "A-IM", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.AIM;
            else if (String.Equals(input, "Accept", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Accept;
            else if (String.Equals(input, "Accept-Charset", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.AcceptCharset;
            else if (String.Equals(input, "Accept-Datetime", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.AcceptDatetime;
            else if (String.Equals(input, "Accept-Encoding", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.AcceptEncoding;
            else if (String.Equals(input, "Accept-Features", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.AcceptFeatures;
            else if (String.Equals(input, "Accept-Language", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.AcceptLanguage;
            else if (String.Equals(input, "Access-Control-Request-Headers", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.AccessControlRequestHeaders;
            else if (String.Equals(input, "Access-Control-Request-Method", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.AccessControlRequestMethod;
            else if (String.Equals(input, "Allow", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Allow;
            else if (String.Equals(input, "ALPN", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ALPN;
            else if (String.Equals(input, "Apply-To-Redirect-Ref", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ApplyToRedirectRef;
            else if (String.Equals(input, "Authorization", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Authorization;
            else if (String.Equals(input, "C-Man", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.CMan;
            else if (String.Equals(input, "Cache-Control", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.CacheControl;
            else if (String.Equals(input, "CalDAV-Timezones", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.CalDAVTimezones;
            else if (String.Equals(input, "Compliance", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Compliance;
            else if (String.Equals(input, "Connection", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Connection;
            else if (String.Equals(input, "Content-Base", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ContentBase;
            else if (String.Equals(input, "Content-Disposition", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ContentDisposition;
            else if (String.Equals(input, "Content-Encoding", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ContentEncoding;
            else if (String.Equals(input, "Content-Language", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ContentLanguage;
            else if (String.Equals(input, "Content-Length", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ContentLength;
            else if (String.Equals(input, "Content-Location", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ContentLocation;
            else if (String.Equals(input, "Content-MD5", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ContentMD5;
            else if (String.Equals(input, "Content-Type", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ContentType;
            else if (String.Equals(input, "Cookie", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Cookie;
            else if (String.Equals(input, "Cookie2", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Cookie2;
            else if (String.Equals(input, "Date", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Date;
            else if (String.Equals(input, "Depth", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Depth;
            else if (String.Equals(input, "Destination", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Destination;
            else if (String.Equals(input, "Expect", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Expect;
            else if (String.Equals(input, "Forwarded", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Forwarded;
            else if (String.Equals(input, "From", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.From;
            else if (String.Equals(input, "Front-End-Https", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.FrontEndHttps;
            else if (String.Equals(input, "Host", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Host;
            else if (String.Equals(input, "HTTP2-Settings", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.HTTP2Settings;
            else if (String.Equals(input, "If", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.If;
            else if (String.Equals(input, "If-Match", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.IfMatch;
            else if (String.Equals(input, "If-Modified-Since", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.IfModifiedSince;
            else if (String.Equals(input, "If-None-Match", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.IfNoneMatch;
            else if (String.Equals(input, "If-Range", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.IfRange;
            else if (String.Equals(input, "If-Schedule-Tag-Match", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.IfScheduleTagMatch;
            else if (String.Equals(input, "If-Unmodified-Since", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.IfUnmodifiedSince;
            else if (String.Equals(input, "Keep-Alive", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.KeepAlive;
            else if (String.Equals(input, "Label", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Label;
            else if (String.Equals(input, "Lock-Token", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.LockToken;
            else if (String.Equals(input, "Man", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Man;
            else if (String.Equals(input, "Max-Forwards", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.MaxForwards;
            else if (String.Equals(input, "Negotiate", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Negotiate;
            else if (String.Equals(input, "Non-Compliance", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.NonCompliance;
            else if (String.Equals(input, "Opt", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Opt;
            else if (String.Equals(input, "Optional", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Optional;
            else if (String.Equals(input, "Ordering-Type", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.OrderingType;
            else if (String.Equals(input, "Origin", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Origin;
            else if (String.Equals(input, "Overwrite", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Overwrite;
            else if (String.Equals(input, "Position", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Position;
            else if (String.Equals(input, "Pragma", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Pragma;
            else if (String.Equals(input, "Prefer", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Prefer;
            else if (String.Equals(input, "ProfileObject", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ProfileObject;
            else if (String.Equals(input, "Protocol-Request", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ProtocolRequest;
            else if (String.Equals(input, "Proxy-Authorization", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ProxyAuthorization;
            else if (String.Equals(input, "Proxy-Features", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ProxyFeatures;
            else if (String.Equals(input, "Range", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Range;
            else if (String.Equals(input, "Referer", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Referer;
            else if (String.Equals(input, "Resolution-Hint", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ResolutionHint;
            else if (String.Equals(input, "Schedule-Reply", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.ScheduleReply;
            else if (String.Equals(input, "Sec-WebSocket-Key", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.SecWebSocketKey;
            else if (String.Equals(input, "SoapAction", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.SoapAction;
            else if (String.Equals(input, "SubOK", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.SubOK;
            else if (String.Equals(input, "Surrogate-Capability", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.SurrogateCapability;
            else if (String.Equals(input, "TE", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.TE;
            else if (String.Equals(input, "Timeout", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Timeout;
            else if (String.Equals(input, "Transfer-Encoding", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.TransferEncoding;
            else if (String.Equals(input, "Upgrade-Insecure-Requests", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.UpgradeInsecureRequests;
            else if (String.Equals(input, "User-Agent", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.UserAgent;
            else if (String.Equals(input, "Via", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Via;
            else if (String.Equals(input, "Warning", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.Warning;
            else if (String.Equals(input, "X-ATT-DevcieId", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.XATTDevcieId;
            else if (String.Equals(input, "X-Forwarded-For", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.XForwardedFor;
            else if (String.Equals(input, "X-Forwarded-Host", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.XForwardedHost;
            else if (String.Equals(input, "X-Forwarded-Proto", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.XForwardedProto;
            else if (String.Equals(input, "X-Wap-Profile", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestHeader.XWapProfile;
            return null;
        }

        public static string ConvertBack(EnumHttpRequestHeader? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumHttpRequestHeader.AIM:
                    return "A-IM";
                case EnumHttpRequestHeader.Accept:
                    return "Accept";
                case EnumHttpRequestHeader.AcceptCharset:
                    return "Accept-Charset";
                case EnumHttpRequestHeader.AcceptDatetime:
                    return "Accept-Datetime";
                case EnumHttpRequestHeader.AcceptEncoding:
                    return "Accept-Encoding";
                case EnumHttpRequestHeader.AcceptFeatures:
                    return "Accept-Features";
                case EnumHttpRequestHeader.AcceptLanguage:
                    return "Accept-Language";
                case EnumHttpRequestHeader.AccessControlRequestHeaders:
                    return "Access-Control-Request-Headers";
                case EnumHttpRequestHeader.AccessControlRequestMethod:
                    return "Access-Control-Request-Method";
                case EnumHttpRequestHeader.Allow:
                    return "Allow";
                case EnumHttpRequestHeader.ALPN:
                    return "ALPN";
                case EnumHttpRequestHeader.ApplyToRedirectRef:
                    return "Apply-To-Redirect-Ref";
                case EnumHttpRequestHeader.Authorization:
                    return "Authorization";
                case EnumHttpRequestHeader.CMan:
                    return "C-Man";
                case EnumHttpRequestHeader.CacheControl:
                    return "Cache-Control";
                case EnumHttpRequestHeader.CalDAVTimezones:
                    return "CalDAV-Timezones";
                case EnumHttpRequestHeader.Compliance:
                    return "Compliance";
                case EnumHttpRequestHeader.Connection:
                    return "Connection";
                case EnumHttpRequestHeader.ContentBase:
                    return "Content-Base";
                case EnumHttpRequestHeader.ContentDisposition:
                    return "Content-Disposition";
                case EnumHttpRequestHeader.ContentEncoding:
                    return "Content-Encoding";
                case EnumHttpRequestHeader.ContentLanguage:
                    return "Content-Language";
                case EnumHttpRequestHeader.ContentLength:
                    return "Content-Length";
                case EnumHttpRequestHeader.ContentLocation:
                    return "Content-Location";
                case EnumHttpRequestHeader.ContentMD5:
                    return "Content-MD5";
                case EnumHttpRequestHeader.ContentType:
                    return "Content-Type";
                case EnumHttpRequestHeader.Cookie:
                    return "Cookie";
                case EnumHttpRequestHeader.Cookie2:
                    return "Cookie2";
                case EnumHttpRequestHeader.Date:
                    return "Date";
                case EnumHttpRequestHeader.Depth:
                    return "Depth";
                case EnumHttpRequestHeader.Destination:
                    return "Destination";
                case EnumHttpRequestHeader.Expect:
                    return "Expect";
                case EnumHttpRequestHeader.Forwarded:
                    return "Forwarded";
                case EnumHttpRequestHeader.From:
                    return "From";
                case EnumHttpRequestHeader.FrontEndHttps:
                    return "Front-End-Https";
                case EnumHttpRequestHeader.Host:
                    return "Host";
                case EnumHttpRequestHeader.HTTP2Settings:
                    return "HTTP2-Settings";
                case EnumHttpRequestHeader.If:
                    return "If";
                case EnumHttpRequestHeader.IfMatch:
                    return "If-Match";
                case EnumHttpRequestHeader.IfModifiedSince:
                    return "If-Modified-Since";
                case EnumHttpRequestHeader.IfNoneMatch:
                    return "If-None-Match";
                case EnumHttpRequestHeader.IfRange:
                    return "If-Range";
                case EnumHttpRequestHeader.IfScheduleTagMatch:
                    return "If-Schedule-Tag-Match";
                case EnumHttpRequestHeader.IfUnmodifiedSince:
                    return "If-Unmodified-Since";
                case EnumHttpRequestHeader.KeepAlive:
                    return "Keep-Alive";
                case EnumHttpRequestHeader.Label:
                    return "Label";
                case EnumHttpRequestHeader.LockToken:
                    return "Lock-Token";
                case EnumHttpRequestHeader.Man:
                    return "Man";
                case EnumHttpRequestHeader.MaxForwards:
                    return "Max-Forwards";
                case EnumHttpRequestHeader.Negotiate:
                    return "Negotiate";
                case EnumHttpRequestHeader.NonCompliance:
                    return "Non-Compliance";
                case EnumHttpRequestHeader.Opt:
                    return "Opt";
                case EnumHttpRequestHeader.Optional:
                    return "Optional";
                case EnumHttpRequestHeader.OrderingType:
                    return "Ordering-Type";
                case EnumHttpRequestHeader.Origin:
                    return "Origin";
                case EnumHttpRequestHeader.Overwrite:
                    return "Overwrite";
                case EnumHttpRequestHeader.Position:
                    return "Position";
                case EnumHttpRequestHeader.Pragma:
                    return "Pragma";
                case EnumHttpRequestHeader.Prefer:
                    return "Prefer";
                case EnumHttpRequestHeader.ProfileObject:
                    return "ProfileObject";
                case EnumHttpRequestHeader.ProtocolRequest:
                    return "Protocol-Request";
                case EnumHttpRequestHeader.ProxyAuthorization:
                    return "Proxy-Authorization";
                case EnumHttpRequestHeader.ProxyFeatures:
                    return "Proxy-Features";
                case EnumHttpRequestHeader.Range:
                    return "Range";
                case EnumHttpRequestHeader.Referer:
                    return "Referer";
                case EnumHttpRequestHeader.ResolutionHint:
                    return "Resolution-Hint";
                case EnumHttpRequestHeader.ScheduleReply:
                    return "Schedule-Reply";
                case EnumHttpRequestHeader.SecWebSocketKey:
                    return "Sec-WebSocket-Key";
                case EnumHttpRequestHeader.SoapAction:
                    return "SoapAction";
                case EnumHttpRequestHeader.SubOK:
                    return "SubOK";
                case EnumHttpRequestHeader.SurrogateCapability:
                    return "Surrogate-Capability";
                case EnumHttpRequestHeader.TE:
                    return "TE";
                case EnumHttpRequestHeader.Timeout:
                    return "Timeout";
                case EnumHttpRequestHeader.TransferEncoding:
                    return "Transfer-Encoding";
                case EnumHttpRequestHeader.UpgradeInsecureRequests:
                    return "Upgrade-Insecure-Requests";
                case EnumHttpRequestHeader.UserAgent:
                    return "User-Agent";
                case EnumHttpRequestHeader.Via:
                    return "Via";
                case EnumHttpRequestHeader.Warning:
                    return "Warning";
                case EnumHttpRequestHeader.XATTDevcieId:
                    return "X-ATT-DevcieId";
                case EnumHttpRequestHeader.XForwardedFor:
                    return "X-Forwarded-For";
                case EnumHttpRequestHeader.XForwardedHost:
                    return "X-Forwarded-Host";
                case EnumHttpRequestHeader.XForwardedProto:
                    return "X-Forwarded-Proto";
                case EnumHttpRequestHeader.XWapProfile:
                    return "X-Wap-Profile";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of headers that can only appear in HTTP responses.
    ///</summary>
public enum EnumHttpResponseHeader
    {
        ///<summary>
        /// Specifies the patch document formats accepted by the server (RFC 5789).
        ///</summary>
AcceptPatch,
        ///<summary>
        /// Advertises its support of partial requests.
        ///</summary>
AcceptRanges,
        ///<summary>
        /// Indicates whether response to the request can be exposed to the page.
        ///</summary>
AccessControlAllowCredentials,
        ///<summary>
        /// Used in response to a preflight request to indicate which HTTP headers can be used during the actual request.
        ///</summary>
AccessControlAllowHeaders,
        ///<summary>
        /// Specifies the method or methods allowed when accessing the resource in response to a preflight request.
        ///</summary>
AccessControlAllowMethods,
        ///<summary>
        /// Indicates whether the response can be shared with resources with the given origin.
        ///</summary>
AccessControlAllowOrigin,
        ///<summary>
        /// Indicates which headers can be exposed as part of the response by listing their names.
        ///</summary>
AccessControlExposeHeaders,
        ///<summary>
        /// Indicates how long the results of a preflight request (that is the information contained in the Access-Control-Allow-Methods and Access-Control-Allow-Headers headers) can be cached.
        ///</summary>
AccessControlMaxAge,
        ///<summary>
        /// Contains the time in seconds the object has been in a proxy cache.
        ///</summary>
Age,
        ///<summary>
        /// Lists the set of methods support by a resource.
        ///</summary>
Allow,
        ///<summary>
        /// Used to convey the list of variants bound to a negotiable resource (RFC 2295).
        ///</summary>
Alternates,
        ///<summary>
        /// The Authentication-Info header field can be used in any HTTP response, independently of request method and status code.  Its semantics are defined by the authentication scheme indicated by the Authorization header field ([RFC7235], Section 4.2) of the corresponding request (RFC 7615).
        ///</summary>
AuthenticationInfo,
        ///<summary>
        /// (RFC 2774).
        ///</summary>
CMan,
        ///<summary>
        /// Used to indicate that all hop-by-hop mandatory extension declarations in the request were fulfilled (RFC 2774).
        ///</summary>
CExt,
        ///<summary>
        /// Specifies directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.
        ///</summary>
CacheControl,
        ///<summary>
        /// Allows a client to specify exactly what options it is asking about, and which allows a server to specify exactly what subset of those options are supported.
        ///</summary>
Compliance,
        ///<summary>
        /// Controls whether or not the network connection stays open after the current transaction finishes. If the value sent is keep-alive, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.
        ///</summary>
Connection,
        ///<summary>
        /// The Content-Base entity-header field may be used to specify the base URI for resolving relative URLs within the entity. This header field is described as Base in RFC 1808, which is expected to be revised (RFC 2068).
        ///</summary>
ContentBase,
        ///<summary>
        /// In a regular HTTP response, the Content-Disposition response header is a header indicating if the content is expected to be displayed inline in the browser, that is, as a Web page or as part of a Web page, or as an attachment, that is downloaded and saved locally.
        /// In a multipart/form-data body, the HTTP Content-Disposition general header is a header that can be used on the subpart of a multipart body to give information about the field it applies to.
        ///</summary>
ContentDisposition,
        ///<summary>
        /// Used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body.
        ///</summary>
ContentEncoding,
        ///<summary>
        /// An MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body (RFC 2616).
        ///</summary>
ContentMD5,
        ///<summary>
        /// Used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.
        ///</summary>
ContentLanguage,
        ///<summary>
        /// Indicates the size of the entity-body, in bytes, sent to the recipient.
        ///</summary>
ContentLength,
        ///<summary>
        /// Indicates an alternate location for the returned data.
        ///</summary>
ContentLocation,
        ///<summary>
        /// Indicates where in a full body message a partial message belongs.
        ///</summary>
ContentRange,
        ///<summary>
        /// Specifies the default scripting language.
        ///</summary>
ContentScriptType,
        ///<summary>
        /// Allows web site administrators to control resources the user agent is allowed to load for a given page.
        ///</summary>
ContentSecurityPolicy,
        ///<summary>
        /// Allows web developers to experiment with policies by monitoring (but not enforcing) their effects.
        ///</summary>
ContentSecurityPolicyReportOnly,
        ///<summary>
        /// A single token specifying the type of encoding (RFC 2045).
        ///</summary>
ContentTransferEncoding,
        ///<summary>
        /// Indicates the media type of the resource.
        ///</summary>
ContentType,
        ///<summary>
        /// The DASL response header indicates server support for a query grammar in the OPTIONS method. The value is a URI that indicates the type of grammar. This header MAY be repeated (draft-ietf-dasl-protocol-00.txt).
        ///</summary>
DASL,
        ///<summary>
        /// Contains the date and time at which the message was originated.
        ///</summary>
Date,
        ///<summary>
        /// Identifies a specific version of a resource.
        ///</summary>
ETag,
        ///<summary>
        /// Contains the date/time after which the response is considered stale.
        ///</summary>
Expires,
        ///<summary>
        /// Used to indicate that all end-to-end mandatory extension declarations in the request were fulfilled (RFC 2774).
        ///</summary>
Ext,
        ///<summary>
        /// Used with implementation of OPS Over HTTP.
        ///</summary>
GetProfile,
        ///<summary>
        /// The IM response-header field is used to indicate the instance-manipulations, if any, that have been applied to the instance represented by the response.  Typical instance manipulations include delta encoding and compression (RFC 3229).
        ///</summary>
IM,
        ///<summary>
        /// Allows the sender to hint about how the connection and may be used to set a timeout and a maximum amount of requests.
        ///</summary>
KeepAlive,
        ///<summary>
        /// Tells the browser that the page being loaded is going to want to perform a large allocation.
        ///</summary>
LargeAllocation,
        ///<summary>
        /// Contains the date and time at which the origin server believes the resource was last modified. It is used to determine if a resource received or stored is the same.
        ///</summary>
LastModified,
        ///<summary>
        /// Indicates the URL to redirect a page to. It only provides a meaning when served with a 3xx (redirection) or 201 (created) status response.
        ///</summary>
Location,
        ///<summary>
        /// The Lock-Token response header is used with the LOCK method to indicate the lock token created as a result of a successful LOCK request to create a new lock. (RFC 4918).
        ///</summary>
LockToken,
        ///<summary>
        /// RFC 2774
        ///</summary>
Man,
        ///<summary>
        /// The "Memento-Datetime" response header is used by a server to indicate that a response reflects a prior state of an Original Resource.  Its value expresses the datetime of that state (RFC 7089).
        ///</summary>
MementoDatetime,
        ///<summary>
        /// A non-compliance-option listed in a Non-Compliance response-header field indicates that the proxy server named by the proxy-host value does not support the listed compliance-option.  The set of non-compliance options SHOULD be a subset of the compliance-options listed in a Compliance header field of the forwarded message.
        ///</summary>
NonCompliance,
        ///<summary>
        /// RFC 2774
        ///</summary>
Opt,
        ///<summary>
        /// The P3P header gives one or more comma-separated directives (https://www.w3.org/2002/04/P3Pv1-header.txt).
        ///</summary>
P3P,
        ///<summary>
        /// An implementation-specific header that may have various effects along the request-response chain.
        ///</summary>
Pragma,
        ///<summary>
        /// The Preference-Applied response header MAY be included within a response message as an indication as to which Prefer tokens were honored by the server and applied to the processing of a request (RFC 7240).
        ///</summary>
PreferenceApplied,
        ///<summary>
        /// Defines the authentication method that should be used to gain access to a resource behind a proxy server.
        ///</summary>
ProxyAuthenticate,
        ///<summary>
        /// The Proxy-Authentication-Info response header field is equivalent to Authentication-Info, except that it applies to proxy authentication ([RFC7235], Section 2) and its semantics are defined by the authentication scheme indicated by the Proxy-Authorization header field ([RFC7235], Section 4.4) of the corresponding request (RFC 7614).
        ///</summary>
ProxyAuthenticationInfo,
        ///<summary>
        /// The proxy instruction header is used to reply to a proxy features header. It should only be present when a Proxy-Features header was present in the corresponding request (https://www.w3.org/TR/WD-proxy).
        ///</summary>
ProxyInstruction,
        ///<summary>
        /// The Public response-header field lists the set of methods supported by the server. The purpose of this field is strictly to inform the recipient of the capabilities of the server regarding unusual methods (RFC 2068).
        ///</summary>
Public,
        ///<summary>
        /// Associates a specific cryptographic public key with a certain web server to decrease the risk of MITM attacks with forged certificates.
        ///</summary>
PublicKeyPins,
        ///<summary>
        /// Sends reports of pinning violation to the report-uri specified in the header but, unlike Public-Key-Pins still allows browsers to connect to the server if the pinning is violated.
        ///</summary>
PublicKeyPinsReportOnly,
        ///<summary>
        /// The Redirect-Ref header is used in all 3xx responses from redirect reference resources. The value is the link target as specified during redirect reference resource creation (RFC 4437).
        ///</summary>
RedirectRef,
        ///<summary>
        /// Governs which referrer information, sent in the Referer header, should be included with requests made.
        ///</summary>
ReferrerPolicy,
        ///<summary>
        /// The Resolver-Location header in a 350 response encodes this comma delimited set of bindings (https://tools.ietf.org/html/draft-girod-w3-id-res-ext-00).
        ///</summary>
ResolverLocation,
        ///<summary>
        /// Indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:
        ///</summary>
RetryAfter,
        ///<summary>
        /// The Safe response header field is used by origin servers to indicate whether repeating the received HTTP request is safe in the sense of Section 9.1.1 (Safe Methods) of the HTTP/1.1 specification [1] (RFC 2310).
        ///</summary>
Safe,
        ///<summary>
        /// The Schedule-Tag response header provides the current value of the CALDAV:schedule-tag property value (RFC 6638).
        ///</summary>
ScheduleTag,
        ///<summary>
        /// Contains information about the software used by the origin server to handle the request.
        ///</summary>
Server,
        ///<summary>
        /// The Sec-WebSocket-Accept header field is used in the WebSocket opening handshake.  It is sent from the server to the client to confirm that the server is willing to initiate the WebSocket connection (RFC 6455).
        ///</summary>
SecWebSocketAccept,
        ///<summary>
        /// Used to send cookies from the server to the user agent.
        ///</summary>
SetCookie,
        ///<summary>
        /// (Obsolete) Used to send cookies from the server to the user agent.
        ///</summary>
SetCookie2,
        ///<summary>
        /// Used with implementation of OPS Over HTTP (https://www.w3.org/TR/NOTE-OPS-OverHTTP).
        ///</summary>
SetProfile,
        ///<summary>
        /// Links generated code to a source map, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.
        ///</summary>
SourceMap,
        ///<summary>
        /// The Status header field contains a 3-digit integer result code that indicates the level of success of the script's attempt to handle the request. (RFC 3875).
        ///</summary>
Status,
        ///<summary>
        /// The Status-URI response header may be used with the 102 (Processing) status code to inform the client as to the status of a method (RFC 2518).
        ///</summary>
StatusURI,
        StrictTransportSecurity,
        ///<summary>
        /// The Subst response-header field MUST be used by a proxy to supply the URI of the original source of an entity-body, if the source is different from the client's Request-URI, and if the client's request included the ``inform'' directive in a SubOK request header field. Otherwise, a proxy MAY send a Subst response-header field, if it makes a substitution based on the information in a SubOK request header field (https://tools.ietf.org/html/draft-mogul-http-dupsup-00).
        ///</summary>
Subst,
        ///<summary>
        /// The Surrogate-Control response header allows origin servers to dictate how surrogates should handle response entities, with control directives (https://www.w3.org/TR/edge-arch/).
        ///</summary>
SurrogateControl,
        ///<summary>
        /// The TCN response header is used by a server to signal that the resource is transparently negotiated (RFC 2295).
        ///</summary>
TCN,
        ///<summary>
        /// Specifies origins that are allowed to see values of attributes retrieved via features of the Resource Timing API, which would otherwise be reported as zero due to cross-origin restrictions.
        ///</summary>
TimingAllowOrigin,
        ///<summary>
        /// Indicates the tracking status that applied to the corresponding request.
        ///</summary>
Tk,
        ///<summary>
        /// Allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.
        ///</summary>
Trailer,
        ///<summary>
        /// Specifies the form of encoding used to safely transfer the entity to the user.
        ///</summary>
TransferEncoding,
        ///<summary>
        /// The Variant-Vary response header can be used in a choice response to record any vary information which applies to the variant data (the entity body combined with some of the entity headers) contained in the response, rather than to the response as a whole (RFC 2295).
        ///</summary>
VariantVary,
        ///<summary>
        /// Determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.
        ///</summary>
Vary,
        ///<summary>
        /// Gets added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers.
        ///</summary>
Via,
        ///<summary>
        /// Defines the authentication method that should be used to gain access to a resource.
        ///</summary>
WWWAuthenticate,
        ///<summary>
        /// Contains information about possible problems with the status of the message. More than one Warning header may appear in a response.
        ///</summary>
Warning,
        ///<summary>
        /// Provides the duration of the audio or video in seconds.
        ///</summary>
XContentDuration,
        ///<summary>
        /// Content Security Policy definition.
        ///</summary>
XContentSecurityPolicy,
        ///<summary>
        /// Marker used by the server to indicate that the MIME types advertised in the Content-Type headers should not be changed and be followed.
        ///</summary>
XContentTypeOptions,
        ///<summary>
        /// Controls DNS prefetching, a feature by which browsers pro actively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, etc.
        ///</summary>
XDNSPrefetchControl,
        ///<summary>
        /// Can be used to indicate whether or not a browser should be allowed to render a page in a &lt;frame&gt;, &lt;iframe&gt; or &lt;object&gt;.
        ///</summary>
XFrameOptions,
        ///<summary>
        /// Specifies the technology (e.g. ASP.NET, PHP, JBoss) supporting the web application (version details are often in X-Runtime, X-Version, or X-AspNet-Version).
        ///</summary>
XPoweredBy,
        ///<summary>
        /// Recommends the preferred rendering engine (often a backward-compatibility mode) to use to display the content.
        ///</summary>
XUACompatible,
        ///<summary>
        /// Content Security Policy definition.
        ///</summary>
XWebKitCSP,
        ///<summary>
        /// A feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (XSS) attacks.
        ///</summary>
XXSSProtection
    }

    public static partial class EnumHttpResponseHeaderConverter
    {
        public static EnumHttpResponseHeader? Convert(string input)
        {
            if (String.Equals(input, "Accept-Patch", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AcceptPatch;
            else if (String.Equals(input, "Accept-Ranges", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AcceptRanges;
            else if (String.Equals(input, "Access-Control-Allow-Credentials", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AccessControlAllowCredentials;
            else if (String.Equals(input, "Access-Control-Allow-Headers", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AccessControlAllowHeaders;
            else if (String.Equals(input, "Access-Control-Allow-Methods", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AccessControlAllowMethods;
            else if (String.Equals(input, "Access-Control-Allow-Origin", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AccessControlAllowOrigin;
            else if (String.Equals(input, "Access-Control-Expose-Headers", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AccessControlExposeHeaders;
            else if (String.Equals(input, "Access-Control-Max-Age", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AccessControlMaxAge;
            else if (String.Equals(input, "Age", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Age;
            else if (String.Equals(input, "Allow", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Allow;
            else if (String.Equals(input, "Alternates", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Alternates;
            else if (String.Equals(input, "Authentication-Info", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.AuthenticationInfo;
            else if (String.Equals(input, "C-Man", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.CMan;
            else if (String.Equals(input, "C-Ext", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.CExt;
            else if (String.Equals(input, "Cache-Control", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.CacheControl;
            else if (String.Equals(input, "Compliance", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Compliance;
            else if (String.Equals(input, "Connection", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Connection;
            else if (String.Equals(input, "Content-Base", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentBase;
            else if (String.Equals(input, "Content-Disposition", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentDisposition;
            else if (String.Equals(input, "Content-Encoding", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentEncoding;
            else if (String.Equals(input, "Content-MD5", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentMD5;
            else if (String.Equals(input, "Content-Language", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentLanguage;
            else if (String.Equals(input, "Content-Length", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentLength;
            else if (String.Equals(input, "Content-Location", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentLocation;
            else if (String.Equals(input, "Content-Range", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentRange;
            else if (String.Equals(input, "Content-Script-Type", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentScriptType;
            else if (String.Equals(input, "Content-Security-Policy", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentSecurityPolicy;
            else if (String.Equals(input, "Content-Security-Policy-Report-Only", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentSecurityPolicyReportOnly;
            else if (String.Equals(input, "Content-Transfer-Encoding", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentTransferEncoding;
            else if (String.Equals(input, "Content-Type", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ContentType;
            else if (String.Equals(input, "DASL", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.DASL;
            else if (String.Equals(input, "Date", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Date;
            else if (String.Equals(input, "ETag", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ETag;
            else if (String.Equals(input, "Expires", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Expires;
            else if (String.Equals(input, "Ext", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Ext;
            else if (String.Equals(input, "GetProfile", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.GetProfile;
            else if (String.Equals(input, "IM", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.IM;
            else if (String.Equals(input, "Keep-Alive", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.KeepAlive;
            else if (String.Equals(input, "Large-Allocation", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.LargeAllocation;
            else if (String.Equals(input, "Last-Modified", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.LastModified;
            else if (String.Equals(input, "Location", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Location;
            else if (String.Equals(input, "Lock-Token", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.LockToken;
            else if (String.Equals(input, "Man", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Man;
            else if (String.Equals(input, "Memento-Datetime", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.MementoDatetime;
            else if (String.Equals(input, "Non-Compliance", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.NonCompliance;
            else if (String.Equals(input, "Opt", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Opt;
            else if (String.Equals(input, "P3P", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.P3P;
            else if (String.Equals(input, "Pragma", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Pragma;
            else if (String.Equals(input, "Preference-Applied", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.PreferenceApplied;
            else if (String.Equals(input, "Proxy-Authenticate", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ProxyAuthenticate;
            else if (String.Equals(input, "Proxy-Authentication-Info", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ProxyAuthenticationInfo;
            else if (String.Equals(input, "Proxy-Instruction", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ProxyInstruction;
            else if (String.Equals(input, "Public", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Public;
            else if (String.Equals(input, "Public-Key-Pins", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.PublicKeyPins;
            else if (String.Equals(input, "Public-Key-Pins-Report-Only", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.PublicKeyPinsReportOnly;
            else if (String.Equals(input, "Redirect-Ref", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.RedirectRef;
            else if (String.Equals(input, "Referrer-Policy", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ReferrerPolicy;
            else if (String.Equals(input, "Resolver-Location", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ResolverLocation;
            else if (String.Equals(input, "Retry-After", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.RetryAfter;
            else if (String.Equals(input, "Safe", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Safe;
            else if (String.Equals(input, "Schedule-Tag", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.ScheduleTag;
            else if (String.Equals(input, "Server", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Server;
            else if (String.Equals(input, "Sec-WebSocket-Accept", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.SecWebSocketAccept;
            else if (String.Equals(input, "Set-Cookie", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.SetCookie;
            else if (String.Equals(input, "Set-Cookie2", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.SetCookie2;
            else if (String.Equals(input, "SetProfile", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.SetProfile;
            else if (String.Equals(input, "SourceMap", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.SourceMap;
            else if (String.Equals(input, "Status", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Status;
            else if (String.Equals(input, "Status-URI", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.StatusURI;
            else if (String.Equals(input, "Strict-Transport-Security", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.StrictTransportSecurity;
            else if (String.Equals(input, "Subst", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Subst;
            else if (String.Equals(input, "Surrogate-Control", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.SurrogateControl;
            else if (String.Equals(input, "TCN", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.TCN;
            else if (String.Equals(input, "Timing-Allow-Origin", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.TimingAllowOrigin;
            else if (String.Equals(input, "Tk", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Tk;
            else if (String.Equals(input, "Trailer", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Trailer;
            else if (String.Equals(input, "Transfer-Encoding", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.TransferEncoding;
            else if (String.Equals(input, "Variant-Vary", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.VariantVary;
            else if (String.Equals(input, "Vary", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Vary;
            else if (String.Equals(input, "Via", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Via;
            else if (String.Equals(input, "WWW-Authenticate", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.WWWAuthenticate;
            else if (String.Equals(input, "Warning", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.Warning;
            else if (String.Equals(input, "X-Content-Duration", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XContentDuration;
            else if (String.Equals(input, "X-Content-Security-Policy", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XContentSecurityPolicy;
            else if (String.Equals(input, "X-Content-Type-Options", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XContentTypeOptions;
            else if (String.Equals(input, "X-DNS-Prefetch-Control", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XDNSPrefetchControl;
            else if (String.Equals(input, "X-Frame-Options", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XFrameOptions;
            else if (String.Equals(input, "X-Powered-By", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XPoweredBy;
            else if (String.Equals(input, "X-UA-Compatible", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XUACompatible;
            else if (String.Equals(input, "X-WebKit-CSP", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XWebKitCSP;
            else if (String.Equals(input, "X-XSS-Protection", StringComparison.OrdinalIgnoreCase))
                return EnumHttpResponseHeader.XXSSProtection;
            return null;
        }

        public static string ConvertBack(EnumHttpResponseHeader? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumHttpResponseHeader.AcceptPatch:
                    return "Accept-Patch";
                case EnumHttpResponseHeader.AcceptRanges:
                    return "Accept-Ranges";
                case EnumHttpResponseHeader.AccessControlAllowCredentials:
                    return "Access-Control-Allow-Credentials";
                case EnumHttpResponseHeader.AccessControlAllowHeaders:
                    return "Access-Control-Allow-Headers";
                case EnumHttpResponseHeader.AccessControlAllowMethods:
                    return "Access-Control-Allow-Methods";
                case EnumHttpResponseHeader.AccessControlAllowOrigin:
                    return "Access-Control-Allow-Origin";
                case EnumHttpResponseHeader.AccessControlExposeHeaders:
                    return "Access-Control-Expose-Headers";
                case EnumHttpResponseHeader.AccessControlMaxAge:
                    return "Access-Control-Max-Age";
                case EnumHttpResponseHeader.Age:
                    return "Age";
                case EnumHttpResponseHeader.Allow:
                    return "Allow";
                case EnumHttpResponseHeader.Alternates:
                    return "Alternates";
                case EnumHttpResponseHeader.AuthenticationInfo:
                    return "Authentication-Info";
                case EnumHttpResponseHeader.CMan:
                    return "C-Man";
                case EnumHttpResponseHeader.CExt:
                    return "C-Ext";
                case EnumHttpResponseHeader.CacheControl:
                    return "Cache-Control";
                case EnumHttpResponseHeader.Compliance:
                    return "Compliance";
                case EnumHttpResponseHeader.Connection:
                    return "Connection";
                case EnumHttpResponseHeader.ContentBase:
                    return "Content-Base";
                case EnumHttpResponseHeader.ContentDisposition:
                    return "Content-Disposition";
                case EnumHttpResponseHeader.ContentEncoding:
                    return "Content-Encoding";
                case EnumHttpResponseHeader.ContentMD5:
                    return "Content-MD5";
                case EnumHttpResponseHeader.ContentLanguage:
                    return "Content-Language";
                case EnumHttpResponseHeader.ContentLength:
                    return "Content-Length";
                case EnumHttpResponseHeader.ContentLocation:
                    return "Content-Location";
                case EnumHttpResponseHeader.ContentRange:
                    return "Content-Range";
                case EnumHttpResponseHeader.ContentScriptType:
                    return "Content-Script-Type";
                case EnumHttpResponseHeader.ContentSecurityPolicy:
                    return "Content-Security-Policy";
                case EnumHttpResponseHeader.ContentSecurityPolicyReportOnly:
                    return "Content-Security-Policy-Report-Only";
                case EnumHttpResponseHeader.ContentTransferEncoding:
                    return "Content-Transfer-Encoding";
                case EnumHttpResponseHeader.ContentType:
                    return "Content-Type";
                case EnumHttpResponseHeader.DASL:
                    return "DASL";
                case EnumHttpResponseHeader.Date:
                    return "Date";
                case EnumHttpResponseHeader.ETag:
                    return "ETag";
                case EnumHttpResponseHeader.Expires:
                    return "Expires";
                case EnumHttpResponseHeader.Ext:
                    return "Ext";
                case EnumHttpResponseHeader.GetProfile:
                    return "GetProfile";
                case EnumHttpResponseHeader.IM:
                    return "IM";
                case EnumHttpResponseHeader.KeepAlive:
                    return "Keep-Alive";
                case EnumHttpResponseHeader.LargeAllocation:
                    return "Large-Allocation";
                case EnumHttpResponseHeader.LastModified:
                    return "Last-Modified";
                case EnumHttpResponseHeader.Location:
                    return "Location";
                case EnumHttpResponseHeader.LockToken:
                    return "Lock-Token";
                case EnumHttpResponseHeader.Man:
                    return "Man";
                case EnumHttpResponseHeader.MementoDatetime:
                    return "Memento-Datetime";
                case EnumHttpResponseHeader.NonCompliance:
                    return "Non-Compliance";
                case EnumHttpResponseHeader.Opt:
                    return "Opt";
                case EnumHttpResponseHeader.P3P:
                    return "P3P";
                case EnumHttpResponseHeader.Pragma:
                    return "Pragma";
                case EnumHttpResponseHeader.PreferenceApplied:
                    return "Preference-Applied";
                case EnumHttpResponseHeader.ProxyAuthenticate:
                    return "Proxy-Authenticate";
                case EnumHttpResponseHeader.ProxyAuthenticationInfo:
                    return "Proxy-Authentication-Info";
                case EnumHttpResponseHeader.ProxyInstruction:
                    return "Proxy-Instruction";
                case EnumHttpResponseHeader.Public:
                    return "Public";
                case EnumHttpResponseHeader.PublicKeyPins:
                    return "Public-Key-Pins";
                case EnumHttpResponseHeader.PublicKeyPinsReportOnly:
                    return "Public-Key-Pins-Report-Only";
                case EnumHttpResponseHeader.RedirectRef:
                    return "Redirect-Ref";
                case EnumHttpResponseHeader.ReferrerPolicy:
                    return "Referrer-Policy";
                case EnumHttpResponseHeader.ResolverLocation:
                    return "Resolver-Location";
                case EnumHttpResponseHeader.RetryAfter:
                    return "Retry-After";
                case EnumHttpResponseHeader.Safe:
                    return "Safe";
                case EnumHttpResponseHeader.ScheduleTag:
                    return "Schedule-Tag";
                case EnumHttpResponseHeader.Server:
                    return "Server";
                case EnumHttpResponseHeader.SecWebSocketAccept:
                    return "Sec-WebSocket-Accept";
                case EnumHttpResponseHeader.SetCookie:
                    return "Set-Cookie";
                case EnumHttpResponseHeader.SetCookie2:
                    return "Set-Cookie2";
                case EnumHttpResponseHeader.SetProfile:
                    return "SetProfile";
                case EnumHttpResponseHeader.SourceMap:
                    return "SourceMap";
                case EnumHttpResponseHeader.Status:
                    return "Status";
                case EnumHttpResponseHeader.StatusURI:
                    return "Status-URI";
                case EnumHttpResponseHeader.StrictTransportSecurity:
                    return "Strict-Transport-Security";
                case EnumHttpResponseHeader.Subst:
                    return "Subst";
                case EnumHttpResponseHeader.SurrogateControl:
                    return "Surrogate-Control";
                case EnumHttpResponseHeader.TCN:
                    return "TCN";
                case EnumHttpResponseHeader.TimingAllowOrigin:
                    return "Timing-Allow-Origin";
                case EnumHttpResponseHeader.Tk:
                    return "Tk";
                case EnumHttpResponseHeader.Trailer:
                    return "Trailer";
                case EnumHttpResponseHeader.TransferEncoding:
                    return "Transfer-Encoding";
                case EnumHttpResponseHeader.VariantVary:
                    return "Variant-Vary";
                case EnumHttpResponseHeader.Vary:
                    return "Vary";
                case EnumHttpResponseHeader.Via:
                    return "Via";
                case EnumHttpResponseHeader.WWWAuthenticate:
                    return "WWW-Authenticate";
                case EnumHttpResponseHeader.Warning:
                    return "Warning";
                case EnumHttpResponseHeader.XContentDuration:
                    return "X-Content-Duration";
                case EnumHttpResponseHeader.XContentSecurityPolicy:
                    return "X-Content-Security-Policy";
                case EnumHttpResponseHeader.XContentTypeOptions:
                    return "X-Content-Type-Options";
                case EnumHttpResponseHeader.XDNSPrefetchControl:
                    return "X-DNS-Prefetch-Control";
                case EnumHttpResponseHeader.XFrameOptions:
                    return "X-Frame-Options";
                case EnumHttpResponseHeader.XPoweredBy:
                    return "X-Powered-By";
                case EnumHttpResponseHeader.XUACompatible:
                    return "X-UA-Compatible";
                case EnumHttpResponseHeader.XWebKitCSP:
                    return "X-WebKit-CSP";
                case EnumHttpResponseHeader.XXSSProtection:
                    return "X-XSS-Protection";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of headers that can both appear in HTTP requests and responses.
    ///</summary>
public enum EnumHttpHeader
    {
        ///<summary>
        /// Hop-by-Hop Extension Declaration (http://www.w3.org/TR/WD-http-pep).
        ///</summary>
CPEP,
        ///<summary>
        /// Hop-by-Hop Policy (http://www.w3.org/TR/WD-http-pep).
        ///</summary>
CPEPInfo,
        Close,
        ///<summary>
        /// The content identifier. Used with the HTTP Distribution and Replication Protocol (https://www.w3.org/TR/NOTE-drp-19970825).
        ///</summary>
ContentID,
        ContentStyleType,
        ///<summary>
        /// The Content-Version entity-header field defines the version tag associated with a rendition of an evolving entity. Together with the Derived-From field described in section 19.6.2.3, it allows a group of people to work simultaneously on the creation of a work as an iterative process. The field should be used to allow evolution of a particular work along a single path rather than derived works or renditions in different representations. (RFC 2068).
        ///</summary>
ContentVersion,
        ///<summary>
        /// The cost of retrieving the object is given. This is the cost of access of a copyright work, with a specification of the payment system accepted. Format to be specified. Currently refers to an unspecified charging scheme to be agreed out of band between parties (https://www.w3.org/Protocols/HTTP/Object_Headers.html#cost).
        ///</summary>
Cost,
        ///<summary>
        /// When appearing in the response indicates that the resource supports the DAV schema and protocol as specified. As a request header, this header allows the client to advertise compliance with named features when the server needs that information (RFC 4918).
        ///</summary>
DAV,
        DefaultStyle,
        ///<summary>
        /// The Delta-Base entity-header field is used in a delta-encoded response to specify the entity tag of the base instance (RFC 3229).
        ///</summary>
DeltaBase,
        ///<summary>
        /// The Derived-From entity-header field can be used to indicate the version tag of the resource from which the enclosed entity was derived before modifications were made by the sender. This field is used to help manage the process of merging successive changes to a resource, particularly when such changes are being made in parallel and from multiple sources (RFC 2068).
        ///</summary>
DerivedFrom,
        ///<summary>
        /// Used with the HTTP Distribution and Replication Protocol (https://www.w3.org/TR/NOTE-drp-19970825).
        ///</summary>
DifferentialID,
        ///<summary>
        /// The Digest message header field provides a message digest of the instance described by the message (RFC 3230).
        ///</summary>
Digest,
        ///<summary>
        /// The Want-Digest message header field indicates the sender's desire to receive an instance digest on messages associated with the Request-URI (RFC 3230).
        ///</summary>
WantDigest,
        ///<summary>
        /// The EDIINT-Features header indicates the capability of the user agent to support the listed feature with its trading partner without out-of-band communication and agreement (RFC 6017).
        ///</summary>
EDIINTFeatures,
        ///<summary>
        /// HTTP Origin-Bound Auth (HOBA) (RFC 7486).
        ///</summary>
Hobareg,
        ///<summary>
        /// The Link entity-header field provides a means for serializing one or more links in HTTP headers (RFC 5988).
        ///</summary>
Link,
        MessageID,
        ///<summary>
        /// The Meter header is used to carry zero or more directives (RFC 2227).
        ///</summary>
Meter,
        ///<summary>
        /// Messages MAY include a single MIME-Version general-header field to indicate what version of the MIME protocol was used to construct the message (RFC 2616).
        ///</summary>
MIMEVersion,
        ///<summary>
        /// Hop-by-Hop Extension Declaration (http://www.w3.org/TR/WD-http-pep).
        ///</summary>
PEP,
        ///<summary>
        /// Hop-by-Hop Policy (http://www.w3.org/TR/WD-http-pep).
        ///</summary>
PEPInfo,
        PICSLabel,
        ///<summary>
        /// PICS 1.1 Label Distribution -- Label Syntax and Communication Protocols (https://www.w3.org/standards/history/REC-PICS-labels).
        ///</summary>
Protocol,
        ///<summary>
        /// Joint Electronic Payment Initiative (https://www.w3.org/ECommerce/white-paper).
        ///</summary>
ProtocolInfo,
        ///<summary>
        /// Joint Electronic Payment Initiative (https://www.w3.org/ECommerce/white-paper).
        ///</summary>
ProtocolQuery,
        ///<summary>
        /// All S-HTTP compliant agents must generate the Security-Scheme header in the headers of all HTTP messages they generate. This header permits other agents to detect that they are communicating with an S-HTTP compliant agent and generate the appropriate cryptographic options header (RFC 2660).
        ///</summary>
SecurityScheme,
        ///<summary>
        /// The |Sec-WebSocket-Extensions| header field is used in the WebSocket opening handshake.  It is initially sent from the client to the server, and then subsequently sent from the server to the client, to agree on a set of protocol-level extensions to use for the duration of the connection (RFC 6455).
        ///</summary>
SecWebSocketExtensions,
        ///<summary>
        /// The Sec-WebSocket-Protocol header field is used in the WebSocket opening handshake.  It is sent from the client to the server and back from the server to the client to confirm the subprotocol of the connection.  This enables scripts to both select a subprotocol and be sure that the server agreed to serve that subprotocol (RFC 6455).
        ///</summary>
SecWebSocketProtocol,
        ///<summary>
        /// The Sec-WebSocket-Version header field is used in the WebSocket opening handshake.  It is sent from the client to the server to indicate the protocol version of the connection.  This enables servers to correctly interpret the opening handshake and subsequent data being sent from the data, and close the connection if the server cannot interpret that data in a safe manner.  The Sec-WebSocket-Version header field is also sent from the server to the client on WebSocket handshake error, when the version received from the client does not match a version understood by the server.  In such a case, the header field includes the protocol version(s) supported by the server (RFC 6455).
        ///</summary>
SecWebSocketVersion,
        ///<summary>
        /// Slug is an HTTP entity-header whose presence in a POST to a Collection constitutes a request by the client to use the header’s value as part of any URIs that would normally be used to retrieve the to-be-created Entry or Media Resources. Servers MAY use the value of the Slug header when creating the Member URI of the newly created Resource, for instance, by using some or all of the words in the value for the last URI segment (RFC 5023).
        ///</summary>
SLUG,
        ///<summary>
        /// The title of the document (https://www.w3.org/Protocols/HTTP/Object_Headers.html#title).
        ///</summary>
Title,
        TSV,
        ///<summary>
        /// https://tools.ietf.org/html/draft-mutz-http-attributes-00
        ///</summary>
UAColor,
        ///<summary>
        /// https://tools.ietf.org/html/draft-mutz-http-attributes-00
        ///</summary>
UAMedia,
        ///<summary>
        /// https://tools.ietf.org/html/draft-mutz-http-attributes-00
        ///</summary>
UAPixels,
        ///<summary>
        /// https://tools.ietf.org/html/draft-mutz-http-attributes-00
        ///</summary>
UAResolution,
        ///<summary>
        /// https://tools.ietf.org/html/draft-mutz-http-attributes-00
        ///</summary>
UAWindowpixels,
        ///<summary>
        /// The URI header field has, in past versions of this specification, been used as a combination of the existing Location, Content-Location, and Vary header fields as well as the future Alternates field (above). Its primary purpose has been to include a list of additional URIs for the resource, including names and mirror locations. However, it has become clear that the combination of many	different functions within this single field has been a barrier to consistently and correctly implementing any of those functions. Furthermore, we believe that the identification of names and mirror locations would be better performed via the Link header field. The URI header field is therefore deprecated in favor of those other fields (RFC 2068).
        /// 
        ///</summary>
URI,
        ///<summary>
        /// This is a string defining the version of an evolving object (https://www.w3.org/Protocols/HTTP/Object_Headers.html#z13).
        ///</summary>
Version,
        XDeviceAccept,
        XDeviceAcceptCharset,
        XDeviceAcceptEncoding,
        XDeviceAcceptLanguage,
        XDeviceUserAgent
    }

    public static partial class EnumHttpHeaderConverter
    {
        public static EnumHttpHeader? Convert(string input)
        {
            if (String.Equals(input, "C-PEP", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.CPEP;
            else if (String.Equals(input, "C-PEP-Info", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.CPEPInfo;
            else if (String.Equals(input, "Close", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Close;
            else if (String.Equals(input, "Content-ID", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.ContentID;
            else if (String.Equals(input, "Content-Style-Type", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.ContentStyleType;
            else if (String.Equals(input, "Content-Version", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.ContentVersion;
            else if (String.Equals(input, "Cost", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Cost;
            else if (String.Equals(input, "DAV", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.DAV;
            else if (String.Equals(input, "Default-Style", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.DefaultStyle;
            else if (String.Equals(input, "Delta-Base", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.DeltaBase;
            else if (String.Equals(input, "Derived-From", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.DerivedFrom;
            else if (String.Equals(input, "Differential-ID", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.DifferentialID;
            else if (String.Equals(input, "Digest", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Digest;
            else if (String.Equals(input, "Want-Digest", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.WantDigest;
            else if (String.Equals(input, "EDIINT-Features", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.EDIINTFeatures;
            else if (String.Equals(input, "Hobareg", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Hobareg;
            else if (String.Equals(input, "Link", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Link;
            else if (String.Equals(input, "Message-ID", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.MessageID;
            else if (String.Equals(input, "Meter", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Meter;
            else if (String.Equals(input, "MIME-Version", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.MIMEVersion;
            else if (String.Equals(input, "PEP", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.PEP;
            else if (String.Equals(input, "PEP-Info", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.PEPInfo;
            else if (String.Equals(input, "PICS-Label", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.PICSLabel;
            else if (String.Equals(input, "Protocol", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Protocol;
            else if (String.Equals(input, "Protocol-Info", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.ProtocolInfo;
            else if (String.Equals(input, "Protocol-Query", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.ProtocolQuery;
            else if (String.Equals(input, "Security-Scheme", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.SecurityScheme;
            else if (String.Equals(input, "Sec-WebSocket-Extensions", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.SecWebSocketExtensions;
            else if (String.Equals(input, "Sec-WebSocket-Protocol", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.SecWebSocketProtocol;
            else if (String.Equals(input, "Sec-WebSocket-Version", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.SecWebSocketVersion;
            else if (String.Equals(input, "SLUG", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.SLUG;
            else if (String.Equals(input, "Title", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Title;
            else if (String.Equals(input, "TSV", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.TSV;
            else if (String.Equals(input, "UA-Color", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.UAColor;
            else if (String.Equals(input, "UA-Media", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.UAMedia;
            else if (String.Equals(input, "UA-Pixels", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.UAPixels;
            else if (String.Equals(input, "UA-Resolution", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.UAResolution;
            else if (String.Equals(input, "UA-Windowpixels", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.UAWindowpixels;
            else if (String.Equals(input, "URI", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.URI;
            else if (String.Equals(input, "Version", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.Version;
            else if (String.Equals(input, "X-Device-Accept", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.XDeviceAccept;
            else if (String.Equals(input, "X-Device-Accept-Charset", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.XDeviceAcceptCharset;
            else if (String.Equals(input, "X-Device-Accept-Encoding", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.XDeviceAcceptEncoding;
            else if (String.Equals(input, "X-Device-Accept-Language", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.XDeviceAcceptLanguage;
            else if (String.Equals(input, "X-Device-User-Agent", StringComparison.OrdinalIgnoreCase))
                return EnumHttpHeader.XDeviceUserAgent;
            return null;
        }

        public static string ConvertBack(EnumHttpHeader? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumHttpHeader.CPEP:
                    return "C-PEP";
                case EnumHttpHeader.CPEPInfo:
                    return "C-PEP-Info";
                case EnumHttpHeader.Close:
                    return "Close";
                case EnumHttpHeader.ContentID:
                    return "Content-ID";
                case EnumHttpHeader.ContentStyleType:
                    return "Content-Style-Type";
                case EnumHttpHeader.ContentVersion:
                    return "Content-Version";
                case EnumHttpHeader.Cost:
                    return "Cost";
                case EnumHttpHeader.DAV:
                    return "DAV";
                case EnumHttpHeader.DefaultStyle:
                    return "Default-Style";
                case EnumHttpHeader.DeltaBase:
                    return "Delta-Base";
                case EnumHttpHeader.DerivedFrom:
                    return "Derived-From";
                case EnumHttpHeader.DifferentialID:
                    return "Differential-ID";
                case EnumHttpHeader.Digest:
                    return "Digest";
                case EnumHttpHeader.WantDigest:
                    return "Want-Digest";
                case EnumHttpHeader.EDIINTFeatures:
                    return "EDIINT-Features";
                case EnumHttpHeader.Hobareg:
                    return "Hobareg";
                case EnumHttpHeader.Link:
                    return "Link";
                case EnumHttpHeader.MessageID:
                    return "Message-ID";
                case EnumHttpHeader.Meter:
                    return "Meter";
                case EnumHttpHeader.MIMEVersion:
                    return "MIME-Version";
                case EnumHttpHeader.PEP:
                    return "PEP";
                case EnumHttpHeader.PEPInfo:
                    return "PEP-Info";
                case EnumHttpHeader.PICSLabel:
                    return "PICS-Label";
                case EnumHttpHeader.Protocol:
                    return "Protocol";
                case EnumHttpHeader.ProtocolInfo:
                    return "Protocol-Info";
                case EnumHttpHeader.ProtocolQuery:
                    return "Protocol-Query";
                case EnumHttpHeader.SecurityScheme:
                    return "Security-Scheme";
                case EnumHttpHeader.SecWebSocketExtensions:
                    return "Sec-WebSocket-Extensions";
                case EnumHttpHeader.SecWebSocketProtocol:
                    return "Sec-WebSocket-Protocol";
                case EnumHttpHeader.SecWebSocketVersion:
                    return "Sec-WebSocket-Version";
                case EnumHttpHeader.SLUG:
                    return "SLUG";
                case EnumHttpHeader.Title:
                    return "Title";
                case EnumHttpHeader.TSV:
                    return "TSV";
                case EnumHttpHeader.UAColor:
                    return "UA-Color";
                case EnumHttpHeader.UAMedia:
                    return "UA-Media";
                case EnumHttpHeader.UAPixels:
                    return "UA-Pixels";
                case EnumHttpHeader.UAResolution:
                    return "UA-Resolution";
                case EnumHttpHeader.UAWindowpixels:
                    return "UA-Windowpixels";
                case EnumHttpHeader.URI:
                    return "URI";
                case EnumHttpHeader.Version:
                    return "Version";
                case EnumHttpHeader.XDeviceAccept:
                    return "X-Device-Accept";
                case EnumHttpHeader.XDeviceAcceptCharset:
                    return "X-Device-Accept-Charset";
                case EnumHttpHeader.XDeviceAcceptEncoding:
                    return "X-Device-Accept-Encoding";
                case EnumHttpHeader.XDeviceAcceptLanguage:
                    return "X-Device-Accept-Language";
                case EnumHttpHeader.XDeviceUserAgent:
                    return "X-Device-User-Agent";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the HTTP login method.
    ///</summary>
public enum EnumHttpLoginMethod
    {
        ///<summary>
        /// Credential-based authentication.
        ///</summary>
Credentials,
        ///<summary>
        /// Authentication using a client certificate. Feature introduced in DataMiner 10.0.5 (RN 25243).
        ///</summary>
Certificate
    }

    public static partial class EnumHttpLoginMethodConverter
    {
        public static EnumHttpLoginMethod? Convert(string input)
        {
            if (String.Equals(input, "credentials", StringComparison.OrdinalIgnoreCase))
                return EnumHttpLoginMethod.Credentials;
            else if (String.Equals(input, "certificate", StringComparison.OrdinalIgnoreCase))
                return EnumHttpLoginMethod.Certificate;
            return null;
        }

        public static string ConvertBack(EnumHttpLoginMethod? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumHttpLoginMethod.Credentials:
                    return "credentials";
                case EnumHttpLoginMethod.Certificate:
                    return "certificate";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the HTTP request verb.
    ///</summary>
public enum EnumHttpRequestVerb
    {
        DELETE,
        GET,
        HEAD,
        OPTIONS,
        PATCH,
        POST,
        PUT,
        TRACE,
        COPY,
        LOCK,
        MKCOL,
        PROPFIND,
        PROPPATCH,
        UNLOCK,
        TRACK
    }

    public static partial class EnumHttpRequestVerbConverter
    {
        public static EnumHttpRequestVerb? Convert(string input)
        {
            if (String.Equals(input, "DELETE", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.DELETE;
            else if (String.Equals(input, "GET", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.GET;
            else if (String.Equals(input, "HEAD", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.HEAD;
            else if (String.Equals(input, "OPTIONS", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.OPTIONS;
            else if (String.Equals(input, "PATCH", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.PATCH;
            else if (String.Equals(input, "POST", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.POST;
            else if (String.Equals(input, "PUT", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.PUT;
            else if (String.Equals(input, "TRACE", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.TRACE;
            else if (String.Equals(input, "COPY", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.COPY;
            else if (String.Equals(input, "LOCK", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.LOCK;
            else if (String.Equals(input, "MKCOL", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.MKCOL;
            else if (String.Equals(input, "PROPFIND", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.PROPFIND;
            else if (String.Equals(input, "PROPPATCH", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.PROPPATCH;
            else if (String.Equals(input, "UNLOCK", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.UNLOCK;
            else if (String.Equals(input, "TRACK", StringComparison.OrdinalIgnoreCase))
                return EnumHttpRequestVerb.TRACK;
            return null;
        }

        public static string ConvertBack(EnumHttpRequestVerb? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumHttpRequestVerb.DELETE:
                    return "DELETE";
                case EnumHttpRequestVerb.GET:
                    return "GET";
                case EnumHttpRequestVerb.HEAD:
                    return "HEAD";
                case EnumHttpRequestVerb.OPTIONS:
                    return "OPTIONS";
                case EnumHttpRequestVerb.PATCH:
                    return "PATCH";
                case EnumHttpRequestVerb.POST:
                    return "POST";
                case EnumHttpRequestVerb.PUT:
                    return "PUT";
                case EnumHttpRequestVerb.TRACE:
                    return "TRACE";
                case EnumHttpRequestVerb.COPY:
                    return "COPY";
                case EnumHttpRequestVerb.LOCK:
                    return "LOCK";
                case EnumHttpRequestVerb.MKCOL:
                    return "MKCOL";
                case EnumHttpRequestVerb.PROPFIND:
                    return "PROPFIND";
                case EnumHttpRequestVerb.PROPPATCH:
                    return "PROPPATCH";
                case EnumHttpRequestVerb.UNLOCK:
                    return "UNLOCK";
                case EnumHttpRequestVerb.TRACK:
                    return "TRACK";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the trap OID type.
    ///</summary>
public enum EnumTrapOIDType
    {
        ///<summary>
        /// The resulting OID is the combination of VendorOID + DeviceOID + Param ID.
        ///</summary>
Auto,
        ///<summary>
        /// The complete OID is specified in TrapOID.
        ///</summary>
Complete,
        ///<summary>
        /// The resulting OID is the combination of VendorOID + DeviceOID + the value specified in TrapOID.
        ///</summary>
Composed,
        ///<summary>
        /// When set to wildcard, you can use an asterisk (*) in the OID in order to capture all traps that match this OID.
        ///</summary>
Wildcard
    }

    public static partial class EnumTrapOIDTypeConverter
    {
        public static EnumTrapOIDType? Convert(string input)
        {
            if (String.Equals(input, "auto", StringComparison.OrdinalIgnoreCase))
                return EnumTrapOIDType.Auto;
            else if (String.Equals(input, "complete", StringComparison.OrdinalIgnoreCase))
                return EnumTrapOIDType.Complete;
            else if (String.Equals(input, "composed", StringComparison.OrdinalIgnoreCase))
                return EnumTrapOIDType.Composed;
            else if (String.Equals(input, "wildcard", StringComparison.OrdinalIgnoreCase))
                return EnumTrapOIDType.Wildcard;
            return null;
        }

        public static string ConvertBack(EnumTrapOIDType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumTrapOIDType.Auto:
                    return "auto";
                case EnumTrapOIDType.Complete:
                    return "complete";
                case EnumTrapOIDType.Composed:
                    return "composed";
                case EnumTrapOIDType.Wildcard:
                    return "wildcard";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the OID type.
    ///</summary>
public enum EnumOIDType
    {
        ///<summary>
        /// The resulting OID is the combination of VendorOID + DeviceOID + Param ID.
        ///</summary>
Auto,
        ///<summary>
        /// The resulting OID is the SNMP/OID value of this parameter.
        ///</summary>
Complete,
        ///<summary>
        /// The resulting OID is the combination of VendorOID + DeviceOID + SNMP.OID value of this parameter.
        ///</summary>
Composed,
        ///<summary>
        /// The resulting OID is the SNMP.OID value of this parameter prepended with the content of the parameter referred to by the id attribute.
        ///</summary>
Wildcard
    }

    public static partial class EnumOIDTypeConverter
    {
        public static EnumOIDType? Convert(string input)
        {
            if (String.Equals(input, "auto", StringComparison.OrdinalIgnoreCase))
                return EnumOIDType.Auto;
            else if (String.Equals(input, "complete", StringComparison.OrdinalIgnoreCase))
                return EnumOIDType.Complete;
            else if (String.Equals(input, "composed", StringComparison.OrdinalIgnoreCase))
                return EnumOIDType.Composed;
            else if (String.Equals(input, "wildcard", StringComparison.OrdinalIgnoreCase))
                return EnumOIDType.Wildcard;
            return null;
        }

        public static string ConvertBack(EnumOIDType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumOIDType.Auto:
                    return "auto";
                case EnumOIDType.Complete:
                    return "complete";
                case EnumOIDType.Composed:
                    return "composed";
                case EnumOIDType.Wildcard:
                    return "wildcard";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies on or off.
    ///</summary>
public enum EnumOnOff
    {
        ///<summary>
        /// On
        ///</summary>
On,
        ///<summary>
        /// Off
        ///</summary>
Off
    }

    public static partial class EnumOnOffConverter
    {
        public static EnumOnOff? Convert(string input)
        {
            if (String.Equals(input, "on", StringComparison.OrdinalIgnoreCase))
                return EnumOnOff.On;
            else if (String.Equals(input, "off", StringComparison.OrdinalIgnoreCase))
                return EnumOnOff.Off;
            return null;
        }

        public static string ConvertBack(EnumOnOff? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumOnOff.On:
                    return "on";
                case EnumOnOff.Off:
                    return "off";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the CRC type.
    ///</summary>
public enum EnumParamCRCType
    {
        _2comp,
        Codan,
        Crc,
        CrcCcitt,
        Crc16,
        Exor,
        Fletcher,
        LsbAfterSubtract,
        LsbAfterSum,
        Modbus,
        Rcds,
        Rest,
        Subtract,
        Sum
    }

    public static partial class EnumParamCRCTypeConverter
    {
        public static EnumParamCRCType? Convert(string input)
        {
            if (String.Equals(input, "2comp", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType._2comp;
            else if (String.Equals(input, "codan", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Codan;
            else if (String.Equals(input, "crc", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Crc;
            else if (String.Equals(input, "crc-ccitt", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.CrcCcitt;
            else if (String.Equals(input, "crc16", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Crc16;
            else if (String.Equals(input, "exor", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Exor;
            else if (String.Equals(input, "fletcher", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Fletcher;
            else if (String.Equals(input, "lsb after subtract", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.LsbAfterSubtract;
            else if (String.Equals(input, "lsb after sum", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.LsbAfterSum;
            else if (String.Equals(input, "modbus", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Modbus;
            else if (String.Equals(input, "rcds", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Rcds;
            else if (String.Equals(input, "rest", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Rest;
            else if (String.Equals(input, "subtract", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Subtract;
            else if (String.Equals(input, "sum", StringComparison.OrdinalIgnoreCase))
                return EnumParamCRCType.Sum;
            return null;
        }

        public static string ConvertBack(EnumParamCRCType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamCRCType._2comp:
                    return "2comp";
                case EnumParamCRCType.Codan:
                    return "codan";
                case EnumParamCRCType.Crc:
                    return "crc";
                case EnumParamCRCType.CrcCcitt:
                    return "crc-ccitt";
                case EnumParamCRCType.Crc16:
                    return "crc16";
                case EnumParamCRCType.Exor:
                    return "exor";
                case EnumParamCRCType.Fletcher:
                    return "fletcher";
                case EnumParamCRCType.LsbAfterSubtract:
                    return "lsb after subtract";
                case EnumParamCRCType.LsbAfterSum:
                    return "lsb after sum";
                case EnumParamCRCType.Modbus:
                    return "modbus";
                case EnumParamCRCType.Rcds:
                    return "rcds";
                case EnumParamCRCType.Rest:
                    return "rest";
                case EnumParamCRCType.Subtract:
                    return "subtract";
                case EnumParamCRCType.Sum:
                    return "sum";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter group type.
    ///</summary>
public enum EnumParamGroupType
    {
        ///<summary>
        /// In
        ///</summary>
In,
        ///<summary>
        /// In-Out
        ///</summary>
Inout,
        ///<summary>
        /// Out
        ///</summary>
Out
    }

    public static partial class EnumParamGroupTypeConverter
    {
        public static EnumParamGroupType? Convert(string input)
        {
            if (String.Equals(input, "in", StringComparison.OrdinalIgnoreCase))
                return EnumParamGroupType.In;
            else if (String.Equals(input, "inout", StringComparison.OrdinalIgnoreCase))
                return EnumParamGroupType.Inout;
            else if (String.Equals(input, "out", StringComparison.OrdinalIgnoreCase))
                return EnumParamGroupType.Out;
            return null;
        }

        public static string ConvertBack(EnumParamGroupType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamGroupType.In:
                    return "in";
                case EnumParamGroupType.Inout:
                    return "inout";
                case EnumParamGroupType.Out:
                    return "out";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter information to include.
    ///</summary>
public enum EnumParamInformationInclude
    {
        ///<summary>
        /// The range of the parameter.
        ///</summary>
Range,
        ///<summary>
        /// The step size of the parameter.
        ///</summary>
Steps,
        ///<summary>
        /// A time stamp that refers to one of the following:
        /// The last known change
        /// The last time the parameter was changed by its write parameter (if any)
        ///</summary>
Time,
        ///<summary>
        /// The unit of the parameter.
        ///</summary>
Units
    }

    public static partial class EnumParamInformationIncludeConverter
    {
        public static EnumParamInformationInclude? Convert(string input)
        {
            if (String.Equals(input, "range", StringComparison.OrdinalIgnoreCase))
                return EnumParamInformationInclude.Range;
            else if (String.Equals(input, "steps", StringComparison.OrdinalIgnoreCase))
                return EnumParamInformationInclude.Steps;
            else if (String.Equals(input, "time", StringComparison.OrdinalIgnoreCase))
                return EnumParamInformationInclude.Time;
            else if (String.Equals(input, "units", StringComparison.OrdinalIgnoreCase))
                return EnumParamInformationInclude.Units;
            return null;
        }

        public static string ConvertBack(EnumParamInformationInclude? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamInformationInclude.Range:
                    return "range";
                case EnumParamInformationInclude.Steps:
                    return "steps";
                case EnumParamInformationInclude.Time:
                    return "time";
                case EnumParamInformationInclude.Units:
                    return "units";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the alignment.
    ///</summary>
public enum EnumParamInterpretAlignment
    {
        ///<summary>
        /// Left alignment
        ///</summary>
Left,
        ///<summary>
        /// Right alignment
        ///</summary>
Right
    }

    public static partial class EnumParamInterpretAlignmentConverter
    {
        public static EnumParamInterpretAlignment? Convert(string input)
        {
            if (String.Equals(input, "left", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretAlignment.Left;
            else if (String.Equals(input, "right", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretAlignment.Right;
            return null;
        }

        public static string ConvertBack(EnumParamInterpretAlignment? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamInterpretAlignment.Left:
                    return "left";
                case EnumParamInterpretAlignment.Right:
                    return "right";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the type of trimming.
    ///</summary>
public enum EnumInterpretTypeTrim
    {
        ///<summary>
        /// Remove leading whitespace.
        ///</summary>
Left,
        ///<summary>
        /// Remove trailing whitespace.
        ///</summary>
Right,
        ///<summary>
        /// Remove leading and trailing whitespace.
        ///</summary>
LeftRight
    }

    public static partial class EnumInterpretTypeTrimConverter
    {
        public static EnumInterpretTypeTrim? Convert(string input)
        {
            if (String.Equals(input, "left", StringComparison.OrdinalIgnoreCase))
                return EnumInterpretTypeTrim.Left;
            else if (String.Equals(input, "right", StringComparison.OrdinalIgnoreCase))
                return EnumInterpretTypeTrim.Right;
            else if (String.Equals(input, "left;right", StringComparison.OrdinalIgnoreCase))
                return EnumInterpretTypeTrim.LeftRight;
            return null;
        }

        public static string ConvertBack(EnumInterpretTypeTrim? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumInterpretTypeTrim.Left:
                    return "left";
                case EnumInterpretTypeTrim.Right:
                    return "right";
                case EnumInterpretTypeTrim.LeftRight:
                    return "left;right";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the endian type.
    ///</summary>
public enum EnumParamInterpretEndian
    {
        ///<summary>
        /// The bytes will be reversed.
        ///</summary>
Big,
        ///<summary>
        /// The bytes will not be reversed.
        ///</summary>
Little
    }

    public static partial class EnumParamInterpretEndianConverter
    {
        public static EnumParamInterpretEndian? Convert(string input)
        {
            if (String.Equals(input, "big", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretEndian.Big;
            else if (String.Equals(input, "little", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretEndian.Little;
            return null;
        }

        public static string ConvertBack(EnumParamInterpretEndian? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamInterpretEndian.Big:
                    return "big";
                case EnumParamInterpretEndian.Little:
                    return "little";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter interpret length type.
    ///</summary>
public enum EnumParamInterpretLengthType
    {
        ///<summary>
        /// The parameter has a fixed length, which has to be defined in the /Protocol/Params/Param/Interprete/Length element.
        ///</summary>
Fixed,
        ///<summary>
        /// The parameter has a variable length, which depends on the last instance of the next (fixed-length) parame­ter in the response.
        ///</summary>
LastNextParam,
        ///<summary>
        /// The parameter has a variable length, which depends on the next (fixed-length) parameter in the response.
        ///</summary>
NextParam,
        ///<summary>
        /// The length of the parameter will be inherited from another parameter.
        ///</summary>
OtherParam
    }

    public static partial class EnumParamInterpretLengthTypeConverter
    {
        public static EnumParamInterpretLengthType? Convert(string input)
        {
            if (String.Equals(input, "fixed", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretLengthType.Fixed;
            else if (String.Equals(input, "last next param", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretLengthType.LastNextParam;
            else if (String.Equals(input, "next param", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretLengthType.NextParam;
            else if (String.Equals(input, "other param", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretLengthType.OtherParam;
            return null;
        }

        public static string ConvertBack(EnumParamInterpretLengthType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamInterpretLengthType.Fixed:
                    return "fixed";
                case EnumParamInterpretLengthType.LastNextParam:
                    return "last next param";
                case EnumParamInterpretLengthType.NextParam:
                    return "next param";
                case EnumParamInterpretLengthType.OtherParam:
                    return "other param";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter interpret raw type.
    ///</summary>
public enum EnumParamInterpretRawType
    {
        ///<summary>
        /// Binary Code Decimal (BCD)
        ///</summary>
Bcd,
        ///<summary>
        /// Double
        ///</summary>
Double,
        ///<summary>
        /// Numeric text
        ///</summary>
NumericText,
        ///<summary>
        /// Only others
        ///</summary>
OnlyOthers,
        ///<summary>
        /// Other
        ///</summary>
Other,
        ///<summary>
        /// Signed number
        ///</summary>
SignedNumber,
        ///<summary>
        /// Text
        ///</summary>
Text,
        ///<summary>
        /// Unsigned number
        ///</summary>
UnsignedNumber
    }

    public static partial class EnumParamInterpretRawTypeConverter
    {
        public static EnumParamInterpretRawType? Convert(string input)
        {
            if (String.Equals(input, "bcd", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretRawType.Bcd;
            else if (String.Equals(input, "double", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretRawType.Double;
            else if (String.Equals(input, "numeric text", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretRawType.NumericText;
            else if (String.Equals(input, "only others", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretRawType.OnlyOthers;
            else if (String.Equals(input, "other", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretRawType.Other;
            else if (String.Equals(input, "signed number", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretRawType.SignedNumber;
            else if (String.Equals(input, "text", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretRawType.Text;
            else if (String.Equals(input, "unsigned number", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretRawType.UnsignedNumber;
            return null;
        }

        public static string ConvertBack(EnumParamInterpretRawType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamInterpretRawType.Bcd:
                    return "bcd";
                case EnumParamInterpretRawType.Double:
                    return "double";
                case EnumParamInterpretRawType.NumericText:
                    return "numeric text";
                case EnumParamInterpretRawType.OnlyOthers:
                    return "only others";
                case EnumParamInterpretRawType.Other:
                    return "other";
                case EnumParamInterpretRawType.SignedNumber:
                    return "signed number";
                case EnumParamInterpretRawType.Text:
                    return "text";
                case EnumParamInterpretRawType.UnsignedNumber:
                    return "unsigned number";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter interpret type.
    ///</summary>
public enum EnumParamInterpretType
    {
        ///<summary>
        /// The parameter value will be processed as a number.
        ///</summary>
Double,
        ///<summary>
        /// The parameter value will be processed as the high nibble (i.e. first four bits) of a byte.
        ///</summary>
HighNibble,
        ///<summary>
        /// The parameter value will be processed as an ASCII string.
        ///</summary>
String
    }

    public static partial class EnumParamInterpretTypeConverter
    {
        public static EnumParamInterpretType? Convert(string input)
        {
            if (String.Equals(input, "double", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretType.Double;
            else if (String.Equals(input, "high nibble", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretType.HighNibble;
            else if (String.Equals(input, "string", StringComparison.OrdinalIgnoreCase))
                return EnumParamInterpretType.String;
            return null;
        }

        public static string ConvertBack(EnumParamInterpretType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamInterpretType.Double:
                    return "double";
                case EnumParamInterpretType.HighNibble:
                    return "high nibble";
                case EnumParamInterpretType.String:
                    return "string";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter view type.
    ///</summary>
public enum EnumParametersViewType
    {
        ///<summary>
        /// Column chart
        ///</summary>
Column,
        ///<summary>
        /// Pie chart
        ///</summary>
Pie,
        ///<summary>
        /// Row chart
        ///</summary>
Row,
        ///<summary>
        /// Stacked area chart
        ///</summary>
Stackedarea
    }

    public static partial class EnumParametersViewTypeConverter
    {
        public static EnumParametersViewType? Convert(string input)
        {
            if (String.Equals(input, "column", StringComparison.OrdinalIgnoreCase))
                return EnumParametersViewType.Column;
            else if (String.Equals(input, "pie", StringComparison.OrdinalIgnoreCase))
                return EnumParametersViewType.Pie;
            else if (String.Equals(input, "row", StringComparison.OrdinalIgnoreCase))
                return EnumParametersViewType.Row;
            else if (String.Equals(input, "stackedarea", StringComparison.OrdinalIgnoreCase))
                return EnumParametersViewType.Stackedarea;
            return null;
        }

        public static string ConvertBack(EnumParametersViewType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParametersViewType.Column:
                    return "column";
                case EnumParametersViewType.Pie:
                    return "pie";
                case EnumParametersViewType.Row:
                    return "row";
                case EnumParametersViewType.Stackedarea:
                    return "stackedarea";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter confirmation type.
    ///</summary>
public enum EnumParamConfirmPopup
    {
        ///<summary>
        /// The confirmation popup will always appear, regardless of the value of the “Never ask for confirmation after setting parameter value” setting in DataMiner Cube.
        ///</summary>
Always,
        ///<summary>
        /// The confirmation popup will never appear, regardless of the value of the “Never ask for confirmation after setting parameter value” setting in DataMiner Cube.
        ///</summary>
Never,
        ///<summary>
        /// The confirmation popup will appear or not, depending on the value of the “Never ask for confirmation after setting parameter value” setting in DataMiner Cube.
        ///</summary>
Dm
    }

    public static partial class EnumParamConfirmPopupConverter
    {
        public static EnumParamConfirmPopup? Convert(string input)
        {
            if (String.Equals(input, "always", StringComparison.OrdinalIgnoreCase))
                return EnumParamConfirmPopup.Always;
            else if (String.Equals(input, "never", StringComparison.OrdinalIgnoreCase))
                return EnumParamConfirmPopup.Never;
            else if (String.Equals(input, "dm", StringComparison.OrdinalIgnoreCase))
                return EnumParamConfirmPopup.Dm;
            return null;
        }

        public static string ConvertBack(EnumParamConfirmPopup? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamConfirmPopup.Always:
                    return "always";
                case EnumParamConfirmPopup.Never:
                    return "never";
                case EnumParamConfirmPopup.Dm:
                    return "dm";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter measurment type.
    ///</summary>
public enum EnumParamMeasurementType
    {
        Analog,
        Button,
        Chart,
        DigitalThreshold,
        Discreet,
        Matrix,
        Number,
        Pagebutton,
        Progress,
        String,
        Table,
        Title,
        Togglebutton
    }

    public static partial class EnumParamMeasurementTypeConverter
    {
        public static EnumParamMeasurementType? Convert(string input)
        {
            if (String.Equals(input, "analog", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Analog;
            else if (String.Equals(input, "button", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Button;
            else if (String.Equals(input, "chart", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Chart;
            else if (String.Equals(input, "digital threshold", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.DigitalThreshold;
            else if (String.Equals(input, "discreet", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Discreet;
            else if (String.Equals(input, "matrix", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Matrix;
            else if (String.Equals(input, "number", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Number;
            else if (String.Equals(input, "pagebutton", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Pagebutton;
            else if (String.Equals(input, "progress", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Progress;
            else if (String.Equals(input, "string", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.String;
            else if (String.Equals(input, "table", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Table;
            else if (String.Equals(input, "title", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Title;
            else if (String.Equals(input, "togglebutton", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementType.Togglebutton;
            return null;
        }

        public static string ConvertBack(EnumParamMeasurementType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamMeasurementType.Analog:
                    return "analog";
                case EnumParamMeasurementType.Button:
                    return "button";
                case EnumParamMeasurementType.Chart:
                    return "chart";
                case EnumParamMeasurementType.DigitalThreshold:
                    return "digital threshold";
                case EnumParamMeasurementType.Discreet:
                    return "discreet";
                case EnumParamMeasurementType.Matrix:
                    return "matrix";
                case EnumParamMeasurementType.Number:
                    return "number";
                case EnumParamMeasurementType.Pagebutton:
                    return "pagebutton";
                case EnumParamMeasurementType.Progress:
                    return "progress";
                case EnumParamMeasurementType.String:
                    return "string";
                case EnumParamMeasurementType.Table:
                    return "table";
                case EnumParamMeasurementType.Title:
                    return "title";
                case EnumParamMeasurementType.Togglebutton:
                    return "togglebutton";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter measurement casing type.
    ///</summary>
public enum EnumParamMeasurementTypeCase
    {
        ///<summary>
        /// Lower case
        ///</summary>
Lower,
        ///<summary>
        /// Upper case
        ///</summary>
Upper
    }

    public static partial class EnumParamMeasurementTypeCaseConverter
    {
        public static EnumParamMeasurementTypeCase? Convert(string input)
        {
            if (String.Equals(input, "lower", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementTypeCase.Lower;
            else if (String.Equals(input, "upper", StringComparison.OrdinalIgnoreCase))
                return EnumParamMeasurementTypeCase.Upper;
            return null;
        }

        public static string ConvertBack(EnumParamMeasurementTypeCase? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamMeasurementTypeCase.Lower:
                    return "lower";
                case EnumParamMeasurementTypeCase.Upper:
                    return "upper";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parameter type.
    ///</summary>
public enum EnumParamType
    {
        Array,
        Bus,
        Crc,
        DataminerInfo,
        DiscreetInfo,
        Dummy,
        Elementdmaid,
        Elementid,
        Elementname,
        Fixed,
        Group,
        Header,
        Ip,
        Length,
        ///<summary>
        /// Represents a matrix. Feature introduced in DataMiner 10.3.1/10.4.0 (RN 34661).
        ///</summary>
Matrix,
        Pollingip,
        Read,
        ReadBit,
        Response,
        Trailer,
        Write,
        WriteBit
    }

    public static partial class EnumParamTypeConverter
    {
        public static EnumParamType? Convert(string input)
        {
            if (String.Equals(input, "array", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Array;
            else if (String.Equals(input, "bus", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Bus;
            else if (String.Equals(input, "crc", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Crc;
            else if (String.Equals(input, "dataminer info", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.DataminerInfo;
            else if (String.Equals(input, "discreet info", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.DiscreetInfo;
            else if (String.Equals(input, "dummy", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Dummy;
            else if (String.Equals(input, "elementdmaid", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Elementdmaid;
            else if (String.Equals(input, "elementid", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Elementid;
            else if (String.Equals(input, "elementname", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Elementname;
            else if (String.Equals(input, "fixed", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Fixed;
            else if (String.Equals(input, "group", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Group;
            else if (String.Equals(input, "header", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Header;
            else if (String.Equals(input, "ip", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Ip;
            else if (String.Equals(input, "length", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Length;
            else if (String.Equals(input, "matrix", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Matrix;
            else if (String.Equals(input, "pollingip", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Pollingip;
            else if (String.Equals(input, "read", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Read;
            else if (String.Equals(input, "read bit", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.ReadBit;
            else if (String.Equals(input, "response", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Response;
            else if (String.Equals(input, "trailer", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Trailer;
            else if (String.Equals(input, "write", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.Write;
            else if (String.Equals(input, "write bit", StringComparison.OrdinalIgnoreCase))
                return EnumParamType.WriteBit;
            return null;
        }

        public static string ConvertBack(EnumParamType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumParamType.Array:
                    return "array";
                case EnumParamType.Bus:
                    return "bus";
                case EnumParamType.Crc:
                    return "crc";
                case EnumParamType.DataminerInfo:
                    return "dataminer info";
                case EnumParamType.DiscreetInfo:
                    return "discreet info";
                case EnumParamType.Dummy:
                    return "dummy";
                case EnumParamType.Elementdmaid:
                    return "elementdmaid";
                case EnumParamType.Elementid:
                    return "elementid";
                case EnumParamType.Elementname:
                    return "elementname";
                case EnumParamType.Fixed:
                    return "fixed";
                case EnumParamType.Group:
                    return "group";
                case EnumParamType.Header:
                    return "header";
                case EnumParamType.Ip:
                    return "ip";
                case EnumParamType.Length:
                    return "length";
                case EnumParamType.Matrix:
                    return "matrix";
                case EnumParamType.Pollingip:
                    return "pollingip";
                case EnumParamType.Read:
                    return "read";
                case EnumParamType.ReadBit:
                    return "read bit";
                case EnumParamType.Response:
                    return "response";
                case EnumParamType.Trailer:
                    return "trailer";
                case EnumParamType.Write:
                    return "write";
                case EnumParamType.WriteBit:
                    return "write bit";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the flow control type.
    ///</summary>
public enum EnumPortSettingsFlowControl
    {
        ///<summary>
        /// No flow control
        ///</summary>
No,
        ///<summary>
        /// CTS (Clear to Send) RTS (Request to Send)
        ///</summary>
CtsRts,
        ///<summary>
        /// CTS (Clear to Send) DTR (Data Terminal Ready)
        ///</summary>
CtsDtr,
        ///<summary>
        /// DSR (Data Set Ready) RTS (Request to Send)
        ///</summary>
DsrRts,
        ///<summary>
        /// DSR (Data Set Ready) DTR (Data Terminal Ready)
        ///</summary>
DsrDtr,
        ///<summary>
        /// XON/XOFF
        ///</summary>
XonXoff
    }

    public static partial class EnumPortSettingsFlowControlConverter
    {
        public static EnumPortSettingsFlowControl? Convert(string input)
        {
            if (String.Equals(input, "no", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsFlowControl.No;
            else if (String.Equals(input, "cts_rts", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsFlowControl.CtsRts;
            else if (String.Equals(input, "cts_dtr", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsFlowControl.CtsDtr;
            else if (String.Equals(input, "dsr_rts", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsFlowControl.DsrRts;
            else if (String.Equals(input, "dsr_dtr", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsFlowControl.DsrDtr;
            else if (String.Equals(input, "xon_xoff", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsFlowControl.XonXoff;
            return null;
        }

        public static string ConvertBack(EnumPortSettingsFlowControl? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumPortSettingsFlowControl.No:
                    return "no";
                case EnumPortSettingsFlowControl.CtsRts:
                    return "cts_rts";
                case EnumPortSettingsFlowControl.CtsDtr:
                    return "cts_dtr";
                case EnumPortSettingsFlowControl.DsrRts:
                    return "dsr_rts";
                case EnumPortSettingsFlowControl.DsrDtr:
                    return "dsr_dtr";
                case EnumPortSettingsFlowControl.XonXoff:
                    return "xon_xoff";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the parity.
    ///</summary>
public enum EnumPortSettingsParity
    {
        ///<summary>
        /// Even parity
        ///</summary>
Even,
        ///<summary>
        /// Mark parity
        ///</summary>
Mark,
        ///<summary>
        /// No parity
        ///</summary>
No,
        ///<summary>
        /// Odd parity
        ///</summary>
Odd,
        ///<summary>
        /// Space parity
        ///</summary>
Space
    }

    public static partial class EnumPortSettingsParityConverter
    {
        public static EnumPortSettingsParity? Convert(string input)
        {
            if (String.Equals(input, "even", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsParity.Even;
            else if (String.Equals(input, "mark", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsParity.Mark;
            else if (String.Equals(input, "no", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsParity.No;
            else if (String.Equals(input, "odd", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsParity.Odd;
            else if (String.Equals(input, "space", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsParity.Space;
            return null;
        }

        public static string ConvertBack(EnumPortSettingsParity? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumPortSettingsParity.Even:
                    return "even";
                case EnumPortSettingsParity.Mark:
                    return "mark";
                case EnumPortSettingsParity.No:
                    return "no";
                case EnumPortSettingsParity.Odd:
                    return "odd";
                case EnumPortSettingsParity.Space:
                    return "space";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the number of stop bits.
    ///</summary>
public enum EnumPortSettingsStopBits
    {
        _1,
        _15,
        _2
    }

    public static partial class EnumPortSettingsStopBitsConverter
    {
        public static EnumPortSettingsStopBits? Convert(string input)
        {
            if (String.Equals(input, "1", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsStopBits._1;
            else if (String.Equals(input, "1.5", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsStopBits._15;
            else if (String.Equals(input, "2", StringComparison.OrdinalIgnoreCase))
                return EnumPortSettingsStopBits._2;
            return null;
        }

        public static string ConvertBack(EnumPortSettingsStopBits? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumPortSettingsStopBits._1:
                    return "1";
                case EnumPortSettingsStopBits._15:
                    return "1.5";
                case EnumPortSettingsStopBits._2:
                    return "2";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the WebSocket message type.
    ///</summary>
public enum EnumWebSocketMessageType
    {
        ///<summary>
        /// The message will be sent as binary data (Default).
        ///</summary>
Binary,
        ///<summary>
        /// The message will be sent in plain text format using UTF-8 encoding.
        ///</summary>
Text
    }

    public static partial class EnumWebSocketMessageTypeConverter
    {
        public static EnumWebSocketMessageType? Convert(string input)
        {
            if (String.Equals(input, "binary", StringComparison.OrdinalIgnoreCase))
                return EnumWebSocketMessageType.Binary;
            else if (String.Equals(input, "text", StringComparison.OrdinalIgnoreCase))
                return EnumWebSocketMessageType.Text;
            return null;
        }

        public static string ConvertBack(EnumWebSocketMessageType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumWebSocketMessageType.Binary:
                    return "binary";
                case EnumWebSocketMessageType.Text:
                    return "text";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the slow poll base.
    ///</summary>
public enum EnumTypePortSlowPollBase
    {
        ///<summary>
        /// The SlowPoll setting is a number of timeouts.
        ///</summary>
Number,
        ///<summary>
        /// The SlowPoll setting is a number of milliseconds.
        ///</summary>
Time
    }

    public static partial class EnumTypePortSlowPollBaseConverter
    {
        public static EnumTypePortSlowPollBase? Convert(string input)
        {
            if (String.Equals(input, "number", StringComparison.OrdinalIgnoreCase))
                return EnumTypePortSlowPollBase.Number;
            else if (String.Equals(input, "time", StringComparison.OrdinalIgnoreCase))
                return EnumTypePortSlowPollBase.Time;
            return null;
        }

        public static string ConvertBack(EnumTypePortSlowPollBase? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumTypePortSlowPollBase.Number:
                    return "number";
                case EnumTypePortSlowPollBase.Time:
                    return "time";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the protocol type.
    ///</summary>
public enum EnumProtocolType
    {
        ///<summary>
        /// General Purpose Interface Bus (GPIB)
        ///</summary>
Gpib,
        ///<summary>
        /// Hypertext Transfer Protocol (HTTP)
        ///</summary>
Http,
        ///<summary>
        /// OLE Process Control (OPC)
        ///</summary>
Opc,
        ///<summary>
        /// Serial
        ///</summary>
Serial,
        ///<summary>
        /// Serial single
        ///</summary>
SerialSingle,
        ///<summary>
        /// Service
        ///</summary>
Service,
        ///<summary>
        /// Service Level Agreement (SLA)
        ///</summary>
Sla,
        ///<summary>
        /// Smart-serial
        ///</summary>
SmartSerial,
        ///<summary>
        /// Smart-serial single
        ///</summary>
SmartSerialSingle,
        ///<summary>
        /// SNMP
        ///</summary>
Snmp,
        ///<summary>
        /// SNMPv2
        ///</summary>
Snmpv2,
        ///<summary>
        /// SNMPv3
        ///</summary>
Snmpv3,
        ///<summary>
        /// Virtual
        ///</summary>
Virtual
    }

    public static partial class EnumProtocolTypeConverter
    {
        public static EnumProtocolType? Convert(string input)
        {
            if (String.Equals(input, "gpib", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Gpib;
            else if (String.Equals(input, "http", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Http;
            else if (String.Equals(input, "opc", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Opc;
            else if (String.Equals(input, "serial", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Serial;
            else if (String.Equals(input, "serial single", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.SerialSingle;
            else if (String.Equals(input, "service", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Service;
            else if (String.Equals(input, "sla", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Sla;
            else if (String.Equals(input, "smart-serial", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.SmartSerial;
            else if (String.Equals(input, "smart-serial single", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.SmartSerialSingle;
            else if (String.Equals(input, "snmp", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Snmp;
            else if (String.Equals(input, "snmpv2", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Snmpv2;
            else if (String.Equals(input, "snmpv3", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Snmpv3;
            else if (String.Equals(input, "virtual", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolType.Virtual;
            return null;
        }

        public static string ConvertBack(EnumProtocolType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumProtocolType.Gpib:
                    return "gpib";
                case EnumProtocolType.Http:
                    return "http";
                case EnumProtocolType.Opc:
                    return "opc";
                case EnumProtocolType.Serial:
                    return "serial";
                case EnumProtocolType.SerialSingle:
                    return "serial single";
                case EnumProtocolType.Service:
                    return "service";
                case EnumProtocolType.Sla:
                    return "sla";
                case EnumProtocolType.SmartSerial:
                    return "smart-serial";
                case EnumProtocolType.SmartSerialSingle:
                    return "smart-serial single";
                case EnumProtocolType.Snmp:
                    return "snmp";
                case EnumProtocolType.Snmpv2:
                    return "snmpv2";
                case EnumProtocolType.Snmpv3:
                    return "snmpv3";
                case EnumProtocolType.Virtual:
                    return "virtual";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the relative timers type.
    ///</summary>
public enum EnumProtocolTypeRelativeTimers
    {
        ///<summary>
        /// If the interval is changed in the middle of the current interval, the timer will only be executed when the interval is completely finished.
        ///</summary>
True,
        ///<summary>
        /// Each time the interval is changed the timer is executed instantly.
        ///</summary>
TrueWithReset
    }

    public static partial class EnumProtocolTypeRelativeTimersConverter
    {
        public static EnumProtocolTypeRelativeTimers? Convert(string input)
        {
            if (String.Equals(input, "true", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolTypeRelativeTimers.True;
            else if (String.Equals(input, "true with reset", StringComparison.OrdinalIgnoreCase))
                return EnumProtocolTypeRelativeTimers.TrueWithReset;
            return null;
        }

        public static string ConvertBack(EnumProtocolTypeRelativeTimers? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumProtocolTypeRelativeTimers.True:
                    return "true";
                case EnumProtocolTypeRelativeTimers.TrueWithReset:
                    return "true with reset";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the encoding of the QAction.
    ///</summary>
public enum EnumQActionEncoding
    {
        ///<summary>
        /// JScript
        ///</summary>
Jscript,
        ///<summary>
        /// VBScript
        ///</summary>
Vbscript,
        ///<summary>
        /// C#
        ///</summary>
Csharp
    }

    public static partial class EnumQActionEncodingConverter
    {
        public static EnumQActionEncoding? Convert(string input)
        {
            if (String.Equals(input, "jscript", StringComparison.OrdinalIgnoreCase))
                return EnumQActionEncoding.Jscript;
            else if (String.Equals(input, "vbscript", StringComparison.OrdinalIgnoreCase))
                return EnumQActionEncoding.Vbscript;
            else if (String.Equals(input, "csharp", StringComparison.OrdinalIgnoreCase))
                return EnumQActionEncoding.Csharp;
            return null;
        }

        public static string ConvertBack(EnumQActionEncoding? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumQActionEncoding.Jscript:
                    return "jscript";
                case EnumQActionEncoding.Vbscript:
                    return "vbscript";
                case EnumQActionEncoding.Csharp:
                    return "csharp";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the possible QAction options.
    ///</summary>
public enum EnumQActionOption
    {
        ///<summary>
        /// If specified, all values in “inputParameters” are forwarded to the QAction as a byte array holding the raw content of the parameter.
        ///</summary>
Binary,
        ///<summary>
        /// Compiles the QAction in debug mode.
        ///</summary>
Debug,
        ///<summary>
        /// By default, every QAction is compiled into a DLL file at first use. This DLL file is stored in the C:\Skyline DataMiner\ProtocolScripts directory, and is assigned a name that is constructed in the following format:
        /// [ProtocolName].[ProtocolVersion].QAction.[QactionID].dll
        /// When you want the DLL file to include a meaningful name, enter that name in this options attribute.
        /// This name will then replace the QAction.[QActionID] part.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
DllName,
        ///<summary>
        /// When you specify this option, the “OldRow()” function will return the values retrieved by that group.
        ///</summary>
Group,
        ///<summary>
        /// Compiles the QAction immediately, without waiting for it to be triggered for execution.
        ///</summary>
Precompile,
        ///<summary>
        /// The QAction will be executed asynchronously. This implies that the QAction is triggered and set in the back­ground.
        ///</summary>
Queued
    }

    public static partial class EnumQActionOptionConverter
    {
        public static EnumQActionOption? Convert(string input)
        {
            if (String.Equals(input, "binary", StringComparison.OrdinalIgnoreCase))
                return EnumQActionOption.Binary;
            else if (String.Equals(input, "debug", StringComparison.OrdinalIgnoreCase))
                return EnumQActionOption.Debug;
            else if (String.Equals(input, "dllName=", StringComparison.OrdinalIgnoreCase))
                return EnumQActionOption.DllName;
            else if (String.Equals(input, "group", StringComparison.OrdinalIgnoreCase))
                return EnumQActionOption.Group;
            else if (String.Equals(input, "precompile", StringComparison.OrdinalIgnoreCase))
                return EnumQActionOption.Precompile;
            else if (String.Equals(input, "queued", StringComparison.OrdinalIgnoreCase))
                return EnumQActionOption.Queued;
            return null;
        }

        public static string ConvertBack(EnumQActionOption? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumQActionOption.Binary:
                    return "binary";
                case EnumQActionOption.Debug:
                    return "debug";
                case EnumQActionOption.DllName:
                    return "dllName=";
                case EnumQActionOption.Group:
                    return "group";
                case EnumQActionOption.Precompile:
                    return "precompile";
                case EnumQActionOption.Queued:
                    return "queued";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the rounding type.
    ///</summary>
public enum EnumRounding
    {
        Down,
        Up,
        ToZero,
        ToInfinity,
        HalfDown,
        HalfUp,
        HalfToZero,
        HalfToInfinity
    }

    public static partial class EnumRoundingConverter
    {
        public static EnumRounding? Convert(string input)
        {
            if (String.Equals(input, "down", StringComparison.OrdinalIgnoreCase))
                return EnumRounding.Down;
            else if (String.Equals(input, "up", StringComparison.OrdinalIgnoreCase))
                return EnumRounding.Up;
            else if (String.Equals(input, "toZero", StringComparison.OrdinalIgnoreCase))
                return EnumRounding.ToZero;
            else if (String.Equals(input, "toInfinity", StringComparison.OrdinalIgnoreCase))
                return EnumRounding.ToInfinity;
            else if (String.Equals(input, "halfDown", StringComparison.OrdinalIgnoreCase))
                return EnumRounding.HalfDown;
            else if (String.Equals(input, "halfUp", StringComparison.OrdinalIgnoreCase))
                return EnumRounding.HalfUp;
            else if (String.Equals(input, "halfToZero", StringComparison.OrdinalIgnoreCase))
                return EnumRounding.HalfToZero;
            else if (String.Equals(input, "halfToInfinity", StringComparison.OrdinalIgnoreCase))
                return EnumRounding.HalfToInfinity;
            return null;
        }

        public static string ConvertBack(EnumRounding? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumRounding.Down:
                    return "down";
                case EnumRounding.Up:
                    return "up";
                case EnumRounding.ToZero:
                    return "toZero";
                case EnumRounding.ToInfinity:
                    return "toInfinity";
                case EnumRounding.HalfDown:
                    return "halfDown";
                case EnumRounding.HalfUp:
                    return "halfUp";
                case EnumRounding.HalfToZero:
                    return "halfToZero";
                case EnumRounding.HalfToInfinity:
                    return "halfToInfinity";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the scientific notation type.
    ///</summary>
public enum EnumScientificNotation
    {
        ///<summary>
        /// Displays the number using normalized scientific notation.
        ///</summary>
Universal,
        ///<summary>
        /// Displays the number using engineering notation.
        ///</summary>
Scientific
    }

    public static partial class EnumScientificNotationConverter
    {
        public static EnumScientificNotation? Convert(string input)
        {
            if (String.Equals(input, "universal", StringComparison.OrdinalIgnoreCase))
                return EnumScientificNotation.Universal;
            else if (String.Equals(input, "scientific", StringComparison.OrdinalIgnoreCase))
                return EnumScientificNotation.Scientific;
            return null;
        }

        public static string ConvertBack(EnumScientificNotation? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumScientificNotation.Universal:
                    return "universal";
                case EnumScientificNotation.Scientific:
                    return "scientific";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the OID assignment type.
    ///</summary>
public enum EnumSNMP
    {
        ///<summary>
        /// The MIB will assign an OID to each parameter according to its number in the protocol.
        ///</summary>
Auto,
        ///<summary>
        /// The MIB will not automatically create an OID for each parameter.
        ///</summary>
False
    }

    public static partial class EnumSNMPConverter
    {
        public static EnumSNMP? Convert(string input)
        {
            if (String.Equals(input, "auto", StringComparison.OrdinalIgnoreCase))
                return EnumSNMP.Auto;
            else if (String.Equals(input, "false", StringComparison.OrdinalIgnoreCase))
                return EnumSNMP.False;
            return null;
        }

        public static string ConvertBack(EnumSNMP? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumSNMP.Auto:
                    return "auto";
                case EnumSNMP.False:
                    return "false";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the SNMP type.
    ///</summary>
public enum EnumSNMPType
    {
        ///<summary>
        /// Represents a non-negative integer which monotonically increases until it reaches a maximum value of 2^32-1 (4294967295 decimal), when it wraps around and starts increasing again from zero.
        ///</summary>
Counter32,
        ///<summary>
        /// Represents a non-negative integer which monotonically increases until it reaches a maximum value of 2^64-1 (18446744073709551615 decimal), when it wraps around and starts increasing again from zero.
        ///</summary>
Counter64,
        ///<summary>
        /// Can be used to receive the SNMP counter64 as a string, where the counter64 uses double and may therefore lose definition. Introduced in DataMiner 8.5.4 (RN 9284).
        ///</summary>
Counter64String,
        ///<summary>
        /// Represents a non-negative integer, which may increase or decrease, but shall never exceed a maximum value, nor fall below a minimum value. The maximum value can not be greater than 2^32-1 (4294967295 decimal), and the minimum value can not be smaller than 0.
        ///</summary>
Gauge32,
        ///<summary>
        /// Represents integer-valued information between -2^31 and 2^31-1 inclusive.
        ///</summary>
Integer,
        ///<summary>
        /// Represents integer-valued information between -2^31 and 2^31-1 inclusive.
        ///</summary>
Integer32,
        ///<summary>
        /// Represents an IP address.
        ///</summary>
Ipaddress,
        ///<summary>
        /// Represents an OSI address as a variable-length OCTET STRING.
        ///</summary>
Nsapaddress,
        ///<summary>
        /// Indicates effective absence of a sequence element.
        ///</summary>
Null,
        ///<summary>
        /// Represents administratively assigned names.
        ///</summary>
Objectid,
        ///<summary>
        /// Represents arbitrary binary or textual data.
        ///</summary>
Octetstring,
        Octetstringhex,
        Octetstringascii,
        Octetstringutf8,
        Octetstringdecimal,
        ///<summary>
        /// A globally unique value associated with an object to unambiguously identify it.
        ///</summary>
Oid,
        ///<summary>
        /// Provided solely for backward-compatibility, and shall not be used for newly-defined object types.
        ///</summary>
Opaque,
        ///<summary>
        /// Represents a non-negative integer which represents the time, modulo 2^32 (4294967296 decimal), in hundredths of a second between two epochs.
        ///</summary>
Timeticks,
        ///<summary>
        /// The Unsigned32 type represents integer-valued information between 0 and 2^32-1 inclusive (0 to 4294967295 decimal).
        ///</summary>
Uinteger32
    }

    public static partial class EnumSNMPTypeConverter
    {
        public static EnumSNMPType? Convert(string input)
        {
            if (String.Equals(input, "counter32", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Counter32;
            else if (String.Equals(input, "counter64", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Counter64;
            else if (String.Equals(input, "counter64String", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Counter64String;
            else if (String.Equals(input, "gauge32", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Gauge32;
            else if (String.Equals(input, "integer", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Integer;
            else if (String.Equals(input, "integer32", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Integer32;
            else if (String.Equals(input, "ipaddress", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Ipaddress;
            else if (String.Equals(input, "nsapaddress", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Nsapaddress;
            else if (String.Equals(input, "null", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Null;
            else if (String.Equals(input, "objectid", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Objectid;
            else if (String.Equals(input, "octetstring", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Octetstring;
            else if (String.Equals(input, "octetstringhex", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Octetstringhex;
            else if (String.Equals(input, "octetstringascii", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Octetstringascii;
            else if (String.Equals(input, "octetstringutf8", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Octetstringutf8;
            else if (String.Equals(input, "octetstringdecimal", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Octetstringdecimal;
            else if (String.Equals(input, "oid", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Oid;
            else if (String.Equals(input, "opaque", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Opaque;
            else if (String.Equals(input, "timeticks", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Timeticks;
            else if (String.Equals(input, "uinteger32", StringComparison.OrdinalIgnoreCase))
                return EnumSNMPType.Uinteger32;
            return null;
        }

        public static string ConvertBack(EnumSNMPType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumSNMPType.Counter32:
                    return "counter32";
                case EnumSNMPType.Counter64:
                    return "counter64";
                case EnumSNMPType.Counter64String:
                    return "counter64String";
                case EnumSNMPType.Gauge32:
                    return "gauge32";
                case EnumSNMPType.Integer:
                    return "integer";
                case EnumSNMPType.Integer32:
                    return "integer32";
                case EnumSNMPType.Ipaddress:
                    return "ipaddress";
                case EnumSNMPType.Nsapaddress:
                    return "nsapaddress";
                case EnumSNMPType.Null:
                    return "null";
                case EnumSNMPType.Objectid:
                    return "objectid";
                case EnumSNMPType.Octetstring:
                    return "octetstring";
                case EnumSNMPType.Octetstringhex:
                    return "octetstringhex";
                case EnumSNMPType.Octetstringascii:
                    return "octetstringascii";
                case EnumSNMPType.Octetstringutf8:
                    return "octetstringutf8";
                case EnumSNMPType.Octetstringdecimal:
                    return "octetstringdecimal";
                case EnumSNMPType.Oid:
                    return "oid";
                case EnumSNMPType.Opaque:
                    return "opaque";
                case EnumSNMPType.Timeticks:
                    return "timeticks";
                case EnumSNMPType.Uinteger32:
                    return "uinteger32";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the trending type.
    ///</summary>
public enum EnumTrendingType
    {
        ///<summary>
        /// Average value in the time span (default when no trending tag is present).
        ///</summary>
Average,
        ///<summary>
        /// Maximum value in the time span.
        ///</summary>
Max,
        ///<summary>
        /// Minimum value in the time span.
        ///</summary>
Min,
        ///<summary>
        /// Last value in the time span.
        ///</summary>
Last,
        ///<summary>
        /// Sum of all the values in the time span. This cannot be used for discreet parameters.
        ///</summary>
Sum
    }

    public static partial class EnumTrendingTypeConverter
    {
        public static EnumTrendingType? Convert(string input)
        {
            if (String.Equals(input, "average", StringComparison.OrdinalIgnoreCase))
                return EnumTrendingType.Average;
            else if (String.Equals(input, "max", StringComparison.OrdinalIgnoreCase))
                return EnumTrendingType.Max;
            else if (String.Equals(input, "min", StringComparison.OrdinalIgnoreCase))
                return EnumTrendingType.Min;
            else if (String.Equals(input, "last", StringComparison.OrdinalIgnoreCase))
                return EnumTrendingType.Last;
            else if (String.Equals(input, "sum", StringComparison.OrdinalIgnoreCase))
                return EnumTrendingType.Sum;
            return null;
        }

        public static string ConvertBack(EnumTrendingType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumTrendingType.Average:
                    return "average";
                case EnumTrendingType.Max:
                    return "max";
                case EnumTrendingType.Min:
                    return "min";
                case EnumTrendingType.Last:
                    return "last";
                case EnumTrendingType.Sum:
                    return "sum";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the item on which the trigger triggers.
    ///</summary>
public enum EnumTriggerOn
    {
        Command,
        Communication,
        Group,
        Pair,
        Parameter,
        Protocol,
        Response,
        Session,
        Timer
    }

    public static partial class EnumTriggerOnConverter
    {
        public static EnumTriggerOn? Convert(string input)
        {
            if (String.Equals(input, "command", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Command;
            else if (String.Equals(input, "communication", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Communication;
            else if (String.Equals(input, "group", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Group;
            else if (String.Equals(input, "pair", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Pair;
            else if (String.Equals(input, "parameter", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Parameter;
            else if (String.Equals(input, "protocol", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Protocol;
            else if (String.Equals(input, "response", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Response;
            else if (String.Equals(input, "session", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Session;
            else if (String.Equals(input, "timer", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerOn.Timer;
            return null;
        }

        public static string ConvertBack(EnumTriggerOn? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumTriggerOn.Command:
                    return "command";
                case EnumTriggerOn.Communication:
                    return "communication";
                case EnumTriggerOn.Group:
                    return "group";
                case EnumTriggerOn.Pair:
                    return "pair";
                case EnumTriggerOn.Parameter:
                    return "parameter";
                case EnumTriggerOn.Protocol:
                    return "protocol";
                case EnumTriggerOn.Response:
                    return "response";
                case EnumTriggerOn.Session:
                    return "session";
                case EnumTriggerOn.Timer:
                    return "timer";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the trigger time.
    ///</summary>
public enum EnumTriggerTime
    {
        After,
        AfterStartup,
        Before,
        Change,
        ChangeAfterResponse,
        LinkFileChange,
        Succeeded,
        Timeout,
        ///<summary>
        /// Specifies that the trigger will go off after the last retry. Feature introduced in DataMiner 8.5.2 (RN 8573).
        ///</summary>
TimeoutAfterRetries
    }

    public static partial class EnumTriggerTimeConverter
    {
        public static EnumTriggerTime? Convert(string input)
        {
            if (String.Equals(input, "after", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.After;
            else if (String.Equals(input, "after startup", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.AfterStartup;
            else if (String.Equals(input, "before", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.Before;
            else if (String.Equals(input, "change", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.Change;
            else if (String.Equals(input, "change after response", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.ChangeAfterResponse;
            else if (String.Equals(input, "link file change", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.LinkFileChange;
            else if (String.Equals(input, "succeeded", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.Succeeded;
            else if (String.Equals(input, "timeout", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.Timeout;
            else if (String.Equals(input, "timeout after retries", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerTime.TimeoutAfterRetries;
            return null;
        }

        public static string ConvertBack(EnumTriggerTime? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumTriggerTime.After:
                    return "after";
                case EnumTriggerTime.AfterStartup:
                    return "after startup";
                case EnumTriggerTime.Before:
                    return "before";
                case EnumTriggerTime.Change:
                    return "change";
                case EnumTriggerTime.ChangeAfterResponse:
                    return "change after response";
                case EnumTriggerTime.LinkFileChange:
                    return "link file change";
                case EnumTriggerTime.Succeeded:
                    return "succeeded";
                case EnumTriggerTime.Timeout:
                    return "timeout";
                case EnumTriggerTime.TimeoutAfterRetries:
                    return "timeout after retries";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the type of items that will be executed when the trigger goes off.
    ///</summary>
public enum EnumTriggerType
    {
        ///<summary>
        /// When the trigger goes off, the action(s) specified in /Protocol/Triggers/Trigger/Content will be executed.
        ///</summary>
Action,
        ///<summary>
        /// When the trigger goes off, the trigger(s) specified in /Protocol/Triggers/Trigger/Content will be activated.
        ///</summary>
Trigger
    }

    public static partial class EnumTriggerTypeConverter
    {
        public static EnumTriggerType? Convert(string input)
        {
            if (String.Equals(input, "action", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerType.Action;
            else if (String.Equals(input, "trigger", StringComparison.OrdinalIgnoreCase))
                return EnumTriggerType.Trigger;
            return null;
        }

        public static string ConvertBack(EnumTriggerType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumTriggerType.Action:
                    return "action";
                case EnumTriggerType.Trigger:
                    return "trigger";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies true and false values.
    ///</summary>
public enum EnumTrueFalse
    {
        ///<summary>
        /// True
        ///</summary>
True,
        ///<summary>
        /// False
        ///</summary>
False
    }

    public static partial class EnumTrueFalseConverter
    {
        public static EnumTrueFalse? Convert(string input)
        {
            if (String.Equals(input, "true", StringComparison.OrdinalIgnoreCase))
                return EnumTrueFalse.True;
            else if (String.Equals(input, "false", StringComparison.OrdinalIgnoreCase))
                return EnumTrueFalse.False;
            return null;
        }

        public static string ConvertBack(EnumTrueFalse? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumTrueFalse.True:
                    return "true";
                case EnumTrueFalse.False:
                    return "false";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the display state.
    ///</summary>
public enum EnumDisplayState
    {
        ///<summary>
        /// Enabled
        ///</summary>
Enabled,
        ///<summary>
        /// Disabled
        ///</summary>
Disabled
    }

    public static partial class EnumDisplayStateConverter
    {
        public static EnumDisplayState? Convert(string input)
        {
            if (String.Equals(input, "enabled", StringComparison.OrdinalIgnoreCase))
                return EnumDisplayState.Enabled;
            else if (String.Equals(input, "disabled", StringComparison.OrdinalIgnoreCase))
                return EnumDisplayState.Disabled;
            return null;
        }

        public static string ConvertBack(EnumDisplayState? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumDisplayState.Enabled:
                    return "enabled";
                case EnumDisplayState.Disabled:
                    return "disabled";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the ownership access type.
    ///</summary>
public enum EnumOwnershipAccessType
    {
        ///<summary>
        /// read-only
        ///</summary>
ReadOnly,
        ///<summary>
        /// read-write
        ///</summary>
ReadWrite
    }

    public static partial class EnumOwnershipAccessTypeConverter
    {
        public static EnumOwnershipAccessType? Convert(string input)
        {
            if (String.Equals(input, "read-only", StringComparison.OrdinalIgnoreCase))
                return EnumOwnershipAccessType.ReadOnly;
            else if (String.Equals(input, "read-write", StringComparison.OrdinalIgnoreCase))
                return EnumOwnershipAccessType.ReadWrite;
            return null;
        }

        public static string ConvertBack(EnumOwnershipAccessType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumOwnershipAccessType.ReadOnly:
                    return "read-only";
                case EnumOwnershipAccessType.ReadWrite:
                    return "read-write";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the port type.
    ///</summary>
public enum EnumPortTypes
    {
        ///<summary>
        /// UDP
        ///</summary>
Udp,
        ///<summary>
        /// IP
        ///</summary>
Ip,
        ///<summary>
        /// RS-232
        ///</summary>
Rs232
    }

    public static partial class EnumPortTypesConverter
    {
        public static EnumPortTypes? Convert(string input)
        {
            if (String.Equals(input, "udp", StringComparison.OrdinalIgnoreCase))
                return EnumPortTypes.Udp;
            else if (String.Equals(input, "ip", StringComparison.OrdinalIgnoreCase))
                return EnumPortTypes.Ip;
            else if (String.Equals(input, "rs232", StringComparison.OrdinalIgnoreCase))
                return EnumPortTypes.Rs232;
            return null;
        }

        public static string ConvertBack(EnumPortTypes? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumPortTypes.Udp:
                    return "udp";
                case EnumPortTypes.Ip:
                    return "ip";
                case EnumPortTypes.Rs232:
                    return "rs232";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// Specifies the icon.
    ///</summary>
public enum EnumIcons
    {
        ///<summary>
        /// Analyzer cards
        ///</summary>
ANALYZERCARDS,
        ///<summary>
        /// Application
        ///</summary>
APPLICATION,
        ///<summary>
        /// Arrow Down
        ///</summary>
ArrowDown,
        ///<summary>
        /// Arrow Up
        ///</summary>
ArrowUp,
        ///<summary>
        /// ASI Port
        ///</summary>
ASIPort,
        ///<summary>
        /// ATSC
        ///</summary>
ATSC,
        ///<summary>
        /// Backup
        ///</summary>
Backup,
        ///<summary>
        /// Carrier
        ///</summary>
Carrier,
        ///<summary>
        /// Conditional Access Table
        ///</summary>
CAT,
        ///<summary>
        /// Data PID
        ///</summary>
DATA,
        ///<summary>
        /// Data Carousel
        ///</summary>
DATACAROUSEL,
        ///<summary>
        /// Device
        ///</summary>
Device,
        ///<summary>
        /// Direct Connection
        ///</summary>
DirectConnection,
        ///<summary>
        /// DVBS Card
        ///</summary>
DVBSCard,
        ///<summary>
        /// Entitlement Control Message (Encrypted key for EMM)
        ///</summary>
ECM,
        ///<summary>
        /// Event Information Table
        ///</summary>
EIT,
        ///<summary>
        /// Entitlement Management Message
        ///</summary>
EMM,
        ///<summary>
        /// Fixed Input
        ///</summary>
FixedInput,
        ///<summary>
        /// Fixed Output
        ///</summary>
FixedOutput,
        ///<summary>
        /// GBE Port
        ///</summary>
GBEPort,
        ///<summary>
        /// General
        ///</summary>
General,
        ///<summary>
        /// General Input
        ///</summary>
GeneralInput,
        ///<summary>
        /// General PID
        ///</summary>
GeneralPID,
        ///<summary>
        /// General Service
        ///</summary>
GeneralService,
        ///<summary>
        /// General Transport Stream
        ///</summary>
GeneralTransportStream,
        ///<summary>
        /// General Transport Stream
        ///</summary>
GT,
        ///<summary>
        /// IDP-OK
        ///</summary>
IDPOK,
        ///<summary>
        /// IDP-NOK
        ///</summary>
IDPNOK,
        ///<summary>
        /// IDP-Running
        ///</summary>
IDPRunning,
        ///<summary>
        /// IDP-Unknown
        ///</summary>
IDPUnknown,
        ///<summary>
        /// Input
        ///</summary>
Input,
        ///<summary>
        /// Input and Output
        ///</summary>
InputAndOutput,
        ///<summary>
        /// Input Transport Stream
        ///</summary>
InputTransportStream,
        ///<summary>
        /// Blue LED. Available from DataMiner 10.1.2 onwards (RN 28566).
        ///</summary>
LEDBlue,
        ///<summary>
        /// Cyan LED. Available from DataMiner 10.1.2 onwards (RN 28566).
        ///</summary>
LEDCyan,
        ///<summary>
        /// Lime LED. Available from DataMiner 10.1.2 onwards (RN 28566).
        ///</summary>
LEDLime,
        ///<summary>
        /// Red LED. Available from DataMiner 10.1.2 onwards (RN 28566).
        ///</summary>
LEDRed,
        ///<summary>
        /// Silver LED. Available from DataMiner 10.1.2 onwards (RN 28566).
        ///</summary>
LEDSilver,
        ///<summary>
        /// Yellow LED. Available from DataMiner 10.1.2 onwards (RN 28566).
        ///</summary>
LEDYellow,
        ///<summary>
        /// Main
        ///</summary>
Main,
        ///<summary>
        /// Matrix
        ///</summary>
Matrix,
        ///<summary>
        /// MIP
        ///</summary>
MIP,
        ///<summary>
        /// MPE
        ///</summary>
MPE,
        ///<summary>
        /// Audio PID
        ///</summary>
MPEG2AUDIO,
        ///<summary>
        /// Video PID
        ///</summary>
MPEG2VIDEO,
        ///<summary>
        /// New Item. Supported since DataMiner 10.0.13 (RN 28060).
        ///</summary>
NewItem,
        ///<summary>
        /// Network Information Table
        ///</summary>
NIT,
        ///<summary>
        /// Object Carousel
        ///</summary>
OBJECTCAROUSEL,
        ///<summary>
        /// Output
        ///</summary>
Output,
        ///<summary>
        /// Output Transport Stream
        ///</summary>
OutputTransportStream,
        ///<summary>
        /// Program Association Table
        ///</summary>
PAT,
        ///<summary>
        /// Program Clock Reference
        ///</summary>
PCR,
        ///<summary>
        /// PD
        ///</summary>
PD,
        ///<summary>
        /// Packetized Elementary Stream
        ///</summary>
PES,
        ///<summary>
        /// Program Map Table
        ///</summary>
PMT,
        ///<summary>
        /// Primary
        ///</summary>
Primary,
        ///<summary>
        /// Processor
        ///</summary>
Processor,
        ///<summary>
        /// Service of type Radio
        ///</summary>
RADIO,
        ///<summary>
        /// Rectangle filled with color #FFF0F8FF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTAliceBlue,
        ///<summary>
        /// Rectangle filled with color #FFFAEBD7. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTAntiqueWhite,
        ///<summary>
        /// Rectangle filled with color #FF00FFFF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTAqua,
        ///<summary>
        /// Rectangle filled with color #FF7FFFD4. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTAquamarine,
        ///<summary>
        /// Rectangle filled with color #FFF0FFFF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTAzure,
        ///<summary>
        /// Rectangle filled with color #FFF5F5DC. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTBeige,
        ///<summary>
        /// Rectangle filled with color #FFFFE4C4. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTBisque,
        ///<summary>
        /// Rectangle filled with color #FF000000. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTBlack,
        ///<summary>
        /// Rectangle filled with color #FFFFEBCD. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTBlanchedAlmond,
        ///<summary>
        /// Rectangle filled with color #FF0000FF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTBlue,
        ///<summary>
        /// Rectangle filled with color #FF8A2BE2. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTBlueViolet,
        ///<summary>
        /// Rectangle filled with color #FFA52A2A. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTBrown,
        ///<summary>
        /// Rectangle filled with color #FFDEB887. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTBurlyWood,
        ///<summary>
        /// Rectangle filled with color #FF5F9EA0. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTCadetBlue,
        ///<summary>
        /// Rectangle filled with color #FF7FFF00. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTChartreuse,
        ///<summary>
        /// Rectangle filled with color #FFD2691E. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTChocolate,
        ///<summary>
        /// Rectangle filled with color #FFFF7F50. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTCoral,
        ///<summary>
        /// Rectangle filled with color #FF6495ED. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTCornflowerBlue,
        ///<summary>
        /// Rectangle filled with color #FFFFF8DC. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTCornsilk,
        ///<summary>
        /// Rectangle filled with color #FFDC143C. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTCrimson,
        ///<summary>
        /// Rectangle filled with color #FF00FFFF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTCyan,
        ///<summary>
        /// Rectangle filled with color #FF00008B. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkBlue,
        ///<summary>
        /// Rectangle filled with color #FF008B8B. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkCyan,
        ///<summary>
        /// Rectangle filled with color #FFB8860B. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkGoldenrod,
        ///<summary>
        /// Rectangle filled with color #FFA9A9A9. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkGray,
        ///<summary>
        /// Rectangle filled with color #FF006400. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkGreen,
        ///<summary>
        /// Rectangle filled with color #FFBDB76B. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkKhaki,
        ///<summary>
        /// Rectangle filled with color #FF8B008B. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkMagenta,
        ///<summary>
        /// Rectangle filled with color #FF556B2F. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkOliveGreen,
        ///<summary>
        /// Rectangle filled with color #FFFF8C00. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkOrange,
        ///<summary>
        /// Rectangle filled with color #FF9932CC. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkOrchid,
        ///<summary>
        /// Rectangle filled with color #FF8B0000. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkRed,
        ///<summary>
        /// Rectangle filled with color #FFE9967A. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkSalmon,
        ///<summary>
        /// Rectangle filled with color #FF8FBC8F. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkSeaGreen,
        ///<summary>
        /// Rectangle filled with color #FF483D8B. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkSlateBlue,
        ///<summary>
        /// Rectangle filled with color #FF2F4F4F. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkSlateGray,
        ///<summary>
        /// Rectangle filled with color #FF00CED1. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkTurquoise,
        ///<summary>
        /// Rectangle filled with color #FF9400D3. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDarkViolet,
        ///<summary>
        /// Rectangle filled with color #FFFF1493. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDeepPink,
        ///<summary>
        /// Rectangle filled with color #FF00BFFF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDeepSkyBlue,
        ///<summary>
        /// Rectangle filled with color #FF696969. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDimGray,
        ///<summary>
        /// Rectangle filled with color #FF1E90FF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTDodgerBlue,
        ///<summary>
        /// Rectangle filled with color #FFB22222. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTFirebrick,
        ///<summary>
        /// Rectangle filled with color #FFFFFAF0. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTFloralWhite,
        ///<summary>
        /// Rectangle filled with color #FF228B22. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTForestGreen,
        ///<summary>
        /// Rectangle filled with color #FFFF00FF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTFuchsia,
        ///<summary>
        /// Rectangle filled with color #FFDCDCDC. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTGainsboro,
        ///<summary>
        /// Rectangle filled with color #FFF8F8FF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTGhostWhite,
        ///<summary>
        /// Rectangle filled with color #FFFFD700. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTGold,
        ///<summary>
        /// Rectangle filled with color #FFDAA520. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTGoldenrod,
        ///<summary>
        /// Rectangle filled with color #FF808080. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTGray,
        ///<summary>
        /// Rectangle filled with color #FF008000. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTGreen,
        ///<summary>
        /// Rectangle filled with color #FFADFF2F. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTGreenYellow,
        ///<summary>
        /// Rectangle filled with color #FFF0FFF0. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTHoneydew,
        ///<summary>
        /// Rectangle filled with color #FFFF69B4. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTHotPink,
        ///<summary>
        /// Rectangle filled with color #FFCD5C5C. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTIndianRed,
        ///<summary>
        /// Rectangle filled with color #FF4B0082. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTIndigo,
        ///<summary>
        /// Rectangle filled with color #FFFFFFF0. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTIvory,
        ///<summary>
        /// Rectangle filled with color #FFF0E68C. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTKhaki,
        ///<summary>
        /// Rectangle filled with color #FFE6E6FA. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLavender,
        ///<summary>
        /// Rectangle filled with color #FFFFF0F5. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLavenderBlush,
        ///<summary>
        /// Rectangle filled with color #FF7CFC00. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLawnGreen,
        ///<summary>
        /// Rectangle filled with color #FFFFFACD. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLemonChiffon,
        ///<summary>
        /// Rectangle filled with color #FFADD8E6. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightBlue,
        ///<summary>
        /// Rectangle filled with color #FFF08080. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightCoral,
        ///<summary>
        /// Rectangle filled with color #FFE0FFFF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightCyan,
        ///<summary>
        /// Rectangle filled with color #FFFAFAD2. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightGoldenrodYellow,
        ///<summary>
        /// Rectangle filled with color #FFD3D3D3. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightGray,
        ///<summary>
        /// Rectangle filled with color #FF90EE90. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightGreen,
        ///<summary>
        /// Rectangle filled with color #FFFFB6C1. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightPink,
        ///<summary>
        /// Rectangle filled with color #FFFFA07A. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightSalmon,
        ///<summary>
        /// Rectangle filled with color #FF20B2AA. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightSeaGreen,
        ///<summary>
        /// Rectangle filled with color #FF87CEFA. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightSkyBlue,
        ///<summary>
        /// Rectangle filled with color #FF778899. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightSlateGray,
        ///<summary>
        /// Rectangle filled with color #FFB0C4DE. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightSteelBlue,
        ///<summary>
        /// Rectangle filled with color #FFFFFFE0. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLightYellow,
        ///<summary>
        /// Rectangle filled with color #FF00FF00. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLime,
        ///<summary>
        /// Rectangle filled with color #FF32CD32. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLimeGreen,
        ///<summary>
        /// Rectangle filled with color #FFFAF0E6. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTLinen,
        ///<summary>
        /// Rectangle filled with color #FFFF00FF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMagenta,
        ///<summary>
        /// Rectangle filled with color #FF800000. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMaroon,
        ///<summary>
        /// Rectangle filled with color #FF66CDAA. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumAquamarine,
        ///<summary>
        /// Rectangle filled with color #FF0000CD. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumBlue,
        ///<summary>
        /// Rectangle filled with color #FFBA55D3. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumOrchid,
        ///<summary>
        /// Rectangle filled with color #FF9370DB. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumPurple,
        ///<summary>
        /// Rectangle filled with color #FF3CB371. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumSeaGreen,
        ///<summary>
        /// Rectangle filled with color #FF7B68EE. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumSlateBlue,
        ///<summary>
        /// Rectangle filled with color #FF00FA9A. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumSpringGreen,
        ///<summary>
        /// Rectangle filled with color #FF48D1CC. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumTurquoise,
        ///<summary>
        /// Rectangle filled with color #FFC71585. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMediumVioletRed,
        ///<summary>
        /// Rectangle filled with color #FF191970. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMidnightBlue,
        ///<summary>
        /// Rectangle filled with color #FFF5FFFA. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMintCream,
        ///<summary>
        /// Rectangle filled with color #FFFFE4E1. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMistyRose,
        ///<summary>
        /// Rectangle filled with color #FFFFE4B5. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTMoccasin,
        ///<summary>
        /// Rectangle filled with color #FFFFDEAD. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTNavajoWhite,
        ///<summary>
        /// Rectangle filled with color #FF000080. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTNavy,
        ///<summary>
        /// Rectangle filled with color #FFFDF5E6. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTOldLace,
        ///<summary>
        /// Rectangle filled with color #FF808000. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTOlive,
        ///<summary>
        /// Rectangle filled with color #FF6B8E23. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTOliveDrab,
        ///<summary>
        /// Rectangle filled with color #FFFFA500. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTOrange,
        ///<summary>
        /// Rectangle filled with color #FFFF4500. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTOrangeRed,
        ///<summary>
        /// Rectangle filled with color #FFDA70D6. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTOrchid,
        ///<summary>
        /// Rectangle filled with color #FFEEE8AA. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPaleGoldenrod,
        ///<summary>
        /// Rectangle filled with color #FF98FB98. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPaleGreen,
        ///<summary>
        /// Rectangle filled with color #FFAFEEEE. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPaleTurquoise,
        ///<summary>
        /// Rectangle filled with color #FFDB7093. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPaleVioletRed,
        ///<summary>
        /// Rectangle filled with color #FFFFEFD5. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPapayaWhip,
        ///<summary>
        /// Rectangle filled with color #FFFFDAB9. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPeachPuff,
        ///<summary>
        /// Rectangle filled with color #FFCD853F. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPeru,
        ///<summary>
        /// Rectangle filled with color #FFFFC0CB. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPink,
        ///<summary>
        /// Rectangle filled with color #FFDDA0DD. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPlum,
        ///<summary>
        /// Rectangle filled with color #FFB0E0E6. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPowderBlue,
        ///<summary>
        /// Rectangle filled with color #FF800080. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTPurple,
        ///<summary>
        /// Rectangle filled with color #FFFF0000. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTRed,
        ///<summary>
        /// Rectangle filled with color #FFBC8F8F. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTRosyBrown,
        ///<summary>
        /// Rectangle filled with color #FF4169E1. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTRoyalBlue,
        ///<summary>
        /// Rectangle filled with color #FF8B4513. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSaddleBrown,
        ///<summary>
        /// Rectangle filled with color #FFFA8072. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSalmon,
        ///<summary>
        /// Rectangle filled with color #FFF4A460. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSandyBrown,
        ///<summary>
        /// Rectangle filled with color #FF2E8B57. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSeaGreen,
        ///<summary>
        /// Rectangle filled with color #FFFFF5EE. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSeaShell,
        ///<summary>
        /// Rectangle filled with color #FFA0522D. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSienna,
        ///<summary>
        /// Rectangle filled with color #FFC0C0C0. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSilver,
        ///<summary>
        /// Rectangle filled with color #FF87CEEB. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSkyBlue,
        ///<summary>
        /// Rectangle filled with color #FF6A5ACD. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSlateBlue,
        ///<summary>
        /// Rectangle filled with color #FF708090. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSlateGray,
        ///<summary>
        /// Rectangle filled with color #FFFFFAFA. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSnow,
        ///<summary>
        /// Rectangle filled with color #FF00FF7F. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSpringGreen,
        ///<summary>
        /// Rectangle filled with color #FF4682B4. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTSteelBlue,
        ///<summary>
        /// Rectangle filled with color #FFD2B48C. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTTan,
        ///<summary>
        /// Rectangle filled with color #FF008080. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTTeal,
        ///<summary>
        /// Rectangle filled with color #FFD8BFD8. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTThistle,
        ///<summary>
        /// Rectangle filled with color #FFFF6347. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTTomato,
        ///<summary>
        /// Rectangle filled with color #00FFFFFF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTTransparent,
        ///<summary>
        /// Rectangle filled with color #FF40E0D0. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTTurquoise,
        ///<summary>
        /// Rectangle filled with color #FFEE82EE. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTViolet,
        ///<summary>
        /// Rectangle filled with color #FFF5DEB3. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTWheat,
        ///<summary>
        /// Rectangle filled with color #FFFFFFFF. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTWhite,
        ///<summary>
        /// Rectangle filled with color #FFF5F5F5. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTWhiteSmoke,
        ///<summary>
        /// Rectangle filled with color #FFFFFF00. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTYellow,
        ///<summary>
        /// Rectangle filled with color #FF9ACD32. Supported since DataMiner 9.6.11/9.6.0 [CU5] (RN 22832).
        ///</summary>
RECTYellowGreen,
        ///<summary>
        /// RST
        ///</summary>
RST,
        ///<summary>
        /// Satellite
        ///</summary>
Satellite,
        ///<summary>
        /// Service Description Table
        ///</summary>
SDT,
        ///<summary>
        /// Secondary
        ///</summary>
Secondary,
        ///<summary>
        /// SI
        ///</summary>
SI,
        ///<summary>
        /// Storage Cell Empty
        ///</summary>
StorageCellEmpty,
        ///<summary>
        /// Storage Cell Full
        ///</summary>
StorageCellFull,
        ///<summary>
        /// Storage Tap
        ///</summary>
StorageTape,
        ///<summary>
        /// Subtitle PID
        ///</summary>
SUBTITLE,
        ///<summary>
        /// Time and Data Table
        ///</summary>
TDT,
        ///<summary>
        /// Teletext PID
        ///</summary>
TELETEXT,
        ///<summary>
        /// Transponder
        ///</summary>
Transponder,
        ///<summary>
        /// Transponder Leased
        ///</summary>
TransponderLeased,
        ///<summary>
        /// Trash can. Supported since DataMiner 10.0.13 (RN 28060).
        ///</summary>
Trash,
        ///<summary>
        /// Service of type Television
        ///</summary>
TV,
        ///<summary>
        /// VSAT
        ///</summary>
VSAT,
        ///<summary>
        /// Unknown
        ///</summary>
Unknown
    }

    public static partial class EnumIconsConverter
    {
        public static EnumIcons? Convert(string input)
        {
            if (String.Equals(input, "ANALYZERCARDS", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.ANALYZERCARDS;
            else if (String.Equals(input, "APPLICATION", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.APPLICATION;
            else if (String.Equals(input, "arrowDown", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.ArrowDown;
            else if (String.Equals(input, "arrowUp", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.ArrowUp;
            else if (String.Equals(input, "ASIPort", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.ASIPort;
            else if (String.Equals(input, "ATSC", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.ATSC;
            else if (String.Equals(input, "Backup", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Backup;
            else if (String.Equals(input, "Carrier", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Carrier;
            else if (String.Equals(input, "CAT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.CAT;
            else if (String.Equals(input, "DATA", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.DATA;
            else if (String.Equals(input, "DATACAROUSEL", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.DATACAROUSEL;
            else if (String.Equals(input, "Device", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Device;
            else if (String.Equals(input, "DirectConnection", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.DirectConnection;
            else if (String.Equals(input, "DVBSCard", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.DVBSCard;
            else if (String.Equals(input, "ECM", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.ECM;
            else if (String.Equals(input, "EIT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.EIT;
            else if (String.Equals(input, "EMM", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.EMM;
            else if (String.Equals(input, "FixedInput", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.FixedInput;
            else if (String.Equals(input, "FixedOutput", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.FixedOutput;
            else if (String.Equals(input, "GBEPort", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.GBEPort;
            else if (String.Equals(input, "General", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.General;
            else if (String.Equals(input, "GeneralInput", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.GeneralInput;
            else if (String.Equals(input, "GeneralPID", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.GeneralPID;
            else if (String.Equals(input, "GeneralService", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.GeneralService;
            else if (String.Equals(input, "GeneralTransportStream", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.GeneralTransportStream;
            else if (String.Equals(input, "GT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.GT;
            else if (String.Equals(input, "IDP-OK", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.IDPOK;
            else if (String.Equals(input, "IDP-NOK", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.IDPNOK;
            else if (String.Equals(input, "IDP-Running", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.IDPRunning;
            else if (String.Equals(input, "IDP-Unknown", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.IDPUnknown;
            else if (String.Equals(input, "Input", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Input;
            else if (String.Equals(input, "InputAndOutput", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.InputAndOutput;
            else if (String.Equals(input, "InputTransportStream", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.InputTransportStream;
            else if (String.Equals(input, "LED-Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.LEDBlue;
            else if (String.Equals(input, "LED-Cyan", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.LEDCyan;
            else if (String.Equals(input, "LED-Lime", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.LEDLime;
            else if (String.Equals(input, "LED-Red", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.LEDRed;
            else if (String.Equals(input, "LED-Silver", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.LEDSilver;
            else if (String.Equals(input, "LED-Yellow", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.LEDYellow;
            else if (String.Equals(input, "Main", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Main;
            else if (String.Equals(input, "Matrix", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Matrix;
            else if (String.Equals(input, "MIP", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.MIP;
            else if (String.Equals(input, "MPE", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.MPE;
            else if (String.Equals(input, "MPEG2_AUDIO", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.MPEG2AUDIO;
            else if (String.Equals(input, "MPEG2_VIDEO", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.MPEG2VIDEO;
            else if (String.Equals(input, "New-Item", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.NewItem;
            else if (String.Equals(input, "NIT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.NIT;
            else if (String.Equals(input, "OBJECTCAROUSEL", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.OBJECTCAROUSEL;
            else if (String.Equals(input, "Output", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Output;
            else if (String.Equals(input, "OutputTransportStream", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.OutputTransportStream;
            else if (String.Equals(input, "PAT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.PAT;
            else if (String.Equals(input, "PCR", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.PCR;
            else if (String.Equals(input, "PD", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.PD;
            else if (String.Equals(input, "PES", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.PES;
            else if (String.Equals(input, "PMT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.PMT;
            else if (String.Equals(input, "Primary", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Primary;
            else if (String.Equals(input, "Processor", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Processor;
            else if (String.Equals(input, "RADIO", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RADIO;
            else if (String.Equals(input, "RECT-Alice​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTAliceBlue;
            else if (String.Equals(input, "RECT-Antique​White", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTAntiqueWhite;
            else if (String.Equals(input, "RECT-Aqua", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTAqua;
            else if (String.Equals(input, "RECT-Aquamarine", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTAquamarine;
            else if (String.Equals(input, "RECT-Azure", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTAzure;
            else if (String.Equals(input, "RECT-Beige", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTBeige;
            else if (String.Equals(input, "RECT-Bisque", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTBisque;
            else if (String.Equals(input, "RECT-Black", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTBlack;
            else if (String.Equals(input, "RECT-Blanched​Almond", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTBlanchedAlmond;
            else if (String.Equals(input, "RECT-Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTBlue;
            else if (String.Equals(input, "RECT-Blue​Violet", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTBlueViolet;
            else if (String.Equals(input, "RECT-Brown", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTBrown;
            else if (String.Equals(input, "RECT-Burly​Wood", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTBurlyWood;
            else if (String.Equals(input, "RECT-Cadet​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTCadetBlue;
            else if (String.Equals(input, "RECT-Chartreuse", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTChartreuse;
            else if (String.Equals(input, "RECT-Chocolate", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTChocolate;
            else if (String.Equals(input, "RECT-Coral", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTCoral;
            else if (String.Equals(input, "RECT-Cornflower​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTCornflowerBlue;
            else if (String.Equals(input, "RECT-Cornsilk", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTCornsilk;
            else if (String.Equals(input, "RECT-Crimson", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTCrimson;
            else if (String.Equals(input, "RECT-Cyan", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTCyan;
            else if (String.Equals(input, "RECT-Dark​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkBlue;
            else if (String.Equals(input, "RECT-Dark​Cyan", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkCyan;
            else if (String.Equals(input, "RECT-Dark​Goldenrod", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkGoldenrod;
            else if (String.Equals(input, "RECT-Dark​Gray", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkGray;
            else if (String.Equals(input, "RECT-Dark​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkGreen;
            else if (String.Equals(input, "RECT-Dark​Khaki", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkKhaki;
            else if (String.Equals(input, "RECT-Dark​Magenta", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkMagenta;
            else if (String.Equals(input, "RECT-Dark​Olive​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkOliveGreen;
            else if (String.Equals(input, "RECT-Dark​Orange", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkOrange;
            else if (String.Equals(input, "RECT-Dark​Orchid", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkOrchid;
            else if (String.Equals(input, "RECT-Dark​Red", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkRed;
            else if (String.Equals(input, "RECT-Dark​Salmon", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkSalmon;
            else if (String.Equals(input, "RECT-Dark​Sea​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkSeaGreen;
            else if (String.Equals(input, "RECT-Dark​Slate​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkSlateBlue;
            else if (String.Equals(input, "RECT-Dark​Slate​Gray", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkSlateGray;
            else if (String.Equals(input, "RECT-Dark​Turquoise", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkTurquoise;
            else if (String.Equals(input, "RECT-Dark​Violet", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDarkViolet;
            else if (String.Equals(input, "RECT-Deep​Pink", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDeepPink;
            else if (String.Equals(input, "RECT-Deep​Sky​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDeepSkyBlue;
            else if (String.Equals(input, "RECT-Dim​Gray", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDimGray;
            else if (String.Equals(input, "RECT-Dodger​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTDodgerBlue;
            else if (String.Equals(input, "RECT-Firebrick", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTFirebrick;
            else if (String.Equals(input, "RECT-Floral​White", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTFloralWhite;
            else if (String.Equals(input, "RECT-Forest​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTForestGreen;
            else if (String.Equals(input, "RECT-Fuchsia", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTFuchsia;
            else if (String.Equals(input, "RECT-Gainsboro", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTGainsboro;
            else if (String.Equals(input, "RECT-Ghost​White", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTGhostWhite;
            else if (String.Equals(input, "RECT-Gold", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTGold;
            else if (String.Equals(input, "RECT-Goldenrod", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTGoldenrod;
            else if (String.Equals(input, "RECT-Gray", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTGray;
            else if (String.Equals(input, "RECT-Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTGreen;
            else if (String.Equals(input, "RECT-Green​Yellow", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTGreenYellow;
            else if (String.Equals(input, "RECT-Honeydew", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTHoneydew;
            else if (String.Equals(input, "RECT-Hot​Pink", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTHotPink;
            else if (String.Equals(input, "RECT-Indian​Red", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTIndianRed;
            else if (String.Equals(input, "RECT-Indigo", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTIndigo;
            else if (String.Equals(input, "RECT-Ivory", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTIvory;
            else if (String.Equals(input, "RECT-Khaki", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTKhaki;
            else if (String.Equals(input, "RECT-Lavender", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLavender;
            else if (String.Equals(input, "RECT-Lavender​Blush", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLavenderBlush;
            else if (String.Equals(input, "RECT-Lawn​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLawnGreen;
            else if (String.Equals(input, "RECT-Lemon​Chiffon", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLemonChiffon;
            else if (String.Equals(input, "RECT-Light​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightBlue;
            else if (String.Equals(input, "RECT-Light​Coral", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightCoral;
            else if (String.Equals(input, "RECT-Light​Cyan", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightCyan;
            else if (String.Equals(input, "RECT-Light​Goldenrod​Yellow", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightGoldenrodYellow;
            else if (String.Equals(input, "RECT-Light​Gray", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightGray;
            else if (String.Equals(input, "RECT-Light​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightGreen;
            else if (String.Equals(input, "RECT-Light​Pink", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightPink;
            else if (String.Equals(input, "RECT-Light​Salmon", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightSalmon;
            else if (String.Equals(input, "RECT-Light​Sea​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightSeaGreen;
            else if (String.Equals(input, "RECT-Light​Sky​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightSkyBlue;
            else if (String.Equals(input, "RECT-Light​Slate​Gray", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightSlateGray;
            else if (String.Equals(input, "RECT-Light​Steel​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightSteelBlue;
            else if (String.Equals(input, "RECT-Light​Yellow", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLightYellow;
            else if (String.Equals(input, "RECT-Lime", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLime;
            else if (String.Equals(input, "RECT-Lime​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLimeGreen;
            else if (String.Equals(input, "RECT-Linen", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTLinen;
            else if (String.Equals(input, "RECT-Magenta", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMagenta;
            else if (String.Equals(input, "RECT-Maroon", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMaroon;
            else if (String.Equals(input, "RECT-Medium​Aquamarine", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumAquamarine;
            else if (String.Equals(input, "RECT-Medium​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumBlue;
            else if (String.Equals(input, "RECT-Medium​Orchid", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumOrchid;
            else if (String.Equals(input, "RECT-Medium​Purple", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumPurple;
            else if (String.Equals(input, "RECT-Medium​Sea​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumSeaGreen;
            else if (String.Equals(input, "RECT-Medium​Slate​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumSlateBlue;
            else if (String.Equals(input, "RECT-Medium​Spring​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumSpringGreen;
            else if (String.Equals(input, "RECT-Medium​Turquoise", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumTurquoise;
            else if (String.Equals(input, "RECT-Medium​Violet​Red", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMediumVioletRed;
            else if (String.Equals(input, "RECT-Midnight​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMidnightBlue;
            else if (String.Equals(input, "RECT-Mint​Cream", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMintCream;
            else if (String.Equals(input, "RECT-Misty​Rose", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMistyRose;
            else if (String.Equals(input, "RECT-Moccasin", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTMoccasin;
            else if (String.Equals(input, "RECT-Navajo​White", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTNavajoWhite;
            else if (String.Equals(input, "RECT-Navy", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTNavy;
            else if (String.Equals(input, "RECT-Old​Lace", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTOldLace;
            else if (String.Equals(input, "RECT-Olive", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTOlive;
            else if (String.Equals(input, "RECT-Olive​Drab", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTOliveDrab;
            else if (String.Equals(input, "RECT-Orange", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTOrange;
            else if (String.Equals(input, "RECT-Orange​Red", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTOrangeRed;
            else if (String.Equals(input, "RECT-Orchid", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTOrchid;
            else if (String.Equals(input, "RECT-Pale​Goldenrod", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPaleGoldenrod;
            else if (String.Equals(input, "RECT-Pale​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPaleGreen;
            else if (String.Equals(input, "RECT-Pale​Turquoise", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPaleTurquoise;
            else if (String.Equals(input, "RECT-Pale​Violet​Red", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPaleVioletRed;
            else if (String.Equals(input, "RECT-Papaya​Whip", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPapayaWhip;
            else if (String.Equals(input, "RECT-Peach​Puff", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPeachPuff;
            else if (String.Equals(input, "RECT-Peru", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPeru;
            else if (String.Equals(input, "RECT-Pink", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPink;
            else if (String.Equals(input, "RECT-Plum", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPlum;
            else if (String.Equals(input, "RECT-Powder​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPowderBlue;
            else if (String.Equals(input, "RECT-Purple", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTPurple;
            else if (String.Equals(input, "RECT-Red", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTRed;
            else if (String.Equals(input, "RECT-Rosy​Brown", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTRosyBrown;
            else if (String.Equals(input, "RECT-Royal​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTRoyalBlue;
            else if (String.Equals(input, "RECT-Saddle​Brown", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSaddleBrown;
            else if (String.Equals(input, "RECT-Salmon", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSalmon;
            else if (String.Equals(input, "RECT-Sandy​Brown", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSandyBrown;
            else if (String.Equals(input, "RECT-Sea​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSeaGreen;
            else if (String.Equals(input, "RECT-Sea​Shell", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSeaShell;
            else if (String.Equals(input, "RECT-Sienna", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSienna;
            else if (String.Equals(input, "RECT-Silver", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSilver;
            else if (String.Equals(input, "RECT-Sky​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSkyBlue;
            else if (String.Equals(input, "RECT-Slate​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSlateBlue;
            else if (String.Equals(input, "RECT-Slate​Gray", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSlateGray;
            else if (String.Equals(input, "RECT-Snow", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSnow;
            else if (String.Equals(input, "RECT-Spring​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSpringGreen;
            else if (String.Equals(input, "RECT-Steel​Blue", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTSteelBlue;
            else if (String.Equals(input, "RECT-Tan", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTTan;
            else if (String.Equals(input, "RECT-Teal", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTTeal;
            else if (String.Equals(input, "RECT-Thistle", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTThistle;
            else if (String.Equals(input, "RECT-Tomato", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTTomato;
            else if (String.Equals(input, "RECT-Transparent", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTTransparent;
            else if (String.Equals(input, "RECT-Turquoise", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTTurquoise;
            else if (String.Equals(input, "RECT-Violet", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTViolet;
            else if (String.Equals(input, "RECT-Wheat", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTWheat;
            else if (String.Equals(input, "RECT-White", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTWhite;
            else if (String.Equals(input, "RECT-White​Smoke", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTWhiteSmoke;
            else if (String.Equals(input, "RECT-Yellow", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTYellow;
            else if (String.Equals(input, "RECT-Yellow​Green", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RECTYellowGreen;
            else if (String.Equals(input, "RST", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.RST;
            else if (String.Equals(input, "Satellite", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Satellite;
            else if (String.Equals(input, "SDT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.SDT;
            else if (String.Equals(input, "Secondary", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Secondary;
            else if (String.Equals(input, "SI", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.SI;
            else if (String.Equals(input, "StorageCellEmpty", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.StorageCellEmpty;
            else if (String.Equals(input, "StorageCellFull", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.StorageCellFull;
            else if (String.Equals(input, "StorageTape", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.StorageTape;
            else if (String.Equals(input, "SUBTITLE", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.SUBTITLE;
            else if (String.Equals(input, "TDT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.TDT;
            else if (String.Equals(input, "TELETEXT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.TELETEXT;
            else if (String.Equals(input, "Transponder", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Transponder;
            else if (String.Equals(input, "TransponderLeased", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.TransponderLeased;
            else if (String.Equals(input, "Trash", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Trash;
            else if (String.Equals(input, "TV", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.TV;
            else if (String.Equals(input, "VSAT", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.VSAT;
            else if (String.Equals(input, "Unknown", StringComparison.OrdinalIgnoreCase))
                return EnumIcons.Unknown;
            return null;
        }

        public static string ConvertBack(EnumIcons? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumIcons.ANALYZERCARDS:
                    return "ANALYZERCARDS";
                case EnumIcons.APPLICATION:
                    return "APPLICATION";
                case EnumIcons.ArrowDown:
                    return "arrowDown";
                case EnumIcons.ArrowUp:
                    return "arrowUp";
                case EnumIcons.ASIPort:
                    return "ASIPort";
                case EnumIcons.ATSC:
                    return "ATSC";
                case EnumIcons.Backup:
                    return "Backup";
                case EnumIcons.Carrier:
                    return "Carrier";
                case EnumIcons.CAT:
                    return "CAT";
                case EnumIcons.DATA:
                    return "DATA";
                case EnumIcons.DATACAROUSEL:
                    return "DATACAROUSEL";
                case EnumIcons.Device:
                    return "Device";
                case EnumIcons.DirectConnection:
                    return "DirectConnection";
                case EnumIcons.DVBSCard:
                    return "DVBSCard";
                case EnumIcons.ECM:
                    return "ECM";
                case EnumIcons.EIT:
                    return "EIT";
                case EnumIcons.EMM:
                    return "EMM";
                case EnumIcons.FixedInput:
                    return "FixedInput";
                case EnumIcons.FixedOutput:
                    return "FixedOutput";
                case EnumIcons.GBEPort:
                    return "GBEPort";
                case EnumIcons.General:
                    return "General";
                case EnumIcons.GeneralInput:
                    return "GeneralInput";
                case EnumIcons.GeneralPID:
                    return "GeneralPID";
                case EnumIcons.GeneralService:
                    return "GeneralService";
                case EnumIcons.GeneralTransportStream:
                    return "GeneralTransportStream";
                case EnumIcons.GT:
                    return "GT";
                case EnumIcons.IDPOK:
                    return "IDP-OK";
                case EnumIcons.IDPNOK:
                    return "IDP-NOK";
                case EnumIcons.IDPRunning:
                    return "IDP-Running";
                case EnumIcons.IDPUnknown:
                    return "IDP-Unknown";
                case EnumIcons.Input:
                    return "Input";
                case EnumIcons.InputAndOutput:
                    return "InputAndOutput";
                case EnumIcons.InputTransportStream:
                    return "InputTransportStream";
                case EnumIcons.LEDBlue:
                    return "LED-Blue";
                case EnumIcons.LEDCyan:
                    return "LED-Cyan";
                case EnumIcons.LEDLime:
                    return "LED-Lime";
                case EnumIcons.LEDRed:
                    return "LED-Red";
                case EnumIcons.LEDSilver:
                    return "LED-Silver";
                case EnumIcons.LEDYellow:
                    return "LED-Yellow";
                case EnumIcons.Main:
                    return "Main";
                case EnumIcons.Matrix:
                    return "Matrix";
                case EnumIcons.MIP:
                    return "MIP";
                case EnumIcons.MPE:
                    return "MPE";
                case EnumIcons.MPEG2AUDIO:
                    return "MPEG2_AUDIO";
                case EnumIcons.MPEG2VIDEO:
                    return "MPEG2_VIDEO";
                case EnumIcons.NewItem:
                    return "New-Item";
                case EnumIcons.NIT:
                    return "NIT";
                case EnumIcons.OBJECTCAROUSEL:
                    return "OBJECTCAROUSEL";
                case EnumIcons.Output:
                    return "Output";
                case EnumIcons.OutputTransportStream:
                    return "OutputTransportStream";
                case EnumIcons.PAT:
                    return "PAT";
                case EnumIcons.PCR:
                    return "PCR";
                case EnumIcons.PD:
                    return "PD";
                case EnumIcons.PES:
                    return "PES";
                case EnumIcons.PMT:
                    return "PMT";
                case EnumIcons.Primary:
                    return "Primary";
                case EnumIcons.Processor:
                    return "Processor";
                case EnumIcons.RADIO:
                    return "RADIO";
                case EnumIcons.RECTAliceBlue:
                    return "RECT-Alice​Blue";
                case EnumIcons.RECTAntiqueWhite:
                    return "RECT-Antique​White";
                case EnumIcons.RECTAqua:
                    return "RECT-Aqua";
                case EnumIcons.RECTAquamarine:
                    return "RECT-Aquamarine";
                case EnumIcons.RECTAzure:
                    return "RECT-Azure";
                case EnumIcons.RECTBeige:
                    return "RECT-Beige";
                case EnumIcons.RECTBisque:
                    return "RECT-Bisque";
                case EnumIcons.RECTBlack:
                    return "RECT-Black";
                case EnumIcons.RECTBlanchedAlmond:
                    return "RECT-Blanched​Almond";
                case EnumIcons.RECTBlue:
                    return "RECT-Blue";
                case EnumIcons.RECTBlueViolet:
                    return "RECT-Blue​Violet";
                case EnumIcons.RECTBrown:
                    return "RECT-Brown";
                case EnumIcons.RECTBurlyWood:
                    return "RECT-Burly​Wood";
                case EnumIcons.RECTCadetBlue:
                    return "RECT-Cadet​Blue";
                case EnumIcons.RECTChartreuse:
                    return "RECT-Chartreuse";
                case EnumIcons.RECTChocolate:
                    return "RECT-Chocolate";
                case EnumIcons.RECTCoral:
                    return "RECT-Coral";
                case EnumIcons.RECTCornflowerBlue:
                    return "RECT-Cornflower​Blue";
                case EnumIcons.RECTCornsilk:
                    return "RECT-Cornsilk";
                case EnumIcons.RECTCrimson:
                    return "RECT-Crimson";
                case EnumIcons.RECTCyan:
                    return "RECT-Cyan";
                case EnumIcons.RECTDarkBlue:
                    return "RECT-Dark​Blue";
                case EnumIcons.RECTDarkCyan:
                    return "RECT-Dark​Cyan";
                case EnumIcons.RECTDarkGoldenrod:
                    return "RECT-Dark​Goldenrod";
                case EnumIcons.RECTDarkGray:
                    return "RECT-Dark​Gray";
                case EnumIcons.RECTDarkGreen:
                    return "RECT-Dark​Green";
                case EnumIcons.RECTDarkKhaki:
                    return "RECT-Dark​Khaki";
                case EnumIcons.RECTDarkMagenta:
                    return "RECT-Dark​Magenta";
                case EnumIcons.RECTDarkOliveGreen:
                    return "RECT-Dark​Olive​Green";
                case EnumIcons.RECTDarkOrange:
                    return "RECT-Dark​Orange";
                case EnumIcons.RECTDarkOrchid:
                    return "RECT-Dark​Orchid";
                case EnumIcons.RECTDarkRed:
                    return "RECT-Dark​Red";
                case EnumIcons.RECTDarkSalmon:
                    return "RECT-Dark​Salmon";
                case EnumIcons.RECTDarkSeaGreen:
                    return "RECT-Dark​Sea​Green";
                case EnumIcons.RECTDarkSlateBlue:
                    return "RECT-Dark​Slate​Blue";
                case EnumIcons.RECTDarkSlateGray:
                    return "RECT-Dark​Slate​Gray";
                case EnumIcons.RECTDarkTurquoise:
                    return "RECT-Dark​Turquoise";
                case EnumIcons.RECTDarkViolet:
                    return "RECT-Dark​Violet";
                case EnumIcons.RECTDeepPink:
                    return "RECT-Deep​Pink";
                case EnumIcons.RECTDeepSkyBlue:
                    return "RECT-Deep​Sky​Blue";
                case EnumIcons.RECTDimGray:
                    return "RECT-Dim​Gray";
                case EnumIcons.RECTDodgerBlue:
                    return "RECT-Dodger​Blue";
                case EnumIcons.RECTFirebrick:
                    return "RECT-Firebrick";
                case EnumIcons.RECTFloralWhite:
                    return "RECT-Floral​White";
                case EnumIcons.RECTForestGreen:
                    return "RECT-Forest​Green";
                case EnumIcons.RECTFuchsia:
                    return "RECT-Fuchsia";
                case EnumIcons.RECTGainsboro:
                    return "RECT-Gainsboro";
                case EnumIcons.RECTGhostWhite:
                    return "RECT-Ghost​White";
                case EnumIcons.RECTGold:
                    return "RECT-Gold";
                case EnumIcons.RECTGoldenrod:
                    return "RECT-Goldenrod";
                case EnumIcons.RECTGray:
                    return "RECT-Gray";
                case EnumIcons.RECTGreen:
                    return "RECT-Green";
                case EnumIcons.RECTGreenYellow:
                    return "RECT-Green​Yellow";
                case EnumIcons.RECTHoneydew:
                    return "RECT-Honeydew";
                case EnumIcons.RECTHotPink:
                    return "RECT-Hot​Pink";
                case EnumIcons.RECTIndianRed:
                    return "RECT-Indian​Red";
                case EnumIcons.RECTIndigo:
                    return "RECT-Indigo";
                case EnumIcons.RECTIvory:
                    return "RECT-Ivory";
                case EnumIcons.RECTKhaki:
                    return "RECT-Khaki";
                case EnumIcons.RECTLavender:
                    return "RECT-Lavender";
                case EnumIcons.RECTLavenderBlush:
                    return "RECT-Lavender​Blush";
                case EnumIcons.RECTLawnGreen:
                    return "RECT-Lawn​Green";
                case EnumIcons.RECTLemonChiffon:
                    return "RECT-Lemon​Chiffon";
                case EnumIcons.RECTLightBlue:
                    return "RECT-Light​Blue";
                case EnumIcons.RECTLightCoral:
                    return "RECT-Light​Coral";
                case EnumIcons.RECTLightCyan:
                    return "RECT-Light​Cyan";
                case EnumIcons.RECTLightGoldenrodYellow:
                    return "RECT-Light​Goldenrod​Yellow";
                case EnumIcons.RECTLightGray:
                    return "RECT-Light​Gray";
                case EnumIcons.RECTLightGreen:
                    return "RECT-Light​Green";
                case EnumIcons.RECTLightPink:
                    return "RECT-Light​Pink";
                case EnumIcons.RECTLightSalmon:
                    return "RECT-Light​Salmon";
                case EnumIcons.RECTLightSeaGreen:
                    return "RECT-Light​Sea​Green";
                case EnumIcons.RECTLightSkyBlue:
                    return "RECT-Light​Sky​Blue";
                case EnumIcons.RECTLightSlateGray:
                    return "RECT-Light​Slate​Gray";
                case EnumIcons.RECTLightSteelBlue:
                    return "RECT-Light​Steel​Blue";
                case EnumIcons.RECTLightYellow:
                    return "RECT-Light​Yellow";
                case EnumIcons.RECTLime:
                    return "RECT-Lime";
                case EnumIcons.RECTLimeGreen:
                    return "RECT-Lime​Green";
                case EnumIcons.RECTLinen:
                    return "RECT-Linen";
                case EnumIcons.RECTMagenta:
                    return "RECT-Magenta";
                case EnumIcons.RECTMaroon:
                    return "RECT-Maroon";
                case EnumIcons.RECTMediumAquamarine:
                    return "RECT-Medium​Aquamarine";
                case EnumIcons.RECTMediumBlue:
                    return "RECT-Medium​Blue";
                case EnumIcons.RECTMediumOrchid:
                    return "RECT-Medium​Orchid";
                case EnumIcons.RECTMediumPurple:
                    return "RECT-Medium​Purple";
                case EnumIcons.RECTMediumSeaGreen:
                    return "RECT-Medium​Sea​Green";
                case EnumIcons.RECTMediumSlateBlue:
                    return "RECT-Medium​Slate​Blue";
                case EnumIcons.RECTMediumSpringGreen:
                    return "RECT-Medium​Spring​Green";
                case EnumIcons.RECTMediumTurquoise:
                    return "RECT-Medium​Turquoise";
                case EnumIcons.RECTMediumVioletRed:
                    return "RECT-Medium​Violet​Red";
                case EnumIcons.RECTMidnightBlue:
                    return "RECT-Midnight​Blue";
                case EnumIcons.RECTMintCream:
                    return "RECT-Mint​Cream";
                case EnumIcons.RECTMistyRose:
                    return "RECT-Misty​Rose";
                case EnumIcons.RECTMoccasin:
                    return "RECT-Moccasin";
                case EnumIcons.RECTNavajoWhite:
                    return "RECT-Navajo​White";
                case EnumIcons.RECTNavy:
                    return "RECT-Navy";
                case EnumIcons.RECTOldLace:
                    return "RECT-Old​Lace";
                case EnumIcons.RECTOlive:
                    return "RECT-Olive";
                case EnumIcons.RECTOliveDrab:
                    return "RECT-Olive​Drab";
                case EnumIcons.RECTOrange:
                    return "RECT-Orange";
                case EnumIcons.RECTOrangeRed:
                    return "RECT-Orange​Red";
                case EnumIcons.RECTOrchid:
                    return "RECT-Orchid";
                case EnumIcons.RECTPaleGoldenrod:
                    return "RECT-Pale​Goldenrod";
                case EnumIcons.RECTPaleGreen:
                    return "RECT-Pale​Green";
                case EnumIcons.RECTPaleTurquoise:
                    return "RECT-Pale​Turquoise";
                case EnumIcons.RECTPaleVioletRed:
                    return "RECT-Pale​Violet​Red";
                case EnumIcons.RECTPapayaWhip:
                    return "RECT-Papaya​Whip";
                case EnumIcons.RECTPeachPuff:
                    return "RECT-Peach​Puff";
                case EnumIcons.RECTPeru:
                    return "RECT-Peru";
                case EnumIcons.RECTPink:
                    return "RECT-Pink";
                case EnumIcons.RECTPlum:
                    return "RECT-Plum";
                case EnumIcons.RECTPowderBlue:
                    return "RECT-Powder​Blue";
                case EnumIcons.RECTPurple:
                    return "RECT-Purple";
                case EnumIcons.RECTRed:
                    return "RECT-Red";
                case EnumIcons.RECTRosyBrown:
                    return "RECT-Rosy​Brown";
                case EnumIcons.RECTRoyalBlue:
                    return "RECT-Royal​Blue";
                case EnumIcons.RECTSaddleBrown:
                    return "RECT-Saddle​Brown";
                case EnumIcons.RECTSalmon:
                    return "RECT-Salmon";
                case EnumIcons.RECTSandyBrown:
                    return "RECT-Sandy​Brown";
                case EnumIcons.RECTSeaGreen:
                    return "RECT-Sea​Green";
                case EnumIcons.RECTSeaShell:
                    return "RECT-Sea​Shell";
                case EnumIcons.RECTSienna:
                    return "RECT-Sienna";
                case EnumIcons.RECTSilver:
                    return "RECT-Silver";
                case EnumIcons.RECTSkyBlue:
                    return "RECT-Sky​Blue";
                case EnumIcons.RECTSlateBlue:
                    return "RECT-Slate​Blue";
                case EnumIcons.RECTSlateGray:
                    return "RECT-Slate​Gray";
                case EnumIcons.RECTSnow:
                    return "RECT-Snow";
                case EnumIcons.RECTSpringGreen:
                    return "RECT-Spring​Green";
                case EnumIcons.RECTSteelBlue:
                    return "RECT-Steel​Blue";
                case EnumIcons.RECTTan:
                    return "RECT-Tan";
                case EnumIcons.RECTTeal:
                    return "RECT-Teal";
                case EnumIcons.RECTThistle:
                    return "RECT-Thistle";
                case EnumIcons.RECTTomato:
                    return "RECT-Tomato";
                case EnumIcons.RECTTransparent:
                    return "RECT-Transparent";
                case EnumIcons.RECTTurquoise:
                    return "RECT-Turquoise";
                case EnumIcons.RECTViolet:
                    return "RECT-Violet";
                case EnumIcons.RECTWheat:
                    return "RECT-Wheat";
                case EnumIcons.RECTWhite:
                    return "RECT-White";
                case EnumIcons.RECTWhiteSmoke:
                    return "RECT-White​Smoke";
                case EnumIcons.RECTYellow:
                    return "RECT-Yellow";
                case EnumIcons.RECTYellowGreen:
                    return "RECT-Yellow​Green";
                case EnumIcons.RST:
                    return "RST";
                case EnumIcons.Satellite:
                    return "Satellite";
                case EnumIcons.SDT:
                    return "SDT";
                case EnumIcons.Secondary:
                    return "Secondary";
                case EnumIcons.SI:
                    return "SI";
                case EnumIcons.StorageCellEmpty:
                    return "StorageCellEmpty";
                case EnumIcons.StorageCellFull:
                    return "StorageCellFull";
                case EnumIcons.StorageTape:
                    return "StorageTape";
                case EnumIcons.SUBTITLE:
                    return "SUBTITLE";
                case EnumIcons.TDT:
                    return "TDT";
                case EnumIcons.TELETEXT:
                    return "TELETEXT";
                case EnumIcons.Transponder:
                    return "Transponder";
                case EnumIcons.TransponderLeased:
                    return "TransponderLeased";
                case EnumIcons.Trash:
                    return "Trash";
                case EnumIcons.TV:
                    return "TV";
                case EnumIcons.VSAT:
                    return "VSAT";
                case EnumIcons.Unknown:
                    return "Unknown";
                default:
                    return null;
            }
        }
    }

    public enum EnumSuppressionType
    {
        ///<summary>
        /// Major Change Suppression
        ///</summary>
MajorChange
    }

    public static partial class EnumSuppressionTypeConverter
    {
        public static EnumSuppressionType? Convert(string input)
        {
            if (String.Equals(input, "MajorChange", StringComparison.OrdinalIgnoreCase))
                return EnumSuppressionType.MajorChange;
            return null;
        }

        public static string ConvertBack(EnumSuppressionType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumSuppressionType.MajorChange:
                    return "MajorChange";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of Process Automation Option names that can be used.
    ///</summary>
public enum EnumProcessAutomationOptionName
    {
        ///<summary>
        /// Current Queue Size.
        ///</summary>
QueueSize,
        ///<summary>
        /// Maximum Queue Size.
        ///</summary>
QueueSizeMax
    }

    public static partial class EnumProcessAutomationOptionNameConverter
    {
        public static EnumProcessAutomationOptionName? Convert(string input)
        {
            if (String.Equals(input, "QueueSize", StringComparison.OrdinalIgnoreCase))
                return EnumProcessAutomationOptionName.QueueSize;
            else if (String.Equals(input, "QueueSizeMax", StringComparison.OrdinalIgnoreCase))
                return EnumProcessAutomationOptionName.QueueSizeMax;
            return null;
        }

        public static string ConvertBack(EnumProcessAutomationOptionName? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumProcessAutomationOptionName.QueueSize:
                    return "QueueSize";
                case EnumProcessAutomationOptionName.QueueSizeMax:
                    return "QueueSizeMax";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of types that can be used as value in the matrix mapping.
    ///</summary>
public enum EnumMatrixMappingType
    {
        ///<summary>
        /// Parameter ID.
        ///</summary>
Pid
    }

    public static partial class EnumMatrixMappingTypeConverter
    {
        public static EnumMatrixMappingType? Convert(string input)
        {
            if (String.Equals(input, "pid", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixMappingType.Pid;
            return null;
        }

        public static string ConvertBack(EnumMatrixMappingType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumMatrixMappingType.Pid:
                    return "pid";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of options that can be used as type in the matrix mapping.
    ///</summary>
public enum EnumMatrixInputsMappingNameType
    {
        ///<summary>
        /// Indicates the index of the input.
        ///</summary>
Index,
        ///<summary>
        /// Indicates the label of the input.
        ///</summary>
Label,
        ///<summary>
        /// Indicates the state of the input.
        ///</summary>
State,
        ///<summary>
        /// Indicates the lock state of the input.
        ///</summary>
Lock,
        ///<summary>
        /// Indicates the page on which the input is located.
        ///</summary>
Page
    }

    public static partial class EnumMatrixInputsMappingNameTypeConverter
    {
        public static EnumMatrixInputsMappingNameType? Convert(string input)
        {
            if (String.Equals(input, "index", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixInputsMappingNameType.Index;
            else if (String.Equals(input, "label", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixInputsMappingNameType.Label;
            else if (String.Equals(input, "state", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixInputsMappingNameType.State;
            else if (String.Equals(input, "lock", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixInputsMappingNameType.Lock;
            else if (String.Equals(input, "page", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixInputsMappingNameType.Page;
            return null;
        }

        public static string ConvertBack(EnumMatrixInputsMappingNameType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumMatrixInputsMappingNameType.Index:
                    return "index";
                case EnumMatrixInputsMappingNameType.Label:
                    return "label";
                case EnumMatrixInputsMappingNameType.State:
                    return "state";
                case EnumMatrixInputsMappingNameType.Lock:
                    return "lock";
                case EnumMatrixInputsMappingNameType.Page:
                    return "page";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of options that can be used as type in the matrix mapping.
    ///</summary>
public enum EnumMatrixOutputsMappingNameType
    {
        ///<summary>
        /// Indicates the index of the output.
        ///</summary>
Index,
        ///<summary>
        /// Indicates the label of the output.
        ///</summary>
Label,
        ///<summary>
        /// Indicates the state of the output.
        ///</summary>
State,
        ///<summary>
        /// Indicates the lock state of the output.
        ///</summary>
Lock,
        ///<summary>
        /// Indicates the page on which the output is located.
        ///</summary>
Page,
        ///<summary>
        /// Indicates the input on which the output is connected.
        ///</summary>
ConnectedInput,
        ///<summary>
        /// Indicates the tooltip of the output which is shown on the crosspoint.
        ///</summary>
Tooltip,
        ///<summary>
        /// Indicates the lock override of the output. This can be used to (un)set a crosspoint while locked.
        ///</summary>
LockOverride
    }

    public static partial class EnumMatrixOutputsMappingNameTypeConverter
    {
        public static EnumMatrixOutputsMappingNameType? Convert(string input)
        {
            if (String.Equals(input, "index", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixOutputsMappingNameType.Index;
            else if (String.Equals(input, "label", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixOutputsMappingNameType.Label;
            else if (String.Equals(input, "state", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixOutputsMappingNameType.State;
            else if (String.Equals(input, "lock", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixOutputsMappingNameType.Lock;
            else if (String.Equals(input, "page", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixOutputsMappingNameType.Page;
            else if (String.Equals(input, "connectedInput", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixOutputsMappingNameType.ConnectedInput;
            else if (String.Equals(input, "tooltip", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixOutputsMappingNameType.Tooltip;
            else if (String.Equals(input, "lockOverride", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixOutputsMappingNameType.LockOverride;
            return null;
        }

        public static string ConvertBack(EnumMatrixOutputsMappingNameType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumMatrixOutputsMappingNameType.Index:
                    return "index";
                case EnumMatrixOutputsMappingNameType.Label:
                    return "label";
                case EnumMatrixOutputsMappingNameType.State:
                    return "state";
                case EnumMatrixOutputsMappingNameType.Lock:
                    return "lock";
                case EnumMatrixOutputsMappingNameType.Page:
                    return "page";
                case EnumMatrixOutputsMappingNameType.ConnectedInput:
                    return "connectedInput";
                case EnumMatrixOutputsMappingNameType.Tooltip:
                    return "tooltip";
                case EnumMatrixOutputsMappingNameType.LockOverride:
                    return "lockOverride";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of types that can be used in the matrix option type.
    ///</summary>
public enum EnumMatrixMatrixOptionType
    {
        ///<summary>
        /// A value without a link to components of the protocol.
        ///</summary>
Value
    }

    public static partial class EnumMatrixMatrixOptionTypeConverter
    {
        public static EnumMatrixMatrixOptionType? Convert(string input)
        {
            if (String.Equals(input, "value", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixMatrixOptionType.Value;
            return null;
        }

        public static string ConvertBack(EnumMatrixMatrixOptionType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumMatrixMatrixOptionType.Value:
                    return "value";
                default:
                    return null;
            }
        }
    }

    ///<summary>
    /// List of types that can be used in the matrix option name.
    ///</summary>
public enum EnumMatrixMatrixOptionNameType
    {
        ///<summary>
        /// Indicates to position inputs or outputs at the top or on the left. Note: For table matrices, the only supported values are 'InputTopOutputLeft' or 'InputLeftOutputTop'.
        ///</summary>
MatrixLayout,
        ///<summary>
        /// Indicates to enable auto-paging. Note: custom pages can be set via the page column on the table.
        ///</summary>
Pages,
        ///<summary>
        /// Indicates the minimum of connected inputs for an output. Note: 0 for no minimum.
        ///</summary>
MinimumConnectedInputsPerOutput,
        ///<summary>
        /// Indicates the maximum of connected inputs for an output. Note: Always 1 for table matrices.
        ///</summary>
MaximumConnectedInputsPerOutput,
        ///<summary>
        /// Indicates the minimum of connected outputs for an input. Note: 0 for no minimum.
        ///</summary>
MinimumConnectedOutputsPerInput,
        ///<summary>
        /// Indicates the maximum of connected outputs for an input. Note: auto for no maximum.
        ///</summary>
MaximumConnectedOutputsPerInput
    }

    public static partial class EnumMatrixMatrixOptionNameTypeConverter
    {
        public static EnumMatrixMatrixOptionNameType? Convert(string input)
        {
            if (String.Equals(input, "matrixLayout", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixMatrixOptionNameType.MatrixLayout;
            else if (String.Equals(input, "pages", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixMatrixOptionNameType.Pages;
            else if (String.Equals(input, "minimumConnectedInputsPerOutput", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixMatrixOptionNameType.MinimumConnectedInputsPerOutput;
            else if (String.Equals(input, "maximumConnectedInputsPerOutput", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixMatrixOptionNameType.MaximumConnectedInputsPerOutput;
            else if (String.Equals(input, "minimumConnectedOutputsPerInput", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixMatrixOptionNameType.MinimumConnectedOutputsPerInput;
            else if (String.Equals(input, "maximumConnectedOutputsPerInput", StringComparison.OrdinalIgnoreCase))
                return EnumMatrixMatrixOptionNameType.MaximumConnectedOutputsPerInput;
            return null;
        }

        public static string ConvertBack(EnumMatrixMatrixOptionNameType? input)
        {
            if (!input.HasValue)
                return "UNDEFINED";
            switch (input)
            {
                case EnumMatrixMatrixOptionNameType.MatrixLayout:
                    return "matrixLayout";
                case EnumMatrixMatrixOptionNameType.Pages:
                    return "pages";
                case EnumMatrixMatrixOptionNameType.MinimumConnectedInputsPerOutput:
                    return "minimumConnectedInputsPerOutput";
                case EnumMatrixMatrixOptionNameType.MaximumConnectedInputsPerOutput:
                    return "maximumConnectedInputsPerOutput";
                case EnumMatrixMatrixOptionNameType.MinimumConnectedOutputsPerInput:
                    return "minimumConnectedOutputsPerInput";
                case EnumMatrixMatrixOptionNameType.MaximumConnectedOutputsPerInput:
                    return "maximumConnectedOutputsPerInput";
                default:
                    return null;
            }
        }
    }
}

// Auto-generated code
// <auto-generated>This is auto-generated code by DIS. Do not modify.</auto-generated>
#pragma warning disable CS1591
namespace Skyline.DataMiner.CICD.Models.Protocol.Read
{
    public abstract partial class ProtocolVisitor
    {
        public virtual void VisitProtocol(IProtocol obj)
        {
            this.DefaultVisit(obj);
            obj.Actions?.Accept(this);
            obj.Advanced?.Accept(this);
            obj.AlarmLevelLinks?.Accept(this);
            obj.App?.Accept(this);
            obj.Chains?.Accept(this);
            obj.Commands?.Accept(this);
            obj.Compliancies?.Accept(this);
            obj.Connections?.Accept(this);
            obj.Description?.Accept(this);
            obj.DeviceOID?.Accept(this);
            obj.Display?.Accept(this);
            obj.DVEs?.Accept(this);
            obj.ElementOptions?.Accept(this);
            obj.SystemOptions?.Accept(this);
            obj.ElementType?.Accept(this);
            obj.ExportRules?.Accept(this);
            obj.GeneralParameters?.Accept(this);
            obj.Groups?.Accept(this);
            obj.HTTP?.Accept(this);
            obj.Icon?.Accept(this);
            obj.IntegrationID?.Accept(this);
            obj.InternalLicenses?.Accept(this);
            obj.Mib?.Accept(this);
            obj.Name?.Accept(this);
            obj.NoTimeouts?.Accept(this);
            obj.Options?.Accept(this);
            obj.Ownership?.Accept(this);
            obj.Pairs?.Accept(this);
            obj.ParameterGroups?.Accept(this);
            obj.Params?.Accept(this);
            obj.Ports?.Accept(this);
            obj.PortSettings?.Accept(this);
            obj.ProcessAutomation?.Accept(this);
            obj.Provider?.Accept(this);
            obj.QActions?.Accept(this);
            obj.RCA?.Accept(this);
            obj.Relations?.Accept(this);
            obj.Responses?.Accept(this);
            obj.SeverityBubbleUp?.Accept(this);
            obj.SNMP?.Accept(this);
            obj.Threads?.Accept(this);
            obj.Timers?.Accept(this);
            obj.Topology?.Accept(this);
            obj.Topologies?.Accept(this);
            obj.TreeControls?.Accept(this);
            obj.Triggers?.Accept(this);
            obj.Type?.Accept(this);
            obj.Vendor?.Accept(this);
            obj.VendorOID?.Accept(this);
            obj.Version?.Accept(this);
            obj.VersionHistory?.Accept(this);
            obj.BaseFor?.Accept(this);
        }

        public virtual void VisitActions(IActions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitActionsAction(IActionsAction obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Name?.Accept(this);
            obj.On?.Accept(this);
            obj.Type?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitActionsActionOn(IActionsActionOn obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Nr?.Accept(this);
        }

        public virtual void VisitActionsActionType(IActionsActionType obj)
        {
            this.DefaultVisit(obj);
            obj.Allowed?.Accept(this);
            obj.Arguments?.Accept(this);
            obj.Endoffset?.Accept(this);
            obj.Id?.Accept(this);
            obj.Nr?.Accept(this);
            obj.Options?.Accept(this);
            obj.Reschedule?.Accept(this);
            obj.ReturnValue?.Accept(this);
            obj.Regex?.Accept(this);
            obj.Scale?.Accept(this);
            obj.Script?.Accept(this);
            obj.Sequence?.Accept(this);
            obj.Startoffset?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitAdvanced(IAdvanced obj)
        {
            this.DefaultVisit(obj);
            obj.IgnoreEqualResponse?.Accept(this);
            obj.Stuffing?.Accept(this);
        }

        public virtual void VisitAlarmLevelLinks(IAlarmLevelLinks obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitAlarmLevelLinksAlarmLevelLink(IAlarmLevelLinksAlarmLevelLink obj)
        {
            this.DefaultVisit(obj);
            obj.Destination?.Accept(this);
            obj.Filters?.Accept(this);
            obj.Id?.Accept(this);
            obj.RemoteElement?.Accept(this);
        }

        public virtual void VisitApp(IApp obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
        }

        public virtual void VisitChains(IChains obj)
        {
            this.DefaultVisit(obj);
            obj.Filters?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitChainsItem(IChainsItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitChainsChain(IChainsChain obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.DefaultSelectionField?.Accept(this);
            obj.GroupingName?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Topology?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitChainsSearchChain(IChainsSearchChain obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.Tabs?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitChainsSearchChainTabs(IChainsSearchChainTabs obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitChainsSearchChainTabsTab(IChainsSearchChainTabsTab obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.Fields?.Accept(this);
            obj.TablePid?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitChainsSearchChainTabsTabFields(IChainsSearchChainTabsTabFields obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitCommands(ICommands obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitCommandsCommand(ICommandsCommand obj)
        {
            this.DefaultVisit(obj);
            obj.Content?.Accept(this);
            obj.Description?.Accept(this);
            obj.Name?.Accept(this);
            obj.WebSocketMessageType?.Accept(this);
            obj.Id?.Accept(this);
            obj.Ascii?.Accept(this);
        }

        public virtual void VisitCommandsCommandContent(ICommandsCommandContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitCommandsCommandContentParam(ICommandsCommandContentParam obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitCompliancies(ICompliancies obj)
        {
            this.DefaultVisit(obj);
            obj.CassandraReady?.Accept(this);
            obj.CassandraRequired?.Accept(this);
            obj.MinimumRequiredVersion?.Accept(this);
            obj.MaximumSupportedVersion?.Accept(this);
        }

        public virtual void VisitConnections(IConnections obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnection(IConnectionsConnection obj)
        {
            this.DefaultVisit(obj);
            obj.Virtual?.Accept(this);
            obj.Snmp?.Accept(this);
            obj.SnmpV2?.Accept(this);
            obj.SnmpV3?.Accept(this);
            obj.Http?.Accept(this);
            obj.Serial?.Accept(this);
            obj.SmartSerial?.Accept(this);
            obj.Gpib?.Accept(this);
            obj.Opc?.Accept(this);
            obj.Id?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionVirtual(IConnectionsConnectionVirtual obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSnmp(IConnectionsConnectionSnmp obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpCommunicationOptions(IConnectionsConnectionSnmpCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.RedundantPolling?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettings(IConnectionsConnectionSnmpUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsBusAddress(IConnectionsConnectionSnmpUserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsBusAddressRange(IConnectionsConnectionSnmpUserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsBusAddressValues(IConnectionsConnectionSnmpUserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsBusAddressValuesValue(IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsIPport(IConnectionsConnectionSnmpUserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsGetCommunity(IConnectionsConnectionSnmpUserSettingsGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsSetCommunity(IConnectionsConnectionSnmpUserSettingsSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsTimeoutTime(IConnectionsConnectionSnmpUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsRetries(IConnectionsConnectionSnmpUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2(IConnectionsConnectionSnmpV2 obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2CommunicationOptions(IConnectionsConnectionSnmpV2CommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.RedundantPolling?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettings(IConnectionsConnectionSnmpV2UserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsBusAddress(IConnectionsConnectionSnmpV2UserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsBusAddressRange(IConnectionsConnectionSnmpV2UserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsBusAddressValues(IConnectionsConnectionSnmpV2UserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue(IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsIPport(IConnectionsConnectionSnmpV2UserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsGetCommunity(IConnectionsConnectionSnmpV2UserSettingsGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsSetCommunity(IConnectionsConnectionSnmpV2UserSettingsSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsTimeoutTime(IConnectionsConnectionSnmpV2UserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsRetries(IConnectionsConnectionSnmpV2UserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3(IConnectionsConnectionSnmpV3 obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3CommunicationOptions(IConnectionsConnectionSnmpV3CommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.RedundantPolling?.Accept(this);
            obj.DynamicContextName?.Accept(this);
            obj.DynamicContextID?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettings(IConnectionsConnectionSnmpV3UserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.SecurityLevel?.Accept(this);
            obj.AuthenticationAlgorithm?.Accept(this);
            obj.EncryptionAlgorithm?.Accept(this);
            obj.UserName?.Accept(this);
            obj.AuthenticationPassword?.Accept(this);
            obj.EncryptionPassword?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsBusAddress(IConnectionsConnectionSnmpV3UserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsBusAddressRange(IConnectionsConnectionSnmpV3UserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsBusAddressValues(IConnectionsConnectionSnmpV3UserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue(IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsIPport(IConnectionsConnectionSnmpV3UserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsSecurityLevel(IConnectionsConnectionSnmpV3UserSettingsSecurityLevel obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm(IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm(IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsUserName(IConnectionsConnectionSnmpV3UserSettingsUserName obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword(IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsEncryptionPassword(IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsTimeoutTime(IConnectionsConnectionSnmpV3UserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsRetries(IConnectionsConnectionSnmpV3UserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttp(IConnectionsConnectionHttp obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpCommunicationOptions(IConnectionsConnectionHttpCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.WebSocket?.Accept(this);
            obj.NotifyConnectionPIDs?.Accept(this);
            obj.MakeCommandByProtocol?.Accept(this);
            obj.WebSocketHandshake?.Accept(this);
            obj.RedundantPolling?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs(IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs obj)
        {
            this.DefaultVisit(obj);
            obj.Connections?.Accept(this);
            obj.Disconnections?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettings(IConnectionsConnectionHttpUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsBusAddress(IConnectionsConnectionHttpUserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsBusAddressRange(IConnectionsConnectionHttpUserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsBusAddressValues(IConnectionsConnectionHttpUserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsBusAddressValuesValue(IConnectionsConnectionHttpUserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsIPport(IConnectionsConnectionHttpUserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsTimeoutTime(IConnectionsConnectionHttpUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsRetries(IConnectionsConnectionHttpUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerial(IConnectionsConnectionSerial obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
            obj.Single?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialCommunicationOptions(IConnectionsConnectionSerialCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.ChunkedHTML?.Accept(this);
            obj.CloseConnectionOnResponse?.Accept(this);
            obj.KexAlgorithms?.Accept(this);
            obj.MakeCommandByProtocol?.Accept(this);
            obj.RedundantPolling?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialCommunicationOptionsKexAlgorithms(IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm(IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettings(IConnectionsConnectionSerialUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.Baudrate?.Accept(this);
            obj.Parity?.Accept(this);
            obj.Databits?.Accept(this);
            obj.Stopbits?.Accept(this);
            obj.Flowcontrol?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeSerial?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Type?.Accept(this);
            obj.SslTlsEnabled?.Accept(this);
            obj.LocalIPport?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBusAddress(IConnectionsConnectionSerialUserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBusAddressRange(IConnectionsConnectionSerialUserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBusAddressValues(IConnectionsConnectionSerialUserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBusAddressValuesValue(IConnectionsConnectionSerialUserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsIPport(IConnectionsConnectionSerialUserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBaudrate(IConnectionsConnectionSerialUserSettingsBaudrate obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBaudrateRange(IConnectionsConnectionSerialUserSettingsBaudrateRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBaudrateValues(IConnectionsConnectionSerialUserSettingsBaudrateValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBaudrateValuesValue(IConnectionsConnectionSerialUserSettingsBaudrateValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsParity(IConnectionsConnectionSerialUserSettingsParity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsParityRange(IConnectionsConnectionSerialUserSettingsParityRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsParityValues(IConnectionsConnectionSerialUserSettingsParityValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsParityValuesValue(IConnectionsConnectionSerialUserSettingsParityValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsDatabits(IConnectionsConnectionSerialUserSettingsDatabits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsDatabitsRange(IConnectionsConnectionSerialUserSettingsDatabitsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsDatabitsValues(IConnectionsConnectionSerialUserSettingsDatabitsValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsDatabitsValuesValue(IConnectionsConnectionSerialUserSettingsDatabitsValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsStopbits(IConnectionsConnectionSerialUserSettingsStopbits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsStopbitsValues(IConnectionsConnectionSerialUserSettingsStopbitsValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsStopbitsValuesValue(IConnectionsConnectionSerialUserSettingsStopbitsValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsFlowcontrol(IConnectionsConnectionSerialUserSettingsFlowcontrol obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsFlowcontrolRange(IConnectionsConnectionSerialUserSettingsFlowcontrolRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsFlowcontrolValues(IConnectionsConnectionSerialUserSettingsFlowcontrolValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue(IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsTimeoutTime(IConnectionsConnectionSerialUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsRetries(IConnectionsConnectionSerialUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsPortTypeIP(IConnectionsConnectionSerialUserSettingsPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsPortTypeSerial(IConnectionsConnectionSerialUserSettingsPortTypeSerial obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsPortTypeUDP(IConnectionsConnectionSerialUserSettingsPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsType(IConnectionsConnectionSerialUserSettingsType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsSslTlsEnabled(IConnectionsConnectionSerialUserSettingsSslTlsEnabled obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsLocalIPport(IConnectionsConnectionSerialUserSettingsLocalIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerial(IConnectionsConnectionSmartSerial obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
            obj.Single?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialCommunicationOptions(IConnectionsConnectionSmartSerialCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.MakeCommandByProtocol?.Accept(this);
            obj.MaxConcurrentConnections?.Accept(this);
            obj.MaxReceiveBuffer?.Accept(this);
            obj.NotifyConnectionPIDs?.Accept(this);
            obj.PacketInfo?.Accept(this);
            obj.RedundantPolling?.Accept(this);
            obj.SmartIPHeader?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs(IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs obj)
        {
            this.DefaultVisit(obj);
            obj.Connections?.Accept(this);
            obj.Disconnections?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo(IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo obj)
        {
            this.DefaultVisit(obj);
            obj.LengthIdentifierOffset?.Accept(this);
            obj.LengthIdentifierLength?.Accept(this);
            obj.IncludeLengthIdentifier?.Accept(this);
            obj.LittleEndian?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettings(IConnectionsConnectionSmartSerialUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Type?.Accept(this);
            obj.SslTlsEnabled?.Accept(this);
            obj.AllowedIPAddresses?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsBusAddress(IConnectionsConnectionSmartSerialUserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsBusAddressRange(IConnectionsConnectionSmartSerialUserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsBusAddressValues(IConnectionsConnectionSmartSerialUserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue(IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsIPport(IConnectionsConnectionSmartSerialUserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsTimeoutTime(IConnectionsConnectionSmartSerialUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsRetries(IConnectionsConnectionSmartSerialUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsPortTypeIP(IConnectionsConnectionSmartSerialUserSettingsPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsPortTypeUDP(IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsType(IConnectionsConnectionSmartSerialUserSettingsType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled(IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses(IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpib(IConnectionsConnectionGpib obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibCommunicationOptions(IConnectionsConnectionGpibCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettings(IConnectionsConnectionGpibUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.DeviceAddress?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsDeviceAddress(IConnectionsConnectionGpibUserSettingsDeviceAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsDeviceAddressRange(IConnectionsConnectionGpibUserSettingsDeviceAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsDeviceAddressValues(IConnectionsConnectionGpibUserSettingsDeviceAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue(IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsTimeoutTime(IConnectionsConnectionGpibUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsRetries(IConnectionsConnectionGpibUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionOpc(IConnectionsConnectionOpc obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionOpcCommunicationOptions(IConnectionsConnectionOpcCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.ProgID?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionOpcUserSettings(IConnectionsConnectionOpcUserSettings obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitDisplay(IDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Pages?.Accept(this);
            obj.DefaultPage?.Accept(this);
            obj.PageOptions?.Accept(this);
            obj.PageOrder?.Accept(this);
            obj.Type?.Accept(this);
            obj.WideColumnPages?.Accept(this);
        }

        public virtual void VisitDisplayPages(IDisplayPages obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitDisplayPagesPage(IDisplayPagesPage obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitDisplayPagesPageVisibility(IDisplayPagesPageVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            obj.OverridePID?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitDVEs(IDVEs obj)
        {
            this.DefaultVisit(obj);
            obj.DVEProtocols?.Accept(this);
            obj.ExportRules?.Accept(this);
        }

        public virtual void VisitDVEsDVEProtocols(IDVEsDVEProtocols obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitDVEsDVEProtocolsDVEProtocol(IDVEsDVEProtocolsDVEProtocol obj)
        {
            this.DefaultVisit(obj);
            obj.ElementPrefix?.Accept(this);
            obj.Name?.Accept(this);
            obj.TablePID?.Accept(this);
        }

        public virtual void VisitElementOptions(IElementOptions obj)
        {
            this.DefaultVisit(obj);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitElementOptionsUserSettings(IElementOptionsUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.PingInterval?.Accept(this);
            obj.SlowPoll?.Accept(this);
            obj.SlowPollBase?.Accept(this);
            obj.TimeoutTimeElement?.Accept(this);
        }

        public virtual void VisitSystemOptions(ISystemOptions obj)
        {
            this.DefaultVisit(obj);
            obj.RunInSeparateInstance?.Accept(this);
        }

        public virtual void VisitGeneralParameters(IGeneralParameters obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitGeneralParametersGeneralParameter(IGeneralParametersGeneralParameter obj)
        {
            this.DefaultVisit(obj);
            obj.Group?.Accept(this);
            obj.Enabled?.Accept(this);
        }

        public virtual void VisitGroups(IGroups obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitGroupsGroup(IGroupsGroup obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Content?.Accept(this);
            obj.Description?.Accept(this);
            obj.Name?.Accept(this);
            obj.Type?.Accept(this);
            obj.Connection?.Accept(this);
            obj.ConnectionPID?.Accept(this);
            obj.Id?.Accept(this);
            obj.Ping?.Accept(this);
        }

        public virtual void VisitGroupsGroupContent(IGroupsGroupContent obj)
        {
            this.DefaultVisit(obj);
            obj.MultipleGet?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitGroupsGroupContentItem(IGroupsGroupContentItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitGroupsGroupContentAction(IGroupsGroupContentAction obj)
        {
            this.DefaultVisit(obj);
            obj.Next?.Accept(this);
        }

        public virtual void VisitGroupsGroupContentPair(IGroupsGroupContentPair obj)
        {
            this.DefaultVisit(obj);
            obj.Next?.Accept(this);
        }

        public virtual void VisitGroupsGroupContentParam(IGroupsGroupContentParam obj)
        {
            this.DefaultVisit(obj);
            obj.Next?.Accept(this);
        }

        public virtual void VisitGroupsGroupContentSession(IGroupsGroupContentSession obj)
        {
            this.DefaultVisit(obj);
            obj.Connection?.Accept(this);
            obj.Next?.Accept(this);
        }

        public virtual void VisitGroupsGroupContentTrigger(IGroupsGroupContentTrigger obj)
        {
            this.DefaultVisit(obj);
            obj.Next?.Accept(this);
        }

        public virtual void VisitHTTP(IHTTP obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHTTPSession(IHTTPSession obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.IgnoreTimeout?.Accept(this);
            obj.KeepAlive?.Accept(this);
            obj.LoginMethod?.Accept(this);
            obj.Name?.Accept(this);
            obj.Password?.Accept(this);
            obj.ProxyPassword?.Accept(this);
            obj.ProxyServer?.Accept(this);
            obj.ProxyUser?.Accept(this);
            obj.Timeout?.Accept(this);
            obj.UserName?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHTTPSessionConnection(IHTTPSessionConnection obj)
        {
            this.DefaultVisit(obj);
            obj.Request?.Accept(this);
            obj.Response?.Accept(this);
            obj.Id?.Accept(this);
            obj.IgnoreTimeout?.Accept(this);
            obj.Name?.Accept(this);
            obj.Timeout?.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionRequest(IHTTPSessionConnectionRequest obj)
        {
            this.DefaultVisit(obj);
            obj.Headers?.Accept(this);
            obj.Data?.Accept(this);
            obj.Parameters?.Accept(this);
            obj.Pid?.Accept(this);
            obj.Verb?.Accept(this);
            obj.Url?.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionResponse(IHTTPSessionConnectionResponse obj)
        {
            this.DefaultVisit(obj);
            obj.Headers?.Accept(this);
            obj.Content?.Accept(this);
            obj.StatusCode?.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionResponseHeaders(IHTTPSessionConnectionResponseHeaders obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionResponseHeadersHeader(IHTTPSessionConnectionResponseHeadersHeader obj)
        {
            this.DefaultVisit(obj);
            obj.Key?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionResponseContent(IHTTPSessionConnectionResponseContent obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitInternalLicenses(IInternalLicenses obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitInternalLicensesInternalLicense(IInternalLicensesInternalLicense obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
        }

        public virtual void VisitNoTimeouts(INoTimeouts obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitNoTimeoutsNoTimeout(INoTimeoutsNoTimeout obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitOptions(IOptions obj)
        {
            this.DefaultVisit(obj);
            obj.DataBaseOptions?.Accept(this);
            obj.DisableViewRefresh?.Accept(this);
            obj.Encoding?.Accept(this);
            obj.ForceDefaultAlarming?.Accept(this);
            obj.GenerateMIB?.Accept(this);
            obj.Icon?.Accept(this);
            obj.NoTimeouts?.Accept(this);
            obj.OverrideTimeoutDVE?.Accept(this);
            obj.PostPonePortInitialisation?.Accept(this);
            obj.UseAgentBinding?.Accept(this);
        }

        public virtual void VisitOptionsDataBaseOptions(IOptionsDataBaseOptions obj)
        {
            this.DefaultVisit(obj);
            obj.CustomDataIDs?.Accept(this);
            obj.PartitionedTrending?.Accept(this);
        }

        public virtual void VisitOptionsGenerateMIB(IOptionsGenerateMIB obj)
        {
            this.DefaultVisit(obj);
            obj.IncludePages?.Accept(this);
        }

        public virtual void VisitOptionsNoTimeouts(IOptionsNoTimeouts obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOptionsNoTimeoutsNoTimeout(IOptionsNoTimeoutsNoTimeout obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitOwnership(IOwnership obj)
        {
            this.DefaultVisit(obj);
            obj.Elements?.Accept(this);
            obj.Views?.Accept(this);
            obj.Services?.Accept(this);
            obj.RedundancyGroups?.Accept(this);
        }

        public virtual void VisitOwnershipElements(IOwnershipElements obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOwnershipElementsElement(IOwnershipElementsElement obj)
        {
            this.DefaultVisit(obj);
            obj.Protocol?.Accept(this);
            obj.Description?.Accept(this);
            obj.Properties?.Accept(this);
            obj.AlarmTemplate?.Accept(this);
            obj.TrendTemplate?.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementDescription(IOwnershipElementsElementDescription obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementProperties(IOwnershipElementsElementProperties obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementPropertiesProperty(IOwnershipElementsElementPropertiesProperty obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementAlarmTemplate(IOwnershipElementsElementAlarmTemplate obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementTrendTemplate(IOwnershipElementsElementTrendTemplate obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipViews(IOwnershipViews obj)
        {
            this.DefaultVisit(obj);
            obj.View?.Accept(this);
        }

        public virtual void VisitOwnershipViewsView(IOwnershipViewsView obj)
        {
            this.DefaultVisit(obj);
            obj.Properties?.Accept(this);
        }

        public virtual void VisitOwnershipViewsViewProperties(IOwnershipViewsViewProperties obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOwnershipViewsViewPropertiesProperty(IOwnershipViewsViewPropertiesProperty obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipServices(IOwnershipServices obj)
        {
            this.DefaultVisit(obj);
            obj.Service?.Accept(this);
        }

        public virtual void VisitOwnershipServicesService(IOwnershipServicesService obj)
        {
            this.DefaultVisit(obj);
            obj.Description?.Accept(this);
            obj.Properties?.Accept(this);
        }

        public virtual void VisitOwnershipServicesServiceDescription(IOwnershipServicesServiceDescription obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipServicesServiceProperties(IOwnershipServicesServiceProperties obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOwnershipServicesServicePropertiesProperty(IOwnershipServicesServicePropertiesProperty obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroups(IOwnershipRedundancyGroups obj)
        {
            this.DefaultVisit(obj);
            obj.RedundancyGroup?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroupsRedundancyGroup(IOwnershipRedundancyGroupsRedundancyGroup obj)
        {
            this.DefaultVisit(obj);
            obj.Description?.Accept(this);
            obj.Maintenance?.Accept(this);
            obj.Switching?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroupsRedundancyGroupDescription(IOwnershipRedundancyGroupsRedundancyGroupDescription obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroupsRedundancyGroupMaintenance(IOwnershipRedundancyGroupsRedundancyGroupMaintenance obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroupsRedundancyGroupSwitching(IOwnershipRedundancyGroupsRedundancyGroupSwitching obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitPairs(IPairs obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPairsPair(IPairsPair obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Content?.Accept(this);
            obj.Description?.Accept(this);
            obj.Name?.Accept(this);
            obj.Id?.Accept(this);
            obj.Options?.Accept(this);
            obj.Ping?.Accept(this);
            obj.Timeout?.Accept(this);
        }

        public virtual void VisitPairsPairContent(IPairsPairContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPairsPairContentItem(IPairsPairContentItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPairsPairContentCommand(IPairsPairContentCommand obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPairsPairContentResponse(IPairsPairContentResponse obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPairsPairContentResponseOnBadCommand(IPairsPairContentResponseOnBadCommand obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParameterGroups(IParameterGroups obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParameterGroupsGroup(IParameterGroupsGroup obj)
        {
            this.DefaultVisit(obj);
            obj.Params?.Accept(this);
            obj.CalculateAlarmState?.Accept(this);
            obj.DynamicId?.Accept(this);
            obj.DynamicIndex?.Accept(this);
            obj.DynamicUsePK?.Accept(this);
            obj.Id?.Accept(this);
            obj.IsInternal?.Accept(this);
            obj.Name?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParameterGroupsGroupParams(IParameterGroupsGroupParams obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParameterGroupsGroupParamsParam(IParameterGroupsGroupParamsParam obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Index?.Accept(this);
        }

        public virtual void VisitParams(IParams obj)
        {
            this.DefaultVisit(obj);
            obj.LoadSequence?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParam(IParamsParam obj)
        {
            this.DefaultVisit(obj);
            obj.Alarm?.Accept(this);
            obj.ArrayOptions?.Accept(this);
            obj.CRC?.Accept(this);
            obj.CrossDriverOptions?.Accept(this);
            obj.Dashboard?.Accept(this);
            obj.Database?.Accept(this);
            obj.Dependencies?.Accept(this);
            obj.Description?.Accept(this);
            obj.Display?.Accept(this);
            obj.HyperLinks?.Accept(this);
            obj.Icon?.Accept(this);
            obj.Information?.Accept(this);
            obj.Interprete?.Accept(this);
            obj.Length?.Accept(this);
            obj.Matrix?.Accept(this);
            obj.Measurement?.Accept(this);
            obj.Mediation?.Accept(this);
            obj.Message?.Accept(this);
            obj.Name?.Accept(this);
            obj.Replication?.Accept(this);
            obj.SNMP?.Accept(this);
            obj.Type?.Accept(this);
            obj.ConfirmPopup?.Accept(this);
            obj.DuplicateAs?.Accept(this);
            obj.Export?.Accept(this);
            obj.HistorySet?.Accept(this);
            obj.Id?.Accept(this);
            obj.Level?.Accept(this);
            obj.Options?.Accept(this);
            obj.PollingInterval?.Accept(this);
            obj.Save?.Accept(this);
            obj.SaveInterval?.Accept(this);
            obj.Setter?.Accept(this);
            obj.Snapshot?.Accept(this);
            obj.SnmpSetAndGet?.Accept(this);
            obj.Trending?.Accept(this);
            obj.VerificationTimeout?.Accept(this);
        }

        public virtual void VisitParamsParamAlarm(IParamsParamAlarm obj)
        {
            this.DefaultVisit(obj);
            obj.CH?.Accept(this);
            obj.CL?.Accept(this);
            obj.Info?.Accept(this);
            obj.MaH?.Accept(this);
            obj.MaL?.Accept(this);
            obj.MiH?.Accept(this);
            obj.MiL?.Accept(this);
            obj.Monitored?.Accept(this);
            obj.Normal?.Accept(this);
            obj.WaH?.Accept(this);
            obj.WaL?.Accept(this);
            obj.ActiveTime?.Accept(this);
            obj.Options?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamAlarmMonitored(IParamsParamAlarmMonitored obj)
        {
            this.DefaultVisit(obj);
            obj.DisabledIf?.Accept(this);
        }

        public virtual void VisitParamsParamArrayOptions(IParamsParamArrayOptions obj)
        {
            this.DefaultVisit(obj);
            obj.NamingFormat?.Accept(this);
            obj.DeleteRow?.Accept(this);
            obj.DisplayColumn?.Accept(this);
            obj.Index?.Accept(this);
            obj.Options?.Accept(this);
            obj.Partial?.Accept(this);
            obj.SnmpIndex?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamArrayOptionsNamingFormat(IParamsParamArrayOptionsNamingFormat obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParamsParamCRC(IParamsParamCRC obj)
        {
            this.DefaultVisit(obj);
            obj.Content?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamCRCContent(IParamsParamCRCContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamCRCContentParam(IParamsParamCRCContentParam obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParamsParamCRCType(IParamsParamCRCType obj)
        {
            this.DefaultVisit(obj);
            obj.Byteoffset?.Accept(this);
            obj.Groupbytes?.Accept(this);
            obj.Mod?.Accept(this);
            obj.Off?.Accept(this);
            obj.Options?.Accept(this);
            obj.Totaloffset?.Accept(this);
        }

        public virtual void VisitParamsParamCrossDriverOptions(IParamsParamCrossDriverOptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamCrossDriverOptionsCrossDriverOption(IParamsParamCrossDriverOptionsCrossDriverOption obj)
        {
            this.DefaultVisit(obj);
            obj.Protocol?.Accept(this);
            obj.RemoteTablePID?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation(IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation obj)
        {
            this.DefaultVisit(obj);
            obj.Local?.Accept(this);
            obj.Remote?.Accept(this);
        }

        public virtual void VisitParamsParamDashboard(IParamsParamDashboard obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.DashboardOptions?.Accept(this);
        }

        public virtual void VisitParamsParamDashboardDashboardOptions(IParamsParamDashboardDashboardOptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDashboardDashboardOptionsDashboardOption(IParamsParamDashboardDashboardOptionsDashboardOption obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitParamsParamDatabase(IParamsParamDatabase obj)
        {
            this.DefaultVisit(obj);
            obj.ColumnDefinition?.Accept(this);
            obj.Connection?.Accept(this);
            obj.CQLOptions?.Accept(this);
            obj.Partition?.Accept(this);
            obj.IndexingOptions?.Accept(this);
        }

        public virtual void VisitParamsParamDatabaseColumnDefinition(IParamsParamDatabaseColumnDefinition obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
        }

        public virtual void VisitParamsParamDatabaseConnection(IParamsParamDatabaseConnection obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamDatabaseCQLOptions(IParamsParamDatabaseCQLOptions obj)
        {
            this.DefaultVisit(obj);
            obj.Clustering?.Accept(this);
            obj.Finalizer?.Accept(this);
            obj.TableProperty?.Accept(this);
        }

        public virtual void VisitParamsParamDatabasePartition(IParamsParamDatabasePartition obj)
        {
            this.DefaultVisit(obj);
            obj.PartitionsToKeep?.Accept(this);
        }

        public virtual void VisitParamsParamDatabaseIndexingOptions(IParamsParamDatabaseIndexingOptions obj)
        {
            this.DefaultVisit(obj);
            obj.Enabled?.Accept(this);
        }

        public virtual void VisitParamsParamDependencies(IParamsParamDependencies obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDependenciesId(IParamsParamDependenciesId obj)
        {
            this.DefaultVisit(obj);
            obj.PostSet?.Accept(this);
        }

        public virtual void VisitParamsParamDisplay(IParamsParamDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.DynamicUnits?.Accept(this);
            obj.Decimals?.Accept(this);
            obj.ParametersView?.Accept(this);
            obj.Positions?.Accept(this);
            obj.Range?.Accept(this);
            obj.RTDisplay?.Accept(this);
            obj.Steps?.Accept(this);
            obj.Trending?.Accept(this);
            obj.Units?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayDynamicUnits(IParamsParamDisplayDynamicUnits obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDisplayDynamicUnitsUnit(IParamsParamDisplayDynamicUnitsUnit obj)
        {
            this.DefaultVisit(obj);
            obj.Decimals?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayParametersView(IParamsParamDisplayParametersView obj)
        {
            this.DefaultVisit(obj);
            obj.Parameters?.Accept(this);
            obj.Options?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayParametersViewParameters(IParamsParamDisplayParametersViewParameters obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDisplayParametersViewParametersParameter(IParamsParamDisplayParametersViewParametersParameter obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Options?.Accept(this);
            obj.TableIndex?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayPositions(IParamsParamDisplayPositions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDisplayPositionsPosition(IParamsParamDisplayPositionsPosition obj)
        {
            this.DefaultVisit(obj);
            obj.Page?.Accept(this);
            obj.Column?.Accept(this);
            obj.Row?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayPositionsPositionPage(IParamsParamDisplayPositionsPositionPage obj)
        {
            this.DefaultVisit(obj);
            obj.MeasType?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayRange(IParamsParamDisplayRange obj)
        {
            this.DefaultVisit(obj);
            obj.Low?.Accept(this);
            obj.High?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayRTDisplay(IParamsParamDisplayRTDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.OnAppLevel?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayTrending(IParamsParamDisplayTrending obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Logarithmic?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayTrendingType(IParamsParamDisplayTrendingType obj)
        {
            this.DefaultVisit(obj);
            obj.Operations?.Accept(this);
        }

        public virtual void VisitParamsParamHyperLinks(IParamsParamHyperLinks obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamHyperLinksHyperLink(IParamsParamHyperLinksHyperLink obj)
        {
            this.DefaultVisit(obj);
            obj.ValueParsing?.Accept(this);
        }

        public virtual void VisitParamsParamInformation(IParamsParamInformation obj)
        {
            this.DefaultVisit(obj);
            obj.AlarmDescription?.Accept(this);
            obj.Category?.Accept(this);
            obj.CorrectiveAction?.Accept(this);
            obj.Includes?.Accept(this);
            obj.Subtext?.Accept(this);
            obj.Text?.Accept(this);
        }

        public virtual void VisitParamsParamInformationIncludes(IParamsParamInformationIncludes obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamInformationIncludesInclude(IParamsParamInformationIncludesInclude obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParamsParamInterprete(IParamsParamInterprete obj)
        {
            this.DefaultVisit(obj);
            obj.Alignment?.Accept(this);
            obj.Base?.Accept(this);
            obj.Bits?.Accept(this);
            obj.ByteOffset?.Accept(this);
            obj.Decimals?.Accept(this);
            obj.DefaultValue?.Accept(this);
            obj.Endian?.Accept(this);
            obj.Exceptions?.Accept(this);
            obj.Factor?.Accept(this);
            obj.Length?.Accept(this);
            obj.LengthType?.Accept(this);
            obj.NbrOfBits?.Accept(this);
            obj.OffSet?.Accept(this);
            obj.Others?.Accept(this);
            obj.Range?.Accept(this);
            obj.RawType?.Accept(this);
            obj.Rounding?.Accept(this);
            obj.Scale?.Accept(this);
            obj.Sequence?.Accept(this);
            obj.StartPosition?.Accept(this);
            obj.Type?.Accept(this);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteExceptions(IParamsParamInterpreteExceptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteExceptionsException(IParamsParamInterpreteExceptionsException obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.ValueElement?.Accept(this);
            obj.Id?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteExceptionsExceptionDisplay(IParamsParamInterpreteExceptionsExceptionDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.State?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteLengthType(IParamsParamInterpreteLengthType obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Times?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteOffSet(IParamsParamInterpreteOffSet obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteOthers(IParamsParamInterpreteOthers obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteOthersOther(IParamsParamInterpreteOthersOther obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.ValueElement?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteOthersOtherDisplay(IParamsParamInterpreteOthersOtherDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.State?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteRange(IParamsParamInterpreteRange obj)
        {
            this.DefaultVisit(obj);
            obj.Low?.Accept(this);
            obj.High?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteScale(IParamsParamInterpreteScale obj)
        {
            this.DefaultVisit(obj);
            obj.LowData?.Accept(this);
            obj.HighData?.Accept(this);
            obj.Low?.Accept(this);
            obj.High?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteSequence(IParamsParamInterpreteSequence obj)
        {
            this.DefaultVisit(obj);
            obj.Loop?.Accept(this);
            obj.Noset?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteType(IParamsParamInterpreteType obj)
        {
            this.DefaultVisit(obj);
            obj.Filter?.Accept(this);
            obj.Trim?.Accept(this);
        }

        public virtual void VisitParamsParamLength(IParamsParamLength obj)
        {
            this.DefaultVisit(obj);
            obj.Content?.Accept(this);
        }

        public virtual void VisitParamsParamLengthContent(IParamsParamLengthContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamLengthContentParam(IParamsParamLengthContentParam obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParamsParamMatrix(IParamsParamMatrix obj)
        {
            this.DefaultVisit(obj);
            obj.Inputs?.Accept(this);
            obj.Outputs?.Accept(this);
            obj.MatrixOptions?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixInputs(IParamsParamMatrixInputs obj)
        {
            this.DefaultVisit(obj);
            obj.Mappings?.Accept(this);
            obj.TablePid?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixInputsMappings(IParamsParamMatrixInputsMappings obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMatrixInputsMappingsMapping(IParamsParamMatrixInputsMappingsMapping obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixOutputs(IParamsParamMatrixOutputs obj)
        {
            this.DefaultVisit(obj);
            obj.Mappings?.Accept(this);
            obj.TablePid?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixOutputsMappings(IParamsParamMatrixOutputsMappings obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMatrixOutputsMappingsMapping(IParamsParamMatrixOutputsMappingsMapping obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixMatrixOptions(IParamsParamMatrixMatrixOptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMatrixMatrixOptionsMatrixOption(IParamsParamMatrixMatrixOptionsMatrixOption obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurement(IParamsParamMeasurement obj)
        {
            this.DefaultVisit(obj);
            obj.Discreets?.Accept(this);
            obj.Threshold?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementDiscreets(IParamsParamMeasurementDiscreets obj)
        {
            this.DefaultVisit(obj);
            obj.DependencyId?.Accept(this);
            obj.MatrixLayout?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementDiscreetsDiscreet(IParamsParamMeasurementDiscreetsDiscreet obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.ValueElement?.Accept(this);
            obj.Tooltip?.Accept(this);
            obj.DependencyValues?.Accept(this);
            obj.DisplayIconAndLabel?.Accept(this);
            obj.Export?.Accept(this);
            obj.IconRef?.Accept(this);
            obj.Options?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementDiscreetsDiscreetDisplay(IParamsParamMeasurementDiscreetsDiscreetDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.State?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementDiscreetsDiscreetValue(IParamsParamMeasurementDiscreetsDiscreetValue obj)
        {
            this.DefaultVisit(obj);
            obj.Location?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementType(IParamsParamMeasurementType obj)
        {
            this.DefaultVisit(obj);
            obj.Case?.Accept(this);
            obj.Continuous?.Accept(this);
            obj.Hex?.Accept(this);
            obj.Lines?.Accept(this);
            obj.Link?.Accept(this);
            obj.Number?.Accept(this);
            obj.Options?.Accept(this);
            obj.ScientificNotation?.Accept(this);
            obj.VerificationDeviation?.Accept(this);
            obj.Width?.Accept(this);
        }

        public virtual void VisitParamsParamMediation(IParamsParamMediation obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMediationLinkTo(IParamsParamMediationLinkTo obj)
        {
            this.DefaultVisit(obj);
            obj.Description?.Accept(this);
            obj.Ops?.Accept(this);
            obj.Pid?.Accept(this);
            obj.Protocol?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMediationLinkToValueMapping(IParamsParamMediationLinkToValueMapping obj)
        {
            this.DefaultVisit(obj);
            obj.RemoteValue?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitParamsParamReplication(IParamsParamReplication obj)
        {
            this.DefaultVisit(obj);
            obj.Element?.Accept(this);
            obj.Parameter?.Accept(this);
            obj.Ip?.Accept(this);
            obj.Uid?.Accept(this);
            obj.Pwd?.Accept(this);
            obj.Domain?.Accept(this);
        }

        public virtual void VisitParamsParamReplicationElement(IParamsParamReplicationElement obj)
        {
            this.DefaultVisit(obj);
            obj.Dynamic?.Accept(this);
        }

        public virtual void VisitParamsParamReplicationParameter(IParamsParamReplicationParameter obj)
        {
            this.DefaultVisit(obj);
            obj.Dynamic?.Accept(this);
        }

        public virtual void VisitParamsParamSNMP(IParamsParamSNMP obj)
        {
            this.DefaultVisit(obj);
            obj.Enabled?.Accept(this);
            obj.Factor?.Accept(this);
            obj.InvalidResponseHandling?.Accept(this);
            obj.OID?.Accept(this);
            obj.TrapMappings?.Accept(this);
            obj.TrapOID?.Accept(this);
            obj.Type?.Accept(this);
            obj.Options?.Accept(this);
        }

        public virtual void VisitParamsParamSNMPInvalidResponseHandling(IParamsParamSNMPInvalidResponseHandling obj)
        {
            this.DefaultVisit(obj);
            obj.InfiniteLoop?.Accept(this);
        }

        public virtual void VisitParamsParamSNMPOID(IParamsParamSNMPOID obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Ipid?.Accept(this);
            obj.Options?.Accept(this);
            obj.SkipDynamicSNMPGet?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamSNMPTrapMappings(IParamsParamSNMPTrapMappings obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamSNMPTrapMappingsTrapMapping(IParamsParamSNMPTrapMappingsTrapMapping obj)
        {
            this.DefaultVisit(obj);
            obj.BindingMatch?.Accept(this);
            obj.Severity?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitParamsParamSNMPTrapOID(IParamsParamSNMPTrapOID obj)
        {
            this.DefaultVisit(obj);
            obj.CheckBindings?.Accept(this);
            obj.Ipid?.Accept(this);
            obj.MapAlarm?.Accept(this);
            obj.SetBindings?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamType(IParamsParamType obj)
        {
            this.DefaultVisit(obj);
            obj.AlarmRegistration?.Accept(this);
            obj.Distribution?.Accept(this);
            obj.DynamicSnmpGet?.Accept(this);
            obj.Id?.Accept(this);
            obj.Options?.Accept(this);
            obj.RelativeTimers?.Accept(this);
            obj.Times?.Accept(this);
            obj.Virtual?.Accept(this);
        }

        public virtual void VisitPorts(IPorts obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitProcessAutomation(IProcessAutomation obj)
        {
            this.DefaultVisit(obj);
            obj.ProcessAutomationOptions?.Accept(this);
        }

        public virtual void VisitProcessAutomationProcessAutomationOptions(IProcessAutomationProcessAutomationOptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitProcessAutomationProcessAutomationOptionsProcessAutomationOption(IProcessAutomationProcessAutomationOptionsProcessAutomationOption obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitQActions(IQActions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitQActionsQAction(IQActionsQAction obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.DllImport?.Accept(this);
            obj.Encoding?.Accept(this);
            obj.EntryPoint?.Accept(this);
            obj.Id?.Accept(this);
            obj.Include?.Accept(this);
            obj.InputParameters?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Row?.Accept(this);
            obj.Triggers?.Accept(this);
        }

        public virtual void VisitRCA(IRCA obj)
        {
            this.DefaultVisit(obj);
            obj.Protocol?.Accept(this);
        }

        public virtual void VisitRCAProtocol(IRCAProtocol obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitRCAProtocolLink(IRCAProtocolLink obj)
        {
            this.DefaultVisit(obj);
            obj.Distribute?.Accept(this);
            obj.Path?.Accept(this);
            obj.ValueFilter?.Accept(this);
        }

        public virtual void VisitRelations(IRelations obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitRelationsRelation(IRelationsRelation obj)
        {
            this.DefaultVisit(obj);
            obj.Options?.Accept(this);
            obj.Path?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitResponses(IResponses obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitResponsesResponse(IResponsesResponse obj)
        {
            this.DefaultVisit(obj);
            obj.Content?.Accept(this);
            obj.Description?.Accept(this);
            obj.Name?.Accept(this);
            obj.Id?.Accept(this);
            obj.Options?.Accept(this);
        }

        public virtual void VisitResponsesResponseContent(IResponsesResponseContent obj)
        {
            this.DefaultVisit(obj);
            obj.Optional?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitResponsesResponseContentParam(IResponsesResponseContentParam obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitSeverityBubbleUp(ISeverityBubbleUp obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitSeverityBubbleUpPath(ISeverityBubbleUpPath obj)
        {
            this.DefaultVisit(obj);
            obj.StatePid?.Accept(this);
        }

        public virtual void VisitSNMP(ISNMP obj)
        {
            this.DefaultVisit(obj);
            obj.Includepages?.Accept(this);
        }

        public virtual void VisitThreads(IThreads obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitThreadsThread(IThreadsThread obj)
        {
            this.DefaultVisit(obj);
            obj.Connection?.Accept(this);
        }

        public virtual void VisitTimers(ITimers obj)
        {
            this.DefaultVisit(obj);
            obj.RelativeTimers?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTimersTimer(ITimersTimer obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Name?.Accept(this);
            obj.Content?.Accept(this);
            obj.Interval?.Accept(this);
            obj.Time?.Accept(this);
            obj.Id?.Accept(this);
            obj.FixedTimer?.Accept(this);
            obj.Options?.Accept(this);
        }

        public virtual void VisitTimersTimerContent(ITimersTimerContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTimersTimerContentGroup(ITimersTimerContentGroup obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTimersTimerTime(ITimersTimerTime obj)
        {
            this.DefaultVisit(obj);
            obj.DataDisplay?.Accept(this);
            obj.Initial?.Accept(this);
        }

        public virtual void VisitTopologies(ITopologies obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologiesTopology(ITopologiesTopology obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologiesTopologyCell(ITopologiesTopologyCell obj)
        {
            this.DefaultVisit(obj);
            obj.Exposer?.Accept(this);
            obj.DetailColumns?.Accept(this);
            obj.ListColumns?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Table?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologiesTopologyCellExposer(ITopologiesTopologyCellExposer obj)
        {
            this.DefaultVisit(obj);
            obj.LinkedIds?.Accept(this);
            obj.Enabled?.Accept(this);
        }

        public virtual void VisitTopologiesTopologyCellExposerLinkedIds(ITopologiesTopologyCellExposerLinkedIds obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologiesTopologyCellExposerLinkedIdsLinkedId(ITopologiesTopologyCellExposerLinkedIdsLinkedId obj)
        {
            this.DefaultVisit(obj);
            obj.ColumnPid?.Accept(this);
        }

        public virtual void VisitTreeControls(ITreeControls obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControl(ITreeControlsTreeControl obj)
        {
            this.DefaultVisit(obj);
            obj.ExtraDetails?.Accept(this);
            obj.ExtraTabs?.Accept(this);
            obj.HiddenColumns?.Accept(this);
            obj.Hierarchy?.Accept(this);
            obj.ReadonlyColumns?.Accept(this);
            obj.OverrideDisplayColumns?.Accept(this);
            obj.OverrideIconColumns?.Accept(this);
            obj.ParameterId?.Accept(this);
            obj.ReadOnly?.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlExtraDetails(ITreeControlsTreeControlExtraDetails obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlExtraDetailsLinkedDetails(ITreeControlsTreeControlExtraDetailsLinkedDetails obj)
        {
            this.DefaultVisit(obj);
            obj.DetailsTableId?.Accept(this);
            obj.DiscreetColumnId?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlExtraTabs(ITreeControlsTreeControlExtraTabs obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlExtraTabsTab(ITreeControlsTreeControlExtraTabsTab obj)
        {
            this.DefaultVisit(obj);
            obj.Parameter?.Accept(this);
            obj.TableId?.Accept(this);
            obj.Title?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlHierarchy(ITreeControlsTreeControlHierarchy obj)
        {
            this.DefaultVisit(obj);
            obj.Path?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlHierarchyTable(ITreeControlsTreeControlHierarchyTable obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Id?.Accept(this);
            obj.ParentAttribute?.Accept(this);
        }

        public virtual void VisitTriggers(ITriggers obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTriggersTrigger(ITriggersTrigger obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Content?.Accept(this);
            obj.Name?.Accept(this);
            obj.On?.Accept(this);
            obj.Time?.Accept(this);
            obj.Type?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitTriggersTriggerContent(ITriggersTriggerContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTriggersTriggerContentId(ITriggersTriggerContentId obj)
        {
            this.DefaultVisit(obj);
            obj.Else?.Accept(this);
        }

        public virtual void VisitTriggersTriggerOn(ITriggersTriggerOn obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
        }

        public virtual void VisitTriggersTriggerTime(ITriggersTriggerTime obj)
        {
            this.DefaultVisit(obj);
            obj.Case?.Accept(this);
            obj.Id?.Accept(this);
            obj.Nr?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitProtocolType(IProtocolType obj)
        {
            this.DefaultVisit(obj);
            obj.Advanced?.Accept(this);
            obj.CommunicationOptions?.Accept(this);
            obj.DatabaseOptions?.Accept(this);
            obj.Options?.Accept(this);
            obj.OverrideTimeoutDVE?.Accept(this);
            obj.RelativeTimers?.Accept(this);
        }

        public virtual void VisitVersionHistory(IVersionHistory obj)
        {
            this.DefaultVisit(obj);
            obj.Branches?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranches(IVersionHistoryBranches obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranch(IVersionHistoryBranchesBranch obj)
        {
            this.DefaultVisit(obj);
            obj.Comment?.Accept(this);
            obj.Features?.Accept(this);
            obj.SystemVersions?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchFeatures(IVersionHistoryBranchesBranchFeatures obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchFeaturesFeature(IVersionHistoryBranchesBranchFeaturesFeature obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersions(IVersionHistoryBranchesBranchSystemVersions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersion(IVersionHistoryBranchesBranchSystemVersionsSystemVersion obj)
        {
            this.DefaultVisit(obj);
            obj.Comment?.Accept(this);
            obj.MajorVersions?.Accept(this);
            obj.SupportedVersions?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion obj)
        {
            this.DefaultVisit(obj);
            obj.Changes?.Accept(this);
            obj.MinorVersions?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange obj)
        {
            this.DefaultVisit(obj);
            obj.Impact?.Accept(this);
            obj.ActionsToTake?.Accept(this);
            obj.CoversMajorChanges?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion obj)
        {
            this.DefaultVisit(obj);
            obj.Changes?.Accept(this);
            obj.Date?.Accept(this);
            obj.Provider?.Accept(this);
            obj.References?.Accept(this);
            obj.Suppressions?.Accept(this);
            obj.Id?.Accept(this);
            obj.BasedOn?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider obj)
        {
            this.DefaultVisit(obj);
            obj.Company?.Accept(this);
            obj.Author?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression(IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression obj)
        {
            this.DefaultVisit(obj);
            obj.Reason?.Accept(this);
            obj.Location?.Accept(this);
            obj.ResultId?.Accept(this);
            obj.Type?.Accept(this);
            obj.TaskId?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions(IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion(IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion obj)
        {
            this.DefaultVisit(obj);
            obj.Min?.Accept(this);
            obj.Max?.Accept(this);
        }

        public virtual void VisitTypeColumnOption(ITypeColumnOption obj)
        {
            this.DefaultVisit(obj);
            obj.CpeAlignment?.Accept(this);
            obj.Idx?.Accept(this);
            obj.Options?.Accept(this);
            obj.Pid?.Accept(this);
            obj.PollingRate?.Accept(this);
            obj.Type?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitExportRules(IExportRules obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitExportRulesExportRule(IExportRulesExportRule obj)
        {
            this.DefaultVisit(obj);
            obj.Attribute?.Accept(this);
            obj.Name?.Accept(this);
            obj.Regex?.Accept(this);
            obj.Table?.Accept(this);
            obj.Tag?.Accept(this);
            obj.ValueAttribute?.Accept(this);
            obj.WhereAttribute?.Accept(this);
            obj.WhereTag?.Accept(this);
            obj.WhereValue?.Accept(this);
        }

        public virtual void VisitHttpRequestData(IHttpRequestData obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitHttpRequestHeaders(IHttpRequestHeaders obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHttpRequestHeadersHeader(IHttpRequestHeadersHeader obj)
        {
            this.DefaultVisit(obj);
            obj.Key?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitHttpRequestParameters(IHttpRequestParameters obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHttpRequestParametersParameter(IHttpRequestParametersParameter obj)
        {
            this.DefaultVisit(obj);
            obj.Key?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitIcon(IIcon obj)
        {
            this.DefaultVisit(obj);
            obj.Ref?.Accept(this);
        }

        public virtual void VisitPingInterval(IPingInterval obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitSlowPoll(ISlowPoll obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitSlowPollBase(ISlowPollBase obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitTypeUserSettings(ITypeUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.Values?.Accept(this);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
        }

        public virtual void VisitTypeUserSettingsValues(ITypeUserSettingsValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeUserSettingsValuesValue(ITypeUserSettingsValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeUserSettingsRange(ITypeUserSettingsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettings(IPortSettings obj)
        {
            this.DefaultVisit(obj);
            obj.Baudrate?.Accept(this);
            obj.BusAddress?.Accept(this);
            obj.Databits?.Accept(this);
            obj.Flowcontrol?.Accept(this);
            obj.FlushPerDatagram?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.IPport?.Accept(this);
            obj.LocalIPport?.Accept(this);
            obj.Parity?.Accept(this);
            obj.PingInterval?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeSerial?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Retries?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.SSH?.Accept(this);
            obj.Stopbits?.Accept(this);
            obj.TimeoutTimeElement?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
            obj.VisibleInUi?.Accept(this);
        }

        public virtual void VisitPortSettingsBaudrate(IPortSettingsBaudrate obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsBaudrateDefaultValue(IPortSettingsBaudrateDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBaudrateDisabled(IPortSettingsBaudrateDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBaudrateRange(IPortSettingsBaudrateRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsBaudrateValue(IPortSettingsBaudrateValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBusAddress(IPortSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsBusAddressDefaultValue(IPortSettingsBusAddressDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBusAddressDisabled(IPortSettingsBusAddressDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBusAddressRange(IPortSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsBusAddressValue(IPortSettingsBusAddressValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsDatabits(IPortSettingsDatabits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsDatabitsDefaultValue(IPortSettingsDatabitsDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsDatabitsDisabled(IPortSettingsDatabitsDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsDatabitsRange(IPortSettingsDatabitsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsDatabitsValue(IPortSettingsDatabitsValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsFlowcontrol(IPortSettingsFlowcontrol obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsFlowcontrolDefaultValue(IPortSettingsFlowcontrolDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsFlowcontrolDisabled(IPortSettingsFlowcontrolDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsFlowcontrolRange(IPortSettingsFlowcontrolRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsFlowcontrolValue(IPortSettingsFlowcontrolValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsGetCommunity(IPortSettingsGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsIPport(IPortSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsLocalIPport(IPortSettingsLocalIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsParity(IPortSettingsParity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsParityDefaultValue(IPortSettingsParityDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsParityDisabled(IPortSettingsParityDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsParityRange(IPortSettingsParityRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsParityValue(IPortSettingsParityValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsPortTypeIP(IPortSettingsPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsPortTypeSerial(IPortSettingsPortTypeSerial obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsPortTypeUDP(IPortSettingsPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsRetries(IPortSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsSetCommunity(IPortSettingsSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsSSH(IPortSettingsSSH obj)
        {
            this.DefaultVisit(obj);
            obj.Credentials?.Accept(this);
            obj.Identity?.Accept(this);
        }

        public virtual void VisitPortSettingsSSHCredentials(IPortSettingsSSHCredentials obj)
        {
            this.DefaultVisit(obj);
            obj.Username?.Accept(this);
            obj.Password?.Accept(this);
        }

        public virtual void VisitPortSettingsSSHCredentialsUsername(IPortSettingsSSHCredentialsUsername obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsSSHCredentialsPassword(IPortSettingsSSHCredentialsPassword obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsSSHIdentity(IPortSettingsSSHIdentity obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsStopbits(IPortSettingsStopbits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsStopbitsDefaultValue(IPortSettingsStopbitsDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsStopbitsDisabled(IPortSettingsStopbitsDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsStopbitsValue(IPortSettingsStopbitsValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsTimeoutTimeElement(IPortSettingsTimeoutTimeElement obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsTimeoutTime(IPortSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsType(IPortSettingsType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitPortSettingsMain(IPortSettingsMain obj)
        {
            this.DefaultVisit(obj);
            obj.Baudrate?.Accept(this);
            obj.BusAddress?.Accept(this);
            obj.Databits?.Accept(this);
            obj.Flowcontrol?.Accept(this);
            obj.FlushPerDatagram?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.IPport?.Accept(this);
            obj.LocalIPport?.Accept(this);
            obj.Parity?.Accept(this);
            obj.PingInterval?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeSerial?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Retries?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.SlowPoll?.Accept(this);
            obj.SlowPollBase?.Accept(this);
            obj.SSH?.Accept(this);
            obj.Stopbits?.Accept(this);
            obj.TimeoutTimeElement?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitPortSettingsMainBaudrate(IPortSettingsMainBaudrate obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainBaudrateDefaultValue(IPortSettingsMainBaudrateDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBaudrateDisabled(IPortSettingsMainBaudrateDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBaudrateRange(IPortSettingsMainBaudrateRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainBaudrateValue(IPortSettingsMainBaudrateValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBusAddress(IPortSettingsMainBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainBusAddressDefaultValue(IPortSettingsMainBusAddressDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBusAddressDisabled(IPortSettingsMainBusAddressDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBusAddressRange(IPortSettingsMainBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainBusAddressValue(IPortSettingsMainBusAddressValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainDatabits(IPortSettingsMainDatabits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainDatabitsDefaultValue(IPortSettingsMainDatabitsDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainDatabitsDisabled(IPortSettingsMainDatabitsDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainDatabitsRange(IPortSettingsMainDatabitsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainDatabitsValue(IPortSettingsMainDatabitsValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainFlowcontrol(IPortSettingsMainFlowcontrol obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainFlowcontrolDefaultValue(IPortSettingsMainFlowcontrolDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainFlowcontrolDisabled(IPortSettingsMainFlowcontrolDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainFlowcontrolRange(IPortSettingsMainFlowcontrolRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainFlowcontrolValue(IPortSettingsMainFlowcontrolValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainGetCommunity(IPortSettingsMainGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainIPport(IPortSettingsMainIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainLocalIPport(IPortSettingsMainLocalIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainParity(IPortSettingsMainParity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainParityDefaultValue(IPortSettingsMainParityDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainParityDisabled(IPortSettingsMainParityDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainParityRange(IPortSettingsMainParityRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainParityValue(IPortSettingsMainParityValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainPortTypeIP(IPortSettingsMainPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainPortTypeSerial(IPortSettingsMainPortTypeSerial obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainPortTypeUDP(IPortSettingsMainPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainRetries(IPortSettingsMainRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSetCommunity(IPortSettingsMainSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSH(IPortSettingsMainSSH obj)
        {
            this.DefaultVisit(obj);
            obj.Credentials?.Accept(this);
            obj.Identity?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSHCredentials(IPortSettingsMainSSHCredentials obj)
        {
            this.DefaultVisit(obj);
            obj.Username?.Accept(this);
            obj.Password?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSHCredentialsUsername(IPortSettingsMainSSHCredentialsUsername obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSHCredentialsPassword(IPortSettingsMainSSHCredentialsPassword obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSHIdentity(IPortSettingsMainSSHIdentity obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsMainStopbits(IPortSettingsMainStopbits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainStopbitsDefaultValue(IPortSettingsMainStopbitsDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainStopbitsDisabled(IPortSettingsMainStopbitsDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainStopbitsValue(IPortSettingsMainStopbitsValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainTimeoutTimeElement(IPortSettingsMainTimeoutTimeElement obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainTimeoutTime(IPortSettingsMainTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainType(IPortSettingsMainType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValues(IPortSettingsWithValues obj)
        {
            this.DefaultVisit(obj);
            obj.Baudrate?.Accept(this);
            obj.BusAddress?.Accept(this);
            obj.Databits?.Accept(this);
            obj.Flowcontrol?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.IPport?.Accept(this);
            obj.LocalIPport?.Accept(this);
            obj.Parity?.Accept(this);
            obj.PingInterval?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeSerial?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Retries?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.SlowPoll?.Accept(this);
            obj.SlowPollBase?.Accept(this);
            obj.Stopbits?.Accept(this);
            obj.TimeoutTimeElement?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
            obj.VisibleInUi?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBaudrate(IPortSettingsWithValuesBaudrate obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBaudrateRange(IPortSettingsWithValuesBaudrateRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBaudrateValues(IPortSettingsWithValuesBaudrateValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBusAddress(IPortSettingsWithValuesBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBusAddressRange(IPortSettingsWithValuesBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBusAddressValues(IPortSettingsWithValuesBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesDatabits(IPortSettingsWithValuesDatabits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesDatabitsRange(IPortSettingsWithValuesDatabitsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesDatabitsValues(IPortSettingsWithValuesDatabitsValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesFlowcontrol(IPortSettingsWithValuesFlowcontrol obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesFlowcontrolValues(IPortSettingsWithValuesFlowcontrolValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesGetCommunity(IPortSettingsWithValuesGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesIPport(IPortSettingsWithValuesIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesLocalIPport(IPortSettingsWithValuesLocalIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesParity(IPortSettingsWithValuesParity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesParityValues(IPortSettingsWithValuesParityValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesPortTypeIP(IPortSettingsWithValuesPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesPortTypeSerial(IPortSettingsWithValuesPortTypeSerial obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesPortTypeUDP(IPortSettingsWithValuesPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesRetries(IPortSettingsWithValuesRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesSetCommunity(IPortSettingsWithValuesSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesStopbits(IPortSettingsWithValuesStopbits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesStopbitsValues(IPortSettingsWithValuesStopbitsValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesTimeoutTime(IPortSettingsWithValuesTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesType(IPortSettingsWithValuesType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitTypeTopologyCellLink(ITypeTopologyCellLink obj)
        {
            this.DefaultVisit(obj);
            obj.Dest?.Accept(this);
            obj.Source?.Accept(this);
        }

        public virtual void VisitTypeChainsChainDisplay(ITypeChainsChainDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitTypeChainsChainDisplayVisibility(ITypeChainsChainDisplayVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsChainDisplayVisibilityStandalone(ITypeChainsChainDisplayVisibilityStandalone obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsChainDisplayVisibilityStandaloneValue(ITypeChainsChainDisplayVisibilityStandaloneValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeChainsSearchChainDisplay(ITypeChainsSearchChainDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainDisplayVisibility(ITypeChainsSearchChainDisplayVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainDisplayVisibilityStandalone(ITypeChainsSearchChainDisplayVisibilityStandalone obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainDisplayVisibilityStandaloneValue(ITypeChainsSearchChainDisplayVisibilityStandaloneValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeChainsChainFieldDisplay(ITypeChainsChainFieldDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Selection?.Accept(this);
        }

        public virtual void VisitTypeChainsChainFieldDisplaySelection(ITypeChainsChainFieldDisplaySelection obj)
        {
            this.DefaultVisit(obj);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitTypeChainsChainFieldDisplaySelectionVisibility(ITypeChainsChainFieldDisplaySelectionVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsChainFieldDisplaySelectionVisibilityStandalone(ITypeChainsChainFieldDisplaySelectionVisibilityStandalone obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue(ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabField(ITypeChainsSearchChainTabsTabField obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.Substitutions?.Accept(this);
            obj.Validation?.Accept(this);
            obj.ColumnPid?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabFieldSubstitutions(ITypeChainsSearchChainTabsTabFieldSubstitutions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution(ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution obj)
        {
            this.DefaultVisit(obj);
            obj.Regex?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex(ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex obj)
        {
            this.DefaultVisit(obj);
            obj.Input?.Accept(this);
            obj.Output?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabFieldValidation(ITypeChainsSearchChainTabsTabFieldValidation obj)
        {
            this.DefaultVisit(obj);
            obj.ErrorMessage?.Accept(this);
            obj.Regex?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainFieldDisplay(ITypeChainsSearchChainFieldDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainFieldDisplayVisibility(ITypeChainsSearchChainFieldDisplayVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainFieldDisplayVisibilityStandalone(ITypeChainsSearchChainFieldDisplayVisibilityStandalone obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainFieldDisplayVisibilityStandaloneValue(ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeChainsChainField(ITypeChainsChainField obj)
        {
            this.DefaultVisit(obj);
            obj.DiagramPids?.Accept(this);
            obj.DiagramSorting?.Accept(this);
            obj.DiagramTitleFormat?.Accept(this);
            obj.Display?.Accept(this);
            obj.DisplayTable?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitTopology(ITopology obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologyCell(ITopologyCell obj)
        {
            this.DefaultVisit(obj);
            obj.DetailColumns?.Accept(this);
            obj.ListColumns?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Table?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologyCellLink(ITopologyCellLink obj)
        {
            this.DefaultVisit(obj);
            obj.Dest?.Accept(this);
            obj.Source?.Accept(this);
        }
    }
}

// Auto-generated code
// <auto-generated>This is auto-generated code by DIS. Do not modify.</auto-generated>
#pragma warning disable CS1591
namespace Skyline.DataMiner.CICD.Models.Protocol.Read
{
    ///<summary>
    /// The root element of a DataMiner protocol.
    ///</summary>
public partial interface IProtocol : IReadable
    {
        ///<summary>
        /// Contains the actions defined in this protocol.
        ///</summary>
IActions Actions { get; }

        ///<summary>
        /// Specifies a number of advanced settings with regard to the protocol's commands and responses.
        ///</summary>
IAdvanced Advanced { get; }

        ///<summary>
        /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
        ///</summary>
IAlarmLevelLinks AlarmLevelLinks { get; }

        ///<summary>
        /// Add this element if you want to turn DataMiner elements executing this protocol into applications.
        /// In DataMiner Cube, protocol-based applications can be found in the Apps tab of the Surveyor.
        ///</summary>
IApp App { get; }

        ///<summary>
        /// Contains the chains defined in this protocol.
        ///</summary>
IChains Chains { get; }

        ///<summary>
        /// Contains all commands defined in the protocol.
        /// Commands are sent from DataMiner to the device
        /// - to request information from the device, or
        /// - to change a device setting.
        ///</summary>
ICommands Commands { get; }

        ///<summary>
        /// Provides compliance information about this protocol.
        ///</summary>
ICompliancies Compliancies { get; }

        ///<summary>
        /// Defines communication connections.
        ///</summary>
IConnections Connections { get; }

        ///<summary>
        /// Specifies a description of the protocol.
        /// Can be used to specify some general information about the protocol. You could, for example, specify that the protocol has been
        /// developed for elements running a specific firmware version.
        /// In protocols of DataMiner elements that are used in automation, the description must be unique.
        ///</summary>
IValueTag<string> Description { get; }

        ///<summary>
        /// Specifies an OID for the device that will be managed with the protocol.
        /// The device OID has to be specified right after the vendor OID. Note that the complete OID, i.e. the vendor OID followed by the device OID, must be unique.
        /// This means that for each device from the same vendor you have to use a new device OID.
        ///</summary>
IValueTag<uint?> DeviceOID { get; }

        ///<summary>
        /// Defines the layout and the order of the Data Display pages.
        ///</summary>
IDisplay Display { get; }

        ///<summary>
        /// This tag allows you to describe the behavior of Dynamic Virtual Elements.
        ///</summary>
IDVEs DVEs { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IElementOptions ElementOptions { get; }

        ///<summary>
        /// Contains options that can be enabled or configured that change how the system will manage or interact with the element.
        ///</summary>
ISystemOptions SystemOptions { get; }

        ///<summary>
        /// Specifies the type of device for which the protocol will be used.
        /// The type will be shown whenever a DataMiner element is added or edited. It will also be shown in the Details section of System Display when a DataMiner element is
        /// selected.
        ///</summary>
IValueTag<string> ElementType { get; }

        ///<summary>
        /// Defines rules that are used for changing the displayed items in a Dynamic Virtual Element (DVE), for example changing the location of a parameter.
        ///</summary>
IExportRules ExportRules { get; }

        ///<summary>
        /// Specifies which general parameter groups should be loaded or not. Feature introduced in DataMiner 9.0.1 (RN 12263).
        ///</summary>
IGeneralParameters GeneralParameters { get; }

        ///<summary>
        /// Contains the groups defined in the protocol.
        ///</summary>
IGroups Groups { get; }

        ///<summary>
        /// The root of the HTTP-specific features in a protocol.
        ///</summary>
IHTTP HTTP { get; }

        ///<summary>
        /// Defines an icon (via XAML content in a CDATA tag) to be used in the Applications list in the DataMiner Cube surveyor.
        ///</summary>
IValueTag<string> Icon { get; }

        ///<summary>
        /// Specifies the integration ID.
        ///</summary>
IValueTag<string> IntegrationID { get; }

        ///<summary>
        /// Configures internal licensing.
        ///</summary>
IInternalLicenses InternalLicenses { get; }

        ///<summary>
        /// Allows providing additional content (conforming the SMI specification) that must be included in the generated MIB.
        ///</summary>
IValueTag<string> Mib { get; }

        ///<summary>
        /// Defines the name of the protocol.
        /// This name, which must be unique, will be used throughout the DataMiner System to identify the protocol.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Groups NoTimeout elements.
        ///</summary>
INoTimeouts NoTimeouts { get; }

        ///<summary>
        /// Defines options for the protocol.
        ///</summary>
IOptions Options { get; }

        ///<summary>
        /// Specifies the level of access users will have to elements, views, services and redundancy groups created by elements based on this protocol.
        /// Feature introduced in DataMiner 9.0.3 (RN 13010).
        ///</summary>
IOwnership Ownership { get; }

        ///<summary>
        /// Contains all the pairs defined in the protocol.
        ///</summary>
IPairs Pairs { get; }

        ///<summary>
        /// Defines the DataMiner Connectivity Framework (DCF) interfaces.
        /// Feature introduced in DataMiner 8.0.0 (RN 5663).
        ///</summary>
IParameterGroups ParameterGroups { get; }

        ///<summary>
        /// Contains all the parameters defined in the protocol.
        ///</summary>
IParams Params { get; }

        ///<summary>
        /// For every protocol, you have to specify its type in /Protocol/Type, and its port settings in /Protocol/Portsettings.
        /// In case of a multi-type protocol, the /Protocol/Type@advanced attribute is used to any additional protocol types.
        /// The port settings for those additional protocol types then have to be specified in a /Protocol/Ports/Portsettings element in which the name attribute contains the name of the additional type as specified in the /Protocol/Type@advanced attribute.
        ///</summary>
IPorts Ports { get; }

        ///<summary>
        /// Defines the default port settings of the main device port.
        /// It also allows you to restrict the capabilities of a device port, and to define the format and range of the bus address, if any.
        ///</summary>
IPortSettingsMain PortSettings { get; }

        IProcessAutomation ProcessAutomation { get; }

        ///<summary>
        /// Specifies the protocol provider.
        /// Example: If a protocol was created by someone from Skyline Communications, this provider tag has to be set to "Skyline Communications".
        ///</summary>
IValueTag<string> Provider { get; }

        ///<summary>
        /// Contains all the QActions defined in the protocol.
        /// A QAction (i.e. Quick Action) is a script that can be executed when a parameter or a row changes. Inside a QAction, the following scripting languages can be used:
        /// -	JScript
        /// -	VBScript
        /// -	C#
        ///</summary>
IQActions QActions { get; }

        ///<summary>
        /// Configures Root Cause Analysis (RCA).
        ///</summary>
IRCA RCA { get; }

        ///<summary>
        /// Defines relations between tables.
        ///</summary>
IRelations Relations { get; }

        ///<summary>
        /// Contains all responses defined in the protocol.
        ///</summary>
IResponses Responses { get; }

        ///<summary>
        /// Used to pass alarm severities to linked tables.
        ///</summary>
ISeverityBubbleUp SeverityBubbleUp { get; }

        ///<summary>
        /// Specifies how the MIB file for the protocol will be created.
        ///</summary>
ISNMP SNMP { get; }

        ///<summary>
        /// Specifies additional threads that will be used by the protocol. This allows you to separate time-critical actions from device-polling actions. Use with caution.
        ///</summary>
IThreads Threads { get; }

        ///<summary>
        /// Contains all timers defined in the protocol.
        /// Timers are used to configure recurring events (group execution, device polling, ...). Basically, a timer defines the interval between two consecutive executions of a given event.
        /// By default, the interval specified in a timer is a fixed interval. However, in the protocol, you can make the interval dynamic.
        /// The interval can be modified by changing the value of the [Timer base] Parameter (ID: 65017). The value of this parameter is the factor by which the interval time is multiplied.
        /// So "1" means the original interval, "2" means twice as slow, "0.5" means twice as fast, etc.
        ///</summary>
ITimers Timers { get; }

        ///<summary>
        /// Defines a topology. In this element, you can specify several Cell elements, each representing a cell in the diagram displayed in the CPE Manager.
        ///</summary>
ITopology Topology { get; }

        ///<summary>
        /// Groups topologies defined in the protocol.
        ///</summary>
ITopologies Topologies { get; }

        ///<summary>
        /// Contains all the tree controls defined in the protocol.
        ///</summary>
ITreeControls TreeControls { get; }

        ///<summary>
        /// Contains the triggers defined in the protocol.
        /// In a trigger, you define when it should go off, and which actions it should execute.
        ///</summary>
ITriggers Triggers { get; }

        ///<summary>
        /// Specifies the protocol type. In multi-connection protocols, it specifies the type of the main connection.
        ///</summary>
IProtocolType Type { get; }

        ///<summary>
        /// Specifies the name of the vendor of the monitored device.
        ///</summary>
IValueTag<string> Vendor { get; }

        ///<summary>
        /// Specifies the vendor OID of the monitored device.
        /// This OID, to be provided either by the vendor of the device or (on request) by Skyline Communications, must be unique, as it is used to define MIB objects for all Elements using the protocol.
        /// Typically, the vendor OID will start with the prefix 1.3.6.1.4.1, which identifies private enterprises.
        ///</summary>
IValueTag<string> VendorOID { get; }

        ///<summary>
        /// Specifies the protocol version.
        /// Within one DataMiner system, you can maintain different versions of the same protocol and assign them to different elements. If you have to make modifications to a protocol, do not create a completely new protocol.
        /// Instead, make a new version of that same protocol.
        /// Version can be a number (e.g. 1.0.0.3) or a string (e.g. "high power").
        /// Tip: When you have two types of elements that are very similar (e.g. an optical transmitter: one with a high output power and another with a low output power), you can use the same protocol and create two
        /// versions (e.g. version "high power" and version "low power" for the protocol "optical transmitter". The only difference between the two versions would then be e.g. the range settings for the "output power" parameter).
        ///</summary>
IValueTag<string> Version { get; }

        ///<summary>
        /// Contains an overview of the version history of this protocol.
        /// Feature introduced in DataMiner 9.5.11 (RN 17697, RN 18360).
        ///</summary>
IVersionHistory VersionHistory { get; }

        ///<summary>
        /// Specifies the type of element for which this protocol serves as a base protocol.
        /// In case a value is defined in this attribute, the protocol is considered a base protocol.
        ///</summary>
IValueTag<string> BaseFor { get; }
    }

    ///<summary>
    /// Contains the actions defined in this protocol.
    ///</summary>
public partial interface IActions : IReadableList<IActionsAction>
    {
    }

    ///<summary>
    /// Defines an action.
    ///</summary>
public partial interface IActionsAction : IReadable
    {
        ///<summary>
        /// Specifies a condition that must be met in order for the action to execute.
        ///</summary>
IValueTag<string> Condition { get; }

        ///<summary>
        /// Specifies the name of the action.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Defines, together with Action/Type, how the action is executed.
        /// Not all Action/Type values can be used in combination with the different Action/On types.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
        ///</summary>
IActionsActionOn On { get; }

        ///<summary>
        /// Defines, together with Action/On, how the action is executed.
        /// Not all Action/Type values can be used in combination with the different Action/On types.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
        ///</summary>
IActionsActionType Type { get; }

        ///<summary>
        /// Specifies the unique action ID.
        ///</summary>
IValueTag<uint?> Id { get; }
    }

    ///<summary>
    /// Defines, together with Action/Type, how the action is executed.
    /// Not all Action/Type values can be used in combination with the different Action/On types.
    /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
    ///</summary>
public partial interface IActionsActionOn : IValueTag<Enums.EnumActionOn?>
    {
        ///<summary>
        /// The ID of the parameter, command, response, etc.
        /// In case the "id" attribute is not present, the trigger will apply to all items of the type specified in /Protocol/Actions/Action/On.
        ///</summary>
IValueTag<string> Id { get; }

        ///<summary>
        /// If Action/Type is "reverse", this attribute specifies the (0-based) position(s) of the parameter(s) in the command/response.
        /// If Action/Type is "set next", this attribute specifies the (1-based) position(s) of the pair(s) in the group.
        /// In any case, separate multiple positions with semicolons.
        ///</summary>
IValueTag<string> Nr { get; }
    }

    ///<summary>
    /// Defines, together with Action/On, how the action is executed.
    /// Not all Action/Type values can be used in combination with the different Action/On types.
    /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
    ///</summary>
public partial interface IActionsActionType : IValueTag<Enums.EnumActionType?>
    {
        ///<summary>
        /// If Action/Type is "stuffing": If the byte specified in the "value" attribute is followed by one of the characters specified in this attri­bute, then it will not be repeated.
        ///</summary>
IValueTag<string> Allowed { get; }

        ///<summary>
        /// If Action/Type is "wmi", this attribute specifies the names of the columns to be returned (separated by semicolons).
        ///</summary>
IValueTag<string> Arguments { get; }

        ///<summary>
        /// If Action/Type is "stuffing", this attribute specifies the (fixed) end position that delimits the part of the data block in which stuffing has to be performed.
        ///</summary>
IValueTag<uint?> Endoffset { get; }

        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter containing the directory in which the file can be found.
        /// If Action/Type is "replace", this attribute specifies the ID of the parameter that contains the ID of the parameter that has to be put in the command/response.
        /// If Action/Type is "increment", this attribute specifies the ID of the parameter that holds the increment value.
        /// 
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the number of bytes to be read.
        /// If Action/Type is "replace", this attribute specifies the (0-based) position of the parameter in the command/response.
        /// If Action/Type is "set", "set and get with wait", "set with wait", "open", "close", "lock", "unlock", "priority lock" or "priority unlock", this attribute sepcifies the (0-based) connection ID.
        /// 
        ///</summary>
IValueTag<string> Nr { get; }

        ///<summary>
        /// This attribute allows defining different options depending on the Action/Type.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options for a given type.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// If Action/Type is "restart timer" and this attribute is set to “true”, then the timer will immediately start again. Feature introduced in DataMiner 8.5.4 (RN 9189).
        ///</summary>
IValueTag<bool?> Reschedule { get; }

        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter in which to store the retrieved file content.
        /// If Type is "wmi", this attribute specifies the ID of the parameter containing the returned values (if "table" is set to "true", this ID should be the ID of a parameter of type "array").
        ///</summary>
IValueTag<string> ReturnValue { get; }

        ///<summary>
        /// If Action/Type is "aggregate", this attribute allows to specify the regular expression to use for filtering.
        /// Feature introduced in DataMiner 10.1.8 (RN 30199).
        ///</summary>
IValueTag<string> Regex { get; }

        ///<summary>
        /// If Action/Type is "set info", this attribute specifies the scale to be set on the parameter.
        /// Expected format: lowdata;highdata;low;high (for example: scale="0;65535;-10;10").
        ///</summary>
IValueTag<string> Scale { get; }

        ///<summary>
        /// If Action/Type is "wmi", this attribute specifies the WMI class (e.g. Win32_PerfRawData_PerfOS_Memory).
        ///</summary>
IValueTag<string> Script { get; }

        ///<summary>
        /// If Action/Type is "set info", this attribute specifies the sequence to be set on the parameter.
        ///</summary>
IValueTag<string> Sequence { get; }

        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter containing the start offset (i.e. the number of bytes to skip before starting to read the file).
        /// If Action/Type is "stuffing", this attribute specifies the (fixed) start position that delimits the part of the data block in which stuffing has to be performed.
        /// 
        ///</summary>
IValueTag<uint?> Startoffset { get; }

        ///<summary>
        /// If Action/Type is "stuffing", this attribute specifies the actual stuffing character, i.e. the byte that has to be repeated.
        ///</summary>
IValueTag<string> ValueAttribute { get; }
    }

    ///<summary>
    /// Specifies a number of advanced settings with regard to the protocol's commands and responses.
    ///</summary>
public partial interface IAdvanced : IReadable
    {
        ///<summary>
        /// If you set this attribute to "true", then a received response will be ignored if it is identical to the response received previously (for the same pair).
        /// In other words, the trigger associated with a response will not go off if that response is identical to the previous one.
        /// Note: Use this option with extreme care, as it can have a profound impact on the general behavior of the protocol.
        ///</summary>
IValueTag<bool?> IgnoreEqualResponse { get; }

        ///<summary>
        /// In this attribute, you can specify a number of settings with regard to stuffing. Separate these by semicolons.
        ///</summary>
IValueTag<string> Stuffing { get; }
    }

    ///<summary>
    /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
    ///</summary>
public partial interface IAlarmLevelLinks : IReadableList<IAlarmLevelLinksAlarmLevelLink>
    {
    }

    ///<summary>
    /// Defines an alarm level link.
    /// An alarm level link allows aggregating alarms from DataMiner elements or table rows at runtime.
    /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
    /// The source and destination are table columns.
    ///</summary>
public partial interface IAlarmLevelLinksAlarmLevelLink : IReadable
    {
        ///<summary>
        /// Specifies the column parameter ID where the result of the alarm level needs to be set.
        ///</summary>
IValueTag<string> Destination { get; }

        ///<summary>
        /// By default, alarm level linking is done via primary key or display key. For every key, a link is made with the aggregator element.
        /// If you enter a filter in the filters attribute, the link will only be made if the condition is met. Example: filters="VALUE=204 === 1"
        ///</summary>
IValueTag<string> Filters { get; }

        ///<summary>
        /// The unique ID of the AlarmLevelLink.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Used to retrieve the alarm state of a different element.
        ///</summary>
IValueTag<string> RemoteElement { get; }
    }

    ///<summary>
    /// Add this element if you want to turn DataMiner elements executing this protocol into applications.
    /// In DataMiner Cube, protocol-based applications can be found in the Apps tab of the Surveyor.
    ///</summary>
public partial interface IApp : IReadable
    {
        ///<summary>
        /// Specifies the name of the app.
        ///</summary>
IValueTag<string> Type { get; }
    }

    ///<summary>
    /// Contains the chains defined in this protocol.
    ///</summary>
public partial interface IChains : IReadableList<IChainsItem>
    {
        ///<summary>
        /// Determines the layout of the filters.
        ///</summary>
IValueTag<Enums.EnumChainsFilters?> Filters { get; }
    }

    public partial interface IChainsItem : IReadable
    {
    }

    ///<summary>
    /// Represents a different topology view of a CPE manager or Service Over­view Manager (SOM) element.
    ///</summary>
public partial interface IChainsChain : IReadableList<ITypeChainsChainField>, IChainsItem
    {
        ITypeChainsChainDisplay Display { get; }

        ///<summary>
        /// Specifies the name of the field for which selection should be applied.
        ///</summary>
IValueTag<string> DefaultSelectionField { get; }

        ///<summary>
        /// Specifies the name of the group to which this Chain belongs. Feature introduced in DataMiner 10.1.3 (RN 28751, RN 28834, RN 28846).
        ///</summary>
IValueTag<string> GroupingName { get; }

        ///<summary>
        /// Specifies the name of the chain, which is used as the name of the corresponding tab page in DataMiner.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies a number of options (separated by semicolons).
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Contains the name defined in the /Protocol/Topologies/Topology@name attribute (only Service Overview Manager). See Protocol/Topologies/Topology@name.
        ///</summary>
IValueTag<string> Topology { get; }
    }

    ///<summary>
    /// Defines a search chain in a CPE environment.
    ///</summary>
public partial interface IChainsSearchChain : IReadable, IChainsItem
    {
        ITypeChainsSearchChainDisplay Display { get; }

        IChainsSearchChainTabs Tabs { get; }

        ///<summary>
        /// Specifies the name of the search chain.
        ///</summary>
IValueTag<string> Name { get; }
    }

    public partial interface IChainsSearchChainTabs : IReadableList<IChainsSearchChainTabsTab>
    {
    }

    ///<summary>
    /// Defines a tab.
    ///</summary>
public partial interface IChainsSearchChainTabsTab : IReadable
    {
        ITypeChainsSearchChainFieldDisplay Display { get; }

        ///<summary>
        /// Contains the definition of the fields to be included in this search tab.
        ///</summary>
IChainsSearchChainTabsTabFields Fields { get; }

        ///<summary>
        /// Specifies the table parameter ID of the table for which a search Tab will be defined.
        ///</summary>
IValueTag<uint?> TablePid { get; }

        ///<summary>
        /// Specifies the name of the search tab.
        ///</summary>
IValueTag<string> Name { get; }
    }

    ///<summary>
    /// Contains the definition of the fields to be included in this search tab.
    ///</summary>
public partial interface IChainsSearchChainTabsTabFields : IReadableList<ITypeChainsSearchChainTabsTabField>
    {
    }

    ///<summary>
    /// Contains all commands defined in the protocol.
    /// Commands are sent from DataMiner to the device
    /// - to request information from the device, or
    /// - to change a device setting.
    ///</summary>
public partial interface ICommands : IReadableList<ICommandsCommand>
    {
    }

    ///<summary>
    /// Defines a complete command.
    /// DataMiner sends a command to the device
    /// - to request information, or
    /// - to change a device setting.
    /// In both cases, DataMiner will expect a response from the device. If it requests information, it will expect a response that contains that
    /// information, and if it changes a setting, it will expect a confirmation (although, in some cases, none is returned).
    ///</summary>
public partial interface ICommandsCommand : IReadable
    {
        ///<summary>
        /// Specifies the consecutive parameters that together form the command to be sent to the device.
        /// Quite often, commands have a header parameter and a trailer parameter that demarcate the beginning and the end of the command.
        ///</summary>
ICommandsCommandContent Content { get; }

        ///<summary>
        /// Specifies the command description.
        ///</summary>
IValueTag<string> Description { get; }

        ///<summary>
        /// Specifies the command name.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies the format in which the message should be sent.
        /// By default, the message is sent in binary format.
        /// Feature introduced in DataMiner 9.5.1.
        ///</summary>
IValueTag<Enums.EnumWebSocketMessageType?> WebSocketMessageType { get; }

        ///<summary>
        /// Specifies the command ID.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Only applicable for Unicode protocols. Set to "true" if all parameters of the command should be sent as ASCII.
        /// Use semicolon-separated parameter IDs if only certain parameters should be sent as ASCII.
        ///</summary>
IValueTag<string> Ascii { get; }
    }

    ///<summary>
    /// Specifies the consecutive parameters that together form the command to be sent to the device.
    /// Quite often, commands have a header parameter and a trailer parameter that demarcate the beginning and the end of the command.
    ///</summary>
public partial interface ICommandsCommandContent : IReadableList<ICommandsCommandContentParam>
    {
    }

    ///<summary>
    /// Specifies the ID of the parameter to include in the command.
    ///</summary>
public partial interface ICommandsCommandContentParam : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Provides compliance information about this protocol.
    ///</summary>
public partial interface ICompliancies : IReadable
    {
        ///<summary>
        /// True if the protocol is compatible with a Cassandra database; otherwise, false.
        ///</summary>
IValueTag<bool?> CassandraReady { get; }

        ///<summary>
        /// Specifies whether a Cassandra database is required to execute the protocol. True if Cassandra is required to use this protocol; otherwise, false.
        ///</summary>
IValueTag<bool?> CassandraRequired { get; }

        ///<summary>
        /// Indicates the minimum DataMiner version that the driver is compatible with.
        /// Expected format: [MainVersion].[MainVersionIncrement].[FeatureVersionIncrement].[CurrentlyUnused] - [BuildNumber] (in which [BuildNumber] is a four-digit number) (e.g. 10.0.7.0 - 9247)
        ///</summary>
IValueTag<string> MinimumRequiredVersion { get; }

        ///<summary>
        /// Specifies the maximum DataMiner version this protocol supports.
        /// Expected format: [MainVersion].[MainVersionIncrement].[FeatureVersionIncrement].[CurrentlyUnused] - [BuildNumber] (in which [BuildNumber] is a four-digit number) (e.g. 10.0.7.0 - 9247)
        ///</summary>
IValueTag<string> MaximumSupportedVersion { get; }
    }

    ///<summary>
    /// Defines communication connections.
    ///</summary>
public partial interface IConnections : IReadableList<IConnectionsConnection>
    {
    }

    ///<summary>
    /// Defines a connection.
    ///</summary>
public partial interface IConnectionsConnection : IReadable
    {
        ///<summary>
        /// Defines a Virtual connection.
        ///</summary>
IConnectionsConnectionVirtual Virtual { get; }

        ///<summary>
        /// Defines an SNMP connection.
        ///</summary>
IConnectionsConnectionSnmp Snmp { get; }

        ///<summary>
        /// Defines an SNMPv2 connection.
        ///</summary>
IConnectionsConnectionSnmpV2 SnmpV2 { get; }

        ///<summary>
        /// Defines an SNMPv3 connection.
        ///</summary>
IConnectionsConnectionSnmpV3 SnmpV3 { get; }

        ///<summary>
        /// Defines an HTTP connection.
        ///</summary>
IConnectionsConnectionHttp Http { get; }

        ///<summary>
        /// Defines a serial connection.
        ///</summary>
IConnectionsConnectionSerial Serial { get; }

        ///<summary>
        /// Defines a smart-serial connection.
        ///</summary>
IConnectionsConnectionSmartSerial SmartSerial { get; }

        ///<summary>
        /// Defines a GPIB connection.
        ///</summary>
IConnectionsConnectionGpib Gpib { get; }

        ///<summary>
        /// Defines a OPC connection.
        ///</summary>
IConnectionsConnectionOpc Opc { get; }

        ///<summary>
        /// Specifies the connection ID.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies the connection name.
        ///</summary>
IValueTag<string> Name { get; }
    }

    ///<summary>
    /// Defines a Virtual connection.
    ///</summary>
public partial interface IConnectionsConnectionVirtual : IReadable
    {
    }

    ///<summary>
    /// Defines an SNMP connection.
    ///</summary>
public partial interface IConnectionsConnectionSnmp : IReadable
    {
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
IConnectionsConnectionSnmpCommunicationOptions CommunicationOptions { get; }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
IConnectionsConnectionSnmpUserSettings UserSettings { get; }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpCommunicationOptions : IReadable
    {
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
IValueTag<bool?> RedundantPolling { get; }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettings : IReadable
    {
        ///<summary>
        /// Configures the bus address.
        ///</summary>
IConnectionsConnectionSnmpUserSettingsBusAddress BusAddress { get; }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
IConnectionsConnectionSnmpUserSettingsIPport IPport { get; }

        ///<summary>
        /// Configures the get community string.
        ///</summary>
IConnectionsConnectionSnmpUserSettingsGetCommunity GetCommunity { get; }

        ///<summary>
        /// Configures the get community string.
        ///</summary>
IConnectionsConnectionSnmpUserSettingsSetCommunity SetCommunity { get; }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
IConnectionsConnectionSnmpUserSettingsTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
IConnectionsConnectionSnmpUserSettingsRetries Retries { get; }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettingsBusAddress : IReadable
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IConnectionsConnectionSnmpUserSettingsBusAddressRange Range { get; }

        IConnectionsConnectionSnmpUserSettingsBusAddressValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettingsBusAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    public partial interface IConnectionsConnectionSnmpUserSettingsBusAddressValues : IReadableList<IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettingsIPport : IReadable
    {
        ///<summary>
        /// Specifies the default value.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettingsGetCommunity : IReadable
    {
        IValueTag<string> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettingsSetCommunity : IReadable
    {
        IValueTag<string> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettingsTimeoutTime : IReadable
    {
        IValueTag<uint?> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpUserSettingsRetries : IReadable
    {
        IValueTag<uint?> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Defines an SNMPv2 connection.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2 : IReadable
    {
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
IConnectionsConnectionSnmpV2CommunicationOptions CommunicationOptions { get; }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
IConnectionsConnectionSnmpV2UserSettings UserSettings { get; }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2CommunicationOptions : IReadable
    {
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
IValueTag<bool?> RedundantPolling { get; }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettings : IReadable
    {
        ///<summary>
        /// Configures the bus address.
        ///</summary>
IConnectionsConnectionSnmpV2UserSettingsBusAddress BusAddress { get; }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
IConnectionsConnectionSnmpV2UserSettingsIPport IPport { get; }

        ///<summary>
        /// Configures the get community string.
        ///</summary>
IConnectionsConnectionSnmpV2UserSettingsGetCommunity GetCommunity { get; }

        ///<summary>
        /// Configures the get community string.
        ///</summary>
IConnectionsConnectionSnmpV2UserSettingsSetCommunity SetCommunity { get; }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
IConnectionsConnectionSnmpV2UserSettingsTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
IConnectionsConnectionSnmpV2UserSettingsRetries Retries { get; }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettingsBusAddress : IReadable
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IConnectionsConnectionSnmpV2UserSettingsBusAddressRange Range { get; }

        IConnectionsConnectionSnmpV2UserSettingsBusAddressValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettingsBusAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    public partial interface IConnectionsConnectionSnmpV2UserSettingsBusAddressValues : IReadableList<IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettingsIPport : IReadable
    {
        ///<summary>
        /// Specifies the default value.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettingsGetCommunity : IReadable
    {
        IValueTag<string> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettingsSetCommunity : IReadable
    {
        IValueTag<string> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettingsTimeoutTime : IReadable
    {
        IValueTag<uint?> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV2UserSettingsRetries : IReadable
    {
        IValueTag<uint?> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Defines an SNMPv3 connection.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3 : IReadable
    {
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
IConnectionsConnectionSnmpV3CommunicationOptions CommunicationOptions { get; }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettings UserSettings { get; }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3CommunicationOptions : IReadable
    {
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
IValueTag<bool?> RedundantPolling { get; }

        ///<summary>
        /// Specifies the dynamic context name.
        ///</summary>
IValueTag<string> DynamicContextName { get; }

        ///<summary>
        /// Specifies the dynamic context ID.
        ///</summary>
IValueTag<string> DynamicContextID { get; }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettings : IReadable
    {
        ///<summary>
        /// Configures the bus address.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsBusAddress BusAddress { get; }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsIPport IPport { get; }

        ///<summary>
        /// Specifies the security level settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsSecurityLevel SecurityLevel { get; }

        ///<summary>
        /// Specifies the authentication algorithm settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm AuthenticationAlgorithm { get; }

        ///<summary>
        /// Specifies the encryption algorithm settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm EncryptionAlgorithm { get; }

        ///<summary>
        /// Specifies the user name settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsUserName UserName { get; }

        ///<summary>
        /// Specifies the authentication password settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword AuthenticationPassword { get; }

        ///<summary>
        /// Specifies the encryption password settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword EncryptionPassword { get; }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsRetries Retries { get; }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsBusAddress : IReadable
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IConnectionsConnectionSnmpV3UserSettingsBusAddressRange Range { get; }

        IConnectionsConnectionSnmpV3UserSettingsBusAddressValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsBusAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    public partial interface IConnectionsConnectionSnmpV3UserSettingsBusAddressValues : IReadableList<IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsIPport : IReadable
    {
        ///<summary>
        /// Specifies the default value.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the security level settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsSecurityLevel : IReadable
    {
        IValueTag<string> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies the authentication algorithm settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm : IReadable
    {
        IValueTag<string> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies the encryption algorithm settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm : IReadable
    {
        IValueTag<string> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies the user name settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsUserName : IReadable
    {
        IValueTag<string> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies the authentication password settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword : IReadable
    {
        IValueTag<string> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies the encryption password settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword : IReadable
    {
        IValueTag<string> DefaultValue { get; }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsTimeoutTime : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<uint?> DefaultValue { get; }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial interface IConnectionsConnectionSnmpV3UserSettingsRetries : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<uint?> DefaultValue { get; }
    }

    ///<summary>
    /// Defines an HTTP connection.
    ///</summary>
public partial interface IConnectionsConnectionHttp : IReadable
    {
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
IConnectionsConnectionHttpCommunicationOptions CommunicationOptions { get; }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
IConnectionsConnectionHttpUserSettings UserSettings { get; }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial interface IConnectionsConnectionHttpCommunicationOptions : IReadable
    {
        ///<summary>
        /// Specifies whether this connection is an HTTP connection.
        ///</summary>
IValueTag<bool?> WebSocket { get; }

        ///<summary>
        /// Specifies the parameter IDs to use to monitor (dis)connects.
        ///</summary>
IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs NotifyConnectionPIDs { get; }

        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
IValueTag<bool?> MakeCommandByProtocol { get; }

        ///<summary>
        /// Specifies the ID of the Session to use as a custom opening handshake.
        ///</summary>
IValueTag<uint?> WebSocketHandshake { get; }

        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
IValueTag<bool?> RedundantPolling { get; }
    }

    ///<summary>
    /// Specifies the parameter IDs to use to monitor (dis)connects.
    ///</summary>
public partial interface IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter in which the connects have to be logged.
        ///</summary>
IValueTag<uint?> Connections { get; }

        ///<summary>
        /// Specifies the ID of the parameter in which the disconnects have to be logged.
        ///</summary>
IValueTag<uint?> Disconnections { get; }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial interface IConnectionsConnectionHttpUserSettings : IReadable
    {
        ///<summary>
        /// Configures the bus address.
        ///</summary>
IConnectionsConnectionHttpUserSettingsBusAddress BusAddress { get; }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
IConnectionsConnectionHttpUserSettingsIPport IPport { get; }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
IConnectionsConnectionHttpUserSettingsTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
IConnectionsConnectionHttpUserSettingsRetries Retries { get; }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial interface IConnectionsConnectionHttpUserSettingsBusAddress : IReadable
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IConnectionsConnectionHttpUserSettingsBusAddressRange Range { get; }

        IConnectionsConnectionHttpUserSettingsBusAddressValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IConnectionsConnectionHttpUserSettingsBusAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    public partial interface IConnectionsConnectionHttpUserSettingsBusAddressValues : IReadableList<IConnectionsConnectionHttpUserSettingsBusAddressValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionHttpUserSettingsBusAddressValuesValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial interface IConnectionsConnectionHttpUserSettingsIPport : IReadable
    {
        ///<summary>
        /// Specifies the default value.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial interface IConnectionsConnectionHttpUserSettingsTimeoutTime : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<uint?> DefaultValue { get; }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial interface IConnectionsConnectionHttpUserSettingsRetries : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<uint?> DefaultValue { get; }
    }

    ///<summary>
    /// Defines a serial connection.
    ///</summary>
public partial interface IConnectionsConnectionSerial : IReadable
    {
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
IConnectionsConnectionSerialCommunicationOptions CommunicationOptions { get; }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
IConnectionsConnectionSerialUserSettings UserSettings { get; }

        ///<summary>
        /// Specifies whether this is a dedicated connection.
        ///</summary>
IValueTag<bool?> Single { get; }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialCommunicationOptions : IReadable
    {
        IValueTag<bool?> ChunkedHTML { get; }

        IValueTag<bool?> CloseConnectionOnResponse { get; }

        IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms KexAlgorithms { get; }

        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
IValueTag<bool?> MakeCommandByProtocol { get; }

        IValueTag<bool?> RedundantPolling { get; }
    }

    public partial interface IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms : IReadableList<IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm>
    {
    }

    public partial interface IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettings : IReadable
    {
        ///<summary>
        /// Configures the bus address.
        ///</summary>
IConnectionsConnectionSerialUserSettingsBusAddress BusAddress { get; }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsIPport IPport { get; }

        IConnectionsConnectionSerialUserSettingsBaudrate Baudrate { get; }

        IConnectionsConnectionSerialUserSettingsParity Parity { get; }

        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
IConnectionsConnectionSerialUserSettingsDatabits Databits { get; }

        ///<summary>
        /// Specifies the stop bits settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsStopbits Stopbits { get; }

        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        ///</summary>
IConnectionsConnectionSerialUserSettingsFlowcontrol Flowcontrol { get; }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsRetries Retries { get; }

        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
IConnectionsConnectionSerialUserSettingsPortTypeIP PortTypeIP { get; }

        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
IConnectionsConnectionSerialUserSettingsPortTypeSerial PortTypeSerial { get; }

        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
IConnectionsConnectionSerialUserSettingsPortTypeUDP PortTypeUDP { get; }

        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsType Type { get; }

        ///<summary>
        /// Specifies the SSL/TLS settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsSslTlsEnabled SslTlsEnabled { get; }

        ///<summary>
        /// Specifies the local port settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsLocalIPport LocalIPport { get; }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsBusAddress : IReadable
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IConnectionsConnectionSerialUserSettingsBusAddressRange Range { get; }

        IConnectionsConnectionSerialUserSettingsBusAddressValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsBusAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    public partial interface IConnectionsConnectionSerialUserSettingsBusAddressValues : IReadableList<IConnectionsConnectionSerialUserSettingsBusAddressValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsBusAddressValuesValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsIPport : IReadable
    {
        ///<summary>
        /// Specifies the default value.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    public partial interface IConnectionsConnectionSerialUserSettingsBaudrate : IReadable
    {
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsBaudrateRange Range { get; }

        IConnectionsConnectionSerialUserSettingsBaudrateValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsBaudrateRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
IValueTag<uint?> From { get; }

        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
IValueTag<uint?> To { get; }
    }

    public partial interface IConnectionsConnectionSerialUserSettingsBaudrateValues : IReadableList<IConnectionsConnectionSerialUserSettingsBaudrateValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsBaudrateValuesValue : IValueTag<string>
    {
    }

    public partial interface IConnectionsConnectionSerialUserSettingsParity : IReadable
    {
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
IValueTag<Enums.EnumPortSettingsParity?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
IConnectionsConnectionSerialUserSettingsParityRange Range { get; }

        IConnectionsConnectionSerialUserSettingsParityValues Values { get; }
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsParityRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsParity?> From { get; }

        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsParity?> To { get; }
    }

    public partial interface IConnectionsConnectionSerialUserSettingsParityValues : IReadableList<IConnectionsConnectionSerialUserSettingsParityValuesValue>
    {
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsParityValuesValue : IValueTag<Enums.EnumPortSettingsParity?>
    {
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsDatabits : IReadable
    {
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
IConnectionsConnectionSerialUserSettingsDatabitsRange Range { get; }

        IConnectionsConnectionSerialUserSettingsDatabitsValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsDatabitsRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
IValueTag<uint?> From { get; }

        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
IValueTag<uint?> To { get; }
    }

    public partial interface IConnectionsConnectionSerialUserSettingsDatabitsValues : IReadableList<IConnectionsConnectionSerialUserSettingsDatabitsValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsDatabitsValuesValue : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Specifies the stop bits settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsStopbits : IReadable
    {
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        IConnectionsConnectionSerialUserSettingsStopbitsValues Values { get; }
    }

    public partial interface IConnectionsConnectionSerialUserSettingsStopbitsValues : IReadableList<IConnectionsConnectionSerialUserSettingsStopbitsValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsStopbitsValuesValue : IValueTag<Enums.EnumPortSettingsStopBits?>
    {
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsFlowcontrol : IReadable
    {
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
IValueTag<Enums.EnumPortSettingsFlowControl?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
IConnectionsConnectionSerialUserSettingsFlowcontrolRange Range { get; }

        IConnectionsConnectionSerialUserSettingsFlowcontrolValues Values { get; }
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsFlowcontrolRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsFlowControl?> From { get; }

        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsFlowControl?> To { get; }
    }

    public partial interface IConnectionsConnectionSerialUserSettingsFlowcontrolValues : IReadableList<IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue : IValueTag<Enums.EnumPortSettingsFlowControl?>
    {
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsTimeoutTime : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<uint?> DefaultValue { get; }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsRetries : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<uint?> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsPortTypeIP : IReadable
    {
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsPortTypeSerial : IReadable
    {
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsPortTypeUDP : IReadable
    {
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsType : IReadable
    {
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
IValueTag<Enums.EnumPortTypes?> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies the SSL/TLS settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsSslTlsEnabled : IReadable
    {
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
IValueTag<bool?> DefaultValue { get; }

        ///<summary>
        /// Specifies the default setting.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the local port settings.
    ///</summary>
public partial interface IConnectionsConnectionSerialUserSettingsLocalIPport : IReadable
    {
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies the default setting.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Defines a smart-serial connection.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerial : IReadable
    {
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
IConnectionsConnectionSmartSerialCommunicationOptions CommunicationOptions { get; }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettings UserSettings { get; }

        ///<summary>
        /// Specifies whether this is a dedicated connection.
        ///</summary>
IValueTag<bool?> Single { get; }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialCommunicationOptions : IReadable
    {
        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
IValueTag<bool?> MakeCommandByProtocol { get; }

        IValueTag<uint?> MaxConcurrentConnections { get; }

        IValueTag<uint?> MaxReceiveBuffer { get; }

        IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs NotifyConnectionPIDs { get; }

        IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo PacketInfo { get; }

        IValueTag<bool?> RedundantPolling { get; }

        IValueTag<bool?> SmartIPHeader { get; }
    }

    public partial interface IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs : IReadable
    {
        IValueTag<uint?> Connections { get; }

        IValueTag<uint?> Disconnections { get; }
    }

    public partial interface IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo : IReadable
    {
        IValueTag<uint?> LengthIdentifierOffset { get; }

        IValueTag<uint?> LengthIdentifierLength { get; }

        IValueTag<bool?> IncludeLengthIdentifier { get; }

        IValueTag<bool?> LittleEndian { get; }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettings : IReadable
    {
        ///<summary>
        /// Configures the bus address.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsBusAddress BusAddress { get; }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsIPport IPport { get; }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsRetries Retries { get; }

        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsPortTypeIP PortTypeIP { get; }

        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP PortTypeUDP { get; }

        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsType Type { get; }

        ///<summary>
        /// Specifies the SSL/TLS settings.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled SslTlsEnabled { get; }

        ///<summary>
        /// Specifies the local port settings.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses AllowedIPAddresses { get; }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsBusAddress : IReadable
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IConnectionsConnectionSmartSerialUserSettingsBusAddressRange Range { get; }

        IConnectionsConnectionSmartSerialUserSettingsBusAddressValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsBusAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    public partial interface IConnectionsConnectionSmartSerialUserSettingsBusAddressValues : IReadableList<IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsIPport : IReadable
    {
        ///<summary>
        /// Specifies the default value.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsTimeoutTime : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<uint?> DefaultValue { get; }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsRetries : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<uint?> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsPortTypeIP : IReadable
    {
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP : IReadable
    {
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsType : IReadable
    {
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
IValueTag<Enums.EnumPortTypes?> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies the SSL/TLS settings.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled : IReadable
    {
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
IValueTag<bool?> DefaultValue { get; }

        ///<summary>
        /// Specifies the default setting.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the local port settings.
    ///</summary>
public partial interface IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses : IReadable
    {
        ///<summary>
        /// Specifies whether allowed IP addresses can be provided.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Defines a GPIB connection.
    ///</summary>
public partial interface IConnectionsConnectionGpib : IReadable
    {
        IConnectionsConnectionGpibCommunicationOptions CommunicationOptions { get; }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
IConnectionsConnectionGpibUserSettings UserSettings { get; }
    }

    public partial interface IConnectionsConnectionGpibCommunicationOptions : IReadable
    {
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial interface IConnectionsConnectionGpibUserSettings : IReadable
    {
        ///<summary>
        /// Configures the bus address.
        ///</summary>
IConnectionsConnectionGpibUserSettingsDeviceAddress DeviceAddress { get; }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
IConnectionsConnectionGpibUserSettingsTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
IConnectionsConnectionGpibUserSettingsRetries Retries { get; }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial interface IConnectionsConnectionGpibUserSettingsDeviceAddress : IReadable
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IConnectionsConnectionGpibUserSettingsDeviceAddressRange Range { get; }

        IConnectionsConnectionGpibUserSettingsDeviceAddressValues Values { get; }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IConnectionsConnectionGpibUserSettingsDeviceAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    public partial interface IConnectionsConnectionGpibUserSettingsDeviceAddressValues : IReadableList<IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial interface IConnectionsConnectionGpibUserSettingsTimeoutTime : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<string> DefaultValue { get; }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial interface IConnectionsConnectionGpibUserSettingsRetries : IReadable
    {
        IValueTag<bool?> Disabled { get; }

        IValueTag<string> DefaultValue { get; }
    }

    ///<summary>
    /// Defines a OPC connection.
    ///</summary>
public partial interface IConnectionsConnectionOpc : IReadable
    {
        IConnectionsConnectionOpcCommunicationOptions CommunicationOptions { get; }

        IConnectionsConnectionOpcUserSettings UserSettings { get; }
    }

    public partial interface IConnectionsConnectionOpcCommunicationOptions : IReadable
    {
        IValueTag<string> ProgID { get; }
    }

    public partial interface IConnectionsConnectionOpcUserSettings : IReadable
    {
    }

    ///<summary>
    /// Defines the layout and the order of the Data Display pages.
    ///</summary>
public partial interface IDisplay : IReadable
    {
        ///<summary>
        /// Allows to define pages and specify their configuration (e.g. configure the visibility).
        ///</summary>
IDisplayPages Pages { get; }

        ///<summary>
        /// Defines the page that will be shown by default. Only one page name is allowed.
        /// If you do not specify a default page, the first page will be shown.
        ///</summary>
IValueTag<string> DefaultPage { get; }

        ///<summary>
        /// Used for CPE elements in order to disable the possibility to open the Data Display page of the element.
        ///</summary>
IValueTag<string> PageOptions { get; }

        ///<summary>
        /// Defines the order of the pages in DataMiner Cube or in the Element Display drop-down box.
        /// By default, the pages will be ordered alphabetically.
        /// In addition to the pages, you can add a reference to a web interface by specifying
        /// -	Webinterface#http://[Polling Ip], or
        /// -	WebInterface#http://[id:parameterID]
        ///</summary>
IValueTag<string> PageOrder { get; }

        ///<summary>
        /// See the tooltips of the different options.
        ///</summary>
IValueTag<Enums.EnumDisplayType?> Type { get; }

        ///<summary>
        /// Defines the pages that have only one column. Page names are separated by a semi-colon (";").
        /// By default, a page will have multiple columns. Use this attribute for pages that will contain e.g. a wide table.
        ///</summary>
IValueTag<string> WideColumnPages { get; }
    }

    ///<summary>
    /// Allows to define pages and specify their configuration (e.g. configure the visibility).
    ///</summary>
public partial interface IDisplayPages : IReadableList<IDisplayPagesPage>
    {
    }

    ///<summary>
    /// Defines a page.
    ///</summary>
public partial interface IDisplayPagesPage : IReadable
    {
        ///<summary>
        /// Specifies the name of the page.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies the page visibility configuration.
        ///</summary>
IDisplayPagesPageVisibility Visibility { get; }
    }

    ///<summary>
    /// Specifies the page visibility configuration.
    ///</summary>
public partial interface IDisplayPagesPageVisibility : IReadable
    {
        ///<summary>
        /// Specifies the default visibility of the page.
        ///</summary>
IValueTag<bool?> Default { get; }

        ///<summary>
        /// Specifies the ID of the parameter to use to compare its value with the value specified in the "value" attribute.
        ///</summary>
IValueTag<uint?> OverridePID { get; }

        ///<summary>
        /// Specifies the value the parameter referred to by the overridePID attribute should have in order to swap the visibility.
        ///</summary>
IValueTag<string> ValueAttribute { get; }
    }

    ///<summary>
    /// This tag allows you to describe the behavior of Dynamic Virtual Elements.
    ///</summary>
public partial interface IDVEs : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IDVEsDVEProtocols DVEProtocols { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IExportRules ExportRules { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IDVEsDVEProtocols : IReadableList<IDVEsDVEProtocolsDVEProtocol>
    {
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IDVEsDVEProtocolsDVEProtocol : IReadable
    {
        ///<summary>
        /// Set to false to leave out the parent element name in the virtual element name.
        ///</summary>
IValueTag<bool?> ElementPrefix { get; }

        ///<summary>
        /// The name of the exported protocol.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Parameter ID of the table to be exported.
        ///</summary>
IValueTag<uint?> TablePID { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IElementOptions : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IElementOptionsUserSettings UserSettings { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IElementOptionsUserSettings : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IPingInterval PingInterval { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
ISlowPoll SlowPoll { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
ISlowPollBase SlowPollBase { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
ISlowPoll TimeoutTimeElement { get; }
    }

    ///<summary>
    /// Contains options that can be enabled or configured that change how the system will manage or interact with the element.
    ///</summary>
public partial interface ISystemOptions : IReadable
    {
        ///<summary>
        /// Set to true if any element running this protocol should be hosted in a separate SLProtocol and SLScripting process. Feature introduced in DataMiner 10.2.7 (RN 33358).
        ///</summary>
IValueTag<bool?> RunInSeparateInstance { get; }
    }

    ///<summary>
    /// Specifies which general parameter groups should be loaded or not. Feature introduced in DataMiner 9.0.1 (RN 12263).
    ///</summary>
public partial interface IGeneralParameters : IReadableList<IGeneralParametersGeneralParameter>
    {
    }

    ///<summary>
    /// Configures a general parameter group.
    ///</summary>
public partial interface IGeneralParametersGeneralParameter : IReadable
    {
        ///<summary>
        /// Specifies the general parameter group.
        ///</summary>
IValueTag<Enums.EnumGeneralParameterGroupType?> Group { get; }

        ///<summary>
        /// When set to false, the specified general parameter group will not be loaded.
        ///</summary>
IValueTag<bool?> Enabled { get; }
    }

    ///<summary>
    /// Contains the groups defined in the protocol.
    ///</summary>
public partial interface IGroups : IReadableList<IGroupsGroup>
    {
    }

    ///<summary>
    /// Groups are used to do the actual device polling.
    /// In a group, you can assemble different parameters, command/response pairs or actions. When a group is executed, all parameters, pairs or actions included in the group will be executed one after the other.
    /// Make sure that the "id" attribute contains a unique group ID.
    ///</summary>
public partial interface IGroupsGroup : IReadable
    {
        ///<summary>
        /// Specifies a condition that must be met in order for the group to execute.
        ///</summary>
IValueTag<string> Condition { get; }

        ///<summary>
        /// Contains all actions, pairs, parameters, sessions, or triggers that have to be executed consecutively when the group is executed.
        /// In a /Protocol/Groups/Group/Content element, you are only allowed to specify items of the same type:
        /// - action items only,
        /// - pair items only,
        /// - parameter items only,
        /// - session items only,
        /// 
        /// - trigger items only.
        /// Recommendation: The content of a group should not exceed 10 items.
        ///</summary>
IGroupsGroupContent Content { get; }

        ///<summary>
        /// Specifies the group description.
        ///</summary>
IValueTag<string> Description { get; }

        ///<summary>
        /// Specifies the name of the group. This name could, for example, refer to the information that will be requested from the device.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// By default, a group includes parameters or pairs. However, if you want to include actions or triggers in a group, specify this here.
        /// If you specify "action" or "trigger", the group will be executed at once.
        /// If, however, you specify "poll", "poll action" or "poll trigger", the group will be added to the group execution queue, awaiting execution.
        ///</summary>
IValueTag<Enums.EnumGroupType?> Type { get; }

        ///<summary>
        /// In case of multiple ports, use this attribute to specify the connection to be used.
        /// Default connection: 0
        ///</summary>
IValueTag<uint?> Connection { get; }

        ///<summary>
        /// Via this attribute it is possible to dynamically select an HTTP connection by referring to the connection by means of a parameter ID.
        /// This way, it is possible to switch connection at run-time.
        ///</summary>
IValueTag<uint?> ConnectionPID { get; }

        ///<summary>
        /// The unique group ID.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies whether this is the group to be used when testing the connection in the element wizard.
        ///</summary>
IValueTag<bool?> Ping { get; }
    }

    ///<summary>
    /// Contains all actions, pairs, parameters, sessions, or triggers that have to be executed consecutively when the group is executed.
    /// In a /Protocol/Groups/Group/Content element, you are only allowed to specify items of the same type:
    /// - action items only,
    /// - pair items only,
    /// - parameter items only,
    /// - session items only,
    /// 
    /// - trigger items only.
    /// Recommendation: The content of a group should not exceed 10 items.
    ///</summary>
public partial interface IGroupsGroupContent : IReadableList<IGroupsGroupContentItem>
    {
        ///<summary>
        /// If "true", all parameters will be read in one SNMP Get operation.
        /// This "multipleGet" option cannot be used with parameters of Type "Array".
        ///</summary>
IValueTag<bool?> MultipleGet { get; }
    }

    public partial interface IGroupsGroupContentItem : IReadable
    {
    }

    ///<summary>
    /// Specifies the ID of an action to include in the group.
    /// If you include actions in a group, do not forget to set the attribute /Protocol/Groups/Group@type to "action".
    ///</summary>
public partial interface IGroupsGroupContentAction : IValueTag<string>, IGroupsGroupContentItem
    {
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed action before executing the next action.
        ///</summary>
IValueTag<uint?> Next { get; }
    }

    ///<summary>
    /// Specifies the ID of a command/response pair to be included in a group.
    /// When a setting has to be changed, it is common practice to include in a group
    /// - a "SET" pair, directly followed by
    /// - a "GET" pair.
    /// That way, the DataMiner interface will immediately show the changed values.
    ///</summary>
public partial interface IGroupsGroupContentPair : IValueTag<uint?>, IGroupsGroupContentItem
    {
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed pair before executing the next pair.
        ///</summary>
IValueTag<uint?> Next { get; }
    }

    ///<summary>
    /// Specifies the ID of a parameter to be included in the group.
    ///</summary>
public partial interface IGroupsGroupContentParam : IValueTag<string>, IGroupsGroupContentItem
    {
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait before reading the next parameter.
        ///</summary>
IValueTag<uint?> Next { get; }
    }

    ///<summary>
    /// Specifies the ID of an HTTP session to be included in the group.
    ///</summary>
public partial interface IGroupsGroupContentSession : IValueTag<uint?>, IGroupsGroupContentItem
    {
        ///<summary>
        /// If you want to execute only a specific connection within a certain session, then use the connection attribute to specify the connection.
        /// Feature introduced in DataMiner 8.5.7 (RN 9928).
        ///</summary>
IValueTag<uint?> Connection { get; }

        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed session before executing the next session.
        /// If the last item in the group contains this attribute, it will also cause a delay before the next group is executed.
        ///</summary>
IValueTag<uint?> Next { get; }
    }

    ///<summary>
    /// Specifies the ID of a trigger to be included in a group.
    /// If you include triggers in a group, do not forget to set the value of the "type" attribute of this group to “trigger”.
    ///</summary>
public partial interface IGroupsGroupContentTrigger : IValueTag<string>, IGroupsGroupContentItem
    {
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait before executing the next trigger.
        ///</summary>
IValueTag<uint?> Next { get; }
    }

    ///<summary>
    /// The root of the HTTP-specific features in a protocol.
    ///</summary>
public partial interface IHTTP : IReadableList<IHTTPSession>
    {
    }

    ///<summary>
    /// Represents a particular HTTP session.
    ///</summary>
public partial interface IHTTPSession : IReadableList<IHTTPSessionConnection>
    {
        ///<summary>
        /// The unique session ID.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// If the HTTP connection should ignore timeout for this session, set this attribute to true.
        /// This works in a similar way as the serial pair ignoreTimeout option.
        /// Default value: false.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        /// 
        ///</summary>
IValueTag<bool?> IgnoreTimeout { get; }

        ///<summary>
        /// Specifies whether the session should be kept alive.
        /// Feature introduced in DataMiner 8.5.7 (RN 9929).
        ///</summary>
IValueTag<bool?> KeepAlive { get; }

        ///<summary>
        /// Specifies the authentication method to use.
        ///</summary>
IValueTag<Enums.EnumHttpLoginMethod?> LoginMethod { get; }

        ///<summary>
        /// Specifies the name of the session.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// If you set loginMethod to "credentials", then use this attribute to specify the password.
        ///</summary>
IValueTag<string> Password { get; }

        ///<summary>
        /// If, in the proxyServer attribute, you specified a proxy server that requires authentication, then use this attribute to specify the password.
        ///</summary>
IValueTag<string> ProxyPassword { get; }

        ///<summary>
        /// Use this attribute to specify the proxy server through which the connection has to be set up.
        /// Note: If you do not specify a proxy server, then an attempt will be made to fetch the default proxy configuration using the Web Proxy Auto-Discovery Protocol (WPAD).
        ///</summary>
IValueTag<string> ProxyServer { get; }

        ///<summary>
        /// If, in the proxyServer attribute, you specified a proxy server that requires authentication, then use this attribute to specify the user name.
        ///</summary>
IValueTag<string> ProxyUser { get; }

        ///<summary>
        /// Specifies that DataMiner must use this timeout value (ms) instead of the default one when executing this session.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        ///</summary>
IValueTag<uint?> Timeout { get; }

        ///<summary>
        /// If you set loginMethod to "credentials", then use this attribute to specify the user name.
        ///</summary>
IValueTag<string> UserName { get; }
    }

    ///<summary>
    /// Specifies a connection. This typically contains a request and a response.
    ///</summary>
public partial interface IHTTPSessionConnection : IReadable
    {
        ///<summary>
        /// Defines the HTTP request to be sent.
        ///</summary>
IHTTPSessionConnectionRequest Request { get; }

        ///<summary>
        /// Defines the response to the HTTP request you defined in ../Connection/Request.
        ///</summary>
IHTTPSessionConnectionResponse Response { get; }

        ///<summary>
        /// The unique connection ID.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// If the HTTP connection should ignore timeout, set this attribute to true.
        /// This works in a similar way as the serial pair ignoreTimeout option.
        /// Default value: false.
        /// Feature introduced in DataMiner 9.0.2 (RN 10543).
        /// 
        ///</summary>
IValueTag<bool?> IgnoreTimeout { get; }

        ///<summary>
        /// Specifies the name of the connection.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies that DataMiner must use this timeout value (ms) )instead of the default one (or the one specified in the Session tag) when executing this connection of this session.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        ///</summary>
IValueTag<uint?> Timeout { get; }
    }

    ///<summary>
    /// Defines the HTTP request to be sent.
    ///</summary>
public partial interface IHTTPSessionConnectionRequest : IReadable
    {
        IHttpRequestHeaders Headers { get; }

        IHttpRequestData Data { get; }

        IHttpRequestParameters Parameters { get; }

        ///<summary>
        /// Replaces the url attribute. The parameter value will be used as URL.
        ///</summary>
IValueTag<uint?> Pid { get; }

        ///<summary>
        /// Specifies the verb to be used in the HTTP request.
        /// If you do not specify this attribute, "GET" will be used by default.
        ///</summary>
IValueTag<Enums.EnumHttpRequestVerb?> Verb { get; }

        ///<summary>
        /// Specifies the URL of the request.
        /// If you do not specify this attribute, the root directory of the server specified in the element wizard will be used.
        ///</summary>
IValueTag<string> Url { get; }
    }

    ///<summary>
    /// Defines the response to the HTTP request you defined in ../Connection/Request.
    ///</summary>
public partial interface IHTTPSessionConnectionResponse : IReadable
    {
        ///<summary>
        /// Specifies the response headers of which you want to store the contents in a parameter.
        ///</summary>
IHTTPSessionConnectionResponseHeaders Headers { get; }

        ///<summary>
        /// The pid attribute of this element specifies the ID of the parameter in which you want the contents of the response to be stored.
        ///</summary>
IHTTPSessionConnectionResponseContent Content { get; }

        ///<summary>
        /// Specifies the ID of the parameter in which the HTTP status-line has to be stored ("e.g. HTTP/1.1 200 OK".
        ///</summary>
IValueTag<uint?> StatusCode { get; }
    }

    ///<summary>
    /// Specifies the response headers of which you want to store the contents in a parameter.
    ///</summary>
public partial interface IHTTPSessionConnectionResponseHeaders : IReadableList<IHTTPSessionConnectionResponseHeadersHeader>
    {
    }

    ///<summary>
    /// Specifies that the contents of a particular response header has to be stored in a parameter.&lt;BR /&gt;
    /// In this context, this has to be done by means of a key/value pair.
    ///</summary>
public partial interface IHTTPSessionConnectionResponseHeadersHeader : IReadable
    {
        ///<summary>
        /// Specifies the name of the header of which you want the contents to be stored in the parameter having the ID defined in the pid attribute.
        ///</summary>
IValueTag<string> Key { get; }

        ///<summary>
        /// Specifies the ID of the parameter in which you want to store the contents of the header defined in the key attribute.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// The pid attribute of this element specifies the ID of the parameter in which you want the contents of the response to be stored.
    ///</summary>
public partial interface IHTTPSessionConnectionResponseContent : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter in which you want the contents of the response to be stored.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Configures internal licensing.
    ///</summary>
public partial interface IInternalLicenses : IReadableList<IInternalLicensesInternalLicense>
    {
    }

    ///<summary>
    /// Configures internal licensing of the specified type.
    ///</summary>
public partial interface IInternalLicensesInternalLicense : IReadable
    {
        IValueTag<string> Type { get; }
    }

    ///<summary>
    /// Groups NoTimeout elements.
    ///</summary>
public partial interface INoTimeouts : IReadableList<INoTimeoutsNoTimeout>
    {
    }

    ///<summary>
    /// Indicates that the specified error (response value) should not cause a timeout.
    ///</summary>
public partial interface INoTimeoutsNoTimeout : IValueTag<string>
    {
    }

    ///<summary>
    /// Defines options for the protocol.
    ///</summary>
public partial interface IOptions : IReadable
    {
        IOptionsDataBaseOptions DataBaseOptions { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<bool?> DisableViewRefresh { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<Enums.EnumEncoding?> Encoding { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<bool?> ForceDefaultAlarming { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IOptionsGenerateMIB GenerateMIB { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IIcon Icon { get; }

        ///<summary>
        /// Groups NoTimeout elements of the protocol. Feature introduced in DataMiner 8.5.3 (RN 8775).
        ///</summary>
IOptionsNoTimeouts NoTimeouts { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> OverrideTimeoutDVE { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<bool?> PostPonePortInitialisation { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<bool?> UseAgentBinding { get; }
    }

    public partial interface IOptionsDataBaseOptions : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<bool?> CustomDataIDs { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<bool?> PartitionedTrending { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IOptionsGenerateMIB : IValueTag<Enums.EnumSNMP?>
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<bool?> IncludePages { get; }
    }

    ///<summary>
    /// Groups NoTimeout elements of the protocol. Feature introduced in DataMiner 8.5.3 (RN 8775).
    ///</summary>
public partial interface IOptionsNoTimeouts : IReadableList<IOptionsNoTimeoutsNoTimeout>
    {
    }

    ///<summary>
    /// Suppresses a timeout in case the specified error (response value) occurs.
    ///</summary>
public partial interface IOptionsNoTimeoutsNoTimeout : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies the level of access users will have to elements, views, services and redundancy groups created by elements based on this protocol.
    /// Feature introduced in DataMiner 9.0.3 (RN 13010).
    ///</summary>
public partial interface IOwnership : IReadable
    {
        ///<summary>
        /// Groups ownership declarations of DataMiner elements.
        ///</summary>
IOwnershipElements Elements { get; }

        ///<summary>
        /// Groups ownership declarations of view properties.
        ///</summary>
IOwnershipViews Views { get; }

        ///<summary>
        /// Groups service ownership declarations.
        ///</summary>
IOwnershipServices Services { get; }

        ///<summary>
        /// Groups redundancy group ownership declarations.
        ///</summary>
IOwnershipRedundancyGroups RedundancyGroups { get; }
    }

    ///<summary>
    /// Groups ownership declarations of DataMiner elements.
    ///</summary>
public partial interface IOwnershipElements : IReadableList<IOwnershipElementsElement>
    {
    }

    ///<summary>
    /// Declares ownership of specific DataMiner elements.
    ///</summary>
public partial interface IOwnershipElementsElement : IReadable
    {
        ///<summary>
        /// Declares ownership of DataMiner elements running the specified protocol. Supported wildcard characters: '*' and '?'.
        ///</summary>
IValueTag<string> Protocol { get; }

        ///<summary>
        /// Declares ownership of the element description.
        ///</summary>
IOwnershipElementsElementDescription Description { get; }

        ///<summary>
        /// Groups ownership declarations of element properties.
        ///</summary>
IOwnershipElementsElementProperties Properties { get; }

        ///<summary>
        /// Declares ownership of the alarm template.
        ///</summary>
IOwnershipElementsElementAlarmTemplate AlarmTemplate { get; }

        ///<summary>
        /// Declares ownership of the trend template.
        ///</summary>
IOwnershipElementsElementTrendTemplate TrendTemplate { get; }
    }

    ///<summary>
    /// Declares ownership of the element description.
    ///</summary>
public partial interface IOwnershipElementsElementDescription : IReadable
    {
        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Groups ownership declarations of element properties.
    ///</summary>
public partial interface IOwnershipElementsElementProperties : IReadableList<IOwnershipElementsElementPropertiesProperty>
    {
    }

    ///<summary>
    /// Declares ownership of the specified element property.
    ///</summary>
public partial interface IOwnershipElementsElementPropertiesProperty : IReadable
    {
        ///<summary>
        /// Specifies the name of the element property. Supported wildcard characters: '*' and '?'.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Declares ownership of the alarm template.
    ///</summary>
public partial interface IOwnershipElementsElementAlarmTemplate : IReadable
    {
        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Declares ownership of the trend template.
    ///</summary>
public partial interface IOwnershipElementsElementTrendTemplate : IReadable
    {
        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Groups ownership declarations of view properties.
    ///</summary>
public partial interface IOwnershipViews : IReadable
    {
        ///<summary>
        /// Declares ownership of view properties.
        ///</summary>
IOwnershipViewsView View { get; }
    }

    ///<summary>
    /// Declares ownership of view properties.
    ///</summary>
public partial interface IOwnershipViewsView : IReadable
    {
        ///<summary>
        /// Groups ownership declarations of view properties.
        ///</summary>
IOwnershipViewsViewProperties Properties { get; }
    }

    ///<summary>
    /// Groups ownership declarations of view properties.
    ///</summary>
public partial interface IOwnershipViewsViewProperties : IReadableList<IOwnershipViewsViewPropertiesProperty>
    {
    }

    ///<summary>
    /// Declares ownership of the specified view property.
    ///</summary>
public partial interface IOwnershipViewsViewPropertiesProperty : IReadable
    {
        ///<summary>
        /// Specifies the name of the view property. Supported wildcard characters: '*' and '?'.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Groups service ownership declarations.
    ///</summary>
public partial interface IOwnershipServices : IReadable
    {
        ///<summary>
        /// Declares ownership of a service.
        ///</summary>
IOwnershipServicesService Service { get; }
    }

    ///<summary>
    /// Declares ownership of a service.
    ///</summary>
public partial interface IOwnershipServicesService : IReadable
    {
        ///<summary>
        /// Declares ownership of the service description.
        ///</summary>
IOwnershipServicesServiceDescription Description { get; }

        ///<summary>
        /// Groups ownership declarations of service properties.
        ///</summary>
IOwnershipServicesServiceProperties Properties { get; }
    }

    ///<summary>
    /// Declares ownership of the service description.
    ///</summary>
public partial interface IOwnershipServicesServiceDescription : IReadable
    {
        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Groups ownership declarations of service properties.
    ///</summary>
public partial interface IOwnershipServicesServiceProperties : IReadableList<IOwnershipServicesServicePropertiesProperty>
    {
    }

    ///<summary>
    /// Declares ownership of the specified service property.
    ///</summary>
public partial interface IOwnershipServicesServicePropertiesProperty : IReadable
    {
        ///<summary>
        /// Specifies the name of the service property. Supported wildcard characters: '*' and '?'.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Groups redundancy group ownership declarations.
    ///</summary>
public partial interface IOwnershipRedundancyGroups : IReadable
    {
        ///<summary>
        /// Declares ownership of a redundancy group.
        ///</summary>
IOwnershipRedundancyGroupsRedundancyGroup RedundancyGroup { get; }
    }

    ///<summary>
    /// Declares ownership of a redundancy group.
    ///</summary>
public partial interface IOwnershipRedundancyGroupsRedundancyGroup : IReadable
    {
        ///<summary>
        /// Declares ownership of the redundancy group description.
        ///</summary>
IOwnershipRedundancyGroupsRedundancyGroupDescription Description { get; }

        ///<summary>
        /// Declares ownership of the redundancy group maintenance.
        ///</summary>
IOwnershipRedundancyGroupsRedundancyGroupMaintenance Maintenance { get; }

        ///<summary>
        /// Declares ownership of the redundancy group switching.
        ///</summary>
IOwnershipRedundancyGroupsRedundancyGroupSwitching Switching { get; }
    }

    ///<summary>
    /// Declares ownership of the redundancy group description.
    ///</summary>
public partial interface IOwnershipRedundancyGroupsRedundancyGroupDescription : IReadable
    {
        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Declares ownership of the redundancy group maintenance.
    ///</summary>
public partial interface IOwnershipRedundancyGroupsRedundancyGroupMaintenance : IReadable
    {
        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Declares ownership of the redundancy group switching.
    ///</summary>
public partial interface IOwnershipRedundancyGroupsRedundancyGroupSwitching : IReadable
    {
        ///<summary>
        /// Specifies the access type.
        ///</summary>
IValueTag<Enums.EnumOwnershipAccessType?> AccessType { get; }
    }

    ///<summary>
    /// Contains all the pairs defined in the protocol.
    ///</summary>
public partial interface IPairs : IReadableList<IPairsPair>
    {
    }

    ///<summary>
    /// Defines a pair consisting of a command and optionally a response.
    ///</summary>
public partial interface IPairsPair : IReadable
    {
        ///<summary>
        /// Specifies a condition that must be met in order for the pair to execute.
        ///</summary>
IValueTag<string> Condition { get; }

        ///<summary>
        /// Specifies the command to be sent and the expected response(s) (if any) after the command has been sent.
        /// You can specify only one command. The number of responses, however, can vary from none to several, depending on the device.
        /// - If no response is expected, then specify the command, but no response.
        /// - If only one single response is expected, then specify the command and the expected response.
        /// - If multiple responses are expected, then specify the command and all expected responses.
        /// 
        /// When DataMiner receives a response from the device after having sent a command, it will try to match the response to one of the responses
        /// defined in this tag. If several responses have been defined, it will check them top down.
        /// If a match is found, DataMiner will move on to the next command/response pair.
        /// If no match is found, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has
        /// occurred. The log files of the device will contain more detailed information. If the new response still does not match one of the defined
        /// responses, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
        /// will skip the command, and move to the next command/response pair.
        /// By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device
        /// in System Display.
        ///</summary>
IPairsPairContent Content { get; }

        ///<summary>
        /// Contains a textual description of the pair.
        ///</summary>
IValueTag<string> Description { get; }

        ///<summary>
        /// Specifies the name of the pair. This name is displayed in the stream viewer when the pair is executed.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies the unique ID of the pair.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";").
        /// For an overview of all options that can be specified in this tag, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// If set to "true", the pair will be executed when the device is in timeout and slow polling is activated.
        /// Note: This option cannot be used in protocols of type SNMP or OPC.
        ///</summary>
IValueTag<bool?> Ping { get; }

        ///<summary>
        /// Specifies the timeout value to use for this pair instead of the default value when executing the pair.
        /// Using this option, you can extend the period of time DataMiner will wait for a response after having sent a command.
        ///</summary>
IValueTag<uint?> Timeout { get; }
    }

    ///<summary>
    /// Specifies the command to be sent and the expected response(s) (if any) after the command has been sent.
    /// You can specify only one command. The number of responses, however, can vary from none to several, depending on the device.
    /// - If no response is expected, then specify the command, but no response.
    /// - If only one single response is expected, then specify the command and the expected response.
    /// - If multiple responses are expected, then specify the command and all expected responses.
    /// 
    /// When DataMiner receives a response from the device after having sent a command, it will try to match the response to one of the responses
    /// defined in this tag. If several responses have been defined, it will check them top down.
    /// If a match is found, DataMiner will move on to the next command/response pair.
    /// If no match is found, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has
    /// occurred. The log files of the device will contain more detailed information. If the new response still does not match one of the defined
    /// responses, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
    /// will skip the command, and move to the next command/response pair.
    /// By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device
    /// in System Display.
    ///</summary>
public partial interface IPairsPairContent : IReadableList<IPairsPairContentItem>
    {
        ///<summary>
        /// Specifies the ID of the command that will be sent when the pair is executed.
        ///</summary>
IPairsPairContentCommand Command { get; }
    }

    public partial interface IPairsPairContentItem : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Specifies the ID of the command that will be sent when the pair is executed.
    ///</summary>
public partial interface IPairsPairContentCommand : IValueTag<uint?>, IPairsPairContentItem
    {
    }

    ///<summary>
    /// Specifies the ID of an expected response.
    ///</summary>
public partial interface IPairsPairContentResponse : IValueTag<uint?>, IPairsPairContentItem
    {
    }

    ///<summary>
    /// Defines an error message coming from the device.
    /// If the device is able to return an error message, and if the structure of that error message is known, then you can create a response that
    /// matches that error message, and included that response in the command/response pair as a "ResponseOnBadCommand".
    /// When the device sends a response that matches the ResponseOnBadCommand, then this will be indicated in the communication indicator of the DataMiner user interface.
    /// The command, however, will not be executed again as the received response matched one of the defined responses.
    /// Also, the information received from the device in the error message can be used to inform users about the error that occurred.
    ///</summary>
public partial interface IPairsPairContentResponseOnBadCommand : IValueTag<uint?>, IPairsPairContentItem
    {
    }

    ///<summary>
    /// Defines the DataMiner Connectivity Framework (DCF) interfaces.
    /// Feature introduced in DataMiner 8.0.0 (RN 5663).
    ///</summary>
public partial interface IParameterGroups : IReadableList<IParameterGroupsGroup>
    {
    }

    ///<summary>
    /// Defines a parameter group.
    ///</summary>
public partial interface IParameterGroupsGroup : IReadable
    {
        ///<summary>
        /// Specifies the parameters that are included in the group.
        ///</summary>
IParameterGroupsGroupParams Params { get; }

        ///<summary>
        /// Specifies whether to disable the interface state calculation.
        ///</summary>
IValueTag<bool?> CalculateAlarmState { get; }

        ///<summary>
        /// Specifies the ID of the table parameter.
        ///</summary>
IValueTag<uint?> DynamicId { get; }

        ///<summary>
        /// Specifies the display key, which can be used as a filter.
        ///</summary>
IValueTag<string> DynamicIndex { get; }

        ///<summary>
        /// Specifies whether the display key or the primary key should be used in the interface name (Default: false).
        ///</summary>
IValueTag<bool?> DynamicUsePK { get; }

        ///<summary>
        /// Specifies the unique ID of the parameter group.
        /// A parameter group cannot have an ID equal to 10000 or higher. The IDs starting from 10000 are reserved for DCF dynamic interfaces. Feature introduced in DataMiner 8.5.3 (RN 8863). Since DataMiner 9.0.4 (RN 13161), DataMiner creates new dynamic interfaces in the range 100 000 - 199 999 (instead of starting from 10 000).
        /// 
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies whether this an internal interface (Default: false).
        ///</summary>
IValueTag<bool?> IsInternal { get; }

        ///<summary>
        /// Specifies the name of the parameter group.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies the type of the interface.
        ///</summary>
IValueTag<Enums.EnumParamGroupType?> Type { get; }
    }

    ///<summary>
    /// Specifies the parameters that are included in the group.
    ///</summary>
public partial interface IParameterGroupsGroupParams : IReadableList<IParameterGroupsGroupParamsParam>
    {
    }

    ///<summary>
    /// Specifies a parameter that is included in the group.
    ///</summary>
public partial interface IParameterGroupsGroupParamsParam : IReadable
    {
        ///<summary>
        /// Specifies the ID of the included parameter.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies the parameter ID of the index column (primary key).
        ///</summary>
IValueTag<string> Index { get; }
    }

    ///<summary>
    /// Contains all the parameters defined in the protocol.
    ///</summary>
public partial interface IParams : IReadableList<IParamsParam>
    {
        ///<summary>
        /// Changes the order in which saved parameter data is retrieved when the element starts up.
        ///</summary>
IValueTag<string> LoadSequence { get; }
    }

    ///<summary>
    /// Defines a parameter.
    ///</summary>
public partial interface IParamsParam : IReadable
    {
        ///<summary>
        /// Specifies the default parameter alarming configuration. Each alarm consists of two components:
        /// -	Severity: Critical, Major, Minor, Warning or Normal
        /// -	Severity Range: Low, Medium or High
        /// These are combined into the following alarm levels:
        /// -	Critical Low (CL)
        /// -	Major Low (MaL)
        /// -	Minor Low (MiL)
        /// -	Warning Low (WaL)
        /// -	Normal (Normal)
        /// -	Warning High (WaH)
        /// -	Minor High (MiH)
        /// -	Major High (MaH)
        /// -	Critical High (CH)
        /// Each alarm level is included in a /Protocol/Params/Param/Alarm element, so a value can be assigned to it. If the value of the monitored parameter is equal to or exceeds
        /// a value included in the /Protocol/Params/Param/Alarm element, DataMiner will process an alarm depending on the alarm level that corresponds to the
        /// value.
        /// These assigned values are not only accessible via the protocol, but also via DataMiner Cuber or System Display. The alarm values of a parameter can be altered by
        /// means of alarm templates, on condition that a /Protocol/Params/Param/Alarm element has been defined for the parameter in the protocol. The alarm
        /// levels of a parameter can be adapted at any moment, regardless of the values specified in the protocol.
        ///</summary>
IParamsParamAlarm Alarm { get; }

        ///<summary>
        /// Defines all table columns.
        /// Each table column is defined by one or two Parameters:
        /// -	one for read, and/or
        /// -	one for write.
        ///</summary>
IParamsParamArrayOptions ArrayOptions { get; }

        ///<summary>
        /// If /Protocol/Params/Param/Type is set to "CRC", then this CRC element allows you to define the CRC used in the communication with the device.
        /// The information you specify here will be used to calculate the CRC of the command/response.
        ///</summary>
IParamsParamCRC CRC { get; }

        ///<summary>
        /// Allows building a direct view table using multiple columns from multiple different protocols. Feature introduced in DataMiner 10.2.9 (RN 33253).
        ///</summary>
IParamsParamCrossDriverOptions CrossDriverOptions { get; }

        ///<summary>
        /// Specifies the configuration for use in dashboards.
        ///</summary>
IParamsParamDashboard Dashboard { get; }

        ///<summary>
        /// Specifies database-related configuration options.
        /// Feature introduced in DataMiner 9.0.0 (RN 11853).
        ///</summary>
IParamsParamDatabase Database { get; }

        ///<summary>
        /// Allows you to link one or more parameters. This is mostly used for situations in which clicking a button executes a command that includes several parameters.
        /// Execution of such a command will only proceed if all dependent parameters have a valid value.
        ///</summary>
IParamsParamDependencies Dependencies { get; }

        ///<summary>
        /// Specifies the description of the parameter.
        /// Typically, the parameter name refers to the technical name of the parameter, while the parameter description provides a more common name or description.
        /// Preferably, the description should be unique throughout the protocol.
        ///</summary>
IValueTag<string> Description { get; }

        ///<summary>
        /// Defines if and how a parameter will be displayed on the user interface.
        ///</summary>
IParamsParamDisplay Display { get; }

        ///<summary>
        /// Contains the custom commands (i.e. “hyperlinks”) that have to appear on the shortcut menu when users right-click an alarm of this parameter.
        /// These custom commands are often hyperlinks pointing to a web page or an automation script.
        ///</summary>
IParamsParamHyperLinks HyperLinks { get; }

        ///<summary>
        /// Specifies the icon to be shown in a tree control.
        ///</summary>
IIcon Icon { get; }

        ///<summary>
        /// Specifies additional information about the parameter.
        /// DataMiner will show this additional information in tooltips.
        /// Note: Only parameters of type "read" or "read bit" will use /Protocol/Params/Param/Information. In some cases, however, also parameters of type "write" or "write bit" will have one.
        ///</summary>
IParamsParamInformation Information { get; }

        ///<summary>
        /// Specifies how a parameter value is processed.
        ///</summary>
IParamsParamInterprete Interprete { get; }

        ///<summary>
        /// Specifies the length of the command/response.
        ///</summary>
IParamsParamLength Length { get; }

        ///<summary>
        /// If /Protocol/Params/Param/Type is set to "matrix", then this will allow you to define the matrix control. Feature introduced in DataMiner 10.3.1/10.4.0 (RN 34661).
        ///</summary>
IParamsParamMatrix Matrix { get; }

        ///<summary>
        /// Specifies how the parameter has to be displayed on the user interface (depending on the parameter type).
        ///</summary>
IParamsParamMeasurement Measurement { get; }

        ///<summary>
        /// Contains the links between parameters of a base protocol and parameters of this protocol.
        ///</summary>
IParamsParamMediation Mediation { get; }

        ///<summary>
        /// Specifies a message to be displayed when users change the parameter on the user interface.
        /// Usually, this text will appear as a pop-up warning when a potentially dangerous setting has to be changed.
        ///</summary>
IValueTag<string> Message { get; }

        ///<summary>
        /// Specifies the name of the parameter. Typically, the parameter name refers to the technical name of the parameter, while the parameter description provides a more common name or description.
        /// Although it is possible that the name is used in alarm notifications, typically the parameter description will be used. See /Protocol/Params/Param/Description.
        /// Important:
        /// -	The name must be unique throughout the protocol.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Used to replicate specific parameters from another element.
        ///</summary>
IParamsParamReplication Replication { get; }

        ///<summary>
        /// Specifies SNMP related functionality for this parameter.
        /// Only used in protocols for elements that are SNMP-compliant. In case of such an element, DataMiner will interrogate the SNMP agent specified in /Proto­col/Params/Param/SNMP/OID or capture traps defined in /Protocol/Params/Param/SNMP/TrapOID.
        ///</summary>
IParamsParamSNMP SNMP { get; }

        ///<summary>
        /// Specifies the parameter type.
        /// For more information about the different types, refer to the DataMiner Protocol Markup Language documentation.
        /// Parameters of type "elementid", "elementname", "elementdmaid" and "dataminer info" are the first parameters that are loaded by a protocol. Although they hold information, they cannot, as such,
        /// be displayed in Element Display. Therefore, for these types of parameters, always set /Protocol/Params/Param/Display/RTDisplay "false".
        /// If you do want to display the information in one of these parameters in Element Display, there is a workaround: create another parameter of type "read", and copy the value from its invisible parameter to this new parameter after protocol start-up. You can then display the "read" parameter in Element Display.
        ///</summary>
IParamsParamType Type { get; }

        ///<summary>
        /// Overrides the "Never ask for confirmation after setting parameter value" setting in DataMiner Cube.
        /// Feature introduced in DataMiner 9.0.0 (RN 11133).
        ///</summary>
IValueTag<Enums.EnumParamConfirmPopup?> ConfirmPopup { get; }

        ///<summary>
        /// Specifies that the value of the parameter on which this attribute is specified should be shown in the specified view table column(s).
        ///</summary>
IValueTag<string> DuplicateAs { get; }

        ///<summary>
        /// Allows exporting a parameter to an exported protocol used by a dynamic virtual element (DVE).
        ///</summary>
IValueTag<string> Export { get; }

        ///<summary>
        /// Specifies that this parameter is a history set parameter.
        /// If you mark a parameter as a history set parameter, its last set value will not be stored in the trending database when the element is restarted.
        ///</summary>
IValueTag<bool?> HistorySet { get; }

        ///<summary>
        /// Specifies the ID of the parameter.
        /// -	Normal protocols: range 1-64000
        /// -	Spectrum analyzers: range 50000-59999
        /// Warning: Never change parameter IDs in existing protocols. This would severely affect alarms, trend displays, MS Visio files, etc.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies the security level of this parameter.
        /// All users of whom the security level is above the one specified in this attribute are able to change (i.e. set) the value of the parameter.
        ///</summary>
IValueTag<uint?> Level { get; }

        ///<summary>
        /// Specifies the options applied to this parameter.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the polling interval (ms) as a hint for the real-time trend graph.
        ///</summary>
IValueTag<uint?> PollingInterval { get; }

        ///<summary>
        /// Specifies whether the parameter has to be saved each time its value changes.
        /// Default: false
        /// Note: Only applicable for standalone parameters. For column parameters, refer to the "save" option in the Protocol/Params/Param/ArrayOptions/ColumnOptions/ColumnOption@options attribute.
        ///</summary>
IValueTag<bool?> Save { get; }

        ///<summary>
        /// Specifies the interval at which the parameter values should be saved.
        /// Feature introduced in DataMiner 9.5.7 (RN 16708).
        ///</summary>
IValueTag<System.TimeSpan?> SaveInterval { get; }

        ///<summary>
        /// Specifies whether the value of the write parameter will be copied to the corresponding read parameter (with­out the need to add a trigger or an action).
        /// Default: false
        ///</summary>
IValueTag<bool?> Setter { get; }

        ///<summary>
        /// Specifies the offload of snapshots of a parameter to the central database.
        /// This option is never set on a table, but on the columns that a snapshot should be taken from.
        /// The behavior is the same as the trending attribute, but does not require a trend template. Also, the data will not be stored in the local database, but in the specified central database. This is done via settings in the Db.xml file.
        /// When this attribute is not present, the snapshot is set to false.
        /// 
        ///</summary>
IValueTag<bool?> Snapshot { get; }

        ///<summary>
        /// Performs a set and get on a "write" parameter.
        /// When defined on columns with the default value true, cells are retrieved via an Execute Next. The get will not be executed when the set failed.
        /// For a list of possible values, see dynamicSnmpGet.
        /// 
        ///</summary>
IValueTag<string> SnmpSetAndGet { get; }

        ///<summary>
        /// Specifies whether the parameter supports trending.
        /// Default: true
        ///</summary>
IValueTag<bool?> Trending { get; }

        ///<summary>
        /// Overrides the default verification timeout (or the verification timeout value set in MaintenanceSettings.xml) for this parameter with the specified value (in milliseconds).
        ///</summary>
IValueTag<uint?> VerificationTimeout { get; }
    }

    ///<summary>
    /// Specifies the default parameter alarming configuration. Each alarm consists of two components:
    /// -	Severity: Critical, Major, Minor, Warning or Normal
    /// -	Severity Range: Low, Medium or High
    /// These are combined into the following alarm levels:
    /// -	Critical Low (CL)
    /// -	Major Low (MaL)
    /// -	Minor Low (MiL)
    /// -	Warning Low (WaL)
    /// -	Normal (Normal)
    /// -	Warning High (WaH)
    /// -	Minor High (MiH)
    /// -	Major High (MaH)
    /// -	Critical High (CH)
    /// Each alarm level is included in a /Protocol/Params/Param/Alarm element, so a value can be assigned to it. If the value of the monitored parameter is equal to or exceeds
    /// a value included in the /Protocol/Params/Param/Alarm element, DataMiner will process an alarm depending on the alarm level that corresponds to the
    /// value.
    /// These assigned values are not only accessible via the protocol, but also via DataMiner Cuber or System Display. The alarm values of a parameter can be altered by
    /// means of alarm templates, on condition that a /Protocol/Params/Param/Alarm element has been defined for the parameter in the protocol. The alarm
    /// levels of a parameter can be adapted at any moment, regardless of the values specified in the protocol.
    ///</summary>
public partial interface IParamsParamAlarm : IReadable
    {
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "critical high" alarm.
        ///</summary>
IValueTag<string> CH { get; }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "critical low" alarm.
        ///</summary>
IValueTag<string> CL { get; }

        ///<summary>
        /// When the value of the alarm is equal to the value specified in this element, an information event is generated.
        ///</summary>
IValueTag<string> Info { get; }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "major high" alarm.
        ///</summary>
IValueTag<string> MaH { get; }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "major low" alarm.
        ///</summary>
IValueTag<string> MaL { get; }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "minor high" alarm.
        ///</summary>
IValueTag<string> MiH { get; }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "minor low" alarm.
        ///</summary>
IValueTag<string> MiL { get; }

        ///<summary>
        /// Allows enabling or disabling the /Protocol/Params/Param/Alarm element assigned to the parameter.
        ///</summary>
IParamsParamAlarmMonitored Monitored { get; }

        ///<summary>
        /// When the parameter value equals this value (Integer or String, depending on the type of the parameter) or does not exceed the
        /// specified warning limits, DataMiner will not generate an alarm. If an alarm was generated earlier, its type will be set to "dropped".
        ///</summary>
IValueTag<string> Normal { get; }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "warning high" alarm.
        ///</summary>
IValueTag<string> WaH { get; }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "warning low" alarm.
        ///</summary>
IValueTag<string> WaL { get; }

        ///<summary>
        /// In case of a constant alarm: the time (in milliseconds) before the alarm is cleared.
        ///</summary>
IValueTag<uint?> ActiveTime { get; }

        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";"). These options can only be used if the table is linked to another table.
        /// -	threshold: When using this option, specify two parameter IDs, separated by a comma. If the value of the second parameter is smaller than the value of the first parameter,
        /// no Alarm will be generated.
        /// -	propertyNames: In this option, specify the property labels to be added to the alarm tab. Multiple names are separated by a comma.
        /// -	properties: In this option, specify the format of the properties to be added to the alarm tab. Always start the properties string with the character used to separate the different formats.
        /// Each property in the string is either a parameter ID or a combination of text and parameter IDs separated by an asterisk ("*"). If the characters between * are numbers only, then they are considered a parameter ID.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// When the polled device is able to send a nominal value for the parameter, this attribute can be added to the /Protocol/Params/Param/Alarm.
        /// - If set to "absolute", the alarm values defined in /Protocol/Params/Param/Alarm will be calculated in accordance with the nominal value sent by the device.
        /// When the "Critical Low" tag contains the value 5, this value will be subtracted from the nominal value to calculate the actual alarm limit.
        /// -	If set to "relative", percentages will be taken instead of absolute values in order to calculate the actual alarm limits. Example: When the "Minor High" element contains 50,
        /// the alarm limit will contain the nominal value increased with 50% of its value.
        /// You can normalize an alarm by (optionally) adding two parameters, separated by a comma.
        /// -	First parameter: The ID of the parameter that holds the nominal value. This can be a dynamic table parameter or a normal parameter. In case of a table parameter,
        /// each row will be compared with the nominal value found in the same row of the specified column.
        /// -	Second parameter: The ID of the parameter that holds the value by which to multiply the nominal value.
        ///</summary>
IValueTag<string> Type { get; }
    }

    ///<summary>
    /// Allows enabling or disabling the /Protocol/Params/Param/Alarm element assigned to the parameter.
    ///</summary>
public partial interface IParamsParamAlarmMonitored : IValueTag<bool?>
    {
        ///<summary>
        /// Allows monitoring to be disabled when a parameter contains a particular value. Format: "pid,value".
        ///</summary>
IValueTag<string> DisabledIf { get; }
    }

    ///<summary>
    /// Defines all table columns.
    /// Each table column is defined by one or two Parameters:
    /// -	one for read, and/or
    /// -	one for write.
    ///</summary>
public partial interface IParamsParamArrayOptions : IReadableList<ITypeColumnOption>
    {
        ///<summary>
        /// Defines the structure of the display key.
        /// The first character denotes the separator used.
        /// Integers between two separators will be used as column pids.
        /// Using any other alphanumeric string between separators will display this string in the row index.
        ///</summary>
IParamsParamArrayOptionsNamingFormat NamingFormat { get; }

        ///<summary>
        /// Specifies how non-existing rows should be handled.
        /// This attribute is used in combination with snmpSetAndGet or dynamicSnmpGet functionality on tables.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        /// Feature introduced in DataMiner 8.5.7 (RN 10007).
        /// 
        ///</summary>
IValueTag<bool?> DeleteRow { get; }

        ///<summary>
        /// Defines which column is used as an identifier for the user.
        /// This column can be updated, and normally contains a readable key which identifies the row for the user.
        ///</summary>
IValueTag<uint?> DisplayColumn { get; }

        ///<summary>
        /// Defines which column contains the primary keys.
        /// The column containing the primary keys has to be of type "string". Once a row is created, the value of the primary key cannot be changed.
        ///</summary>
IValueTag<uint?> Index { get; }

        ///<summary>
        /// Specifies a number of options.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        /// Note: In this attribute, you can specify multiple values separated by a character of choice (a semi-colon is recommended).
        /// This character has to be the first character in the value of the options attribute. If, for example, you want to separate the different options by a semi-colon, the first character of the options value has to be a semi-colon.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// If set to "true", the table will be subdivided into multiple pages (default: 1000 rows per page).
        /// A page navigator will be displayed at the bottom of the table.
        /// To manually set the number of rows per page, type a colon (":") after "true", followed by the number of rows per page. This value has to be a value between 10 and 5000.
        ///</summary>
IValueTag<string> Partial { get; }

        ///<summary>
        /// Defines the columns that are used when you retrieve the table using SNMP.
        /// If you want a concatenation of multiple columns, you can separate them with semicolons (";").
        ///</summary>
IValueTag<string> SnmpIndex { get; }
    }

    ///<summary>
    /// Defines the structure of the display key.
    /// The first character denotes the separator used.
    /// Integers between two separators will be used as column pids.
    /// Using any other alphanumeric string between separators will display this string in the row index.
    ///</summary>
public partial interface IParamsParamArrayOptionsNamingFormat : IValueTag<string>
    {
    }

    ///<summary>
    /// If /Protocol/Params/Param/Type is set to "CRC", then this CRC element allows you to define the CRC used in the communication with the device.
    /// The information you specify here will be used to calculate the CRC of the command/response.
    ///</summary>
public partial interface IParamsParamCRC : IReadable
    {
        ///<summary>
        /// Specifies the parameters of the command/response to be included in the CRC calculation. In other words, the operation specified in
        /// /Protocol/Params/Param/CRC/Type will only be performed on the parameters that make up the content.
        /// Note: The first parameter of the command/response has ID 0.
        ///</summary>
IParamsParamCRCContent Content { get; }

        ///<summary>
        /// Defines the CRC calculation algorithm.
        ///</summary>
IParamsParamCRCType Type { get; }
    }

    ///<summary>
    /// Specifies the parameters of the command/response to be included in the CRC calculation. In other words, the operation specified in
    /// /Protocol/Params/Param/CRC/Type will only be performed on the parameters that make up the content.
    /// Note: The first parameter of the command/response has ID 0.
    ///</summary>
public partial interface IParamsParamCRCContent : IReadableList<IParamsParamCRCContentParam>
    {
    }

    ///<summary>
    /// Specifies a parameter of the command/response to be included in the CRC calculation.
    ///</summary>
public partial interface IParamsParamCRCContentParam : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Defines the CRC calculation algorithm.
    ///</summary>
public partial interface IParamsParamCRCType : IValueTag<Enums.EnumParamCRCType?>
    {
        ///<summary>
        /// Allows to add an offset to every single byte of the CRC.
        /// Can be used in combination with all possible CRC types.
        ///</summary>
IValueTag<int?> Byteoffset { get; }

        ///<summary>
        /// Specifies the number of bytes on which to perform the operation.
        /// Only valid if the CRC type is set to one of the following values: LSB after subtract, LSB after sum, Exor, Sum
        ///</summary>
IValueTag<string> Groupbytes { get; }

        ///<summary>
        /// Specifies that a modulo operation has to be performed on the CRC after it has been calculated.
        ///</summary>
IValueTag<uint?> Mod { get; }

        ///<summary>
        /// Specifies an offset value to be added to the calculated CRC.
        /// Only valid if the CRC type is set to one of the following values: LSB after subtract, LSB after sum, Rest, Subtract, Sum.
        ///</summary>
IValueTag<int?> Off { get; }

        ///<summary>
        /// Specifies additional options, separated by semi-colons (";"). Available options:
        /// -	ones complement: each bit of the calculated CRC will be inverted. (Example: AAAA will become 5555)
        /// -	or totaloffset: the "totaloffset" value will not be added but "OR"-ed.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies an offset value to be added to the CRC after it has been calculated.
        ///</summary>
IValueTag<uint?> Totaloffset { get; }
    }

    ///<summary>
    /// Allows building a direct view table using multiple columns from multiple different protocols. Feature introduced in DataMiner 10.2.9 (RN 33253).
    ///</summary>
public partial interface IParamsParamCrossDriverOptions : IReadableList<IParamsParamCrossDriverOptionsCrossDriverOption>
    {
    }

    ///<summary>
    /// Specifies column mappings from a remote protocol to this protocol.
    ///</summary>
public partial interface IParamsParamCrossDriverOptionsCrossDriverOption : IReadableList<IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation>
    {
        ///<summary>
        /// Specifies the name of the protocol.
        ///</summary>
IValueTag<string> Protocol { get; }

        ///<summary>
        /// Specifies the parameter ID of the remote table.
        ///</summary>
IValueTag<uint?> RemoteTablePID { get; }
    }

    ///<summary>
    /// Maps a column parameter ID from the remote protocol to this protocol.
    ///</summary>
public partial interface IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation : IReadable
    {
        ///<summary>
        /// Specifies the parameter ID of the column in this protocol.
        ///</summary>
IValueTag<uint?> Local { get; }

        ///<summary>
        /// Specifies the parameter ID of the column in the remote protocol.
        ///</summary>
IValueTag<uint?> Remote { get; }
    }

    ///<summary>
    /// Specifies the configuration for use in dashboards.
    ///</summary>
public partial interface IParamsParamDashboard : IReadable
    {
        ///<summary>
        /// Indicates the type of button panel.
        ///</summary>
IValueTag<string> Type { get; }

        ///<summary>
        /// Groups the options that will determine how the button panel is displayed.
        ///</summary>
IParamsParamDashboardDashboardOptions DashboardOptions { get; }
    }

    ///<summary>
    /// Groups the options that will determine how the button panel is displayed.
    ///</summary>
public partial interface IParamsParamDashboardDashboardOptions : IReadableList<IParamsParamDashboardDashboardOptionsDashboardOption>
    {
    }

    ///<summary>
    /// Specifies how the button panel is displayed.
    ///</summary>
public partial interface IParamsParamDashboardDashboardOptionsDashboardOption : IValueTag<uint?>
    {
        ///<summary>
        /// Specifies whether the value denotes a column index or a parameter ID.
        ///</summary>
IValueTag<string> Type { get; }

        ///<summary>
        /// Specifies the name of the option.
        ///</summary>
IValueTag<string> Name { get; }
    }

    ///<summary>
    /// Specifies database-related configuration options.
    /// Feature introduced in DataMiner 9.0.0 (RN 11853).
    ///</summary>
public partial interface IParamsParamDatabase : IReadable
    {
        ///<summary>
        /// Specifies the type of the corresponding column in the database table.
        ///</summary>
IParamsParamDatabaseColumnDefinition ColumnDefinition { get; }

        ///<summary>
        /// Specifies connection options.
        ///</summary>
IParamsParamDatabaseConnection Connection { get; }

        ///<summary>
        /// Specifies Cassandra-related database settings.
        /// Feature introduced in DataMiner 9.0.0 (RN 11853).
        ///</summary>
IParamsParamDatabaseCQLOptions CQLOptions { get; }

        ///<summary>
        /// Specifies the partitioning configuration.
        ///</summary>
IParamsParamDatabasePartition Partition { get; }

        ///<summary>
        /// Specifies indexing options (Elastic).
        /// Feature introduced in DataMiner 9.6.4 (RN 13552).
        ///</summary>
IParamsParamDatabaseIndexingOptions IndexingOptions { get; }
    }

    ///<summary>
    /// Specifies the type of the corresponding column in the database table.
    ///</summary>
public partial interface IParamsParamDatabaseColumnDefinition : IValueTag<string>
    {
        ///<summary>
        /// Specifies the default value.
        ///</summary>
IValueTag<string> Default { get; }
    }

    ///<summary>
    /// Specifies connection options.
    ///</summary>
public partial interface IParamsParamDatabaseConnection : IReadable
    {
        ///<summary>
        /// Specifies the connection type.
        ///</summary>
IValueTag<string> Type { get; }
    }

    ///<summary>
    /// Specifies Cassandra-related database settings.
    /// Feature introduced in DataMiner 9.0.0 (RN 11853).
    ///</summary>
public partial interface IParamsParamDatabaseCQLOptions : IReadable
    {
        ///<summary>
        /// Specifies how the primary key of the table is defined.
        /// Contains a semicolon separated list of column idx values denoting the columns that form the primary key.
        ///</summary>
IValueTag<string> Clustering { get; }

        ///<summary>
        /// Specifies the query that has to be executed after the creation of the table. This can for example be a query that will preload data or create indexes.
        ///</summary>
IValueTag<string> Finalizer { get; }

        ///<summary>
        /// Specifies the WITH clause that is to be used to set the necessary table properties.
        ///</summary>
IValueTag<string> TableProperty { get; }
    }

    ///<summary>
    /// Specifies the partitioning configuration.
    ///</summary>
public partial interface IParamsParamDatabasePartition : IValueTag<Enums.EnumDatabasePartition?>
    {
        ///<summary>
        /// Specifies the number of partitions to keep.
        ///</summary>
IValueTag<uint?> PartitionsToKeep { get; }
    }

    ///<summary>
    /// Specifies indexing options (Elastic).
    /// Feature introduced in DataMiner 9.6.4 (RN 13552).
    ///</summary>
public partial interface IParamsParamDatabaseIndexingOptions : IReadable
    {
        ///<summary>
        /// Indicates whether the data of the logger table will be stored in the Elastic database instead of Cassandra. When set to true, the data of the logger table will be stored in the Elastic database instead of Cassandra.
        ///</summary>
IValueTag<bool?> Enabled { get; }
    }

    ///<summary>
    /// Allows you to link one or more parameters. This is mostly used for situations in which clicking a button executes a command that includes several parameters.
    /// Execution of such a command will only proceed if all dependent parameters have a valid value.
    ///</summary>
public partial interface IParamsParamDependencies : IReadableList<IParamsParamDependenciesId>
    {
    }

    ///<summary>
    /// Specifies the IDs of the parameters that are linked to this parameter.
    ///</summary>
public partial interface IParamsParamDependenciesId : IValueTag<string>
    {
        ///<summary>
        /// Specifies whether the dependency parameter acts as a preset or a post-set. Refer to the DataMiner Protocol Markup Language Documentation for more information.
        ///</summary>
IValueTag<bool?> PostSet { get; }
    }

    ///<summary>
    /// Defines if and how a parameter will be displayed on the user interface.
    ///</summary>
public partial interface IParamsParamDisplay : IReadable
    {
        ///<summary>
        /// Specifies the dynamic units that can be used.
        ///</summary>
IParamsParamDisplayDynamicUnits DynamicUnits { get; }

        ///<summary>
        /// Defines the number of decimals to be used to display the parameter value on the user inter­face.
        ///</summary>
IValueTag<uint?> Decimals { get; }

        ///<summary>
        /// Allows displaying a parameter as a chart.
        /// The parameters holding the actual values to be displayed have to be specified in /Protocol/Params/Param/Display/ParametersView/Parameters.
        /// Note: When this is used, make sure to set /Protocol/Params/Param/Measurement/Type to “Chart”.
        ///</summary>
IParamsParamDisplayParametersView ParametersView { get; }

        ///<summary>
        /// Defines the position of the parameter on the user interface.
        /// Note: As a parameter can be displayed on several locations on the user interface, /Protocol/Params/Param/Display/Positions can contain more than
        /// one position.
        ///</summary>
IParamsParamDisplayPositions Positions { get; }

        ///<summary>
        /// Defines the parameter value range.
        ///</summary>
IParamsParamDisplayRange Range { get; }

        ///<summary>
        /// Specifies whether the parameter should be pushed to the SLElement process.
        ///</summary>
IParamsParamDisplayRTDisplay RTDisplay { get; }

        ///<summary>
        /// Defines the step size of a write parameter.
        ///</summary>
IValueTag<decimal?> Steps { get; }

        ///<summary>
        /// Specifies the formula to be used for the average trending data of this parameter. By default, the average over a 5 minute timespan is stored.
        ///</summary>
IParamsParamDisplayTrending Trending { get; }

        ///<summary>
        /// Specifies a unit for a parameter value displayed on the user interface. This can be a unit like "Vac", "dBm", etc., but it can also be a string like "batteries"
        /// (for a parameter showing the number of batteries attached to a backup power supply).
        /// The specified unit will be used each time the value of the parameter is displayed: in a report, on the alarm display, etc.
        ///</summary>
IValueTag<string> Units { get; }
    }

    ///<summary>
    /// Specifies the dynamic units that can be used.
    ///</summary>
public partial interface IParamsParamDisplayDynamicUnits : IReadableList<IParamsParamDisplayDynamicUnitsUnit>
    {
    }

    ///<summary>
    /// Specifies a dynamic unit.
    ///</summary>
public partial interface IParamsParamDisplayDynamicUnitsUnit : IValueTag<string>
    {
        ///<summary>
        /// Specifies the number of decimals to be used to display the parameter value on the user interface with this unit.
        ///</summary>
IValueTag<uint?> Decimals { get; }
    }

    ///<summary>
    /// Allows displaying a parameter as a chart.
    /// The parameters holding the actual values to be displayed have to be specified in /Protocol/Params/Param/Display/ParametersView/Parameters.
    /// Note: When this is used, make sure to set /Protocol/Params/Param/Measurement/Type to “Chart”.
    ///</summary>
public partial interface IParamsParamDisplayParametersView : IReadable
    {
        ///<summary>
        /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then here you have to define the parameters holding the actual values to be displayed.
        ///</summary>
IParamsParamDisplayParametersViewParameters Parameters { get; }

        ///<summary>
        /// A pipe-separated list of options:
        /// -	Height: Height of the chart (in pixels). If you do not specify a height, the chart will take up the rest of the page.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the chart type: Column, Pie, Row, StackedArea
        /// Note:
        /// -	Pie charts only work if the referenced values are either all positive or all negative.
        /// -	StackedArea charts should not be used to display values that are constantly changing.
        ///</summary>
IValueTag<Enums.EnumParametersViewType?> Type { get; }
    }

    ///<summary>
    /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then here you have to define the parameters holding the actual values to be displayed.
    ///</summary>
public partial interface IParamsParamDisplayParametersViewParameters : IReadableList<IParamsParamDisplayParametersViewParametersParameter>
    {
    }

    ///<summary>
    /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then add a Parameter element to
    /// /Protocol/Params/Param/Display/ParametersView/Parameters for every parameter holding a value to be displayed.
    /// Note: Only specify parameters of type "double".
    ///</summary>
public partial interface IParamsParamDisplayParametersViewParametersParameter : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// *** Not yet implemented. ***
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the row index (in case the “id” attribute refers to a table parameter).
        ///</summary>
IValueTag<string> TableIndex { get; }
    }

    ///<summary>
    /// Defines the position of the parameter on the user interface.
    /// Note: As a parameter can be displayed on several locations on the user interface, /Protocol/Params/Param/Display/Positions can contain more than
    /// one position.
    ///</summary>
public partial interface IParamsParamDisplayPositions : IReadableList<IParamsParamDisplayPositionsPosition>
    {
    }

    ///<summary>
    /// Defines the location of the parameter on the user interface.
    ///</summary>
public partial interface IParamsParamDisplayPositionsPosition : IReadable
    {
        ///<summary>
        /// Specifies on which page you want to display the parameter.
        /// All Data display pages specified in the protocol will appear in the page selection box at the top of the Data Display.
        ///</summary>
IParamsParamDisplayPositionsPositionPage Page { get; }

        ///<summary>
        /// Specifies the horizontal position of the parameter on the page specified in
        /// /Protocol/Params/Param/Display/Positions/Position/Page.
        /// Data display pages are divided into rows and columns. In /Protocol/Params/Param/Display/Positions/Position/Column, you can specify the column on which you want the parameter to be displayed.
        /// Enter an integer value between 0 and 5.
        /// Note: It is recommended to divide the user interface into two columns: a left-hand column with column value 0, and a right-hand column with column value 1.
        ///</summary>
IValueTag<uint?> Column { get; }

        ///<summary>
        /// Specifies the vertical position of the parameter on thepage specified in /Protocol/Params/Param/Display/Positions/Position/Page.
        /// Data display pages are divided into rows and columns. In /Protocol/Params/Param/Display/Positions/Position/Row, you can specify the row on which you want
        /// the parameter to be displayed.
        /// Note: 0 = first row
        ///</summary>
IValueTag<uint?> Row { get; }
    }

    ///<summary>
    /// Specifies on which page you want to display the parameter.
    /// All Data display pages specified in the protocol will appear in the page selection box at the top of the Data Display.
    ///</summary>
public partial interface IParamsParamDisplayPositionsPositionPage : IValueTag<string>
    {
        ///<summary>
        /// This attribute allows you to display a parameter as a specific type of parameter on a particular page.
        ///</summary>
IValueTag<Enums.EnumParamMeasurementType?> MeasType { get; }
    }

    ///<summary>
    /// Defines the parameter value range.
    ///</summary>
public partial interface IParamsParamDisplayRange : IReadable
    {
        ///<summary>
        /// Specifies the lower limit of the range, i.e. the minimum value of the parameter.
        ///</summary>
IValueTag<decimal?> Low { get; }

        ///<summary>
        /// Specifies the upper limit of the value range, i.e. the maximum value of the parameter.
        ///</summary>
IValueTag<decimal?> High { get; }
    }

    ///<summary>
    /// Specifies whether the parameter should be pushed to the SLElement process.
    ///</summary>
public partial interface IParamsParamDisplayRTDisplay : IValueTag<bool?>
    {
        ///<summary>
        /// Set this attribute to "true" if the parameter has no position but needs RTDisplay true for application purposes. For validation only.
        ///</summary>
IValueTag<bool?> OnAppLevel { get; }
    }

    ///<summary>
    /// Specifies the formula to be used for the average trending data of this parameter. By default, the average over a 5 minute timespan is stored.
    ///</summary>
public partial interface IParamsParamDisplayTrending : IReadable
    {
        ///<summary>
        /// Specifies the formula used to determine the average trending data.
        ///</summary>
IParamsParamDisplayTrendingType Type { get; }

        ///<summary>
        /// Set this attribute to "true" if you want to set the trend graph of the parameter to a logarithmic scale.
        ///</summary>
IValueTag<bool?> Logarithmic { get; }
    }

    ///<summary>
    /// Specifies the formula used to determine the average trending data.
    ///</summary>
public partial interface IParamsParamDisplayTrendingType : IValueTag<Enums.EnumTrendingType?>
    {
        ///<summary>
        /// Option to choose a logarithmic scale for the vertical axis. The parameter’s real value should always be larger than 0 for log10(value) to be possible.
        ///</summary>
IValueTag<string> Operations { get; }
    }

    ///<summary>
    /// Contains the custom commands (i.e. “hyperlinks”) that have to appear on the shortcut menu when users right-click an alarm of this parameter.
    /// These custom commands are often hyperlinks pointing to a web page or an automation script.
    ///</summary>
public partial interface IParamsParamHyperLinks : IReadableList<IParamsParamHyperLinksHyperLink>
    {
    }

    ///<summary>
    /// Defines a custom command (i.e. “hyperlink”) that has to appear on the shortcut menu when users right-click an alarm of this parameter.
    ///</summary>
public partial interface IParamsParamHyperLinksHyperLink : IValueTag<string>
    {
        ///<summary>
        /// Makes the command appear on the shortcut menu of specific alarms and information events.
        /// If you specify a string in this attribute, the command will only appear on the shortcut menu of alarms and information events of which the value matches the string you specified.
        /// If you leave this attribute empty, the command will appear on the shortcut menu of every alarm and information event.
        /// The string you specify in this valueParsing attribute can contain wildcards (question marks and asterisks) as well as placeholders.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> ValueParsing { get; }
    }

    ///<summary>
    /// Specifies additional information about the parameter.
    /// DataMiner will show this additional information in tooltips.
    /// Note: Only parameters of type "read" or "read bit" will use /Protocol/Params/Param/Information. In some cases, however, also parameters of type "write" or "write bit" will have one.
    ///</summary>
public partial interface IParamsParamInformation : IReadable
    {
        ///<summary>
        /// Specifies an alarm description. When an alarm for this parameter is generated, the value specified here will be shown in the Alarm Description field of the alarm.
        ///</summary>
IValueTag<string> AlarmDescription { get; }

        ///<summary>
        /// Specifies a category. When an alarm for this parameter is generated, the value specified here will be shown in the Category field of the alarm.
        ///</summary>
IValueTag<string> Category { get; }

        ///<summary>
        /// Specifies a corrective action. When an alarm for this parameter is generated, the value specified here will be shown in the Corrective Action field of the alarm.
        ///</summary>
IValueTag<string> CorrectiveAction { get; }

        ///<summary>
        /// Contains one or more /Protocol/Params/Param/Information/Include elements to indicate that you want additional information to be displayed in the tooltip.
        ///</summary>
IParamsParamInformationIncludes Includes { get; }

        ///<summary>
        /// Specifies the actual content of the tooltip.
        /// Next to the title of the tooltip, a drop-down arrow will allow users to enlarge the tooltip and display the text contained in /Protocol/Params/Param/Information/Subtext.
        ///</summary>
IValueTag<string> Subtext { get; }

        ///<summary>
        /// Specifies the title of the tooltip.
        ///</summary>
IValueTag<string> Text { get; }
    }

    ///<summary>
    /// Contains one or more /Protocol/Params/Param/Information/Include elements to indicate that you want additional information to be displayed in the tooltip.
    ///</summary>
public partial interface IParamsParamInformationIncludes : IReadableList<IParamsParamInformationIncludesInclude>
    {
    }

    ///<summary>
    /// Indicates that you want additional information to be displayed in the tooltip.
    /// Information specified in /Protocol/Params/Param/Information/Include elements will appear underneath the con­tents of the /Protocol/Params/Param/Information/Subtext element.
    /// Can contain one of the following values:
    /// - Range: The range of the parameter.
    /// - Units: The unit of the parameter.
    /// - Steps: The step size of the parameter.
    /// - Time: A time stamp that refers to either the last known change or the last time the Parameter was changed by its write parameter (if any).
    ///</summary>
public partial interface IParamsParamInformationIncludesInclude : IValueTag<Enums.EnumParamInformationInclude?>
    {
    }

    ///<summary>
    /// Specifies how a parameter value is processed.
    ///</summary>
public partial interface IParamsParamInterprete : IReadable
    {
        ///<summary>
        /// Used to retrieve BCD numbers from an incoming stream.
        /// When a /Protocol/Params/Param/Interprete/Bits element is defined in a group, only a couple of bits will be used from each byte.
        /// When a read bit parameter, with its rawtype set to “bcd”, is assigned to that group and exists of multiple bytes, the Alignment element can be needed to specify the exact starting position
        /// of the first BCD.
        ///</summary>
IValueTag<Enums.EnumParamInterpretAlignment?> Alignment { get; }

        ///<summary>
        /// Specifies the numeral system (decimal, hexadecimal, etc.).
        /// Contains a number between 2 and 36. Default: 10
        /// Note: In case of base 36, the letters "a" through "z" (or "A" through "Z") are assigned the values 10 through 35.
        ///</summary>
IValueTag<uint?> Base { get; }

        ///<summary>
        /// Used when a group of multiple bytes has been defined, but only a couple of bits are used from each byte.
        /// For example, when only the lower 4 bits are used from each byte, a group can be defined with /Protocol/Params/Param/Interprete/Bits set to 4.
        /// When a "read bit" parameter of 8 bits is assigned to that group, 4 lower bits of 2 bytes will be taken instead of 1 complete byte.
        ///</summary>
IValueTag<uint?> Bits { get; }

        ///<summary>
        /// Specifies the byte offset.
        /// Each incoming byte of a group containing this ByteOffset element will be decremented with the specified byte offset, while each outgoing byte of the group will be incremented with the specified byte offset.
        ///</summary>
IValueTag<uint?> ByteOffset { get; }

        ///<summary>
        /// Specifies the number of decimals that will be stored in memory.
        ///</summary>
IValueTag<uint?> Decimals { get; }

        ///<summary>
        /// Specifies the default value to be assigned to the parameter if it is empty after startup. If this parameter is saved, the saved value will overrule the default value.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether DataMiner must reverse the byte order.
        /// When numbers are composed of multiple bytes, Intel processors reverse the byte order before writing them to memory.
        /// This optional element instructs DataMiner to either reverse the byte order or not (only relevant in case of unsigned numbers).
        /// - Big: The byte order will be reversed.
        /// - Little: The byte order will not be reversed.
        /// Note: By default, Little Endian is used.
        ///</summary>
IValueTag<Enums.EnumParamInterpretEndian?> Endian { get; }

        ///<summary>
        /// In /Protocol/Params/Param/Interprete/Others, you can define symbols that are not accepted by the rawtype.
        /// However, a rare condition of a parameter can also be expressed by a symbol that is allowed by the parameter's rawtype.
        /// In that case, you can use /Protocol/Params/Param/Interprete/Exceptions/Exception.
        /// In /Protocol/Params/Param/Interprete/Exceptions, you can specify several /Protocol/Params/Param/Interprete/Exceptions/Exception elements, each representing a different exceptional state.
        /// Note: Only useful for parameters of type "read".
        ///</summary>
IParamsParamInterpreteExceptions Exceptions { get; }

        ///<summary>
        /// Multiplies the parameter value with the specified factor.
        ///</summary>
IValueTag<decimal?> Factor { get; }

        ///<summary>
        /// Specifies the exact length of the parameter (in bytes). Used when /Protocol/Params/Param/Interprete/LengthType is set to "fixed".
        ///</summary>
IValueTag<uint?> Length { get; }

        ///<summary>
        /// Specifies whether the parameter has a fixed length.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IParamsParamInterpreteLengthType LengthType { get; }

        ///<summary>
        /// Specifies the number of bits needed.
        /// When this number exceeds the number of bits used in a byte, the /Protocol/Params/Param/Interprete/Endian element can be set to "big" to make DataMiner reverse the bit order when processing them.
        ///</summary>
IValueTag<uint?> NbrOfBits { get; }

        ///<summary>
        /// In case the Sequence tag contains "OffSet " as an operation, to offset to be added can be specified using this tag.
        ///</summary>
IParamsParamInterpreteOffSet OffSet { get; }

        ///<summary>
        /// Each parameter has a certain rawtype, but in some cases other characters are sent instead of the usual ones to indicate a rare condition.
        /// These symbols are often not allowed by the rawtype of the parameter. To catch those characters and display the singular state of the parameter, they can be specified in /Protocol/Params/Param/Interprete/Others.
        ///</summary>
IParamsParamInterpreteOthers Others { get; }

        ///<summary>
        /// Defines a range for the parameter values. By adding a range to /Protocol/Params/Param/Interprete, a value outside this defined range will be ignored.
        /// The limits of the range are defined by /Protocol/Params/Param/Interprete/Range/Low and /Protocol/Params/Param/Interprete/Range/High.
        /// Note: This can also be used to specify a value range in case of a simulated element.
        ///</summary>
IParamsParamInterpreteRange Range { get; }

        ///<summary>
        /// Specifies which type of content is allowed in the parameter.
        /// If an incoming parameter value does not match the expected rawtype, DataMiner will not process it.
        /// The rawtype setting can therefore be considered as a kind of filter.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<Enums.EnumParamInterpretRawType?> RawType { get; }

        ///<summary>
        /// Specifies how the parameter value is rounded (Default: down).
        /// Feature introduced in DataMiner 9.0.0 (Main Release) and DataMiner 9.0.4 (Feature Release) (RN 13519).
        ///</summary>
IValueTag<Enums.EnumRounding?> Rounding { get; }

        ///<summary>
        /// Specifies that you want DataMiner to re-interpret the value range of a particular parameter.
        ///</summary>
IParamsParamInterpreteScale Scale { get; }

        ///<summary>
        /// Specifies a mathematical operation to be performed on the parameter value.
        /// Specify at least one mathematical operation. If you specify multiple operations, separate them using semi-colons (";").
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IParamsParamInterpreteSequence Sequence { get; }

        ///<summary>
        /// Specifies the start bit in the group to which the parameter refers to in case the parameter is of type "read/write bits".
        /// The most significant bit of the group is considered to be bit 0, and the counter is incremented as the significance of the bits decreases.
        ///</summary>
IValueTag<uint?> StartPosition { get; }

        ///<summary>
        /// In this tag, you can specify how the parameter should be processed and saved.
        /// Specify one of the following values:
        /// - string: The parameter will be processed as an ASCII string.
        /// - double: The parameter will be processed as a number.
        /// - high nibble: The parameter will be processed as the high nibble (i.e. first four bits) of a byte.
        ///</summary>
IParamsParamInterpreteType Type { get; }

        ///<summary>
        /// In case of a parameter with a fixed length and a fixed value, set /Protocol/Params/Param/Inter­prete/LengthType to "fixed" and specify the fixed value here.
        ///</summary>
IValueTag<string> ValueElement { get; }
    }

    ///<summary>
    /// In /Protocol/Params/Param/Interprete/Others, you can define symbols that are not accepted by the rawtype.
    /// However, a rare condition of a parameter can also be expressed by a symbol that is allowed by the parameter's rawtype.
    /// In that case, you can use /Protocol/Params/Param/Interprete/Exceptions/Exception.
    /// In /Protocol/Params/Param/Interprete/Exceptions, you can specify several /Protocol/Params/Param/Interprete/Exceptions/Exception elements, each representing a different exceptional state.
    /// Note: Only useful for parameters of type "read".
    ///</summary>
public partial interface IParamsParamInterpreteExceptions : IReadableList<IParamsParamInterpreteExceptionsException>
    {
    }

    ///<summary>
    /// Each exception is uniquely identified by its ID.
    /// If the parameter receives an incoming symbol that matches the value specified in /Protocol/Params/Param/Interprete/Exceptions/Exception, the contents of /Protocol/Params/Param/Interprete/Exceptions/Exception/Display will be shown.
    ///</summary>
public partial interface IParamsParamInterpreteExceptionsException : IReadable
    {
        ///<summary>
        /// Specifies the text that has to be displayed when the incoming value matches the contents of the value attribute of /Protocol/Params/Param/Interprete/Exceptions/Exception.
        ///</summary>
IParamsParamInterpreteExceptionsExceptionDisplay Display { get; }

        ///<summary>
        /// Specifies the new value to which you want to internally map the incoming exception value specified in the value attribute of the /Protocol/Params/Param/Interprete/Exceptions/Exception element.
        ///</summary>
IValueTag<string> ValueElement { get; }

        ///<summary>
        /// Specifies the unique ID of the exception.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// When the parameter receives an incoming symbol that matches the contents of this tag, the contents of /Protocol/Params/Param/Interprete/Exceptions/Exception/Display will be displayed.
        ///</summary>
IValueTag<string> ValueAttribute { get; }
    }

    ///<summary>
    /// Specifies the text that has to be displayed when the incoming value matches the contents of the value attribute of /Protocol/Params/Param/Interprete/Exceptions/Exception.
    ///</summary>
public partial interface IParamsParamInterpreteExceptionsExceptionDisplay : IValueTag<string>
    {
        ///<summary>
        /// To emphasize the rare condition of the parameter, you can set the state attribute to "disabled" to have the parameter displayed in gray.
        ///</summary>
IValueTag<Enums.EnumDisplayState?> State { get; }
    }

    ///<summary>
    /// Specifies whether the parameter has a fixed length.
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
public partial interface IParamsParamInterpreteLengthType : IValueTag<Enums.EnumParamInterpretLengthType?>
    {
        ///<summary>
        /// If LengthType is set to "other param", this attribute has to contain the ID of the "other" parameter that contains the parameter length.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// If LengthType is "next param", then this attribute has to contain the number of times the next parameter should occur before it is considered to be the next parameter.
        ///</summary>
IValueTag<uint?> Times { get; }
    }

    ///<summary>
    /// In case the Sequence tag contains "OffSet " as an operation, to offset to be added can be specified using this tag.
    ///</summary>
public partial interface IParamsParamInterpreteOffSet : IValueTag<uint?>
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the offset value.
        ///</summary>
IValueTag<uint?> Id { get; }
    }

    ///<summary>
    /// Each parameter has a certain rawtype, but in some cases other characters are sent instead of the usual ones to indicate a rare condition.
    /// These symbols are often not allowed by the rawtype of the parameter. To catch those characters and display the singular state of the parameter, they can be specified in /Protocol/Params/Param/Interprete/Others.
    ///</summary>
public partial interface IParamsParamInterpreteOthers : IReadableList<IParamsParamInterpreteOthersOther>
    {
    }

    ///<summary>
    /// When an incoming character does not match the rawtype of a Parameter, DataMiner will try to match the symbol to the rawtype of the Parameter to which a /Protocol/Params/Param/Interprete/Others/Other element refers to, if any.
    ///</summary>
public partial interface IParamsParamInterpreteOthersOther : IReadable
    {
        ///<summary>
        /// When a /Protocol/Params/Param/Interprete/Others/Other element matches the incoming symbol, the contents of /Protocol/Params/Param/Interprete/Others/Other/Display will be shown.
        ///</summary>
IParamsParamInterpreteOthersOtherDisplay Display { get; }

        ///<summary>
        /// Adds a numeric value (&gt;= 10) to the parameter , which can be useful in case you want to show an alarm when this rare condition occurs.
        ///</summary>
IValueTag<decimal?> ValueElement { get; }

        ///<summary>
        /// Specifies the ID of the parameter to which the incoming symbol will be compared.
        /// If the incoming symbol matches the referred parameter, the contents of the/Protocol/Params/Param/Inter­prete/Others/Other/Display element will be shown.
        ///</summary>
IValueTag<uint?> Id { get; }
    }

    ///<summary>
    /// When a /Protocol/Params/Param/Interprete/Others/Other element matches the incoming symbol, the contents of /Protocol/Params/Param/Interprete/Others/Other/Display will be shown.
    ///</summary>
public partial interface IParamsParamInterpreteOthersOtherDisplay : IValueTag<string>
    {
        ///<summary>
        /// If set to "disabled", the parameter will be displayed in gray.
        ///</summary>
IValueTag<Enums.EnumDisplayState?> State { get; }
    }

    ///<summary>
    /// Defines a range for the parameter values. By adding a range to /Protocol/Params/Param/Interprete, a value outside this defined range will be ignored.
    /// The limits of the range are defined by /Protocol/Params/Param/Interprete/Range/Low and /Protocol/Params/Param/Interprete/Range/High.
    /// Note: This can also be used to specify a value range in case of a simulated element.
    ///</summary>
public partial interface IParamsParamInterpreteRange : IReadable
    {
        ///<summary>
        /// Specifies the lower limit of the range, i.e. the minimum value of a parameter.
        ///</summary>
IValueTag<decimal?> Low { get; }

        ///<summary>
        /// Specifies the upper limit of the range, i.e. the maximum value of a parameter.
        ///</summary>
IValueTag<decimal?> High { get; }
    }

    ///<summary>
    /// Specifies that you want DataMiner to re-interpret the value range of a particular parameter.
    ///</summary>
public partial interface IParamsParamInterpreteScale : IReadable
    {
        ///<summary>
        /// Specifies the lowest value that can be returned by the device for the parameter in question.
        ///</summary>
IValueTag<decimal?> LowData { get; }

        ///<summary>
        /// Specifies the highest value that can be returned by the device for the parameter in question.
        ///</summary>
IValueTag<decimal?> HighData { get; }

        ///<summary>
        /// Specifies the value to which DataMiner has to convert the lowest value that can be returned by the device.
        ///</summary>
IValueTag<decimal?> Low { get; }

        ///<summary>
        /// Specifies the value to which DataMiner has to convert the highest value that can be returned by the device.
        ///</summary>
IValueTag<decimal?> High { get; }
    }

    ///<summary>
    /// Specifies a mathematical operation to be performed on the parameter value.
    /// Specify at least one mathematical operation. If you specify multiple operations, separate them using semi-colons (";").
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
public partial interface IParamsParamInterpreteSequence : IValueTag<string>
    {
        ///<summary>
        /// Specifies the loop value for the sequence (integer).
        /// The value in the parameter will be automatically recalculated taking into account the loop (overflow) sequence.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<uint?> Loop { get; }

        ///<summary>
        /// If you do not specify this attribute, or if you set it to "false", sequences will be taken into account when the parameter gets a new value.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<bool?> Noset { get; }
    }

    ///<summary>
    /// In this tag, you can specify how the parameter should be processed and saved.
    /// Specify one of the following values:
    /// - string: The parameter will be processed as an ASCII string.
    /// - double: The parameter will be processed as a number.
    /// - high nibble: The parameter will be processed as the high nibble (i.e. first four bits) of a byte.
    ///</summary>
public partial interface IParamsParamInterpreteType : IValueTag<Enums.EnumParamInterpretType?>
    {
        ///<summary>
        /// When set to "true", only printable characters will be displayed (default value: "false").
        ///</summary>
IValueTag<bool?> Filter { get; }

        ///<summary>
        /// Add this attribute to remove leading and/or trailing whitespace.
        /// You can specify the following values. If you add both values, separate them by a semi-colon (";").
        /// -	left: all leading whitespace will be removed
        /// -	right: all trailing whitespace will be removed.
        ///</summary>
IValueTag<Enums.EnumInterpretTypeTrim?> Trim { get; }
    }

    ///<summary>
    /// Specifies the length of the command/response.
    ///</summary>
public partial interface IParamsParamLength : IReadable
    {
        ///<summary>
        /// Specifies the parameters of the command/response that define the length of the com­mand/response.
        ///</summary>
IParamsParamLengthContent Content { get; }
    }

    ///<summary>
    /// Specifies the parameters of the command/response that define the length of the com­mand/response.
    ///</summary>
public partial interface IParamsParamLengthContent : IReadableList<IParamsParamLengthContentParam>
    {
    }

    ///<summary>
    /// Specifies a parameter of the command/response to be included in the length calculation.
    /// Note: The first parameter of the command/response has ID 0.
    ///</summary>
public partial interface IParamsParamLengthContentParam : IValueTag<uint?>
    {
    }

    ///<summary>
    /// If /Protocol/Params/Param/Type is set to "matrix", then this will allow you to define the matrix control. Feature introduced in DataMiner 10.3.1/10.4.0 (RN 34661).
    ///</summary>
public partial interface IParamsParamMatrix : IReadable
    {
        ///<summary>
        /// Contains the linking between the inputs table and the matrix control.
        ///</summary>
IParamsParamMatrixInputs Inputs { get; }

        ///<summary>
        /// Contains the linking between the outputs table and the matrix control.
        ///</summary>
IParamsParamMatrixOutputs Outputs { get; }

        ///<summary>
        /// Contains additional options related to how the matrix should behave and look.
        ///</summary>
IParamsParamMatrixMatrixOptions MatrixOptions { get; }
    }

    ///<summary>
    /// Contains the linking between the inputs table and the matrix control.
    ///</summary>
public partial interface IParamsParamMatrixInputs : IReadable
    {
        ///<summary>
        /// Specifies the linking between the columns of the inputs table and the matrix control.
        ///</summary>
IParamsParamMatrixInputsMappings Mappings { get; }

        ///<summary>
        /// Specifies the ID of the inputs table.
        ///</summary>
IValueTag<uint?> TablePid { get; }
    }

    ///<summary>
    /// Specifies the linking between the columns of the inputs table and the matrix control.
    ///</summary>
public partial interface IParamsParamMatrixInputsMappings : IReadableList<IParamsParamMatrixInputsMappingsMapping>
    {
    }

    ///<summary>
    /// Specifies the link between the column and the matrix column.
    ///</summary>
public partial interface IParamsParamMatrixInputsMappingsMapping : IValueTag<string>
    {
        ///<summary>
        /// Specifies the type of value of the mapping.
        ///</summary>
IValueTag<Enums.EnumMatrixMappingType?> Type { get; }

        ///<summary>
        /// Specifies the mapping type.
        ///</summary>
IValueTag<Enums.EnumMatrixInputsMappingNameType?> Name { get; }
    }

    ///<summary>
    /// Contains the linking between the outputs table and the matrix control.
    ///</summary>
public partial interface IParamsParamMatrixOutputs : IReadable
    {
        ///<summary>
        /// Specifies the linking between the columns of the outputs table and the matrix control.
        ///</summary>
IParamsParamMatrixOutputsMappings Mappings { get; }

        ///<summary>
        /// Specifies the ID of the outputs table.
        ///</summary>
IValueTag<uint?> TablePid { get; }
    }

    ///<summary>
    /// Specifies the linking between the columns of the outputs table and the matrix control.
    ///</summary>
public partial interface IParamsParamMatrixOutputsMappings : IReadableList<IParamsParamMatrixOutputsMappingsMapping>
    {
    }

    ///<summary>
    /// Specifies the link between the column and the matrix column.
    ///</summary>
public partial interface IParamsParamMatrixOutputsMappingsMapping : IValueTag<string>
    {
        ///<summary>
        /// Specifies the type of value of the mapping.
        ///</summary>
IValueTag<Enums.EnumMatrixMappingType?> Type { get; }

        ///<summary>
        /// Specifies the mapping type.
        ///</summary>
IValueTag<Enums.EnumMatrixOutputsMappingNameType?> Name { get; }
    }

    ///<summary>
    /// Contains additional options related to how the matrix should behave and look.
    ///</summary>
public partial interface IParamsParamMatrixMatrixOptions : IReadableList<IParamsParamMatrixMatrixOptionsMatrixOption>
    {
    }

    ///<summary>
    /// Specifies specific options for the look or behavior of the matrix.
    ///</summary>
public partial interface IParamsParamMatrixMatrixOptionsMatrixOption : IValueTag<string>
    {
        ///<summary>
        /// Specifies the type of value of the matrix option.
        ///</summary>
IValueTag<Enums.EnumMatrixMatrixOptionType?> Type { get; }

        ///<summary>
        /// Specifies the matrix option type.
        ///</summary>
IValueTag<Enums.EnumMatrixMatrixOptionNameType?> Name { get; }
    }

    ///<summary>
    /// Specifies how the parameter has to be displayed on the user interface (depending on the parameter type).
    ///</summary>
public partial interface IParamsParamMeasurement : IReadable
    {
        ///<summary>
        /// Contains the displayed value(s) of the parameter.
        /// For every value, page button or button to be displayed, a separate /Protocol/Params/Param/Measure­ment/Discreets/Discreet element has to be specified.
        /// In Data Display, the values will be displayed in the order in which they are specified in the /Protocol/Params/Param/Measure­ment/Discreets element.
        /// Note: The /Protocol/Params/Param/Measurement/Discreets element only has to be used if /Proto­col/Params/Param/Measurement/Type is set to "discreet", "pagebutton", or "togglebutton".
        ///</summary>
IParamsParamMeasurementDiscreets Discreets { get; }

        ///<summary>
        /// Should only be used in case /Protocol/Params/Param/Measurement/Type is set to "threshold digital".
        /// In some cases, when only two states are allowed (e.g. "On" and "Off") but the parameter value lies within a range of values, a turnover point has to be defined (i.e. when value
        /// "On" is changed to "Off" and vice versa). This turnover point can be defined here. The actual "On" and "Off" values are defined as discrete entries.
        ///</summary>
IValueTag<double?> Threshold { get; }

        ///<summary>
        /// Specifies how the parameter has to be displayed on the user interface.
        /// For more information about the values that can be specified, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IParamsParamMeasurementType Type { get; }
    }

    ///<summary>
    /// Contains the displayed value(s) of the parameter.
    /// For every value, page button or button to be displayed, a separate /Protocol/Params/Param/Measure­ment/Discreets/Discreet element has to be specified.
    /// In Data Display, the values will be displayed in the order in which they are specified in the /Protocol/Params/Param/Measure­ment/Discreets element.
    /// Note: The /Protocol/Params/Param/Measurement/Discreets element only has to be used if /Proto­col/Params/Param/Measurement/Type is set to "discreet", "pagebutton", or "togglebutton".
    ///</summary>
public partial interface IParamsParamMeasurementDiscreets : IReadableList<IParamsParamMeasurementDiscreetsDiscreet>
    {
        ///<summary>
        /// If the discrete values of the parameter depend on the current state of another parameter, the ID of that other parameter can be specified using this attribute.
        ///</summary>
IValueTag<uint?> DependencyId { get; }

        ///<summary>
        /// Configures the layout of the matrix. Default: InputLeftOutputTop.
        ///</summary>
IValueTag<string> MatrixLayout { get; }
    }

    ///<summary>
    /// Specifies a value and a text string.
    /// The latter will be displayed on the user interface if the former matches the value of the parameter.
    ///</summary>
public partial interface IParamsParamMeasurementDiscreetsDiscreet : IReadable
    {
        ///<summary>
        /// Specifies the string to be displayed when the value of the parameter matches the contents of /Protocol/Params/Param/Measurement/Discreets/Discreet/Value.
        ///</summary>
IParamsParamMeasurementDiscreetsDiscreetDisplay Display { get; }

        ///<summary>
        /// Specifies the discrete value has to be displayed.
        /// If the value of the parameter matches the value in this element, the contents of ../Discreet/Display will be displayed.
        ///</summary>
IParamsParamMeasurementDiscreetsDiscreetValue ValueElement { get; }

        ///<summary>
        /// Specifies the tooltip to be displayed when the mouse pointer hovers over the icon displayed in a table cell containing the discrete parameter value to which it is linked.
        ///</summary>
IValueTag<string> Tooltip { get; }

        ///<summary>
        /// When the parameter depends on the current value of another parameter, the dependencyValues attribute can be used to specify whether or not the discreet value
        /// should be available. If the other parameter has one of the values specified in the attribute, the discreet will be displayed, otherwise it will not. In case of a ContextMenu parameter (of which the name is identical to that of the table with “_ContextMenu” suffix), the dependencyValues will first ask the user to enter the value of each parameter specified in this attribute.
        ///</summary>
IValueTag<string> DependencyValues { get; }

        ///<summary>
        /// Specifies whether to show only the icon (false) or to show the icon together with the display value of the discrete entry (true). Default: false.
        /// Feature introduced in DataMiner 9.5.7.
        ///</summary>
IValueTag<bool?> DisplayIconAndLabel { get; }

        ///<summary>
        /// Specifies the parameter values that have to be exported.
        ///</summary>
IValueTag<string> Export { get; }

        ///<summary>
        /// Specifies the key of the icon as defined in the Icons.xml file.
        /// Using this attribute in a column parameter of a table will display an icon in the tree control.
        /// 
        ///</summary>
IValueTag<Enums.EnumIcons?> IconRef { get; }

        ///<summary>
        /// Specifies the options to be used. Refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> Options { get; }
    }

    ///<summary>
    /// Specifies the string to be displayed when the value of the parameter matches the contents of /Protocol/Params/Param/Measurement/Discreets/Discreet/Value.
    ///</summary>
public partial interface IParamsParamMeasurementDiscreetsDiscreetDisplay : IValueTag<string>
    {
        ///<summary>
        /// When /Protocol/Params/Param/Interprete/Exceptions/Exception is used the same state needs to be placed in the write parameter.
        ///</summary>
IValueTag<Enums.EnumDisplayState?> State { get; }
    }

    ///<summary>
    /// Specifies the discrete value has to be displayed.
    /// If the value of the parameter matches the value in this element, the contents of ../Discreet/Display will be displayed.
    ///</summary>
public partial interface IParamsParamMeasurementDiscreetsDiscreetValue : IValueTag<string>
    {
        ///<summary>
        /// If type is “dll”, the location of the DLL file.
        ///</summary>
IValueTag<string> Location { get; }

        ///<summary>
        /// Specifies the type.
        ///</summary>
IValueTag<Enums.EnumDiscreteValue?> Type { get; }
    }

    ///<summary>
    /// Specifies how the parameter has to be displayed on the user interface.
    /// For more information about the values that can be specified, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
public partial interface IParamsParamMeasurementType : IValueTag<Enums.EnumParamMeasurementType?>
    {
        ///<summary>
        /// Specifies the casing to be used. Only to be specified in case of measurement type "string":
        /// -	upper: upper case
        /// -	lower: lower case
        ///</summary>
IValueTag<Enums.EnumParamMeasurementTypeCase?> Case { get; }

        ///<summary>
        /// Only to be specified in case of measurement type "string":
        /// -	On
        /// -	Off
        ///</summary>
IValueTag<Enums.EnumOnOff?> Continuous { get; }

        ///<summary>
        /// Specifies whether the parameter value should be displayed as a hexadecimal number.
        ///</summary>
IValueTag<bool?> Hex { get; }

        ///<summary>
        /// Specifies the number of lines that will be displayed. Only to be specified in case of measurement type "string".
        ///</summary>
IValueTag<uint?> Lines { get; }

        ///<summary>
        /// Specifies the file name in which the input and output labels are stored. Only to be specified in case of measurement type "matrix".
        ///</summary>
IValueTag<string> Link { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> Number { get; }

        ///<summary>
        /// The options that can be specified in this attribute depend on the specified measurement type.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        /// If you specify multiple options, separate these by semi-colons (";").
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the scientific notation to be used.
        ///</summary>
IValueTag<Enums.EnumScientificNotation?> ScientificNotation { get; }

        ///<summary>
        /// Specifies a deviation on analog parameters.
        ///</summary>
IValueTag<decimal?> VerificationDeviation { get; }

        ///<summary>
        /// Specifies the width of a (page) button. Only to be specified in case of measurement types "pagebutton" or "button".
        ///</summary>
IValueTag<uint?> Width { get; }
    }

    ///<summary>
    /// Contains the links between parameters of a base protocol and parameters of this protocol.
    ///</summary>
public partial interface IParamsParamMediation : IReadableList<IParamsParamMediationLinkTo>
    {
    }

    ///<summary>
    /// Defines a link between a parameter of a base protocol and a parameter of this protocol.
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
public partial interface IParamsParamMediationLinkTo : IReadableList<IParamsParamMediationLinkToValueMapping>
    {
        ///<summary>
        /// Allows to provide a description about the defined link.
        ///</summary>
IValueTag<string> Description { get; }

        ///<summary>
        /// Specifies one or more conversion operations separated by semicolons (";").
        /// Supported operations:
        /// *: factor
        /// /: division
        /// -: minus
        /// +: offset
        /// %: remainder
        /// Example: &lt;LinkTo pid="176" protocol="Philips DVS3810" ops="*:1024;+:5" /&gt;
        ///</summary>
IValueTag<string> Ops { get; }

        ///<summary>
        /// Specifies the ID of the parameter this parameter is linked to.
        ///</summary>
IValueTag<uint?> Pid { get; }

        ///<summary>
        /// Specifies the name of the protocol that holds the parameter to which this parameter is linked.
        ///</summary>
IValueTag<string> Protocol { get; }
    }

    ///<summary>
    /// Defines a value mapping.
    ///</summary>
public partial interface IParamsParamMediationLinkToValueMapping : IReadable
    {
        ///<summary>
        /// Specifies the value in the other protocol.
        ///</summary>
IValueTag<string> RemoteValue { get; }

        ///<summary>
        /// Specifies the value in the current protocol.
        ///</summary>
IValueTag<string> ValueAttribute { get; }
    }

    ///<summary>
    /// Used to replicate specific parameters from another element.
    ///</summary>
public partial interface IParamsParamReplication : IReadable
    {
        ///<summary>
        /// Specifies the DataMiner Agent ID/element ID of the replicated element.
        ///</summary>
IParamsParamReplicationElement Element { get; }

        ///<summary>
        /// Specifies the ID of the parameter that has to be replicated.
        ///</summary>
IParamsParamReplicationParameter Parameter { get; }

        ///<summary>
        /// Specifies the IP address of the DataMiner Agent on which the element is located.
        ///</summary>
IValueTag<string> Ip { get; }

        ///<summary>
        /// Specifies the user name to log on to the DataMiner Agent on which the element is located.
        ///</summary>
IValueTag<string> Uid { get; }

        ///<summary>
        /// Specifies the password to log on to the DataMiner Agent on which the element is located.
        ///</summary>
IValueTag<string> Pwd { get; }

        ///<summary>
        /// Specifies the domain containing the DataMiner Agent on which the element is located..
        ///</summary>
IValueTag<string> Domain { get; }
    }

    ///<summary>
    /// Specifies the DataMiner Agent ID/element ID of the replicated element.
    ///</summary>
public partial interface IParamsParamReplicationElement : IValueTag<string>
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the element ID (DMA ID/element ID) of the element from which the parameter should be replicated. Feature introduced in DataMiner 9.6.1 (RN 19311).
        ///</summary>
IValueTag<uint?> Dynamic { get; }
    }

    ///<summary>
    /// Specifies the ID of the parameter that has to be replicated.
    ///</summary>
public partial interface IParamsParamReplicationParameter : IValueTag<string>
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the ID of the parameter that should be replicated. Feature introduced in DataMiner 9.6.1 (RN 19311).
        ///</summary>
IValueTag<uint?> Dynamic { get; }
    }

    ///<summary>
    /// Specifies SNMP related functionality for this parameter.
    /// Only used in protocols for elements that are SNMP-compliant. In case of such an element, DataMiner will interrogate the SNMP agent specified in /Proto­col/Params/Param/SNMP/OID or capture traps defined in /Protocol/Params/Param/SNMP/TrapOID.
    ///</summary>
public partial interface IParamsParamSNMP : IReadable
    {
        ///<summary>
        /// Specifies whether DataMiner is allowed to interrogate the SNMP Agent.
        ///</summary>
IValueTag<bool?> Enabled { get; }

        ///<summary>
        /// Specifies that all values will be divided by the specified factor. By default, SNMP does not support decimal values. In a DataMiner protocol, however, you can use this Factor element to produce decimal values.
        /// If you specify a factor, all values will be divided by that factor.
        /// Default factor: 1
        ///</summary>
IValueTag<uint?> Factor { get; }

        ///<summary>
        /// Specifies the invalid response handling strategy.
        ///</summary>
IParamsParamSNMPInvalidResponseHandling InvalidResponseHandling { get; }

        ///<summary>
        /// Specifies the OID.
        ///</summary>
IParamsParamSNMPOID OID { get; }

        ///<summary>
        /// Specifies trap mappings. Use this if the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute is too limited.
        /// If you want to make more advanced Alarm mappings, add one or more /Protocol/Params/Param/SNMP/Trap­Mappings/TrapMapping elements to this TrapMappings element.
        /// Note that it is possible to combine the TrapMappings element with the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute.
        ///</summary>
IParamsParamSNMPTrapMappings TrapMappings { get; }

        ///<summary>
        /// Specifies the SNMP traps DataMiner has to capture via this parameter.
        ///</summary>
IParamsParamSNMPTrapOID TrapOID { get; }

        ///<summary>
        /// Specifies the SNMP type.
        ///</summary>
IValueTag<Enums.EnumSNMPType?> Type { get; }

        ///<summary>
        /// Use this attribute to change the community get or the community set string for a particular connection.
        /// Specify 'GetCommunity:' or 'SetCommunity:', followed by the connection. Example: options="GetCommunity:0"
        ///</summary>
IValueTag<string> Options { get; }
    }

    ///<summary>
    /// Specifies the invalid response handling strategy.
    ///</summary>
public partial interface IParamsParamSNMPInvalidResponseHandling : IReadable
    {
        ///<summary>
        /// Specifies the response handling in case an infinite loop was detected when polling a table.
        ///</summary>
IValueTag<string> InfiniteLoop { get; }
    }

    ///<summary>
    /// Specifies the OID.
    ///</summary>
public partial interface IParamsParamSNMPOID : IValueTag<string>
    {
        ///<summary>
        /// Specifies the ID of the parameter holding the (partial) OID.
        /// The OID (or a part of it) can be made variable. To do so, replace the variable part of the OID by an asterisk (*), and specify the ID of the parameter holding (part of) the OID in the id attribute.
        /// In case of options=subtable, “id” has to contain the ID of the parameter holding the instance filter for the table.
        /// 
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies the ID of the parameter holding the IP address that needs to be used to poll this SNMP parameter.
        ///</summary>
IValueTag<uint?> Ipid { get; }

        ///<summary>
        /// Specifies some options.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies that the evaluation of a certain parameter is skipped if it needs to be retrieved via a dynamic SNMP Get.
        ///</summary>
IValueTag<bool?> SkipDynamicSNMPGet { get; }

        ///<summary>
        /// Specifies how the OID is constructed.
        /// For more information refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<Enums.EnumOIDType?> Type { get; }
    }

    ///<summary>
    /// Specifies trap mappings. Use this if the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute is too limited.
    /// If you want to make more advanced Alarm mappings, add one or more /Protocol/Params/Param/SNMP/Trap­Mappings/TrapMapping elements to this TrapMappings element.
    /// Note that it is possible to combine the TrapMappings element with the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute.
    ///</summary>
public partial interface IParamsParamSNMPTrapMappings : IReadableList<IParamsParamSNMPTrapMappingsTrapMapping>
    {
    }

    ///<summary>
    /// Specifies a trap mapping. When a trap is received, all TrapMapping elements will be evaluated top down. When a TrapMapping element matches the incoming trap, the severity
    /// and/or the value specified in that mapping will be kept in memory. As soon as both the severity and the value are known, the search will stop and the alarm will be generated.
    /// At the end of the list of /Protocol/Params/Param/SNMP/TrapMappings/TrapMapping elements, you can add a TrapMapping element in which you specify a wildcard. In the event that severity or value still
    /// cannot be determined, the method with the mapAlarm attribute on the /Protocol/Params/Param/SNMP/TrapOID element will be executed in order to try to determine the severity and value.
    ///</summary>
public partial interface IParamsParamSNMPTrapMappingsTrapMapping : IReadable
    {
        ///<summary>
        /// Specifies one or more values for a specific binding.
        /// This attribute consists of two parts, separated by a colon:
        /// -	The number of the binding, and
        /// -	A pipe-separated enumeration of values you want to compare to the value of the binding.
        /// Note: Wildcards are allowed.
        ///</summary>
IValueTag<string> BindingMatch { get; }

        ///<summary>
        /// Specifies a DataMiner severity level.
        /// Instead, you can also specify "NoAlarm" (or "NoTrap") to indicate that no Alarm should be generated.
        /// Note: The severity level information will always overwrite previously assigned severity levels.
        ///</summary>
IValueTag<string> Severity { get; }

        ///<summary>
        /// This attribute contains an alarm value, specified in the same way as the alarm value in the mapAlarm attribute of the /Protocol/Params/Param/SNMP/TrapOID element.
        ///</summary>
IValueTag<string> ValueAttribute { get; }
    }

    ///<summary>
    /// Specifies the SNMP traps DataMiner has to capture via this parameter.
    ///</summary>
public partial interface IParamsParamSNMPTrapOID : IValueTag<string>
    {
        ///<summary>
        /// Specifies basic filtering on the trap bindings.
        /// You can compare a certain binding to a fixed string (which optionally contains wildcards), or you can compare it to the value of another parameter.
        /// Checks must be separated by pipe characters.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> CheckBindings { get; }

        ///<summary>
        /// Specifies the ID of the parameter holding IP addresses.
        /// By default, only the traps received from the polling IP address of an element will be captured. However, using the ipid attribute, you can point to a parameter that contains another IP address.
        /// If you use the ipid attribute, only traps received from the IP address found in the parameter referenced by the ipid attribute will be captured. Traps originating from the polling IP address will be disregarded.
        ///</summary>
IValueTag<string> Ipid { get; }

        ///<summary>
        /// Allows an alarm to be generated when a trap is received.
        /// - The first part must be "true" or "false", to enable or disable the mapping of alarms.
        /// - The order of the following items (separated by pipe characters) is irrelevant: Severity, Value, Link, IgnoreSingleClear
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> MapAlarm { get; }

        ///<summary>
        /// Specifies that the value of a certain binding should be set as the value of another parameter.
        /// Use this attribute to take the value of a certain binding and immediately set (copy) it to another parameter.
        /// Set pairs have to be separated by semi-colons. Every set pair consists of a binding position (1-based) containing the value to be set and the ID of the parameter to set,
        /// separated by a comma. If you want to set a dynamic table parameter, you can add more items to the set pair (which will then be concatenated with a "." to build an index).
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> SetBindings { get; }

        ///<summary>
        /// Specifies how the OID is constructed.
        /// For more information refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<Enums.EnumTrapOIDType?> Type { get; }
    }

    ///<summary>
    /// Specifies the parameter type.
    /// For more information about the different types, refer to the DataMiner Protocol Markup Language documentation.
    /// Parameters of type "elementid", "elementname", "elementdmaid" and "dataminer info" are the first parameters that are loaded by a protocol. Although they hold information, they cannot, as such,
    /// be displayed in Element Display. Therefore, for these types of parameters, always set /Protocol/Params/Param/Display/RTDisplay "false".
    /// If you do want to display the information in one of these parameters in Element Display, there is a workaround: create another parameter of type "read", and copy the value from its invisible parameter to this new parameter after protocol start-up. You can then display the "read" parameter in Element Display.
    ///</summary>
public partial interface IParamsParamType : IValueTag<Enums.EnumParamType?>
    {
        ///<summary>
        /// Allows to trigger a QAction when specific parameters go into alarm.
        ///</summary>
IValueTag<string> AlarmRegistration { get; }

        ///<summary>
        /// This attribute is used in situations in which elements of a certain type are linked to each-other as parent and child.
        /// By using data distribution, you can prevent data from being retrieved more than once, and also make sure that the data in your master and child are the same.
        /// In a protocol, these data distribution parameters can be defined in either a fixed or a dynamic way.
        /// To use data distribution, you have to add the "distribution" attribute to a Parameter in your master element. This parameter can be a "simple" parameter, or a column parameter from a table.
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> Distribution { get; }

        ///<summary>
        /// Specifies what to retrieve (cell, row, etc.) and the way this request is added to the group execution queue.
        ///</summary>
IValueTag<string> DynamicSnmpGet { get; }

        ///<summary>
        /// If Type is "read bit" or "response", this attribute specifies the ID of the parameter or response to which to refer, respectively.
        ///</summary>
IValueTag<string> Id { get; }

        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";").
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// In this attribute, you can specify "true" or "true with reset".
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<Enums.EnumProtocolTypeRelativeTimers?> RelativeTimers { get; }

        ///<summary>
        /// If Type is "trailer", use this attribute to indicate how many times the trailer is allowed to occur before it is considered to be the trailer.
        ///</summary>
IValueTag<uint?> Times { get; }

        ///<summary>
        /// Configures which virtual element connections are allowed to and from elements based on the protocol you are creating.
        /// You can specify multiple connection restraints, separated by a pipe character ("|").
        /// A connection restraint has the following format (building blocks separated by ":")
        /// -	keyword "source" or "destination",
        /// -	optionally followed by one or more Protocol definitions ("Protocol=...") and one or more parameter descriptions ("Parameterdescription=...").
        ///</summary>
IValueTag<string> Virtual { get; }
    }

    ///<summary>
    /// For every protocol, you have to specify its type in /Protocol/Type, and its port settings in /Protocol/Portsettings.
    /// In case of a multi-type protocol, the /Protocol/Type@advanced attribute is used to any additional protocol types.
    /// The port settings for those additional protocol types then have to be specified in a /Protocol/Ports/Portsettings element in which the name attribute contains the name of the additional type as specified in the /Protocol/Type@advanced attribute.
    ///</summary>
public partial interface IPorts : IReadableList<IPortSettings>
    {
    }

    public partial interface IProcessAutomation : IReadable
    {
        ///<summary>
        /// Additional options for the Process Automation Queue.
        ///</summary>
IProcessAutomationProcessAutomationOptions ProcessAutomationOptions { get; }
    }

    ///<summary>
    /// Additional options for the Process Automation Queue.
    ///</summary>
public partial interface IProcessAutomationProcessAutomationOptions : IReadableList<IProcessAutomationProcessAutomationOptionsProcessAutomationOption>
    {
    }

    ///<summary>
    /// The additional options for the Process Automation Queue.
    ///</summary>
public partial interface IProcessAutomationProcessAutomationOptionsProcessAutomationOption : IReadable
    {
        ///<summary>
        /// Name of the option.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Parameter ID of the parameter that will contain the option value.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Contains all the QActions defined in the protocol.
    /// A QAction (i.e. Quick Action) is a script that can be executed when a parameter or a row changes. Inside a QAction, the following scripting languages can be used:
    /// -	JScript
    /// -	VBScript
    /// -	C#
    ///</summary>
public partial interface IQActions : IReadableList<IQActionsQAction>
    {
    }

    ///<summary>
    /// A QAction is a script that can be executed when a parameter or a row has changed.
    /// The actual script code of a QAction must be placed inside a CDATA section.
    /// By placing code inside a CDATA section, characters like "&lt;" and "&amp;", which are normally illegal when placed inside normal XML elements, will no longer be considered as such.
    /// In order to interact with SLProtocol (e.g. to access parameters or to notify DataMiner of certain events)
    /// - in JScript or VBScript code, use the SLScript object
    /// - in C# code, use the Skyline.DataMiner.Scripting namespace
    /// For information on how to use C# in protocols, refer to the appendices of the DaaMiner Protocol Development Guide.
    ///</summary>
public partial interface IQActionsQAction : IValueTag<string>
    {
        ///<summary>
        /// Specifies a condition that must be met in order for the QAction to execute.
        ///</summary>
IValueTag<string> Condition { get; }

        ///<summary>
        /// Specifies external DLL files used by the QAction.
        /// Multiple values have to be separated by semi-colons (";").
        /// System DLL files must be stored in the system dll directory; all other DLL files must be stored in the C:\Skyline DataMiner\ProtocolScripts directory.
        /// Note: The following DLL files do not have to be specified in this dllImport attribute. They are loaded by default.
        /// -	System.dll
        /// -	SLManagedScripting.dll
        /// -	Interop.sldms.dll
        ///</summary>
IValueTag<string> DllImport { get; }

        ///<summary>
        /// Specifies the language in which the script has been written:
        /// -	JScript
        /// -	VBScript
        /// -	CSharp
        /// (case insensitive)
        ///</summary>
IValueTag<Enums.EnumQActionEncoding?> Encoding { get; }

        ///<summary>
        /// Defines the entry point method(s) corresponding with the parameter(s) triggering the QAction execution.
        ///</summary>
IValueTag<string> EntryPoint { get; }

        ///<summary>
        /// Specifies the unique QAction ID.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies the name of the external script to be executed.
        ///</summary>
IValueTag<string> Include { get; }

        ///<summary>
        /// Specifies the IDs of the parameters that will be passed to functions inside the QAction script.
        /// Multiple values have to be separated by semi-colons (";").
        ///</summary>
IValueTag<string> InputParameters { get; }

        ///<summary>
        /// Specifies the name of the QAction.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies a number of options (multiple options can be separated by semicolons (';'). Possible options:
        /// - binary: If specified, all values in “inputParameters” are forwarded to the QAction as a byte array holding the raw content of the parameter.
        /// - debug: Compiles the QAction in debug mode.
        /// - dllName=name: With this option, the specified name will be included in the DLL name. The name of the DLL will be as follows: [ProtocolName].[ProtocolVersion].[name].dll.
        /// - queued: The QAction will be executed asynchronously. This implies that the QAction is triggered and set in the background. Be careful when using this option and make sure to also implement thread synchronization when this QAction is called more than once.
        /// - group: When this option is specified, the "OldRow()" method will return the values retrieved by that group. This option can be used in case of high-volume polling. Use it with care.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// If "true", the QAction will be executed when a row of a table has changed.
        ///</summary>
IValueTag<bool?> Row { get; }

        ///<summary>
        /// Specifies the IDs of the parameters that will cause the QAction to be executed each time their value changes.
        /// Multiple values have to be separated by semi-colons (";").
        ///</summary>
IValueTag<string> Triggers { get; }
    }

    ///<summary>
    /// Configures Root Cause Analysis (RCA).
    ///</summary>
public partial interface IRCA : IReadable
    {
        ///<summary>
        /// *** No documentation available yet. ***
        ///</summary>
IRCAProtocol Protocol { get; }
    }

    ///<summary>
    /// *** No documentation available yet. ***
    ///</summary>
public partial interface IRCAProtocol : IReadableList<IRCAProtocolLink>
    {
    }

    ///<summary>
    /// Defines an RCA chain by defining relations.
    ///</summary>
public partial interface IRCAProtocolLink : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> Distribute { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> Path { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> ValueFilter { get; }
    }

    ///<summary>
    /// Defines relations between tables.
    ///</summary>
public partial interface IRelations : IReadableList<IRelationsRelation>
    {
    }

    ///<summary>
    /// Defines a relation between tables.
    ///</summary>
public partial interface IRelationsRelation : IReadable
    {
        ///<summary>
        /// Defines a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the IDs of the tables that are linked to each other.
        ///</summary>
IValueTag<string> Path { get; }

        ///<summary>
        /// Specifies the name of the relation.
        ///</summary>
IValueTag<string> Name { get; }
    }

    ///<summary>
    /// Contains all responses defined in the protocol.
    ///</summary>
public partial interface IResponses : IReadableList<IResponsesResponse>
    {
    }

    ///<summary>
    /// Specifies a response that DataMiner can expect after having sent a specific command to the device.
    /// Similar to a command, a response is a collection of parameters that describe the message that the device is expected to send back to DataMiner after having received a command.
    /// When it receives a response from the device, DataMiner will compare that response to the response definition specified in /Protocol/Responses/Response. If the response does not match
    /// the definition, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has occurred. The log files of the device will contain
    /// more detailed information. If the response still does not match, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
    /// will skip the command, and move to the next one.
    /// Note: By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device in System Display or DataMiner Cube.
    ///</summary>
public partial interface IResponsesResponse : IReadable
    {
        ///<summary>
        /// Specifies the consecutive parameters that together form the response that is expected from the device.
        ///</summary>
IResponsesResponseContent Content { get; }

        ///<summary>
        /// Specifies a textual description of the response.
        ///</summary>
IValueTag<string> Description { get; }

        ///<summary>
        /// Specifies the name of the response. Often, the response will have the same name as the command with which it is associated.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies the unique response ID.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Defines a number of options. Possible values:
        /// - Connection: This option allows you to specify the ID of the connection (in case of multiple ports). Adding the connection ID at response level is only done in protocols of type "smart serial".
        ///</summary>
IValueTag<string> Options { get; }
    }

    ///<summary>
    /// Specifies the consecutive parameters that together form the response that is expected from the device.
    ///</summary>
public partial interface IResponsesResponseContent : IReadableList<IResponsesResponseContentParam>
    {
        ///<summary>
        /// Specifies that no error will occur if they are not found in the response received from the device.
        /// Parameters included in a response definition can be marked as optional. This means, that no error will occur if they are not found in the response received from the device.
        /// If a parameter matches, DataMiner will simply go on to the next parameter and check that one.
        /// If an optional parameter does not match, the following special characters can be included in the "optional" attribute of the /Protocol/Responses/Response element to tell DataMiner what to do:
        /// +: tells DataMiner to skip the next parameter. Multiple "+" characters can be entered to have several parameters skipped.
        /// *: tells DataMiner to skip the parameters in the response until it reaches the next optional parameter.
        ///</summary>
IValueTag<string> Optional { get; }
    }

    ///<summary>
    /// Specifies the ID of the parameter that you want to include in the response.
    ///</summary>
public partial interface IResponsesResponseContentParam : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Used to pass alarm severities to linked tables.
    ///</summary>
public partial interface ISeverityBubbleUp : IReadableList<ISeverityBubbleUpPath>
    {
    }

    ///<summary>
    /// Specifies the table path that needs to be followed when passing alarm severities.
    ///</summary>
public partial interface ISeverityBubbleUpPath : IValueTag<string>
    {
        ///<summary>
        /// Refers to a parameter that indicates whether the bubble-up path is disabled or enabled.
        /// The referred parameter must have 0 and 1 as possible values.
        /// While the element is running, if the parameter value is set to 0, the bubble-up path will be disabled.
        /// If the parameter value is set to 1, the bubble-up path will be enabled.
        /// If this attribute is absent, the bubble-up path will be enabled by default.
        /// Feature introduced in DataMiner 9.5.3 (RN 15103, RN 15843).
        /// 
        ///</summary>
IValueTag<uint?> StatePid { get; }
    }

    ///<summary>
    /// Specifies how the MIB file for the protocol will be created.
    ///</summary>
public partial interface ISNMP : IValueTag<Enums.EnumSNMP?>
    {
        ///<summary>
        /// If "true", the MIB of the protocol will contain several submaps: one for each page defined in the protocol.
        /// Example: When a number of parameters are placed on a page called "General", the MIB will automatically create a submap named "General", which will contain all the parameters on that page.
        ///</summary>
IValueTag<bool?> Includepages { get; }
    }

    ///<summary>
    /// Specifies additional threads that will be used by the protocol. This allows you to separate time-critical actions from device-polling actions. Use with caution.
    ///</summary>
public partial interface IThreads : IReadableList<IThreadsThread>
    {
    }

    ///<summary>
    /// Defines an additional thread. This will allow you to e.g. separate time-critical actions from device-polling actions.
    /// Each additional thread you create, has its own protocol group execution queue as well as its own run-time error thread registration.
    /// Note: The main protocol group execution queue will always be active, no matter how many additional threads you create.
    ///</summary>
public partial interface IThreadsThread : IReadable
    {
        ///<summary>
        /// When you create an additional thread, you have to link it to a particular connection.
        /// This can be either a real connection or a virtual connection. All groups linked to that connection will then be executed on that thread.
        /// In the connection attribute, you can specify a single connection ID or a comma-separated list of multiple connection IDs in case you want to combine a number of connections into one single thread).
        ///</summary>
IValueTag<string> Connection { get; }
    }

    ///<summary>
    /// Contains all timers defined in the protocol.
    /// Timers are used to configure recurring events (group execution, device polling, ...). Basically, a timer defines the interval between two consecutive executions of a given event.
    /// By default, the interval specified in a timer is a fixed interval. However, in the protocol, you can make the interval dynamic.
    /// The interval can be modified by changing the value of the [Timer base] Parameter (ID: 65017). The value of this parameter is the factor by which the interval time is multiplied.
    /// So "1" means the original interval, "2" means twice as slow, "0.5" means twice as fast, etc.
    ///</summary>
public partial interface ITimers : IReadableList<ITimersTimer>
    {
        IValueTag<bool?> RelativeTimers { get; }
    }

    ///<summary>
    /// Specifies which groups have to be executed, and when.
    /// It is recommended to define multiple timers. That way, you can separate the important groups (which will be polled more frequently) from the less important groups
    /// (which will be polled less frequently).
    ///</summary>
public partial interface ITimersTimer : IReadable
    {
        ///<summary>
        /// Specifies a condition that must be met in order for the timer to execute. Note: Avoid using conditions on timers.
        ///</summary>
IValueTag<string> Condition { get; }

        ///<summary>
        /// Specifies the timer name.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Contains all the groups that have to be executed when the timer is triggered.
        /// Important: Do not include too much groups in one timer.
        ///</summary>
ITimersTimerContent Content { get; }

        ///<summary>
        /// Specifies the interval (in milliseconds) between two consecutive executions of groups within a timer and also between two consecutive pairs within a timer group.
        ///</summary>
IValueTag<uint?> Interval { get; }

        ///<summary>
        /// Specifies how frequently the included groups will be executed.
        /// If you enter "loop", the included groups will be executed over and over again.
        /// If you enter an integer value &gt; 0, the included groups will be executed every X milliseconds.
        ///</summary>
ITimersTimerTime Time { get; }

        ///<summary>
        /// Specifies the unique timer ID.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// If, in case of a relative-timer protocol, this attribute is set to "true", the user will not be able to change the interval.
        /// See also: The /Protocol/Type@relativeTimers attribute.
        ///</summary>
IValueTag<bool?> FixedTimer { get; }

        ///<summary>
        /// Specifies a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        /// 
        ///</summary>
IValueTag<string> Options { get; }
    }

    ///<summary>
    /// Contains all the groups that have to be executed when the timer is triggered.
    /// Important: Do not include too much groups in one timer.
    ///</summary>
public partial interface ITimersTimerContent : IReadableList<ITimersTimerContentGroup>
    {
    }

    ///<summary>
    /// Specifies the ID of the group to be included.
    ///</summary>
public partial interface ITimersTimerContentGroup : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies how frequently the included groups will be executed.
    /// If you enter "loop", the included groups will be executed over and over again.
    /// If you enter an integer value &gt; 0, the included groups will be executed every X milliseconds.
    ///</summary>
public partial interface ITimersTimerTime : IValueTag<string>
    {
        ///<summary>
        /// Specifies the execution frequency of the included groups when a Data Display has been opened.
        /// It is good practice to set this interval to 30000 (30 seconds).
        /// Note: If you set this attribute to "loop", the included groups will be executed as frequently as possible.
        /// In some cases, this can affect overall DataMiner performance.
        ///</summary>
IValueTag<uint?> DataDisplay { get; }

        ///<summary>
        /// Specifies whether the timer should be started when the element is started.
        /// - true: the timer will be started when the element is started.
        /// - false: the timer will not be started when the element is started. This allows you to dynamically start the timer by performing an action.
        /// - random=startvalue:endvalue : the timer will be started a random number of seconds after the start of the element. The random value will be a value between startvalue and endvalue.
        /// E.g. random=0:300
        /// By default, this attribute is omitted. As a consequence, the groups will be executed the moment the element is started.
        ///</summary>
IValueTag<string> Initial { get; }
    }

    ///<summary>
    /// Groups topologies defined in the protocol.
    ///</summary>
public partial interface ITopologies : IReadableList<ITopologiesTopology>
    {
    }

    ///<summary>
    /// Defines a topology. In this element, you can specify several Cell elements, each representing a cell in the diagram displayed in the CPE Manager.
    ///</summary>
public partial interface ITopologiesTopology : IReadableList<ITopologiesTopologyCell>
    {
        ///<summary>
        /// Specifies the name of the topology (Service Overview Manager only).
        ///</summary>
IValueTag<string> Name { get; }
    }

    ///<summary>
    /// Specifies a cell within a CPE topology.
    ///</summary>
public partial interface ITopologiesTopologyCell : IReadableList<ITypeTopologyCellLink>
    {
        ///<summary>
        /// Exposes this cell to the CPE crawler.
        ///</summary>
ITopologiesTopologyCellExposer Exposer { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> DetailColumns { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> ListColumns { get; }

        ///<summary>
        /// Specifies the name of the cell.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies a number of options (Deprecated).
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the table parameter to which the cell is linked.
        ///</summary>
IValueTag<string> Table { get; }
    }

    ///<summary>
    /// Exposes this cell to the CPE crawler.
    ///</summary>
public partial interface ITopologiesTopologyCellExposer : IReadable
    {
        ///<summary>
        /// Specifies the linked tables.
        ///</summary>
ITopologiesTopologyCellExposerLinkedIds LinkedIds { get; }

        ///<summary>
        /// Specifies whether the exposer is enabled.
        ///</summary>
IValueTag<bool?> Enabled { get; }
    }

    ///<summary>
    /// Specifies the linked tables.
    ///</summary>
public partial interface ITopologiesTopologyCellExposerLinkedIds : IReadableList<ITopologiesTopologyCellExposerLinkedIdsLinkedId>
    {
    }

    ///<summary>
    /// Specifies the table parameter ID of the linked table.
    ///</summary>
public partial interface ITopologiesTopologyCellExposerLinkedIdsLinkedId : IValueTag<int?>
    {
        ///<summary>
        /// Specifies the ID of the column parameter that is used to link the specified table.
        ///</summary>
IValueTag<int?> ColumnPid { get; }
    }

    ///<summary>
    /// Contains all the tree controls defined in the protocol.
    ///</summary>
public partial interface ITreeControls : IReadableList<ITreeControlsTreeControl>
    {
    }

    ///<summary>
    /// Defines a tree control.
    ///</summary>
public partial interface ITreeControlsTreeControl : IReadable
    {
        ///<summary>
        /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
        ///</summary>
ITreeControlsTreeControlExtraDetails ExtraDetails { get; }

        ///<summary>
        /// Contains additional tab definitions in the tree control.
        ///</summary>
ITreeControlsTreeControlExtraTabs ExtraTabs { get; }

        ///<summary>
        /// Specifies the columns to be hidden.
        ///</summary>
IValueTag<string> HiddenColumns { get; }

        ///<summary>
        /// Defines the relationship between the (visible) tables.
        /// Rows from these tables will become items in the tree.
        ///</summary>
ITreeControlsTreeControlHierarchy Hierarchy { get; }

        ///<summary>
        /// Used to hide write controls for certain table columns.
        ///</summary>
IValueTag<string> ReadonlyColumns { get; }

        ///<summary>
        /// Used to override the display key or the index of a row by a different column of the same table.
        ///</summary>
IValueTag<string> OverrideDisplayColumns { get; }

        ///<summary>
        /// By specifying a column in this element, you can apply a custom icon based on a cell value in a row.
        /// The column must be a parameter of type Discreet and all discreet values must have an IconRef referring to an icon. If not, a default icon will be displayed.
        ///</summary>
IValueTag<string> OverrideIconColumns { get; }

        ///<summary>
        /// Specifies the parameter ID of the tree control.
        ///</summary>
IValueTag<uint?> ParameterId { get; }

        ///<summary>
        /// If set to "true", disables all the write parameters in the tree control. Default: false.
        ///</summary>
IValueTag<bool?> ReadOnly { get; }
    }

    ///<summary>
    /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
    ///</summary>
public partial interface ITreeControlsTreeControlExtraDetails : IReadableList<ITreeControlsTreeControlExtraDetailsLinkedDetails>
    {
    }

    ///<summary>
    /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
    ///</summary>
public partial interface ITreeControlsTreeControlExtraDetailsLinkedDetails : IReadable
    {
        ///<summary>
        /// Specifies the parameter ID of the table containing the additional information.
        /// If this table has multiple foreign keys, a foreign key column ID can be specified instead.
        ///</summary>
IValueTag<uint?> DetailsTableId { get; }

        ///<summary>
        /// Specifies a column in the main table.
        /// This must be a parameter of type Discreet. The value of this column determines from which other table(s) additional information can be retrieved.
        /// 
        ///</summary>
IValueTag<uint?> DiscreetColumnId { get; }

        ///<summary>
        /// Specifies one of the possible discrete values.
        ///</summary>
IValueTag<string> ValueAttribute { get; }
    }

    ///<summary>
    /// Contains additional tab definitions in the tree control.
    ///</summary>
public partial interface ITreeControlsTreeControlExtraTabs : IReadableList<ITreeControlsTreeControlExtraTabsTab>
    {
    }

    ///<summary>
    /// Defines an additional tab.
    ///</summary>
public partial interface ITreeControlsTreeControlExtraTabsTab : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> Parameter { get; }

        ///<summary>
        /// Specifies the ID of the table this additional tab configuration relates to.
        ///</summary>
IValueTag<uint?> TableId { get; }

        ///<summary>
        /// Specifies the title description of the tab.
        ///</summary>
IValueTag<string> Title { get; }

        ///<summary>
        /// Specifies the tab type.
        ///</summary>
IValueTag<string> Type { get; }
    }

    ///<summary>
    /// Defines the relationship between the (visible) tables.
    /// Rows from these tables will become items in the tree.
    ///</summary>
public partial interface ITreeControlsTreeControlHierarchy : IReadableList<ITreeControlsTreeControlHierarchyTable>
    {
        ///<summary>
        /// When no advanced hierarchy is needed, you can use this attribute to define the table links using a comma-separated list.
        ///</summary>
IValueTag<string> Path { get; }
    }

    ///<summary>
    /// Specifies the table links.
    /// When using a more advanced hierarchy, the table links can be defined using Table tags. In the hierarchy, the path attribute must be omitted or empty.
    ///</summary>
public partial interface ITreeControlsTreeControlHierarchyTable : IReadable
    {
        ///<summary>
        /// Specifies a condition.
        ///</summary>
IValueTag<string> Condition { get; }

        ///<summary>
        /// Specifies the parameter ID of the table that is needed in the tree.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Specifies the parameter ID of the table that is the parent of the table specified in the id attribute.
        ///</summary>
IValueTag<uint?> ParentAttribute { get; }
    }

    ///<summary>
    /// Contains the triggers defined in the protocol.
    /// In a trigger, you define when it should go off, and which actions it should execute.
    ///</summary>
public partial interface ITriggers : IReadableList<ITriggersTrigger>
    {
    }

    ///<summary>
    /// Defines a trigger.
    /// Triggers allow you to define the exact moment at which certain actions have to be executed.
    /// They can, for example, be used to set the exact time at which to perform a copy operation, to calculate a CRC, etc.
    ///</summary>
public partial interface ITriggersTrigger : IReadable
    {
        ///<summary>
        /// Specifies a condition that must be met in order for the trigger to go off.
        ///</summary>
IValueTag<string> Condition { get; }

        ///<summary>
        /// Specifies the actions to be executed, or triggers to be activated the moment the trigger goes off.
        /// Recommendation: Do not include more than 10 items tags.
        ///</summary>
ITriggersTriggerContent Content { get; }

        ///<summary>
        /// Specifies the name of the trigger.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Defines what will set off the trigger. Used together with /Protocol/Triggers/Trigger/Time, which defines the exact moment the trigger has to go off.
        /// This /Protocol/Triggers/Trigger/On element is always used when defining a trigger, except when the trigger has to be activated by another trigger.
        /// In that case, the moment at which the trigger has to go off will already be defined in the initializing trigger. The /Protocol/Triggers/Trigger/Time element will then also be empty.
        ///</summary>
ITriggersTriggerOn On { get; }

        ///<summary>
        /// Defines, together with /Protocol/Triggers/Trigger/On, the exact moment at which a trigger will go off.
        /// Note: Not all /Protocol/Triggers/Trigger/Time values can be used in combination with the different /Protocol/Trig­gers/Trigger/On types.
        /// Refer to the DataMiner Protocol Markup Language documentatio. for an overview of the possible combinations.
        ///</summary>
ITriggersTriggerTime Time { get; }

        ///<summary>
        /// Specifies what should happen when the trigger goes off:
        /// - execute one or more actions, or
        /// - activate one or more triggers.
        ///</summary>
IValueTag<Enums.EnumTriggerType?> Type { get; }

        ///<summary>
        /// Specifies the unique trigger ID.
        ///</summary>
IValueTag<uint?> Id { get; }
    }

    ///<summary>
    /// Specifies the actions to be executed, or triggers to be activated the moment the trigger goes off.
    /// Recommendation: Do not include more than 10 items tags.
    ///</summary>
public partial interface ITriggersTriggerContent : IReadableList<ITriggersTriggerContentId>
    {
    }

    ///<summary>
    /// Specifies the ID of the action to be executed or the trigger to be activated when the trigger goes off.
    ///</summary>
public partial interface ITriggersTriggerContentId : IValueTag<uint?>
    {
        ///<summary>
        /// When a condition has been added to the trigger, the action of which the ID is specified in this attribute will be executed when the condition is not met.
        ///</summary>
IValueTag<bool?> Else { get; }
    }

    ///<summary>
    /// Defines what will set off the trigger. Used together with /Protocol/Triggers/Trigger/Time, which defines the exact moment the trigger has to go off.
    /// This /Protocol/Triggers/Trigger/On element is always used when defining a trigger, except when the trigger has to be activated by another trigger.
    /// In that case, the moment at which the trigger has to go off will already be defined in the initializing trigger. The /Protocol/Triggers/Trigger/Time element will then also be empty.
    ///</summary>
public partial interface ITriggersTriggerOn : IValueTag<Enums.EnumTriggerOn?>
    {
        ///<summary>
        /// Specifies the ID of the parameter, command, response, etc.
        /// If you do not specify an id attribute, the trigger will apply to all items of the type specified in the /Protocol/Triggers/Trigger/On element.
        ///</summary>
IValueTag<string> Id { get; }
    }

    ///<summary>
    /// Defines, together with /Protocol/Triggers/Trigger/On, the exact moment at which a trigger will go off.
    /// Note: Not all /Protocol/Triggers/Trigger/Time values can be used in combination with the different /Protocol/Trig­gers/Trigger/On types.
    /// Refer to the DataMiner Protocol Markup Language documentatio. for an overview of the possible combinations.
    ///</summary>
public partial interface ITriggersTriggerTime : IValueTag<string>
    {
        ///<summary>
        /// Specifies the condition: equal, not equal, greater, less, or a logical combination of those operators.
        ///</summary>
IValueTag<string> Case { get; }

        ///<summary>
        /// The ID of the parameter, command, response, etc. (defined in /Protocol/Triggers/Trigger/On) of which the value will be checked.
        /// If this attribute is omitted, the ID specified in /Protocol/Triggers/Trigger/On will be taken.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// Set this attribute to "true" if the value attribute contains a parameter ID instead of a parameter value.
        ///</summary>
IValueTag<bool?> Nr { get; }

        ///<summary>
        /// Specifies the value that will be used as condition operand.
        ///</summary>
IValueTag<string> ValueAttribute { get; }
    }

    ///<summary>
    /// Specifies the protocol type. In multi-connection protocols, it specifies the type of the main connection.
    ///</summary>
public partial interface IProtocolType : IValueTag<Enums.EnumProtocolType?>
    {
        ///<summary>
        /// Specifies additional connections. This allows you to create e.g. a serial protocol containing some SNMP commands, or a protocol that is capable of communicating with multiple ports.
        /// Protocol types have to be separated by semi-colon (";").
        /// For more information on ports, see:	/Protocol/Ports and /Protocol/Portsettings.
        ///</summary>
IValueTag<string> Advanced { get; }

        ///<summary>
        /// Specifies a number of communication options.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> CommunicationOptions { get; }

        ///<summary>
        /// Specifies a number of database options.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> DatabaseOptions { get; }

        ///<summary>
        /// Specifies a number of options. For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies whether the DVE will go into timeout when the main element is in timeout.
        ///</summary>
IValueTag<bool?> OverrideTimeoutDVE { get; }

        ///<summary>
        /// This attribute can have one of two values:	"true"* and	"true with reset".
        /// *If the /Protocol/Timers/Timer@fixedTimer attribute is also set to "true", then users cannot change the timer interval.
        ///</summary>
IValueTag<Enums.EnumProtocolTypeRelativeTimers?> RelativeTimers { get; }
    }

    ///<summary>
    /// Contains an overview of the version history of this protocol.
    /// Feature introduced in DataMiner 9.5.11 (RN 17697, RN 18360).
    ///</summary>
public partial interface IVersionHistory : IReadable
    {
        ///<summary>
        /// Contains the different branches of this protocol.
        ///</summary>
IVersionHistoryBranches Branches { get; }
    }

    ///<summary>
    /// Contains the different branches of this protocol.
    ///</summary>
public partial interface IVersionHistoryBranches : IReadableList<IVersionHistoryBranchesBranch>
    {
    }

    ///<summary>
    /// Defines a branch of this protocol.
    ///</summary>
public partial interface IVersionHistoryBranchesBranch : IReadable
    {
        ///<summary>
        /// Provides information about this branch.
        ///</summary>
IValueTag<string> Comment { get; }

        ///<summary>
        /// Provides information about the features this branch supports.
        ///</summary>
IVersionHistoryBranchesBranchFeatures Features { get; }

        ///<summary>
        /// Contains the different SystemVersion entries.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersions SystemVersions { get; }

        ///<summary>
        /// The unique ID of the branch version component.
        ///</summary>
IValueTag<uint?> Id { get; }
    }

    ///<summary>
    /// Provides information about the features this branch supports.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchFeatures : IReadableList<IVersionHistoryBranchesBranchFeaturesFeature>
    {
    }

    ///<summary>
    /// Provides information about a specific feature of this branch.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchFeaturesFeature : IValueTag<string>
    {
    }

    ///<summary>
    /// Contains the different SystemVersion entries.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersions : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersion>
    {
    }

    ///<summary>
    /// Defines a SystemVersion entry.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersion : IReadable
    {
        ///<summary>
        /// Provides information about this entry.
        ///</summary>
IValueTag<string> Comment { get; }

        ///<summary>
        /// Contains the different major versions within this branch of this protocol.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions MajorVersions { get; }

        ///<summary>
        /// Specifies the system version support.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions SupportedVersions { get; }

        ///<summary>
        /// The unique ID of the system version component.
        ///</summary>
IValueTag<uint?> Id { get; }
    }

    ///<summary>
    /// Contains the different major versions within this branch of this protocol.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion>
    {
    }

    ///<summary>
    /// Defines a major version of this protocol.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion : IReadable
    {
        ///<summary>
        /// Contains information about the changes.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges Changes { get; }

        ///<summary>
        /// Contains the different minor versions of this protocol within this major version of this protocol.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions MinorVersions { get; }

        ///<summary>
        /// The unique ID of the major version component.
        ///</summary>
IValueTag<uint?> Id { get; }
    }

    ///<summary>
    /// Contains information about the changes.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange>
    {
    }

    ///<summary>
    /// Describes a change.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange : IReadable
    {
        ///<summary>
        /// Describes the impact of this change.
        ///</summary>
IValueTag<string> Impact { get; }

        ///<summary>
        /// Lists the actions to take.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake ActionsToTake { get; }

        ///<summary>
        /// Specifies the major changes this major change covers.
        ///</summary>
IValueTag<string> CoversMajorChanges { get; }
    }

    ///<summary>
    /// Lists the actions to take.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake>
    {
    }

    ///<summary>
    /// Describes an action to take.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake : IValueTag<string>
    {
    }

    ///<summary>
    /// Contains the different minor versions of this protocol within this major version of this protocol.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion>
    {
    }

    ///<summary>
    /// Defines a minor version of this protocol.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion : IReadable
    {
        ///<summary>
        /// Contains information about the changes implemented in this minor version of this protocol.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges Changes { get; }

        ///<summary>
        /// Specifies the date on which this version of this protocol has been released. (Format: YYYY-MM-DD)
        ///</summary>
IValueTag<System.DateTime?> Date { get; }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider Provider { get; }

        ///<summary>
        /// Provides references to e.g. registration systems.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences References { get; }

        ///<summary>
        /// List of all the suppressions for this version.
        ///</summary>
IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions Suppressions { get; }

        ///<summary>
        /// The unique ID of the minor version component.
        ///</summary>
IValueTag<uint?> Id { get; }

        ///<summary>
        /// The version of the protocol on which this protocol is based.
        ///</summary>
IValueTag<string> BasedOn { get; }
    }

    ///<summary>
    /// Contains information about the changes implemented in this minor version of this protocol.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem>
    {
    }

    public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem : IValueTag<string>
    {
    }

    ///<summary>
    /// Describes a fix.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix : IValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem
    {
    }

    ///<summary>
    /// Describes a change.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange : IValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem
    {
    }

    ///<summary>
    /// Describes a new feature.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature : IValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem
    {
    }

    public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider : IReadable
    {
        ///<summary>
        /// Specifies the company providing this version of this protocol.
        ///</summary>
IValueTag<string> Company { get; }

        ///<summary>
        /// Specifies the author of this version of this protocol.
        ///</summary>
IValueTag<string> Author { get; }
    }

    ///<summary>
    /// Provides references to e.g. registration systems.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem>
    {
    }

    public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem : IReadable
    {
    }

    ///<summary>
    /// Provides a reference to a corresponding task.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId : IValueTag<uint?>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem
    {
    }

    ///<summary>
    /// Provides a reference to e.g. a registration system.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference : IValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem
    {
        ///<summary>
        /// Specifies the type of reference.
        ///</summary>
IValueTag<string> Type { get; }
    }

    ///<summary>
    /// List of all the suppressions for this version.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression>
    {
    }

    ///<summary>
    /// A single suppression.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression : IReadable
    {
        ///<summary>
        /// Reason for the suppression.
        ///</summary>
IValueTag<string> Reason { get; }

        ///<summary>
        /// Location of the suppression.
        ///</summary>
IValueTag<string> Location { get; }

        ///<summary>
        /// ID of the result that is being suppressed.
        ///</summary>
IValueTag<string> ResultId { get; }

        ///<summary>
        /// Type of the suppression.
        ///</summary>
IValueTag<Enums.EnumSuppressionType?> Type { get; }

        ///<summary>
        /// Task ID.
        ///</summary>
IValueTag<uint?> TaskId { get; }
    }

    ///<summary>
    /// Specifies the system version support.
    ///</summary>
public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions : IReadableList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion>
    {
    }

    public partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion : IValueTag<string>
    {
        ///<summary>
        /// The minimum system version supported by this protocol range.
        ///</summary>
IValueTag<string> Min { get; }

        ///<summary>
        /// The maximum system version supported by this protocol range.
        ///</summary>
IValueTag<string> Max { get; }
    }

    ///<summary>
    /// Defines a table column. Each table column is defined by one or two parameters: one for read, and/or one for write.
    ///</summary>
public partial interface ITypeColumnOption : IReadable
    {
        ///<summary>
        /// Sets the alignment of KPI values in a CPE interface.
        /// Default value: right.
        /// Feature introduced in DataMiner 8.5.4.3 (RN 9430).
        ///</summary>
IValueTag<Enums.EnumCpeAlignment?> CpeAlignment { get; }

        ///<summary>
        /// Defines the (0-based) position of the column in the table.
        /// Note: The ColumnOption elements have to be defined in order of their idx attribute.
        ///</summary>
IValueTag<uint?> Idx { get; }

        ///<summary>
        /// Defines different options.
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        /// Note: In this attribute, you can specify multiple values separated by a character of choice (a semicolon is recommended).
        /// This character has to be the first character in the value of the options attribute.
        /// If, for example, you want to separate the different options by a semi-colon, the first character of the options value has to be a semi-colon.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the parameter ID of the column data.
        ///</summary>
IValueTag<uint?> Pid { get; }

        ///<summary>
        /// Specifies the polling rate of this column (in ms).
        /// Feature introduced in DataMiner 9.5.6 (RN 16411).
        /// Refer to the DataMiner Protocol Markup Language documentation for more information.
        ///</summary>
IValueTag<uint?> PollingRate { get; }

        ///<summary>
        /// Specifies column type options. For more information on the values allowed in this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
IValueTag<Enums.EnumColumnOptionType?> Type { get; }

        ///<summary>
        /// The interpretation of this attribute depends on the value of the "type" attribute:
        /// -	If type is "concatenation", then value is the comma-separated list of the indexes of the columns to be concatenated.
        /// -	If type is "autoincrement", then value is the offset for the automatic increment of the indexes.
        ///</summary>
IValueTag<string> ValueAttribute { get; }
    }

    ///<summary>
    /// Represents export rules.
    ///</summary>
public partial interface IExportRules : IReadableList<IExportRulesExportRule>
    {
    }

    ///<summary>
    /// Defines a rule that are used for changing the displayed items in a Dynamic Virtual Element (DVE), for example changing the location of a parameter.
    ///</summary>
public partial interface IExportRulesExportRule : IReadable
    {
        ///<summary>
        /// Specifies the attribute of the XML element specified in the "tag" attribute on which to apply this rule.
        ///</summary>
IValueTag<string> Attribute { get; }

        ///<summary>
        /// Specifies the name of the export rule.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies a regular expression to match particular values.
        ///</summary>
IValueTag<string> Regex { get; }

        ///<summary>
        /// Specifies the ID of table parameter that will generate the DVEs.
        ///</summary>
IValueTag<string> Table { get; }

        ///<summary>
        /// Specifies the XML element on which to apply this rule.
        ///</summary>
IValueTag<string> Tag { get; }

        ///<summary>
        /// Specifies the value that needs to be set.
        ///</summary>
IValueTag<string> ValueAttribute { get; }

        ///<summary>
        /// Specifies, together with the whereTag and whereValue attributes, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
IValueTag<string> WhereAttribute { get; }

        ///<summary>
        /// Specifies, together with the whereValue attribute, and optionally the whereAttribute attribute, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
IValueTag<string> WhereTag { get; }

        ///<summary>
        /// Specifies, together with the whereTag attribute, and optionally the whereAttribute attribute, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
IValueTag<string> WhereValue { get; }
    }

    ///<summary>
    /// Specifies the request data to be sent.
    /// Alternatively, you can put this data in parameters, which you should then specify in the Parameters element.
    ///</summary>
public partial interface IHttpRequestData : IValueTag<string>
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the data to be sent.
        /// Note: either use this attribute (and provide the data to be sent in the referred parameter) or specify the data to be sent in Data (e.g. &lt;Data&gt;data&lt;/Data&gt;.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies additional headers that need to be sent as part of the HTTP request.
    ///</summary>
public partial interface IHttpRequestHeaders : IReadableList<IHttpRequestHeadersHeader>
    {
    }

    ///<summary>
    /// Specifies a parameter of which the contents will be put in one of the headers of the HTTP request.
    /// Via HTTP, this has to be done by means of key/value pairs.
    ///</summary>
public partial interface IHttpRequestHeadersHeader : IValueTag<string>
    {
        ///<summary>
        /// Specifies the key of the key/value pair.
        ///</summary>
IValueTag<string> Key { get; }

        ///<summary>
        /// Specifies the ID of the parameter that contains the value to be put in the header.&lt;BR /&gt;
        /// If you do not specify the pid attribute, you have to provide a fixed value in the Header element.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// If you do not want to specify a fixed block of data in Data, but rather a number of parameters containing the data to be sent, then use this element to define the list of parameters of which you want the contents to be sent in the HTTP request.
    ///</summary>
public partial interface IHttpRequestParameters : IReadableList<IHttpRequestParametersParameter>
    {
    }

    ///<summary>
    /// Specifies a parameter of which you want its content to be included in the HTTP request.
    /// Via HTTP, this has to be done by means of key/value pairs.
    ///</summary>
public partial interface IHttpRequestParametersParameter : IValueTag<string>
    {
        ///<summary>
        /// Specifies the key of the key/value pair.
        ///</summary>
IValueTag<string> Key { get; }

        ///<summary>
        /// Specifies the ID of the parameter that contains the value to be sent.&lt;BR /&gt;
        /// If you do not specify the pid attribute, you have to provide a value in the Parameter element.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Represents an icon.
    ///</summary>
public partial interface IIcon : IValueTag<string>
    {
        ///<summary>
        /// Specifies the key of the icon as defined in the Icons.xml file.
        /// Using this attribute in a table or table column parameter will display an icon in the tree control.
        ///</summary>
IValueTag<Enums.EnumIcons?> Ref { get; }
    }

    ///<summary>
    /// Defines a ping interval.
    ///</summary>
public partial interface IPingInterval : IReadable
    {
        ///<summary>
        /// Specifies the default ping interval in milliseconds. The specified value must be in the range [1000,300000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the ping interval can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Defines a slow poll configuration.
    ///</summary>
public partial interface ISlowPoll : IReadable
    {
        ///<summary>
        /// Specifies the default slow poll settings.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the slow poll settings can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Defines a slow poll base.
    ///</summary>
public partial interface ISlowPollBase : IReadable
    {
        ///<summary>
        /// Specifies the default slow poll base.
        ///</summary>
IValueTag<Enums.EnumTypePortSlowPollBase?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the slow poll settings can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Defines user settings.
    ///</summary>
public partial interface ITypeUserSettings : IReadable
    {
        ITypeUserSettingsValues Values { get; }

        IValueTag<string> DefaultValue { get; }

        IValueTag<bool?> Disabled { get; }

        ITypeUserSettingsRange Range { get; }
    }

    public partial interface ITypeUserSettingsValues : IReadableList<ITypeUserSettingsValuesValue>
    {
    }

    public partial interface ITypeUserSettingsValuesValue : IValueTag<string>
    {
    }

    public partial interface ITypeUserSettingsRange : IReadable
    {
        IValueTag<string> From { get; }

        IValueTag<string> To { get; }
    }

    ///<summary>
    /// Defines port settings.
    ///</summary>
public partial interface IPortSettings : IReadable
    {
        ///<summary>
        /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
IPortSettingsBaudrate Baudrate { get; }

        ///<summary>
        /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
IPortSettingsBusAddress BusAddress { get; }

        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
IPortSettingsDatabits Databits { get; }

        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
IPortSettingsFlowcontrol Flowcontrol { get; }

        ///<summary>
        /// When set to true, any datagram received on the connection will be forwarded to SLProtocol immediately, which will then store it in the response parameter. Only applicable for a smart-serial UDP connection.
        ///</summary>
IValueTag<bool?> FlushPerDatagram { get; }

        ///<summary>
        /// Specifies the GetCommunity string of an SNMP protocol.
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
IPortSettingsGetCommunity GetCommunity { get; }

        ///<summary>
        /// Specifies the IP port configuration.
        ///</summary>
IPortSettingsIPport IPport { get; }

        ///<summary>
        /// Specifies the local IP port configuration.
        ///</summary>
IPortSettingsLocalIPport LocalIPport { get; }

        ///<summary>
        /// Allows to limit parity settings and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
IPortSettingsParity Parity { get; }

        ///<summary>
        /// Configures the ping interval.
        ///</summary>
IPingInterval PingInterval { get; }

        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
IPortSettingsPortTypeIP PortTypeIP { get; }

        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
IPortSettingsPortTypeSerial PortTypeSerial { get; }

        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
IPortSettingsPortTypeUDP PortTypeUDP { get; }

        ///<summary>
        /// Configures the number of retries.
        ///</summary>
IPortSettingsRetries Retries { get; }

        ///<summary>
        /// Specifies the SNMP set community string.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
IPortSettingsSetCommunity SetCommunity { get; }

        ///<summary>
        /// Specifies the SSH settings (only applicable for serial connections of type TCP).
        /// Feature introduced in DataMiner 9.5.9 (RN 17732).
        ///</summary>
IPortSettingsSSH SSH { get; }

        ///<summary>
        /// Specifies the stop bits settings.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
IPortSettingsStopbits Stopbits { get; }

        ///<summary>
        /// Specifies settings related to the element timeout.
        ///</summary>
IPortSettingsTimeoutTimeElement TimeoutTimeElement { get; }

        ///<summary>
        /// Specifies settings related to the timeout of a command/request.
        ///</summary>
IPortSettingsTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
IPortSettingsType Type { get; }

        ///<summary>
        /// Specifies the name of the additional protocol type as specified in the advanced attribute of the /Protocol/Type element.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// If set to “false”, users cannot see or change the port settings for this additional protocol type when creating or editing an element.
        ///</summary>
IValueTag<bool?> VisibleInUi { get; }
    }

    ///<summary>
    /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial interface IPortSettingsBaudrate : IReadableList<IPortSettingsBaudrateValue>
    {
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
IPortSettingsBaudrateDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsBaudrateDisabled Disabled { get; }

        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
IPortSettingsBaudrateRange Range { get; }
    }

    ///<summary>
    /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
    ///</summary>
public partial interface IPortSettingsBaudrateDefaultValue : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Specifies whether the baud rate can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsBaudrateDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
public partial interface IPortSettingsBaudrateRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
IValueTag<uint?> From { get; }

        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
IValueTag<uint?> To { get; }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
public partial interface IPortSettingsBaudrateValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial interface IPortSettingsBusAddress : IReadableList<IPortSettingsBusAddressValue>
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IPortSettingsBusAddressDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsBusAddressDisabled Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IPortSettingsBusAddressRange Range { get; }
    }

    ///<summary>
    /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
    /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
    ///</summary>
public partial interface IPortSettingsBusAddressDefaultValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies whether the bus address can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsBusAddressDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IPortSettingsBusAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IPortSettingsBusAddressValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
public partial interface IPortSettingsDatabits : IReadableList<IPortSettingsDatabitsValue>
    {
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
IPortSettingsDatabitsDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsDatabitsDisabled Disabled { get; }

        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
IPortSettingsDatabitsRange Range { get; }
    }

    ///<summary>
    /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
    ///</summary>
public partial interface IPortSettingsDatabitsDefaultValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies whether the databits can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsDatabitsDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
public partial interface IPortSettingsDatabitsRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
IValueTag<uint?> From { get; }

        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
IValueTag<uint?> To { get; }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IPortSettingsDatabitsValue : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
public partial interface IPortSettingsFlowcontrol : IReadableList<IPortSettingsFlowcontrolValue>
    {
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
IPortSettingsFlowcontrolDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsFlowcontrolDisabled Disabled { get; }

        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
IPortSettingsFlowcontrolRange Range { get; }
    }

    ///<summary>
    /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
    ///</summary>
public partial interface IPortSettingsFlowcontrolDefaultValue : IValueTag<Enums.EnumPortSettingsFlowControl?>
    {
    }

    ///<summary>
    /// Specifies whether the flow control can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsFlowcontrolDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
public partial interface IPortSettingsFlowcontrolRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsFlowControl?> From { get; }

        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsFlowControl?> To { get; }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IPortSettingsFlowcontrolValue : IValueTag<Enums.EnumPortSettingsFlowControl?>
    {
    }

    ///<summary>
    /// Specifies the GetCommunity string of an SNMP protocol.
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
public partial interface IPortSettingsGetCommunity : IReadable
    {
        ///<summary>
        /// Specifies the default value of the GetCommunity string that will be used in the DataMiner user interface for SNMP protocols.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the get community string can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the IP port configuration.
    ///</summary>
public partial interface IPortSettingsIPport : IReadable
    {
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the port number can be configured via the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the local IP port configuration.
    ///</summary>
public partial interface IPortSettingsLocalIPport : IReadable
    {
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the local port number can be configured via the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Allows to limit parity settings and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
public partial interface IPortSettingsParity : IReadableList<IPortSettingsParityValue>
    {
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
IPortSettingsParityDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsParityDisabled Disabled { get; }

        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
IPortSettingsParityRange Range { get; }
    }

    ///<summary>
    /// Specifies the default parity.
    ///</summary>
public partial interface IPortSettingsParityDefaultValue : IValueTag<Enums.EnumPortSettingsParity?>
    {
    }

    ///<summary>
    /// Specifies whether the parity can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsParityDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
public partial interface IPortSettingsParityRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsParity?> From { get; }

        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsParity?> To { get; }
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
public partial interface IPortSettingsParityValue : IValueTag<Enums.EnumPortSettingsParity?>
    {
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
public partial interface IPortSettingsPortTypeIP : IReadable
    {
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
public partial interface IPortSettingsPortTypeSerial : IReadable
    {
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
public partial interface IPortSettingsPortTypeUDP : IReadable
    {
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the number of retries.
    ///</summary>
public partial interface IPortSettingsRetries : IReadable
    {
        ///<summary>
        /// Specifies the default value for the maximum number of times that a request will be re-sent.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the maximum number of retries can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the SNMP set community string.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
public partial interface IPortSettingsSetCommunity : IReadable
    {
        ///<summary>
        /// Specifies the default value of the SNMP set community string that will be used.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the SetCommunity string can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the SSH settings (only applicable for serial connections of type TCP).
    /// Feature introduced in DataMiner 9.5.9 (RN 17732).
    ///</summary>
public partial interface IPortSettingsSSH : IReadable
    {
        ///<summary>
        /// Specifies the SSH credentials.
        ///</summary>
IPortSettingsSSHCredentials Credentials { get; }

        ///<summary>
        /// Specifies the identity settings.
        ///</summary>
IPortSettingsSSHIdentity Identity { get; }
    }

    ///<summary>
    /// Specifies the SSH credentials.
    ///</summary>
public partial interface IPortSettingsSSHCredentials : IReadable
    {
        ///<summary>
        /// Specifies the user name.
        ///</summary>
IPortSettingsSSHCredentialsUsername Username { get; }

        ///<summary>
        /// Specifies the password.
        ///</summary>
IPortSettingsSSHCredentialsPassword Password { get; }
    }

    ///<summary>
    /// Specifies the user name.
    ///</summary>
public partial interface IPortSettingsSSHCredentialsUsername : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the user name.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies the password.
    ///</summary>
public partial interface IPortSettingsSSHCredentialsPassword : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the password.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies the identity settings.
    ///</summary>
public partial interface IPortSettingsSSHIdentity : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the identity info.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies the stop bits settings.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
public partial interface IPortSettingsStopbits : IReadableList<IPortSettingsStopbitsValue>
    {
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
IPortSettingsStopbitsDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsStopbitsDisabled Disabled { get; }
    }

    ///<summary>
    /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
    /// Set the default to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial interface IPortSettingsStopbitsDefaultValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsStopbitsDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial interface IPortSettingsStopbitsValue : IValueTag<Enums.EnumPortSettingsStopBits?>
    {
    }

    ///<summary>
    /// Specifies settings related to the element timeout.
    ///</summary>
public partial interface IPortSettingsTimeoutTimeElement : IReadable
    {
        ///<summary>
        /// Specifies the default element timeout value (in milliseconds). The specified value must be in the range [1000, 120000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the element timeout time for this connection can be configured via the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the timeout of a command/request.
    ///</summary>
public partial interface IPortSettingsTimeoutTime : IReadable
    {
        ///<summary>
        /// Specifies the default timeout value (in milliseconds).
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the timeout value can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
public partial interface IPortSettingsType : IReadable
    {
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
IValueTag<Enums.EnumPortTypes?> DefaultValue { get; }
    }

    ///<summary>
    /// Defines main port settings.
    ///</summary>
public partial interface IPortSettingsMain : IReadable
    {
        ///<summary>
        /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
IPortSettingsMainBaudrate Baudrate { get; }

        ///<summary>
        /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
IPortSettingsMainBusAddress BusAddress { get; }

        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
IPortSettingsMainDatabits Databits { get; }

        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
IPortSettingsMainFlowcontrol Flowcontrol { get; }

        ///<summary>
        /// When set to true, any datagram received on the connection will be forwarded to SLProtocol immediately, which will then store it in the response parameter. Only applicable for a smart-serial UDP connection.
        ///</summary>
IValueTag<bool?> FlushPerDatagram { get; }

        ///<summary>
        /// Specifies the GetCommunity string of an SNMP protocol.
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
IPortSettingsMainGetCommunity GetCommunity { get; }

        ///<summary>
        /// Specifies the IP port configuration.
        ///</summary>
IPortSettingsMainIPport IPport { get; }

        ///<summary>
        /// Specifies the local IP port configuration.
        ///</summary>
IPortSettingsMainLocalIPport LocalIPport { get; }

        ///<summary>
        /// Allows to limit parity settings and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
IPortSettingsMainParity Parity { get; }

        ///<summary>
        /// Configures the ping interval.
        ///</summary>
IPingInterval PingInterval { get; }

        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
IPortSettingsMainPortTypeIP PortTypeIP { get; }

        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
IPortSettingsMainPortTypeSerial PortTypeSerial { get; }

        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
IPortSettingsMainPortTypeUDP PortTypeUDP { get; }

        ///<summary>
        /// Configures the number of retries.
        ///</summary>
IPortSettingsMainRetries Retries { get; }

        ///<summary>
        /// Specifies the SNMP set community string.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
IPortSettingsMainSetCommunity SetCommunity { get; }

        ///<summary>
        /// Specifies the slow poll configuration.
        ///</summary>
ISlowPoll SlowPoll { get; }

        ///<summary>
        /// Specifies the slow poll base settings.
        ///</summary>
ISlowPollBase SlowPollBase { get; }

        ///<summary>
        /// Specifies the SSH settings (only applicable for serial connections of type TCP).
        /// Feature introduced in DataMiner 9.5.9 (RN 17732).
        ///</summary>
IPortSettingsMainSSH SSH { get; }

        ///<summary>
        /// Specifies the stop bits settings.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
IPortSettingsMainStopbits Stopbits { get; }

        ///<summary>
        /// Specifies settings related to the element timeout.
        ///</summary>
IPortSettingsMainTimeoutTimeElement TimeoutTimeElement { get; }

        ///<summary>
        /// Specifies settings related to the timeout of a command/request.
        ///</summary>
IPortSettingsMainTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
IPortSettingsMainType Type { get; }

        ///<summary>
        /// Specifies the name of the additional protocol type as specified in the advanced attribute of the /Protocol/Type element.
        ///</summary>
IValueTag<string> Name { get; }
    }

    ///<summary>
    /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial interface IPortSettingsMainBaudrate : IReadableList<IPortSettingsMainBaudrateValue>
    {
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
IPortSettingsMainBaudrateDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsMainBaudrateDisabled Disabled { get; }

        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
IPortSettingsMainBaudrateRange Range { get; }
    }

    ///<summary>
    /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
    ///</summary>
public partial interface IPortSettingsMainBaudrateDefaultValue : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Specifies whether the baud rate can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsMainBaudrateDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
public partial interface IPortSettingsMainBaudrateRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
IValueTag<uint?> From { get; }

        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
IValueTag<uint?> To { get; }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
public partial interface IPortSettingsMainBaudrateValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial interface IPortSettingsMainBusAddress : IReadableList<IPortSettingsMainBusAddressValue>
    {
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IPortSettingsMainBusAddressDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsMainBusAddressDisabled Disabled { get; }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
IPortSettingsMainBusAddressRange Range { get; }
    }

    ///<summary>
    /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
    /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
    ///</summary>
public partial interface IPortSettingsMainBusAddressDefaultValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies whether the bus address can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsMainBusAddressDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial interface IPortSettingsMainBusAddressRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IPortSettingsMainBusAddressValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
public partial interface IPortSettingsMainDatabits : IReadableList<IPortSettingsMainDatabitsValue>
    {
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
IPortSettingsMainDatabitsDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsMainDatabitsDisabled Disabled { get; }

        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
IPortSettingsMainDatabitsRange Range { get; }
    }

    ///<summary>
    /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
    ///</summary>
public partial interface IPortSettingsMainDatabitsDefaultValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies whether the databits can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsMainDatabitsDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
public partial interface IPortSettingsMainDatabitsRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
IValueTag<uint?> From { get; }

        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
IValueTag<uint?> To { get; }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IPortSettingsMainDatabitsValue : IValueTag<uint?>
    {
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
public partial interface IPortSettingsMainFlowcontrol : IReadableList<IPortSettingsMainFlowcontrolValue>
    {
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
IPortSettingsMainFlowcontrolDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsMainFlowcontrolDisabled Disabled { get; }

        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
IPortSettingsMainFlowcontrolRange Range { get; }
    }

    ///<summary>
    /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
    ///</summary>
public partial interface IPortSettingsMainFlowcontrolDefaultValue : IValueTag<Enums.EnumPortSettingsFlowControl?>
    {
    }

    ///<summary>
    /// Specifies whether the flow control can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsMainFlowcontrolDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
public partial interface IPortSettingsMainFlowcontrolRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsFlowControl?> From { get; }

        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsFlowControl?> To { get; }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial interface IPortSettingsMainFlowcontrolValue : IValueTag<Enums.EnumPortSettingsFlowControl?>
    {
    }

    ///<summary>
    /// Specifies the GetCommunity string of an SNMP protocol.
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
public partial interface IPortSettingsMainGetCommunity : IReadable
    {
        ///<summary>
        /// Specifies the default value of the GetCommunity string that will be used in the DataMiner user interface for SNMP protocols.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the get community string can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the IP port configuration.
    ///</summary>
public partial interface IPortSettingsMainIPport : IReadable
    {
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the port number can be configured via the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the local IP port configuration.
    ///</summary>
public partial interface IPortSettingsMainLocalIPport : IReadable
    {
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the local port number can be configured via the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Allows to limit parity settings and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
public partial interface IPortSettingsMainParity : IReadableList<IPortSettingsMainParityValue>
    {
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
IPortSettingsMainParityDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsMainParityDisabled Disabled { get; }

        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
IPortSettingsMainParityRange Range { get; }
    }

    ///<summary>
    /// Specifies the default parity.
    ///</summary>
public partial interface IPortSettingsMainParityDefaultValue : IValueTag<Enums.EnumPortSettingsParity?>
    {
    }

    ///<summary>
    /// Specifies whether the parity can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsMainParityDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
public partial interface IPortSettingsMainParityRange : IReadable
    {
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsParity?> From { get; }

        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
IValueTag<Enums.EnumPortSettingsParity?> To { get; }
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
public partial interface IPortSettingsMainParityValue : IValueTag<Enums.EnumPortSettingsParity?>
    {
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
public partial interface IPortSettingsMainPortTypeIP : IReadable
    {
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
public partial interface IPortSettingsMainPortTypeSerial : IReadable
    {
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
public partial interface IPortSettingsMainPortTypeUDP : IReadable
    {
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Configures the number of retries.
    ///</summary>
public partial interface IPortSettingsMainRetries : IReadable
    {
        ///<summary>
        /// Specifies the default value for the maximum number of times that a request will be re-sent.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the maximum number of retries can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the SNMP set community string.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
public partial interface IPortSettingsMainSetCommunity : IReadable
    {
        ///<summary>
        /// Specifies the default value of the SNMP set community string that will be used.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the SetCommunity string can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the SSH settings (only applicable for serial connections of type TCP).
    /// Feature introduced in DataMiner 9.5.9 (RN 17732).
    ///</summary>
public partial interface IPortSettingsMainSSH : IReadable
    {
        ///<summary>
        /// Specifies the SSH credentials.
        ///</summary>
IPortSettingsMainSSHCredentials Credentials { get; }

        ///<summary>
        /// Specifies the identity settings.
        ///</summary>
IPortSettingsMainSSHIdentity Identity { get; }
    }

    ///<summary>
    /// Specifies the SSH credentials.
    ///</summary>
public partial interface IPortSettingsMainSSHCredentials : IReadable
    {
        ///<summary>
        /// Specifies the user name.
        ///</summary>
IPortSettingsMainSSHCredentialsUsername Username { get; }

        ///<summary>
        /// Specifies the password.
        ///</summary>
IPortSettingsMainSSHCredentialsPassword Password { get; }
    }

    ///<summary>
    /// Specifies the user name.
    ///</summary>
public partial interface IPortSettingsMainSSHCredentialsUsername : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the user name.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies the password.
    ///</summary>
public partial interface IPortSettingsMainSSHCredentialsPassword : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the password.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies the identity settings.
    ///</summary>
public partial interface IPortSettingsMainSSHIdentity : IReadable
    {
        ///<summary>
        /// Specifies the ID of the parameter that holds the identity info.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies the stop bits settings.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
public partial interface IPortSettingsMainStopbits : IReadableList<IPortSettingsMainStopbitsValue>
    {
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
IPortSettingsMainStopbitsDefaultValue DefaultValue { get; }

        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
IPortSettingsMainStopbitsDisabled Disabled { get; }
    }

    ///<summary>
    /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
    /// Set the default to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial interface IPortSettingsMainStopbitsDefaultValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
    ///</summary>
public partial interface IPortSettingsMainStopbitsDisabled : IValueTag<bool?>
    {
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial interface IPortSettingsMainStopbitsValue : IValueTag<Enums.EnumPortSettingsStopBits?>
    {
    }

    ///<summary>
    /// Specifies settings related to the element timeout.
    ///</summary>
public partial interface IPortSettingsMainTimeoutTimeElement : IReadable
    {
        ///<summary>
        /// Specifies the default element timeout value (in milliseconds). The specified value must be in the range [1000, 120000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the element timeout time for this connection can be configured via the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the timeout of a command/request.
    ///</summary>
public partial interface IPortSettingsMainTimeoutTime : IReadable
    {
        ///<summary>
        /// Specifies the default timeout value (in milliseconds).
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the timeout value can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
public partial interface IPortSettingsMainType : IReadable
    {
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
IValueTag<Enums.EnumPortTypes?> DefaultValue { get; }
    }

    ///<summary>
    /// Defines port settings with values.
    ///</summary>
public partial interface IPortSettingsWithValues : IReadable
    {
        ///<summary>
        /// This tag allows you to limit the baud rate settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
IPortSettingsWithValuesBaudrate Baudrate { get; }

        ///<summary>
        /// This tag allows you to limit the bus address settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
IPortSettingsWithValuesBusAddress BusAddress { get; }

        ///<summary>
        /// This tag allows you to specify the possible databits settings, and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
IPortSettingsWithValuesDatabits Databits { get; }

        ///<summary>
        /// This tag allows you to specify the possible flow control settings, and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
IPortSettingsWithValuesFlowcontrol Flowcontrol { get; }

        ///<summary>
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
IPortSettingsWithValuesGetCommunity GetCommunity { get; }

        ///<summary>
        /// Specifies settings related to the port.
        ///</summary>
IPortSettingsWithValuesIPport IPport { get; }

        ///<summary>
        /// Specifies settings related to the local port.
        ///</summary>
IPortSettingsWithValuesLocalIPport LocalIPport { get; }

        ///<summary>
        /// This tag allows you to specify the possible parity settings, and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
IPortSettingsWithValuesParity Parity { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IPingInterval PingInterval { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IPortSettingsWithValuesPortTypeIP PortTypeIP { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IPortSettingsWithValuesPortTypeSerial PortTypeSerial { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IPortSettingsWithValuesPortTypeUDP PortTypeUDP { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IPortSettingsWithValuesRetries Retries { get; }

        ///<summary>
        /// SetCommunity string for SNMP and SNMPv2 communication.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
IPortSettingsWithValuesSetCommunity SetCommunity { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
ISlowPoll SlowPoll { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
ISlowPoll SlowPollBase { get; }

        ///<summary>
        /// This tag allows you to specify the possible stopbits settings, and to define a default value.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
IPortSettingsWithValuesStopbits Stopbits { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
ISlowPoll TimeoutTimeElement { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IPortSettingsWithValuesTimeoutTime TimeoutTime { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IPortSettingsWithValuesType Type { get; }

        ///<summary>
        /// Name of the port to which the port settings apply
        /// OR
        /// The name of the additional Protocol type as specified in the /Protocol/Type@advanced attribute.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// If you set this attribute to "false", users cannot see or change the port settings for this additional protocol type when creating or editing an element.
        ///</summary>
IValueTag<bool?> VisibleInUi { get; }
    }

    ///<summary>
    /// This tag allows you to limit the baud rate settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial interface IPortSettingsWithValuesBaudrate : IReadable
    {
        ///<summary>
        /// This tag can be used to define a default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// This tag allows you to define a range of possible baud rate settings.
        ///</summary>
IPortSettingsWithValuesBaudrateRange Range { get; }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
IPortSettingsWithValuesBaudrateValues Values { get; }
    }

    ///<summary>
    /// This tag allows you to define a range of possible baud rate settings.
    ///</summary>
public partial interface IPortSettingsWithValuesBaudrateRange : IReadable
    {
        ///<summary>
        /// In this tag, you can specify the first of a range of baud rates.
        ///</summary>
IValueTag<uint?> From { get; }

        ///<summary>
        /// In this tag, you can specify the last of a range of baud rates.
        ///</summary>
IValueTag<uint?> To { get; }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial interface IPortSettingsWithValuesBaudrateValues : IReadable
    {
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
IValueTag<string> ValueElement { get; }
    }

    ///<summary>
    /// This tag allows you to limit the bus address settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial interface IPortSettingsWithValuesBusAddress : IReadable
    {
        ///<summary>
        /// This tag can be used to define a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// This tag allows you to define a range of possible bus addresses.
        ///</summary>
IPortSettingsWithValuesBusAddressRange Range { get; }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
IPortSettingsWithValuesBusAddressValues Values { get; }
    }

    ///<summary>
    /// This tag allows you to define a range of possible bus addresses.
    ///</summary>
public partial interface IPortSettingsWithValuesBusAddressRange : IReadable
    {
        ///<summary>
        /// In this tag, you can specify the first of a range of bus addresses.
        ///</summary>
IValueTag<string> From { get; }

        ///<summary>
        /// In this tag, you can specify the last of a range of bus addresses.
        ///</summary>
IValueTag<string> To { get; }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial interface IPortSettingsWithValuesBusAddressValues : IReadable
    {
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
IValueTag<string> ValueElement { get; }
    }

    ///<summary>
    /// This tag allows you to specify the possible databits settings, and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
public partial interface IPortSettingsWithValuesDatabits : IReadable
    {
        ///<summary>
        /// This tag can be used to define a default databits value. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// This tag allows you to define a range of possible databits settings.
        ///</summary>
IPortSettingsWithValuesDatabitsRange Range { get; }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
IPortSettingsWithValuesDatabitsValues Values { get; }
    }

    ///<summary>
    /// This tag allows you to define a range of possible databits settings.
    ///</summary>
public partial interface IPortSettingsWithValuesDatabitsRange : IReadable
    {
        ///<summary>
        /// In this tag, you can specify the first of a range of databits settings.
        ///</summary>
IValueTag<uint?> From { get; }

        ///<summary>
        /// In this tag, you can specify the last of a range of databits settings.
        ///</summary>
IValueTag<uint?> To { get; }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial interface IPortSettingsWithValuesDatabitsValues : IReadable
    {
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not need to defined here again.
        /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
IValueTag<string> ValueElement { get; }
    }

    ///<summary>
    /// This tag allows you to specify the possible flow control settings, and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
public partial interface IPortSettingsWithValuesFlowcontrol : IReadable
    {
        ///<summary>
        /// This tag can be used to define a default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
IPortSettingsWithValuesFlowcontrolValues Values { get; }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial interface IPortSettingsWithValuesFlowcontrolValues : IReadable
    {
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
IValueTag<string> ValueElement { get; }
    }

    ///<summary>
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
public partial interface IPortSettingsWithValuesGetCommunity : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the port.
    ///</summary>
public partial interface IPortSettingsWithValuesIPport : IReadable
    {
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the user is be able to set the port number.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// Specifies settings related to the local port.
    ///</summary>
public partial interface IPortSettingsWithValuesLocalIPport : IReadable
    {
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// Specifies whether the user is able to set the local port number.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// This tag allows you to specify the possible parity settings, and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
public partial interface IPortSettingsWithValuesParity : IReadable
    {
        ///<summary>
        /// This tag can be used to define a default parity. Each time a user adds an Element using the Element wizard, the parity will by default be set to this value.
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
IPortSettingsWithValuesParityValues Values { get; }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial interface IPortSettingsWithValuesParityValues : IReadable
    {
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
IValueTag<string> ValueElement { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IPortSettingsWithValuesPortTypeIP : IReadable
    {
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'TCP/IP'.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IPortSettingsWithValuesPortTypeSerial : IReadable
    {
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'serial'.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IPortSettingsWithValuesPortTypeUDP : IReadable
    {
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'UDP/IP'.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IPortSettingsWithValuesRetries : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// SetCommunity string for SNMP and SNMPv2 communication.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
public partial interface IPortSettingsWithValuesSetCommunity : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// This tag allows you to specify the possible stopbits settings, and to define a default value.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
public partial interface IPortSettingsWithValuesStopbits : IReadable
    {
        ///<summary>
        /// This tag can be used to define a default stopbits value. Each time a user adds an Element using the Element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values:	1, 1.5 or 2
        ///</summary>
IValueTag<string> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
IPortSettingsWithValuesStopbitsValues Values { get; }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial interface IPortSettingsWithValuesStopbitsValues : IReadable
    {
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
IValueTag<string> ValueElement { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IPortSettingsWithValuesTimeoutTime : IReadable
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<uint?> DefaultValue { get; }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
IValueTag<bool?> Disabled { get; }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial interface IPortSettingsWithValuesType : IReadable
    {
        ///<summary>
        /// In this tag, specify which port type should be preselected.
        ///</summary>
IValueTag<Enums.EnumPortTypes?> DefaultValue { get; }
    }

    ///<summary>
    /// Specifies how a cell in a CPE topology is linked to another cell in that topology, using foreign key relations (which can also be inside the same table).
    ///</summary>
public partial interface ITypeTopologyCellLink : IReadable
    {
        ///<summary>
        /// (CPE) Specifies the ID of the parameter column if you want to make a topology with foreign key relations inside a table.
        ///</summary>
IValueTag<uint?> Dest { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<uint?> Source { get; }
    }

    ///<summary>
    /// Configures chain display settings.
    ///</summary>
public partial interface ITypeChainsChainDisplay : IReadable
    {
        ITypeChainsChainDisplayVisibility Visibility { get; }
    }

    public partial interface ITypeChainsChainDisplayVisibility : IReadableList<ITypeChainsChainDisplayVisibilityStandalone>
    {
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
IValueTag<bool?> Default { get; }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial interface ITypeChainsChainDisplayVisibilityStandalone : IReadableList<ITypeChainsChainDisplayVisibilityStandaloneValue>
    {
        IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial interface ITypeChainsChainDisplayVisibilityStandaloneValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures chain display settings.
    ///</summary>
public partial interface ITypeChainsSearchChainDisplay : IReadable
    {
        ITypeChainsSearchChainDisplayVisibility Visibility { get; }
    }

    public partial interface ITypeChainsSearchChainDisplayVisibility : IReadableList<ITypeChainsSearchChainDisplayVisibilityStandalone>
    {
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
IValueTag<bool?> Default { get; }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial interface ITypeChainsSearchChainDisplayVisibilityStandalone : IReadableList<ITypeChainsSearchChainDisplayVisibilityStandaloneValue>
    {
        IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial interface ITypeChainsSearchChainDisplayVisibilityStandaloneValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Configures chain field display settings.
    ///</summary>
public partial interface ITypeChainsChainFieldDisplay : IReadable
    {
        ITypeChainsChainFieldDisplaySelection Selection { get; }
    }

    public partial interface ITypeChainsChainFieldDisplaySelection : IReadable
    {
        ITypeChainsChainFieldDisplaySelectionVisibility Visibility { get; }
    }

    public partial interface ITypeChainsChainFieldDisplaySelectionVisibility : IReadableList<ITypeChainsChainFieldDisplaySelectionVisibilityStandalone>
    {
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
IValueTag<bool?> Default { get; }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial interface ITypeChainsChainFieldDisplaySelectionVisibilityStandalone : IReadableList<ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue>
    {
        IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial interface ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Defines a field to be included in this tab of the search chain.
    ///</summary>
public partial interface ITypeChainsSearchChainTabsTabField : IReadable
    {
        ITypeChainsSearchChainFieldDisplay Display { get; }

        ///<summary>
        /// Defines possible substitutions to be applied to the field content.
        ///</summary>
ITypeChainsSearchChainTabsTabFieldSubstitutions Substitutions { get; }

        ITypeChainsSearchChainTabsTabFieldValidation Validation { get; }

        ///<summary>
        /// Specifies the column parameter ID of a column of the table referred to by the tablePid attribute of the enclosing Tab, or a column of a table that is linked with this table.
        ///</summary>
IValueTag<uint?> ColumnPid { get; }

        ///<summary>
        /// Specifies the name of the search field.
        ///</summary>
IValueTag<string> Name { get; }
    }

    ///<summary>
    /// Defines possible substitutions to be applied to the field content.
    ///</summary>
public partial interface ITypeChainsSearchChainTabsTabFieldSubstitutions : IReadableList<ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution>
    {
    }

    ///<summary>
    /// Defines a substitution to be applied on the field content.
    ///</summary>
public partial interface ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution : IReadable
    {
        ///<summary>
        /// Defines a substitution based on a regular expression.
        ///</summary>
ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex Regex { get; }
    }

    ///<summary>
    /// Defines a substitution based on a regular expression.
    ///</summary>
public partial interface ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex : IReadable
    {
        ///<summary>
        /// Specifies the regular expression defining the pattern of the field content.
        ///</summary>
IValueTag<string> Input { get; }

        ///<summary>
        /// Defines the output after substitution.
        ///</summary>
IValueTag<string> Output { get; }
    }

    public partial interface ITypeChainsSearchChainTabsTabFieldValidation : IReadable
    {
        ///<summary>
        /// Defines the error message to be displayed in case the input is invalid.
        ///</summary>
IValueTag<string> ErrorMessage { get; }

        ///<summary>
        /// Defines the regular expression defining the pattern of allowed field content.
        ///</summary>
IValueTag<string> Regex { get; }
    }

    ///<summary>
    /// Configures chain field display settings.
    ///</summary>
public partial interface ITypeChainsSearchChainFieldDisplay : IReadable
    {
        ITypeChainsSearchChainFieldDisplayVisibility Visibility { get; }
    }

    public partial interface ITypeChainsSearchChainFieldDisplayVisibility : IReadableList<ITypeChainsSearchChainFieldDisplayVisibilityStandalone>
    {
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
IValueTag<bool?> Default { get; }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial interface ITypeChainsSearchChainFieldDisplayVisibilityStandalone : IReadableList<ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue>
    {
        IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial interface ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue : IValueTag<string>
    {
    }

    ///<summary>
    /// Each field in a chain is a possible block in the drill-down diagram displayed on the visual pages of a CPE Manager.
    ///</summary>
public partial interface ITypeChainsChainField : IReadable
    {
        ///<summary>
        /// Specifies the IDs of the (read) parameters to be shown in the diagram box.
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        ///</summary>
IValueTag<string> DiagramPids { get; }

        ///<summary>
        /// Specifies the diagram item sort order.
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        ///</summary>
IValueTag<string> DiagramSorting { get; }

        ///<summary>
        /// Specifies a custom title for the diagram box (By default, the title is the corresponding display key).
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        /// Refer to the DataMiner Protocol Markup Language documentation for more information.
        ///</summary>
IValueTag<string> DiagramTitleFormat { get; }

        ITypeChainsChainFieldDisplay Display { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> DisplayTable { get; }

        ///<summary>
        /// Specifies the name of the block in the drill-down diagram.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the parameter ID of the parameter to which the block is linked.
        /// From DataMiner 8.0.1 onwards (RN 5828), it is also possible to configure pid="0", in case you wish to dis­play lists when no filter is selected.
        ///</summary>
IValueTag<uint?> Pid { get; }
    }

    ///<summary>
    /// Defines a topology, representing the connections in a diagram displayed in a CPE manager.
    ///</summary>
public partial interface ITopology : IReadableList<ITopologyCell>
    {
        ///<summary>
        /// Specifies the name of the topology (Service Overview Manager only).
        ///</summary>
IValueTag<string> Name { get; }
    }

    ///<summary>
    /// Specifies a cell within a CPE topology.
    ///</summary>
public partial interface ITopologyCell : IReadableList<ITopologyCellLink>
    {
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> DetailColumns { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<string> ListColumns { get; }

        ///<summary>
        /// Specifies the name of the cell.
        ///</summary>
IValueTag<string> Name { get; }

        ///<summary>
        /// Specifies a number of options (Deprecated).
        ///</summary>
IValueTag<string> Options { get; }

        ///<summary>
        /// Specifies the table parameter to which the cell is linked.
        ///</summary>
IValueTag<string> Table { get; }
    }

    ///<summary>
    /// Specifies how a cell in a CPE topology is linked to another cell in that topology, using foreign key relations (which can also be inside the same table).
    ///</summary>
public partial interface ITopologyCellLink : IReadable
    {
        ///<summary>
        /// (CPE) Specifies the ID of the parameter column if you want to make a topology with foreign key relations inside a table.
        ///</summary>
IValueTag<uint?> Dest { get; }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
IValueTag<uint?> Source { get; }
    }
}

// Auto-generated code
// <auto-generated>This is auto-generated code by DIS. Do not modify.</auto-generated>
#pragma warning disable CS1591
namespace Skyline.DataMiner.CICD.Models.Protocol.Read
{
    using System;
    using System.Collections.Generic;

    ///<summary>
    /// The root element of a DataMiner protocol.
    ///</summary>
internal partial class Protocol : ElementTag, IProtocol
    {
        internal Protocol(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Protocol")
        {
        }

        private Actions _actions;
        private Advanced _advanced;
        private AlarmLevelLinks _alarmLevelLinks;
        private App _app;
        private Chains _chains;
        private Commands _commands;
        private Compliancies _compliancies;
        private Connections _connections;
        private ElementValueTag<string> _description;
        private ElementValueTag<uint?> _deviceOID;
        private Display _display;
        private DVEs _dVEs;
        private ElementOptions _elementOptions;
        private SystemOptions _systemOptions;
        private ElementValueTag<string> _elementType;
        private ExportRules _exportRules;
        private GeneralParameters _generalParameters;
        private Groups _groups;
        private HTTP _hTTP;
        private ElementValueTag<string> _icon;
        private ElementValueTag<string> _integrationID;
        private InternalLicenses _internalLicenses;
        private ElementValueTag<string> _mib;
        private ElementValueTag<string> _name;
        private NoTimeouts _noTimeouts;
        private Options _options;
        private Ownership _ownership;
        private Pairs _pairs;
        private ParameterGroups _parameterGroups;
        private Params _params;
        private Ports _ports;
        private PortSettingsMain _portSettings;
        private ProcessAutomation _processAutomation;
        private ElementValueTag<string> _provider;
        private QActions _qActions;
        private RCA _rCA;
        private Relations _relations;
        private Responses _responses;
        private SeverityBubbleUp _severityBubbleUp;
        private SNMP _sNMP;
        private Threads _threads;
        private Timers _timers;
        private Topology _topology;
        private Topologies _topologies;
        private TreeControls _treeControls;
        private Triggers _triggers;
        private ProtocolType _type;
        private ElementValueTag<string> _vendor;
        private ElementValueTag<string> _vendorOID;
        private ElementValueTag<string> _version;
        private VersionHistory _versionHistory;
        private AttributeTag<string> _baseFor;
        ///<summary>
        /// Contains the actions defined in this protocol.
        ///</summary>
public IActions Actions => _actions;
        ///<summary>
        /// Specifies a number of advanced settings with regard to the protocol's commands and responses.
        ///</summary>
public IAdvanced Advanced => _advanced;
        ///<summary>
        /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
        ///</summary>
public IAlarmLevelLinks AlarmLevelLinks => _alarmLevelLinks;
        ///<summary>
        /// Add this element if you want to turn DataMiner elements executing this protocol into applications.
        /// In DataMiner Cube, protocol-based applications can be found in the Apps tab of the Surveyor.
        ///</summary>
public IApp App => _app;
        ///<summary>
        /// Contains the chains defined in this protocol.
        ///</summary>
public IChains Chains => _chains;
        ///<summary>
        /// Contains all commands defined in the protocol.
        /// Commands are sent from DataMiner to the device
        /// - to request information from the device, or
        /// - to change a device setting.
        ///</summary>
public ICommands Commands => _commands;
        ///<summary>
        /// Provides compliance information about this protocol.
        ///</summary>
public ICompliancies Compliancies => _compliancies;
        ///<summary>
        /// Defines communication connections.
        ///</summary>
public IConnections Connections => _connections;
        ///<summary>
        /// Specifies a description of the protocol.
        /// Can be used to specify some general information about the protocol. You could, for example, specify that the protocol has been
        /// developed for elements running a specific firmware version.
        /// In protocols of DataMiner elements that are used in automation, the description must be unique.
        ///</summary>
public IValueTag<string> Description => _description;
        ///<summary>
        /// Specifies an OID for the device that will be managed with the protocol.
        /// The device OID has to be specified right after the vendor OID. Note that the complete OID, i.e. the vendor OID followed by the device OID, must be unique.
        /// This means that for each device from the same vendor you have to use a new device OID.
        ///</summary>
public IValueTag<uint?> DeviceOID => _deviceOID;
        ///<summary>
        /// Defines the layout and the order of the Data Display pages.
        ///</summary>
public IDisplay Display => _display;
        ///<summary>
        /// This tag allows you to describe the behavior of Dynamic Virtual Elements.
        ///</summary>
public IDVEs DVEs => _dVEs;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IElementOptions ElementOptions => _elementOptions;
        ///<summary>
        /// Contains options that can be enabled or configured that change how the system will manage or interact with the element.
        ///</summary>
public ISystemOptions SystemOptions => _systemOptions;
        ///<summary>
        /// Specifies the type of device for which the protocol will be used.
        /// The type will be shown whenever a DataMiner element is added or edited. It will also be shown in the Details section of System Display when a DataMiner element is
        /// selected.
        ///</summary>
public IValueTag<string> ElementType => _elementType;
        ///<summary>
        /// Defines rules that are used for changing the displayed items in a Dynamic Virtual Element (DVE), for example changing the location of a parameter.
        ///</summary>
public IExportRules ExportRules => _exportRules;
        ///<summary>
        /// Specifies which general parameter groups should be loaded or not. Feature introduced in DataMiner 9.0.1 (RN 12263).
        ///</summary>
public IGeneralParameters GeneralParameters => _generalParameters;
        ///<summary>
        /// Contains the groups defined in the protocol.
        ///</summary>
public IGroups Groups => _groups;
        ///<summary>
        /// The root of the HTTP-specific features in a protocol.
        ///</summary>
public IHTTP HTTP => _hTTP;
        ///<summary>
        /// Defines an icon (via XAML content in a CDATA tag) to be used in the Applications list in the DataMiner Cube surveyor.
        ///</summary>
public IValueTag<string> Icon => _icon;
        ///<summary>
        /// Specifies the integration ID.
        ///</summary>
public IValueTag<string> IntegrationID => _integrationID;
        ///<summary>
        /// Configures internal licensing.
        ///</summary>
public IInternalLicenses InternalLicenses => _internalLicenses;
        ///<summary>
        /// Allows providing additional content (conforming the SMI specification) that must be included in the generated MIB.
        ///</summary>
public IValueTag<string> Mib => _mib;
        ///<summary>
        /// Defines the name of the protocol.
        /// This name, which must be unique, will be used throughout the DataMiner System to identify the protocol.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Groups NoTimeout elements.
        ///</summary>
public INoTimeouts NoTimeouts => _noTimeouts;
        ///<summary>
        /// Defines options for the protocol.
        ///</summary>
public IOptions Options => _options;
        ///<summary>
        /// Specifies the level of access users will have to elements, views, services and redundancy groups created by elements based on this protocol.
        /// Feature introduced in DataMiner 9.0.3 (RN 13010).
        ///</summary>
public IOwnership Ownership => _ownership;
        ///<summary>
        /// Contains all the pairs defined in the protocol.
        ///</summary>
public IPairs Pairs => _pairs;
        ///<summary>
        /// Defines the DataMiner Connectivity Framework (DCF) interfaces.
        /// Feature introduced in DataMiner 8.0.0 (RN 5663).
        ///</summary>
public IParameterGroups ParameterGroups => _parameterGroups;
        ///<summary>
        /// Contains all the parameters defined in the protocol.
        ///</summary>
public IParams Params => _params;
        ///<summary>
        /// For every protocol, you have to specify its type in /Protocol/Type, and its port settings in /Protocol/Portsettings.
        /// In case of a multi-type protocol, the /Protocol/Type@advanced attribute is used to any additional protocol types.
        /// The port settings for those additional protocol types then have to be specified in a /Protocol/Ports/Portsettings element in which the name attribute contains the name of the additional type as specified in the /Protocol/Type@advanced attribute.
        ///</summary>
public IPorts Ports => _ports;
        ///<summary>
        /// Defines the default port settings of the main device port.
        /// It also allows you to restrict the capabilities of a device port, and to define the format and range of the bus address, if any.
        ///</summary>
public IPortSettingsMain PortSettings => _portSettings;
        public IProcessAutomation ProcessAutomation => _processAutomation;
        ///<summary>
        /// Specifies the protocol provider.
        /// Example: If a protocol was created by someone from Skyline Communications, this provider tag has to be set to "Skyline Communications".
        ///</summary>
public IValueTag<string> Provider => _provider;
        ///<summary>
        /// Contains all the QActions defined in the protocol.
        /// A QAction (i.e. Quick Action) is a script that can be executed when a parameter or a row changes. Inside a QAction, the following scripting languages can be used:
        /// -	JScript
        /// -	VBScript
        /// -	C#
        ///</summary>
public IQActions QActions => _qActions;
        ///<summary>
        /// Configures Root Cause Analysis (RCA).
        ///</summary>
public IRCA RCA => _rCA;
        ///<summary>
        /// Defines relations between tables.
        ///</summary>
public IRelations Relations => _relations;
        ///<summary>
        /// Contains all responses defined in the protocol.
        ///</summary>
public IResponses Responses => _responses;
        ///<summary>
        /// Used to pass alarm severities to linked tables.
        ///</summary>
public ISeverityBubbleUp SeverityBubbleUp => _severityBubbleUp;
        ///<summary>
        /// Specifies how the MIB file for the protocol will be created.
        ///</summary>
public ISNMP SNMP => _sNMP;
        ///<summary>
        /// Specifies additional threads that will be used by the protocol. This allows you to separate time-critical actions from device-polling actions. Use with caution.
        ///</summary>
public IThreads Threads => _threads;
        ///<summary>
        /// Contains all timers defined in the protocol.
        /// Timers are used to configure recurring events (group execution, device polling, ...). Basically, a timer defines the interval between two consecutive executions of a given event.
        /// By default, the interval specified in a timer is a fixed interval. However, in the protocol, you can make the interval dynamic.
        /// The interval can be modified by changing the value of the [Timer base] Parameter (ID: 65017). The value of this parameter is the factor by which the interval time is multiplied.
        /// So "1" means the original interval, "2" means twice as slow, "0.5" means twice as fast, etc.
        ///</summary>
public ITimers Timers => _timers;
        ///<summary>
        /// Defines a topology. In this element, you can specify several Cell elements, each representing a cell in the diagram displayed in the CPE Manager.
        ///</summary>
public ITopology Topology => _topology;
        ///<summary>
        /// Groups topologies defined in the protocol.
        ///</summary>
public ITopologies Topologies => _topologies;
        ///<summary>
        /// Contains all the tree controls defined in the protocol.
        ///</summary>
public ITreeControls TreeControls => _treeControls;
        ///<summary>
        /// Contains the triggers defined in the protocol.
        /// In a trigger, you define when it should go off, and which actions it should execute.
        ///</summary>
public ITriggers Triggers => _triggers;
        ///<summary>
        /// Specifies the protocol type. In multi-connection protocols, it specifies the type of the main connection.
        ///</summary>
public IProtocolType Type => _type;
        ///<summary>
        /// Specifies the name of the vendor of the monitored device.
        ///</summary>
public IValueTag<string> Vendor => _vendor;
        ///<summary>
        /// Specifies the vendor OID of the monitored device.
        /// This OID, to be provided either by the vendor of the device or (on request) by Skyline Communications, must be unique, as it is used to define MIB objects for all Elements using the protocol.
        /// Typically, the vendor OID will start with the prefix 1.3.6.1.4.1, which identifies private enterprises.
        ///</summary>
public IValueTag<string> VendorOID => _vendorOID;
        ///<summary>
        /// Specifies the protocol version.
        /// Within one DataMiner system, you can maintain different versions of the same protocol and assign them to different elements. If you have to make modifications to a protocol, do not create a completely new protocol.
        /// Instead, make a new version of that same protocol.
        /// Version can be a number (e.g. 1.0.0.3) or a string (e.g. "high power").
        /// Tip: When you have two types of elements that are very similar (e.g. an optical transmitter: one with a high output power and another with a low output power), you can use the same protocol and create two
        /// versions (e.g. version "high power" and version "low power" for the protocol "optical transmitter". The only difference between the two versions would then be e.g. the range settings for the "output power" parameter).
        ///</summary>
public IValueTag<string> Version => _version;
        ///<summary>
        /// Contains an overview of the version history of this protocol.
        /// Feature introduced in DataMiner 9.5.11 (RN 17697, RN 18360).
        ///</summary>
public IVersionHistory VersionHistory => _versionHistory;
        ///<summary>
        /// Specifies the type of element for which this protocol serves as a base protocol.
        /// In case a value is defined in this attribute, the protocol is considered a base protocol.
        ///</summary>
public IValueTag<string> BaseFor => _baseFor;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("baseFor", nameof(BaseFor), _baseFor, value => _baseFor = value);
            ParseElementTag("Actions", nameof(Actions), _actions, value => _actions = value);
            ParseElementTag("Advanced", nameof(Advanced), _advanced, value => _advanced = value);
            ParseElementTag("AlarmLevelLinks", nameof(AlarmLevelLinks), _alarmLevelLinks, value => _alarmLevelLinks = value);
            ParseElementTag("App", nameof(App), _app, value => _app = value);
            ParseElementTag("Chains", nameof(Chains), _chains, value => _chains = value);
            ParseElementTag("Commands", nameof(Commands), _commands, value => _commands = value);
            ParseElementTag("Compliancies", nameof(Compliancies), _compliancies, value => _compliancies = value);
            ParseElementTag("Connections", nameof(Connections), _connections, value => _connections = value);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("DeviceOID", nameof(DeviceOID), _deviceOID, value => _deviceOID = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
            ParseElementTag("DVEs", nameof(DVEs), _dVEs, value => _dVEs = value);
            ParseElementTag("ElementOptions", nameof(ElementOptions), _elementOptions, value => _elementOptions = value);
            ParseElementTag("SystemOptions", nameof(SystemOptions), _systemOptions, value => _systemOptions = value);
            ParseElementTag("ElementType", nameof(ElementType), _elementType, value => _elementType = value);
            ParseElementTag("ExportRules", nameof(ExportRules), _exportRules, value => _exportRules = value);
            ParseElementTag("GeneralParameters", nameof(GeneralParameters), _generalParameters, value => _generalParameters = value);
            ParseElementTag("Groups", nameof(Groups), _groups, value => _groups = value);
            ParseElementTag("HTTP", nameof(HTTP), _hTTP, value => _hTTP = value);
            ParseElementTag("Icon", nameof(Icon), _icon, value => _icon = value);
            ParseElementTag("IntegrationID", nameof(IntegrationID), _integrationID, value => _integrationID = value);
            ParseElementTag("InternalLicenses", nameof(InternalLicenses), _internalLicenses, value => _internalLicenses = value);
            ParseElementTag("Mib", nameof(Mib), _mib, value => _mib = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("NoTimeouts", nameof(NoTimeouts), _noTimeouts, value => _noTimeouts = value);
            ParseElementTag("Options", nameof(Options), _options, value => _options = value);
            ParseElementTag("Ownership", nameof(Ownership), _ownership, value => _ownership = value);
            ParseElementTag("Pairs", nameof(Pairs), _pairs, value => _pairs = value);
            ParseElementTag("ParameterGroups", nameof(ParameterGroups), _parameterGroups, value => _parameterGroups = value);
            ParseElementTag("Params", nameof(Params), _params, value => _params = value);
            ParseElementTag("Ports", nameof(Ports), _ports, value => _ports = value);
            ParseElementTag("PortSettings", nameof(PortSettings), _portSettings, value => _portSettings = value);
            ParseElementTag("ProcessAutomation", nameof(ProcessAutomation), _processAutomation, value => _processAutomation = value);
            ParseElementTag("Provider", nameof(Provider), _provider, value => _provider = value);
            ParseElementTag("QActions", nameof(QActions), _qActions, value => _qActions = value);
            ParseElementTag("RCA", nameof(RCA), _rCA, value => _rCA = value);
            ParseElementTag("Relations", nameof(Relations), _relations, value => _relations = value);
            ParseElementTag("Responses", nameof(Responses), _responses, value => _responses = value);
            ParseElementTag("SeverityBubbleUp", nameof(SeverityBubbleUp), _severityBubbleUp, value => _severityBubbleUp = value);
            ParseElementTag("SNMP", nameof(SNMP), _sNMP, value => _sNMP = value);
            ParseElementTag("Threads", nameof(Threads), _threads, value => _threads = value);
            ParseElementTag("Timers", nameof(Timers), _timers, value => _timers = value);
            ParseElementTag("Topology", nameof(Topology), _topology, value => _topology = value);
            ParseElementTag("Topologies", nameof(Topologies), _topologies, value => _topologies = value);
            ParseElementTag("TreeControls", nameof(TreeControls), _treeControls, value => _treeControls = value);
            ParseElementTag("Triggers", nameof(Triggers), _triggers, value => _triggers = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
            ParseElementTag("Vendor", nameof(Vendor), _vendor, value => _vendor = value);
            ParseElementTag("VendorOID", nameof(VendorOID), _vendorOID, value => _vendorOID = value);
            ParseElementTag("Version", nameof(Version), _version, value => _version = value);
            ParseElementTag("VersionHistory", nameof(VersionHistory), _versionHistory, value => _versionHistory = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProtocol(this);
        }
    }

    ///<summary>
    /// Contains the actions defined in this protocol.
    ///</summary>
internal partial class Actions : SimpleProtocolListNode<ActionsAction>, IActions
    {
        internal Actions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Actions", "Action")
        {
        }

        IActionsAction IReadOnlyList<IActionsAction>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IActionsAction> IEnumerable<IActionsAction>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitActions(this);
        }
    }

    ///<summary>
    /// Defines an action.
    ///</summary>
internal partial class ActionsAction : ElementTag, IActionsAction
    {
        internal ActionsAction(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Action")
        {
        }

        private ElementValueTag<string> _condition;
        private ElementValueTag<string> _name;
        private ActionsActionOn _on;
        private ActionsActionType _type;
        private AttributeTag<uint?> _id;
        ///<summary>
        /// Specifies a condition that must be met in order for the action to execute.
        ///</summary>
public IValueTag<string> Condition => _condition;
        ///<summary>
        /// Specifies the name of the action.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Defines, together with Action/Type, how the action is executed.
        /// Not all Action/Type values can be used in combination with the different Action/On types.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
        ///</summary>
public IActionsActionOn On => _on;
        ///<summary>
        /// Defines, together with Action/On, how the action is executed.
        /// Not all Action/Type values can be used in combination with the different Action/On types.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
        ///</summary>
public IActionsActionType Type => _type;
        ///<summary>
        /// Specifies the unique action ID.
        ///</summary>
public IValueTag<uint?> Id => _id;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseElementTag("Condition", nameof(Condition), _condition, value => _condition = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("On", nameof(On), _on, value => _on = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitActionsAction(this);
        }
    }

    ///<summary>
    /// Defines, together with Action/Type, how the action is executed.
    /// Not all Action/Type values can be used in combination with the different Action/On types.
    /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
    ///</summary>
internal partial class ActionsActionOn : ElementValueTag<Enums.EnumActionOn?>, IActionsActionOn
    {
        internal ActionsActionOn(ProtocolModel model, ProtocolTag parent) : base(model, parent, "On")
        {
        }

        private AttributeTag<string> _id;
        private AttributeTag<string> _nr;
        ///<summary>
        /// The ID of the parameter, command, response, etc.
        /// In case the "id" attribute is not present, the trigger will apply to all items of the type specified in /Protocol/Actions/Action/On.
        ///</summary>
public IValueTag<string> Id => _id;
        ///<summary>
        /// If Action/Type is "reverse", this attribute specifies the (0-based) position(s) of the parameter(s) in the command/response.
        /// If Action/Type is "set next", this attribute specifies the (1-based) position(s) of the pair(s) in the group.
        /// In any case, separate multiple positions with semicolons.
        ///</summary>
public IValueTag<string> Nr => _nr;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("nr", nameof(Nr), _nr, value => _nr = value);
        }

        public override Enums.EnumActionOn? ConvertRawValue(string rawValue)
        {
            return Enums.EnumActionOnConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitActionsActionOn(this);
        }
    }

    ///<summary>
    /// Defines, together with Action/On, how the action is executed.
    /// Not all Action/Type values can be used in combination with the different Action/On types.
    /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
    ///</summary>
internal partial class ActionsActionType : ElementValueTag<Enums.EnumActionType?>, IActionsActionType
    {
        internal ActionsActionType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private AttributeTag<string> _allowed;
        private AttributeTag<string> _arguments;
        private AttributeTag<uint?> _endoffset;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _nr;
        private AttributeTag<string> _options;
        private AttributeTag<bool?> _reschedule;
        private AttributeTag<string> _returnValue;
        private AttributeTag<string> _regex;
        private AttributeTag<string> _scale;
        private AttributeTag<string> _script;
        private AttributeTag<string> _sequence;
        private AttributeTag<uint?> _startoffset;
        private AttributeTag<string> _valueAttribute;
        ///<summary>
        /// If Action/Type is "stuffing": If the byte specified in the "value" attribute is followed by one of the characters specified in this attri­bute, then it will not be repeated.
        ///</summary>
public IValueTag<string> Allowed => _allowed;
        ///<summary>
        /// If Action/Type is "wmi", this attribute specifies the names of the columns to be returned (separated by semicolons).
        ///</summary>
public IValueTag<string> Arguments => _arguments;
        ///<summary>
        /// If Action/Type is "stuffing", this attribute specifies the (fixed) end position that delimits the part of the data block in which stuffing has to be performed.
        ///</summary>
public IValueTag<uint?> Endoffset => _endoffset;
        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter containing the directory in which the file can be found.
        /// If Action/Type is "replace", this attribute specifies the ID of the parameter that contains the ID of the parameter that has to be put in the command/response.
        /// If Action/Type is "increment", this attribute specifies the ID of the parameter that holds the increment value.
        /// 
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the number of bytes to be read.
        /// If Action/Type is "replace", this attribute specifies the (0-based) position of the parameter in the command/response.
        /// If Action/Type is "set", "set and get with wait", "set with wait", "open", "close", "lock", "unlock", "priority lock" or "priority unlock", this attribute sepcifies the (0-based) connection ID.
        /// 
        ///</summary>
public IValueTag<string> Nr => _nr;
        ///<summary>
        /// This attribute allows defining different options depending on the Action/Type.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options for a given type.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// If Action/Type is "restart timer" and this attribute is set to “true”, then the timer will immediately start again. Feature introduced in DataMiner 8.5.4 (RN 9189).
        ///</summary>
public IValueTag<bool?> Reschedule => _reschedule;
        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter in which to store the retrieved file content.
        /// If Type is "wmi", this attribute specifies the ID of the parameter containing the returned values (if "table" is set to "true", this ID should be the ID of a parameter of type "array").
        ///</summary>
public IValueTag<string> ReturnValue => _returnValue;
        ///<summary>
        /// If Action/Type is "aggregate", this attribute allows to specify the regular expression to use for filtering.
        /// Feature introduced in DataMiner 10.1.8 (RN 30199).
        ///</summary>
public IValueTag<string> Regex => _regex;
        ///<summary>
        /// If Action/Type is "set info", this attribute specifies the scale to be set on the parameter.
        /// Expected format: lowdata;highdata;low;high (for example: scale="0;65535;-10;10").
        ///</summary>
public IValueTag<string> Scale => _scale;
        ///<summary>
        /// If Action/Type is "wmi", this attribute specifies the WMI class (e.g. Win32_PerfRawData_PerfOS_Memory).
        ///</summary>
public IValueTag<string> Script => _script;
        ///<summary>
        /// If Action/Type is "set info", this attribute specifies the sequence to be set on the parameter.
        ///</summary>
public IValueTag<string> Sequence => _sequence;
        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter containing the start offset (i.e. the number of bytes to skip before starting to read the file).
        /// If Action/Type is "stuffing", this attribute specifies the (fixed) start position that delimits the part of the data block in which stuffing has to be performed.
        /// 
        ///</summary>
public IValueTag<uint?> Startoffset => _startoffset;
        ///<summary>
        /// If Action/Type is "stuffing", this attribute specifies the actual stuffing character, i.e. the byte that has to be repeated.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("allowed", nameof(Allowed), _allowed, value => _allowed = value);
            ParseAttributeTag("arguments", nameof(Arguments), _arguments, value => _arguments = value);
            ParseAttributeTag("endoffset", nameof(Endoffset), _endoffset, value => _endoffset = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("nr", nameof(Nr), _nr, value => _nr = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("reschedule", nameof(Reschedule), _reschedule, value => _reschedule = value);
            ParseAttributeTag("returnValue", nameof(ReturnValue), _returnValue, value => _returnValue = value);
            ParseAttributeTag("regex", nameof(Regex), _regex, value => _regex = value);
            ParseAttributeTag("scale", nameof(Scale), _scale, value => _scale = value);
            ParseAttributeTag("script", nameof(Script), _script, value => _script = value);
            ParseAttributeTag("sequence", nameof(Sequence), _sequence, value => _sequence = value);
            ParseAttributeTag("startoffset", nameof(Startoffset), _startoffset, value => _startoffset = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
        }

        public override Enums.EnumActionType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumActionTypeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitActionsActionType(this);
        }
    }

    ///<summary>
    /// Specifies a number of advanced settings with regard to the protocol's commands and responses.
    ///</summary>
internal partial class Advanced : ElementTag, IAdvanced
    {
        internal Advanced(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Advanced")
        {
        }

        private AttributeTag<bool?> _ignoreEqualResponse;
        private AttributeTag<string> _stuffing;
        ///<summary>
        /// If you set this attribute to "true", then a received response will be ignored if it is identical to the response received previously (for the same pair).
        /// In other words, the trigger associated with a response will not go off if that response is identical to the previous one.
        /// Note: Use this option with extreme care, as it can have a profound impact on the general behavior of the protocol.
        ///</summary>
public IValueTag<bool?> IgnoreEqualResponse => _ignoreEqualResponse;
        ///<summary>
        /// In this attribute, you can specify a number of settings with regard to stuffing. Separate these by semicolons.
        ///</summary>
public IValueTag<string> Stuffing => _stuffing;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("ignoreEqualResponse", nameof(IgnoreEqualResponse), _ignoreEqualResponse, value => _ignoreEqualResponse = value);
            ParseAttributeTag("stuffing", nameof(Stuffing), _stuffing, value => _stuffing = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitAdvanced(this);
        }
    }

    ///<summary>
    /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
    ///</summary>
internal partial class AlarmLevelLinks : SimpleProtocolListNode<AlarmLevelLinksAlarmLevelLink>, IAlarmLevelLinks
    {
        internal AlarmLevelLinks(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AlarmLevelLinks", "AlarmLevelLink")
        {
        }

        IAlarmLevelLinksAlarmLevelLink IReadOnlyList<IAlarmLevelLinksAlarmLevelLink>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IAlarmLevelLinksAlarmLevelLink> IEnumerable<IAlarmLevelLinksAlarmLevelLink>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitAlarmLevelLinks(this);
        }
    }

    ///<summary>
    /// Defines an alarm level link.
    /// An alarm level link allows aggregating alarms from DataMiner elements or table rows at runtime.
    /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
    /// The source and destination are table columns.
    ///</summary>
internal partial class AlarmLevelLinksAlarmLevelLink : ElementTag, IAlarmLevelLinksAlarmLevelLink
    {
        internal AlarmLevelLinksAlarmLevelLink(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AlarmLevelLink")
        {
        }

        private AttributeTag<string> _destination;
        private AttributeTag<string> _filters;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _remoteElement;
        ///<summary>
        /// Specifies the column parameter ID where the result of the alarm level needs to be set.
        ///</summary>
public IValueTag<string> Destination => _destination;
        ///<summary>
        /// By default, alarm level linking is done via primary key or display key. For every key, a link is made with the aggregator element.
        /// If you enter a filter in the filters attribute, the link will only be made if the condition is met. Example: filters="VALUE=204 === 1"
        ///</summary>
public IValueTag<string> Filters => _filters;
        ///<summary>
        /// The unique ID of the AlarmLevelLink.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Used to retrieve the alarm state of a different element.
        ///</summary>
public IValueTag<string> RemoteElement => _remoteElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("destination", nameof(Destination), _destination, value => _destination = value);
            ParseAttributeTag("filters", nameof(Filters), _filters, value => _filters = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("remoteElement", nameof(RemoteElement), _remoteElement, value => _remoteElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitAlarmLevelLinksAlarmLevelLink(this);
        }
    }

    ///<summary>
    /// Add this element if you want to turn DataMiner elements executing this protocol into applications.
    /// In DataMiner Cube, protocol-based applications can be found in the Apps tab of the Surveyor.
    ///</summary>
internal partial class App : ElementTag, IApp
    {
        internal App(ProtocolModel model, ProtocolTag parent) : base(model, parent, "App")
        {
        }

        private AttributeTag<string> _type;
        ///<summary>
        /// Specifies the name of the app.
        ///</summary>
public IValueTag<string> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitApp(this);
        }
    }

    ///<summary>
    /// Contains the chains defined in this protocol.
    ///</summary>
internal partial class Chains : MultipleValueProtocolListNode<IChainsObject>, IChains
    {
        internal Chains(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Chains", new Dictionary<string, Type>() { { "Chain", typeof(ChainsChain) }, { "SearchChain", typeof(ChainsSearchChain) }, { "", typeof(ChainsItem) } })
        {
        }

        private ChainsFilters _filters;
        ///<summary>
        /// Determines the layout of the filters.
        ///</summary>
public IValueTag<Enums.EnumChainsFilters?> Filters => _filters;

        IChainsItem IReadOnlyList<IChainsItem>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IChainsItem> IEnumerable<IChainsItem>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("filters", nameof(Filters), _filters, value => _filters = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChains(this);
        }
    }

    internal partial interface IChainsObject : IProtocolTag, Read.IChainsItem
    {
    }

    internal partial class ChainsItem : ProtocolTag, IChainsObject
    {
        internal ChainsItem(ProtocolModel model, ProtocolTag parent, string tagName) : base(model, parent, tagName)
        {
        }

        protected override void Parse(string notifyPropertyName)
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsItem(this);
        }
    }

    ///<summary>
    /// Represents a different topology view of a CPE manager or Service Over­view Manager (SOM) element.
    ///</summary>
internal partial class ChainsChain : SimpleProtocolListNode<TypeChainsChainField>, IChainsChain, IChainsObject
    {
        internal ChainsChain(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Chain", "Field")
        {
        }

        private TypeChainsChainDisplay _display;
        private AttributeTag<string> _defaultSelectionField;
        private AttributeTag<string> _groupingName;
        private AttributeTag<string> _name;
        private AttributeTag<string> _options;
        private AttributeTag<string> _topology;
        public ITypeChainsChainDisplay Display => _display;
        ///<summary>
        /// Specifies the name of the field for which selection should be applied.
        ///</summary>
public IValueTag<string> DefaultSelectionField => _defaultSelectionField;
        ///<summary>
        /// Specifies the name of the group to which this Chain belongs. Feature introduced in DataMiner 10.1.3 (RN 28751, RN 28834, RN 28846).
        ///</summary>
public IValueTag<string> GroupingName => _groupingName;
        ///<summary>
        /// Specifies the name of the chain, which is used as the name of the corresponding tab page in DataMiner.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies a number of options (separated by semicolons).
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Contains the name defined in the /Protocol/Topologies/Topology@name attribute (only Service Overview Manager). See Protocol/Topologies/Topology@name.
        ///</summary>
public IValueTag<string> Topology => _topology;

        ITypeChainsChainField IReadOnlyList<ITypeChainsChainField>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsChainField> IEnumerable<ITypeChainsChainField>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("defaultSelectionField", nameof(DefaultSelectionField), _defaultSelectionField, value => _defaultSelectionField = value);
            ParseAttributeTag("groupingName", nameof(GroupingName), _groupingName, value => _groupingName = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("topology", nameof(Topology), _topology, value => _topology = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsChain(this);
        }
    }

    ///<summary>
    /// Defines a search chain in a CPE environment.
    ///</summary>
internal partial class ChainsSearchChain : ElementTag, IChainsSearchChain, IChainsObject
    {
        internal ChainsSearchChain(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SearchChain")
        {
        }

        private TypeChainsSearchChainDisplay _display;
        private ChainsSearchChainTabs _tabs;
        private AttributeTag<string> _name;
        public ITypeChainsSearchChainDisplay Display => _display;
        public IChainsSearchChainTabs Tabs => _tabs;
        ///<summary>
        /// Specifies the name of the search chain.
        ///</summary>
public IValueTag<string> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
            ParseElementTag("Tabs", nameof(Tabs), _tabs, value => _tabs = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsSearchChain(this);
        }
    }

    internal partial class ChainsSearchChainTabs : SimpleProtocolListNode<ChainsSearchChainTabsTab>, IChainsSearchChainTabs
    {
        internal ChainsSearchChainTabs(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Tabs", "Tab")
        {
        }

        IChainsSearchChainTabsTab IReadOnlyList<IChainsSearchChainTabsTab>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IChainsSearchChainTabsTab> IEnumerable<IChainsSearchChainTabsTab>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsSearchChainTabs(this);
        }
    }

    ///<summary>
    /// Defines a tab.
    ///</summary>
internal partial class ChainsSearchChainTabsTab : ElementTag, IChainsSearchChainTabsTab
    {
        internal ChainsSearchChainTabsTab(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Tab")
        {
        }

        private TypeChainsSearchChainFieldDisplay _display;
        private ChainsSearchChainTabsTabFields _fields;
        private AttributeTag<uint?> _tablePid;
        private AttributeTag<string> _name;
        public ITypeChainsSearchChainFieldDisplay Display => _display;
        ///<summary>
        /// Contains the definition of the fields to be included in this search tab.
        ///</summary>
public IChainsSearchChainTabsTabFields Fields => _fields;
        ///<summary>
        /// Specifies the table parameter ID of the table for which a search Tab will be defined.
        ///</summary>
public IValueTag<uint?> TablePid => _tablePid;
        ///<summary>
        /// Specifies the name of the search tab.
        ///</summary>
public IValueTag<string> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("tablePid", nameof(TablePid), _tablePid, value => _tablePid = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
            ParseElementTag("Fields", nameof(Fields), _fields, value => _fields = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsSearchChainTabsTab(this);
        }
    }

    ///<summary>
    /// Contains the definition of the fields to be included in this search tab.
    ///</summary>
internal partial class ChainsSearchChainTabsTabFields : SimpleProtocolListNode<TypeChainsSearchChainTabsTabField>, IChainsSearchChainTabsTabFields
    {
        internal ChainsSearchChainTabsTabFields(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Fields", "Field")
        {
        }

        ITypeChainsSearchChainTabsTabField IReadOnlyList<ITypeChainsSearchChainTabsTabField>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsSearchChainTabsTabField> IEnumerable<ITypeChainsSearchChainTabsTabField>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsSearchChainTabsTabFields(this);
        }
    }

    internal partial class ChainsFilters : AttributeTag<Enums.EnumChainsFilters?>
    {
        internal ChainsFilters(ProtocolModel model, ProtocolTag parent) : base(model, parent, "filters")
        {
        }

        public override Enums.EnumChainsFilters? ConvertRawValue(string rawValue)
        {
            return Enums.EnumChainsFiltersConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains all commands defined in the protocol.
    /// Commands are sent from DataMiner to the device
    /// - to request information from the device, or
    /// - to change a device setting.
    ///</summary>
internal partial class Commands : SimpleProtocolListNode<CommandsCommand>, ICommands
    {
        internal Commands(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Commands", "Command")
        {
        }

        ICommandsCommand IReadOnlyList<ICommandsCommand>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ICommandsCommand> IEnumerable<ICommandsCommand>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCommands(this);
        }
    }

    ///<summary>
    /// Defines a complete command.
    /// DataMiner sends a command to the device
    /// - to request information, or
    /// - to change a device setting.
    /// In both cases, DataMiner will expect a response from the device. If it requests information, it will expect a response that contains that
    /// information, and if it changes a setting, it will expect a confirmation (although, in some cases, none is returned).
    ///</summary>
internal partial class CommandsCommand : ElementTag, ICommandsCommand
    {
        internal CommandsCommand(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Command")
        {
        }

        private CommandsCommandContent _content;
        private ElementValueTag<string> _description;
        private ElementValueTag<string> _name;
        private CommandsCommandWebSocketMessageType _webSocketMessageType;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _ascii;
        ///<summary>
        /// Specifies the consecutive parameters that together form the command to be sent to the device.
        /// Quite often, commands have a header parameter and a trailer parameter that demarcate the beginning and the end of the command.
        ///</summary>
public ICommandsCommandContent Content => _content;
        ///<summary>
        /// Specifies the command description.
        ///</summary>
public IValueTag<string> Description => _description;
        ///<summary>
        /// Specifies the command name.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies the format in which the message should be sent.
        /// By default, the message is sent in binary format.
        /// Feature introduced in DataMiner 9.5.1.
        ///</summary>
public IValueTag<Enums.EnumWebSocketMessageType?> WebSocketMessageType => _webSocketMessageType;
        ///<summary>
        /// Specifies the command ID.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Only applicable for Unicode protocols. Set to "true" if all parameters of the command should be sent as ASCII.
        /// Use semicolon-separated parameter IDs if only certain parameters should be sent as ASCII.
        ///</summary>
public IValueTag<string> Ascii => _ascii;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("ascii", nameof(Ascii), _ascii, value => _ascii = value);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("WebSocketMessageType", nameof(WebSocketMessageType), _webSocketMessageType, value => _webSocketMessageType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCommandsCommand(this);
        }
    }

    ///<summary>
    /// Specifies the consecutive parameters that together form the command to be sent to the device.
    /// Quite often, commands have a header parameter and a trailer parameter that demarcate the beginning and the end of the command.
    ///</summary>
internal partial class CommandsCommandContent : SimpleProtocolListNode<CommandsCommandContentParam>, ICommandsCommandContent
    {
        internal CommandsCommandContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content", "Param")
        {
        }

        ICommandsCommandContentParam IReadOnlyList<ICommandsCommandContentParam>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ICommandsCommandContentParam> IEnumerable<ICommandsCommandContentParam>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCommandsCommandContent(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the parameter to include in the command.
    ///</summary>
internal partial class CommandsCommandContentParam : ElementValueTag<uint?>, ICommandsCommandContentParam
    {
        internal CommandsCommandContentParam(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Param")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCommandsCommandContentParam(this);
        }
    }

    internal partial class CommandsCommandWebSocketMessageType : ElementValueTag<Enums.EnumWebSocketMessageType?>
    {
        internal CommandsCommandWebSocketMessageType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "WebSocketMessageType")
        {
        }

        public override Enums.EnumWebSocketMessageType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumWebSocketMessageTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Provides compliance information about this protocol.
    ///</summary>
internal partial class Compliancies : ElementTag, ICompliancies
    {
        internal Compliancies(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Compliancies")
        {
        }

        private ElementValueTag<bool?> _cassandraReady;
        private ElementValueTag<bool?> _cassandraRequired;
        private ElementValueTag<string> _minimumRequiredVersion;
        private ElementValueTag<string> _maximumSupportedVersion;
        ///<summary>
        /// True if the protocol is compatible with a Cassandra database; otherwise, false.
        ///</summary>
public IValueTag<bool?> CassandraReady => _cassandraReady;
        ///<summary>
        /// Specifies whether a Cassandra database is required to execute the protocol. True if Cassandra is required to use this protocol; otherwise, false.
        ///</summary>
public IValueTag<bool?> CassandraRequired => _cassandraRequired;
        ///<summary>
        /// Indicates the minimum DataMiner version that the driver is compatible with.
        /// Expected format: [MainVersion].[MainVersionIncrement].[FeatureVersionIncrement].[CurrentlyUnused] - [BuildNumber] (in which [BuildNumber] is a four-digit number) (e.g. 10.0.7.0 - 9247)
        ///</summary>
public IValueTag<string> MinimumRequiredVersion => _minimumRequiredVersion;
        ///<summary>
        /// Specifies the maximum DataMiner version this protocol supports.
        /// Expected format: [MainVersion].[MainVersionIncrement].[FeatureVersionIncrement].[CurrentlyUnused] - [BuildNumber] (in which [BuildNumber] is a four-digit number) (e.g. 10.0.7.0 - 9247)
        ///</summary>
public IValueTag<string> MaximumSupportedVersion => _maximumSupportedVersion;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("CassandraReady", nameof(CassandraReady), _cassandraReady, value => _cassandraReady = value);
            ParseElementTag("CassandraRequired", nameof(CassandraRequired), _cassandraRequired, value => _cassandraRequired = value);
            ParseElementTag("MinimumRequiredVersion", nameof(MinimumRequiredVersion), _minimumRequiredVersion, value => _minimumRequiredVersion = value);
            ParseElementTag("MaximumSupportedVersion", nameof(MaximumSupportedVersion), _maximumSupportedVersion, value => _maximumSupportedVersion = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCompliancies(this);
        }
    }

    ///<summary>
    /// Defines communication connections.
    ///</summary>
internal partial class Connections : SimpleProtocolListNode<ConnectionsConnection>, IConnections
    {
        internal Connections(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Connections", "Connection")
        {
        }

        IConnectionsConnection IReadOnlyList<IConnectionsConnection>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnection> IEnumerable<IConnectionsConnection>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnections(this);
        }
    }

    ///<summary>
    /// Defines a connection.
    ///</summary>
internal partial class ConnectionsConnection : ElementTag, IConnectionsConnection
    {
        internal ConnectionsConnection(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Connection")
        {
        }

        private ConnectionsConnectionVirtual _virtual;
        private ConnectionsConnectionSnmp _snmp;
        private ConnectionsConnectionSnmpV2 _snmpV2;
        private ConnectionsConnectionSnmpV3 _snmpV3;
        private ConnectionsConnectionHttp _http;
        private ConnectionsConnectionSerial _serial;
        private ConnectionsConnectionSmartSerial _smartSerial;
        private ConnectionsConnectionGpib _gpib;
        private ConnectionsConnectionOpc _opc;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _name;
        ///<summary>
        /// Defines a Virtual connection.
        ///</summary>
public IConnectionsConnectionVirtual Virtual => _virtual;
        ///<summary>
        /// Defines an SNMP connection.
        ///</summary>
public IConnectionsConnectionSnmp Snmp => _snmp;
        ///<summary>
        /// Defines an SNMPv2 connection.
        ///</summary>
public IConnectionsConnectionSnmpV2 SnmpV2 => _snmpV2;
        ///<summary>
        /// Defines an SNMPv3 connection.
        ///</summary>
public IConnectionsConnectionSnmpV3 SnmpV3 => _snmpV3;
        ///<summary>
        /// Defines an HTTP connection.
        ///</summary>
public IConnectionsConnectionHttp Http => _http;
        ///<summary>
        /// Defines a serial connection.
        ///</summary>
public IConnectionsConnectionSerial Serial => _serial;
        ///<summary>
        /// Defines a smart-serial connection.
        ///</summary>
public IConnectionsConnectionSmartSerial SmartSerial => _smartSerial;
        ///<summary>
        /// Defines a GPIB connection.
        ///</summary>
public IConnectionsConnectionGpib Gpib => _gpib;
        ///<summary>
        /// Defines a OPC connection.
        ///</summary>
public IConnectionsConnectionOpc Opc => _opc;
        ///<summary>
        /// Specifies the connection ID.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies the connection name.
        ///</summary>
public IValueTag<string> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Virtual", nameof(Virtual), _virtual, value => _virtual = value);
            ParseElementTag("Snmp", nameof(Snmp), _snmp, value => _snmp = value);
            ParseElementTag("SnmpV2", nameof(SnmpV2), _snmpV2, value => _snmpV2 = value);
            ParseElementTag("SnmpV3", nameof(SnmpV3), _snmpV3, value => _snmpV3 = value);
            ParseElementTag("Http", nameof(Http), _http, value => _http = value);
            ParseElementTag("Serial", nameof(Serial), _serial, value => _serial = value);
            ParseElementTag("SmartSerial", nameof(SmartSerial), _smartSerial, value => _smartSerial = value);
            ParseElementTag("Gpib", nameof(Gpib), _gpib, value => _gpib = value);
            ParseElementTag("Opc", nameof(Opc), _opc, value => _opc = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnection(this);
        }
    }

    ///<summary>
    /// Defines a Virtual connection.
    ///</summary>
internal partial class ConnectionsConnectionVirtual : ElementTag, IConnectionsConnectionVirtual
    {
        internal ConnectionsConnectionVirtual(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Virtual")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionVirtual(this);
        }
    }

    ///<summary>
    /// Defines an SNMP connection.
    ///</summary>
internal partial class ConnectionsConnectionSnmp : ElementTag, IConnectionsConnectionSnmp
    {
        internal ConnectionsConnectionSnmp(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Snmp")
        {
        }

        private ConnectionsConnectionSnmpCommunicationOptions _communicationOptions;
        private ConnectionsConnectionSnmpUserSettings _userSettings;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public IConnectionsConnectionSnmpCommunicationOptions CommunicationOptions => _communicationOptions;
        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public IConnectionsConnectionSnmpUserSettings UserSettings => _userSettings;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("CommunicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmp(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpCommunicationOptions : ElementTag, IConnectionsConnectionSnmpCommunicationOptions
    {
        internal ConnectionsConnectionSnmpCommunicationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CommunicationOptions")
        {
        }

        private ElementValueTag<bool?> _redundantPolling;
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
public IValueTag<bool?> RedundantPolling => _redundantPolling;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("RedundantPolling", nameof(RedundantPolling), _redundantPolling, value => _redundantPolling = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpCommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettings : ElementTag, IConnectionsConnectionSnmpUserSettings
    {
        internal ConnectionsConnectionSnmpUserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        private ConnectionsConnectionSnmpUserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSnmpUserSettingsIPport _iPport;
        private ConnectionsConnectionSnmpUserSettingsGetCommunity _getCommunity;
        private ConnectionsConnectionSnmpUserSettingsSetCommunity _setCommunity;
        private ConnectionsConnectionSnmpUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSnmpUserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public IConnectionsConnectionSnmpUserSettingsBusAddress BusAddress => _busAddress;
        ///<summary>
        /// Configures the port settings.
        ///</summary>
public IConnectionsConnectionSnmpUserSettingsIPport IPport => _iPport;
        ///<summary>
        /// Configures the get community string.
        ///</summary>
public IConnectionsConnectionSnmpUserSettingsGetCommunity GetCommunity => _getCommunity;
        ///<summary>
        /// Configures the get community string.
        ///</summary>
public IConnectionsConnectionSnmpUserSettingsSetCommunity SetCommunity => _setCommunity;
        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public IConnectionsConnectionSnmpUserSettingsTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public IConnectionsConnectionSnmpUserSettingsRetries Retries => _retries;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("GetCommunity", nameof(GetCommunity), _getCommunity, value => _getCommunity = value);
            ParseElementTag("SetCommunity", nameof(SetCommunity), _setCommunity, value => _setCommunity = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettingsBusAddress : ElementTag, IConnectionsConnectionSnmpUserSettingsBusAddress
    {
        internal ConnectionsConnectionSnmpUserSettingsBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSnmpUserSettingsBusAddressRange _range;
        private ConnectionsConnectionSnmpUserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IConnectionsConnectionSnmpUserSettingsBusAddressRange Range => _range;
        public IConnectionsConnectionSnmpUserSettingsBusAddressValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettingsBusAddressRange : ElementTag, IConnectionsConnectionSnmpUserSettingsBusAddressRange
    {
        internal ConnectionsConnectionSnmpUserSettingsBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsBusAddressRange(this);
        }
    }

    internal partial class ConnectionsConnectionSnmpUserSettingsBusAddressValues : SimpleProtocolListNode<ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue>, IConnectionsConnectionSnmpUserSettingsBusAddressValues
    {
        internal ConnectionsConnectionSnmpUserSettingsBusAddressValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue IReadOnlyList<IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue> IEnumerable<IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue : ElementValueTag<string>, IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue
    {
        internal ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettingsIPport : ElementTag, IConnectionsConnectionSnmpUserSettingsIPport
    {
        internal ConnectionsConnectionSnmpUserSettingsIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettingsGetCommunity : ElementTag, IConnectionsConnectionSnmpUserSettingsGetCommunity
    {
        internal ConnectionsConnectionSnmpUserSettingsGetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "GetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        public IValueTag<string> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsGetCommunity(this);
        }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettingsSetCommunity : ElementTag, IConnectionsConnectionSnmpUserSettingsSetCommunity
    {
        internal ConnectionsConnectionSnmpUserSettingsSetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        public IValueTag<string> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsSetCommunity(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettingsTimeoutTime : ElementTag, IConnectionsConnectionSnmpUserSettingsTimeoutTime
    {
        internal ConnectionsConnectionSnmpUserSettingsTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpUserSettingsRetries : ElementTag, IConnectionsConnectionSnmpUserSettingsRetries
    {
        internal ConnectionsConnectionSnmpUserSettingsRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines an SNMPv2 connection.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2 : ElementTag, IConnectionsConnectionSnmpV2
    {
        internal ConnectionsConnectionSnmpV2(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SnmpV2")
        {
        }

        private ConnectionsConnectionSnmpV2CommunicationOptions _communicationOptions;
        private ConnectionsConnectionSnmpV2UserSettings _userSettings;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public IConnectionsConnectionSnmpV2CommunicationOptions CommunicationOptions => _communicationOptions;
        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public IConnectionsConnectionSnmpV2UserSettings UserSettings => _userSettings;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("CommunicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2CommunicationOptions : ElementTag, IConnectionsConnectionSnmpV2CommunicationOptions
    {
        internal ConnectionsConnectionSnmpV2CommunicationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CommunicationOptions")
        {
        }

        private ElementValueTag<bool?> _redundantPolling;
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
public IValueTag<bool?> RedundantPolling => _redundantPolling;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("RedundantPolling", nameof(RedundantPolling), _redundantPolling, value => _redundantPolling = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2CommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettings : ElementTag, IConnectionsConnectionSnmpV2UserSettings
    {
        internal ConnectionsConnectionSnmpV2UserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        private ConnectionsConnectionSnmpV2UserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSnmpV2UserSettingsIPport _iPport;
        private ConnectionsConnectionSnmpV2UserSettingsGetCommunity _getCommunity;
        private ConnectionsConnectionSnmpV2UserSettingsSetCommunity _setCommunity;
        private ConnectionsConnectionSnmpV2UserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSnmpV2UserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public IConnectionsConnectionSnmpV2UserSettingsBusAddress BusAddress => _busAddress;
        ///<summary>
        /// Configures the port settings.
        ///</summary>
public IConnectionsConnectionSnmpV2UserSettingsIPport IPport => _iPport;
        ///<summary>
        /// Configures the get community string.
        ///</summary>
public IConnectionsConnectionSnmpV2UserSettingsGetCommunity GetCommunity => _getCommunity;
        ///<summary>
        /// Configures the get community string.
        ///</summary>
public IConnectionsConnectionSnmpV2UserSettingsSetCommunity SetCommunity => _setCommunity;
        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public IConnectionsConnectionSnmpV2UserSettingsTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public IConnectionsConnectionSnmpV2UserSettingsRetries Retries => _retries;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("GetCommunity", nameof(GetCommunity), _getCommunity, value => _getCommunity = value);
            ParseElementTag("SetCommunity", nameof(SetCommunity), _setCommunity, value => _setCommunity = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettingsBusAddress : ElementTag, IConnectionsConnectionSnmpV2UserSettingsBusAddress
    {
        internal ConnectionsConnectionSnmpV2UserSettingsBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSnmpV2UserSettingsBusAddressRange _range;
        private ConnectionsConnectionSnmpV2UserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IConnectionsConnectionSnmpV2UserSettingsBusAddressRange Range => _range;
        public IConnectionsConnectionSnmpV2UserSettingsBusAddressValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettingsBusAddressRange : ElementTag, IConnectionsConnectionSnmpV2UserSettingsBusAddressRange
    {
        internal ConnectionsConnectionSnmpV2UserSettingsBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsBusAddressRange(this);
        }
    }

    internal partial class ConnectionsConnectionSnmpV2UserSettingsBusAddressValues : SimpleProtocolListNode<ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue>, IConnectionsConnectionSnmpV2UserSettingsBusAddressValues
    {
        internal ConnectionsConnectionSnmpV2UserSettingsBusAddressValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue IReadOnlyList<IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue> IEnumerable<IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue : ElementValueTag<string>, IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue
    {
        internal ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettingsIPport : ElementTag, IConnectionsConnectionSnmpV2UserSettingsIPport
    {
        internal ConnectionsConnectionSnmpV2UserSettingsIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettingsGetCommunity : ElementTag, IConnectionsConnectionSnmpV2UserSettingsGetCommunity
    {
        internal ConnectionsConnectionSnmpV2UserSettingsGetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "GetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        public IValueTag<string> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsGetCommunity(this);
        }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettingsSetCommunity : ElementTag, IConnectionsConnectionSnmpV2UserSettingsSetCommunity
    {
        internal ConnectionsConnectionSnmpV2UserSettingsSetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        public IValueTag<string> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsSetCommunity(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettingsTimeoutTime : ElementTag, IConnectionsConnectionSnmpV2UserSettingsTimeoutTime
    {
        internal ConnectionsConnectionSnmpV2UserSettingsTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV2UserSettingsRetries : ElementTag, IConnectionsConnectionSnmpV2UserSettingsRetries
    {
        internal ConnectionsConnectionSnmpV2UserSettingsRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines an SNMPv3 connection.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3 : ElementTag, IConnectionsConnectionSnmpV3
    {
        internal ConnectionsConnectionSnmpV3(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SnmpV3")
        {
        }

        private ConnectionsConnectionSnmpV3CommunicationOptions _communicationOptions;
        private ConnectionsConnectionSnmpV3UserSettings _userSettings;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public IConnectionsConnectionSnmpV3CommunicationOptions CommunicationOptions => _communicationOptions;
        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettings UserSettings => _userSettings;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("CommunicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3CommunicationOptions : ElementTag, IConnectionsConnectionSnmpV3CommunicationOptions
    {
        internal ConnectionsConnectionSnmpV3CommunicationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CommunicationOptions")
        {
        }

        private ElementValueTag<bool?> _redundantPolling;
        private ElementValueTag<string> _dynamicContextName;
        private ElementValueTag<string> _dynamicContextID;
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
public IValueTag<bool?> RedundantPolling => _redundantPolling;
        ///<summary>
        /// Specifies the dynamic context name.
        ///</summary>
public IValueTag<string> DynamicContextName => _dynamicContextName;
        ///<summary>
        /// Specifies the dynamic context ID.
        ///</summary>
public IValueTag<string> DynamicContextID => _dynamicContextID;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("RedundantPolling", nameof(RedundantPolling), _redundantPolling, value => _redundantPolling = value);
            ParseElementTag("DynamicContextName", nameof(DynamicContextName), _dynamicContextName, value => _dynamicContextName = value);
            ParseElementTag("DynamicContextID", nameof(DynamicContextID), _dynamicContextID, value => _dynamicContextID = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3CommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettings : ElementTag, IConnectionsConnectionSnmpV3UserSettings
    {
        internal ConnectionsConnectionSnmpV3UserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        private ConnectionsConnectionSnmpV3UserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSnmpV3UserSettingsIPport _iPport;
        private ConnectionsConnectionSnmpV3UserSettingsSecurityLevel _securityLevel;
        private ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm _authenticationAlgorithm;
        private ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm _encryptionAlgorithm;
        private ConnectionsConnectionSnmpV3UserSettingsUserName _userName;
        private ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword _authenticationPassword;
        private ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword _encryptionPassword;
        private ConnectionsConnectionSnmpV3UserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSnmpV3UserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsBusAddress BusAddress => _busAddress;
        ///<summary>
        /// Configures the port settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsIPport IPport => _iPport;
        ///<summary>
        /// Specifies the security level settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsSecurityLevel SecurityLevel => _securityLevel;
        ///<summary>
        /// Specifies the authentication algorithm settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm AuthenticationAlgorithm => _authenticationAlgorithm;
        ///<summary>
        /// Specifies the encryption algorithm settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm EncryptionAlgorithm => _encryptionAlgorithm;
        ///<summary>
        /// Specifies the user name settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsUserName UserName => _userName;
        ///<summary>
        /// Specifies the authentication password settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword AuthenticationPassword => _authenticationPassword;
        ///<summary>
        /// Specifies the encryption password settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword EncryptionPassword => _encryptionPassword;
        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsRetries Retries => _retries;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("SecurityLevel", nameof(SecurityLevel), _securityLevel, value => _securityLevel = value);
            ParseElementTag("AuthenticationAlgorithm", nameof(AuthenticationAlgorithm), _authenticationAlgorithm, value => _authenticationAlgorithm = value);
            ParseElementTag("EncryptionAlgorithm", nameof(EncryptionAlgorithm), _encryptionAlgorithm, value => _encryptionAlgorithm = value);
            ParseElementTag("UserName", nameof(UserName), _userName, value => _userName = value);
            ParseElementTag("AuthenticationPassword", nameof(AuthenticationPassword), _authenticationPassword, value => _authenticationPassword = value);
            ParseElementTag("EncryptionPassword", nameof(EncryptionPassword), _encryptionPassword, value => _encryptionPassword = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsBusAddress : ElementTag, IConnectionsConnectionSnmpV3UserSettingsBusAddress
    {
        internal ConnectionsConnectionSnmpV3UserSettingsBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSnmpV3UserSettingsBusAddressRange _range;
        private ConnectionsConnectionSnmpV3UserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IConnectionsConnectionSnmpV3UserSettingsBusAddressRange Range => _range;
        public IConnectionsConnectionSnmpV3UserSettingsBusAddressValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsBusAddressRange : ElementTag, IConnectionsConnectionSnmpV3UserSettingsBusAddressRange
    {
        internal ConnectionsConnectionSnmpV3UserSettingsBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsBusAddressRange(this);
        }
    }

    internal partial class ConnectionsConnectionSnmpV3UserSettingsBusAddressValues : SimpleProtocolListNode<ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue>, IConnectionsConnectionSnmpV3UserSettingsBusAddressValues
    {
        internal ConnectionsConnectionSnmpV3UserSettingsBusAddressValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue IReadOnlyList<IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue> IEnumerable<IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue : ElementValueTag<string>, IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue
    {
        internal ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsIPport : ElementTag, IConnectionsConnectionSnmpV3UserSettingsIPport
    {
        internal ConnectionsConnectionSnmpV3UserSettingsIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Specifies the security level settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsSecurityLevel : ElementTag, IConnectionsConnectionSnmpV3UserSettingsSecurityLevel
    {
        internal ConnectionsConnectionSnmpV3UserSettingsSecurityLevel(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SecurityLevel")
        {
        }

        private ElementValueTag<string> _defaultValue;
        public IValueTag<string> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsSecurityLevel(this);
        }
    }

    ///<summary>
    /// Specifies the authentication algorithm settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm : ElementTag, IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm
    {
        internal ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AuthenticationAlgorithm")
        {
        }

        private ElementValueTag<string> _defaultValue;
        public IValueTag<string> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm(this);
        }
    }

    ///<summary>
    /// Specifies the encryption algorithm settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm : ElementTag, IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm
    {
        internal ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm(ProtocolModel model, ProtocolTag parent) : base(model, parent, "EncryptionAlgorithm")
        {
        }

        private ElementValueTag<string> _defaultValue;
        public IValueTag<string> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm(this);
        }
    }

    ///<summary>
    /// Specifies the user name settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsUserName : ElementTag, IConnectionsConnectionSnmpV3UserSettingsUserName
    {
        internal ConnectionsConnectionSnmpV3UserSettingsUserName(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserName")
        {
        }

        private ElementValueTag<string> _defaultValue;
        public IValueTag<string> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsUserName(this);
        }
    }

    ///<summary>
    /// Specifies the authentication password settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword : ElementTag, IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword
    {
        internal ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AuthenticationPassword")
        {
        }

        private ElementValueTag<string> _defaultValue;
        public IValueTag<string> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword(this);
        }
    }

    ///<summary>
    /// Specifies the encryption password settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword : ElementTag, IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword
    {
        internal ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword(ProtocolModel model, ProtocolTag parent) : base(model, parent, "EncryptionPassword")
        {
        }

        private ElementValueTag<string> _defaultValue;
        public IValueTag<string> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsEncryptionPassword(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsTimeoutTime : ElementTag, IConnectionsConnectionSnmpV3UserSettingsTimeoutTime
    {
        internal ConnectionsConnectionSnmpV3UserSettingsTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<uint?> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
internal partial class ConnectionsConnectionSnmpV3UserSettingsRetries : ElementTag, IConnectionsConnectionSnmpV3UserSettingsRetries
    {
        internal ConnectionsConnectionSnmpV3UserSettingsRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<uint?> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines an HTTP connection.
    ///</summary>
internal partial class ConnectionsConnectionHttp : ElementTag, IConnectionsConnectionHttp
    {
        internal ConnectionsConnectionHttp(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Http")
        {
        }

        private ConnectionsConnectionHttpCommunicationOptions _communicationOptions;
        private ConnectionsConnectionHttpUserSettings _userSettings;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public IConnectionsConnectionHttpCommunicationOptions CommunicationOptions => _communicationOptions;
        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public IConnectionsConnectionHttpUserSettings UserSettings => _userSettings;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("CommunicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttp(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
internal partial class ConnectionsConnectionHttpCommunicationOptions : ElementTag, IConnectionsConnectionHttpCommunicationOptions
    {
        internal ConnectionsConnectionHttpCommunicationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CommunicationOptions")
        {
        }

        private ElementValueTag<bool?> _webSocket;
        private ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs _notifyConnectionPIDs;
        private ElementValueTag<bool?> _makeCommandByProtocol;
        private ElementValueTag<uint?> _webSocketHandshake;
        private ElementValueTag<bool?> _redundantPolling;
        ///<summary>
        /// Specifies whether this connection is an HTTP connection.
        ///</summary>
public IValueTag<bool?> WebSocket => _webSocket;
        ///<summary>
        /// Specifies the parameter IDs to use to monitor (dis)connects.
        ///</summary>
public IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs NotifyConnectionPIDs => _notifyConnectionPIDs;
        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
public IValueTag<bool?> MakeCommandByProtocol => _makeCommandByProtocol;
        ///<summary>
        /// Specifies the ID of the Session to use as a custom opening handshake.
        ///</summary>
public IValueTag<uint?> WebSocketHandshake => _webSocketHandshake;
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
public IValueTag<bool?> RedundantPolling => _redundantPolling;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("WebSocket", nameof(WebSocket), _webSocket, value => _webSocket = value);
            ParseElementTag("NotifyConnectionPIDs", nameof(NotifyConnectionPIDs), _notifyConnectionPIDs, value => _notifyConnectionPIDs = value);
            ParseElementTag("MakeCommandByProtocol", nameof(MakeCommandByProtocol), _makeCommandByProtocol, value => _makeCommandByProtocol = value);
            ParseElementTag("WebSocketHandshake", nameof(WebSocketHandshake), _webSocketHandshake, value => _webSocketHandshake = value);
            ParseElementTag("RedundantPolling", nameof(RedundantPolling), _redundantPolling, value => _redundantPolling = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpCommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the parameter IDs to use to monitor (dis)connects.
    ///</summary>
internal partial class ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs : ElementTag, IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs
    {
        internal ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs(ProtocolModel model, ProtocolTag parent) : base(model, parent, "NotifyConnectionPIDs")
        {
        }

        private ElementValueTag<uint?> _connections;
        private ElementValueTag<uint?> _disconnections;
        ///<summary>
        /// Specifies the ID of the parameter in which the connects have to be logged.
        ///</summary>
public IValueTag<uint?> Connections => _connections;
        ///<summary>
        /// Specifies the ID of the parameter in which the disconnects have to be logged.
        ///</summary>
public IValueTag<uint?> Disconnections => _disconnections;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Connections", nameof(Connections), _connections, value => _connections = value);
            ParseElementTag("Disconnections", nameof(Disconnections), _disconnections, value => _disconnections = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
internal partial class ConnectionsConnectionHttpUserSettings : ElementTag, IConnectionsConnectionHttpUserSettings
    {
        internal ConnectionsConnectionHttpUserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        private ConnectionsConnectionHttpUserSettingsBusAddress _busAddress;
        private ConnectionsConnectionHttpUserSettingsIPport _iPport;
        private ConnectionsConnectionHttpUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionHttpUserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public IConnectionsConnectionHttpUserSettingsBusAddress BusAddress => _busAddress;
        ///<summary>
        /// Configures the port settings.
        ///</summary>
public IConnectionsConnectionHttpUserSettingsIPport IPport => _iPport;
        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public IConnectionsConnectionHttpUserSettingsTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public IConnectionsConnectionHttpUserSettingsRetries Retries => _retries;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
internal partial class ConnectionsConnectionHttpUserSettingsBusAddress : ElementTag, IConnectionsConnectionHttpUserSettingsBusAddress
    {
        internal ConnectionsConnectionHttpUserSettingsBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionHttpUserSettingsBusAddressRange _range;
        private ConnectionsConnectionHttpUserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IConnectionsConnectionHttpUserSettingsBusAddressRange Range => _range;
        public IConnectionsConnectionHttpUserSettingsBusAddressValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class ConnectionsConnectionHttpUserSettingsBusAddressRange : ElementTag, IConnectionsConnectionHttpUserSettingsBusAddressRange
    {
        internal ConnectionsConnectionHttpUserSettingsBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsBusAddressRange(this);
        }
    }

    internal partial class ConnectionsConnectionHttpUserSettingsBusAddressValues : SimpleProtocolListNode<ConnectionsConnectionHttpUserSettingsBusAddressValuesValue>, IConnectionsConnectionHttpUserSettingsBusAddressValues
    {
        internal ConnectionsConnectionHttpUserSettingsBusAddressValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionHttpUserSettingsBusAddressValuesValue IReadOnlyList<IConnectionsConnectionHttpUserSettingsBusAddressValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionHttpUserSettingsBusAddressValuesValue> IEnumerable<IConnectionsConnectionHttpUserSettingsBusAddressValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionHttpUserSettingsBusAddressValuesValue : ElementValueTag<string>, IConnectionsConnectionHttpUserSettingsBusAddressValuesValue
    {
        internal ConnectionsConnectionHttpUserSettingsBusAddressValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
internal partial class ConnectionsConnectionHttpUserSettingsIPport : ElementTag, IConnectionsConnectionHttpUserSettingsIPport
    {
        internal ConnectionsConnectionHttpUserSettingsIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
internal partial class ConnectionsConnectionHttpUserSettingsTimeoutTime : ElementTag, IConnectionsConnectionHttpUserSettingsTimeoutTime
    {
        internal ConnectionsConnectionHttpUserSettingsTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<uint?> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
internal partial class ConnectionsConnectionHttpUserSettingsRetries : ElementTag, IConnectionsConnectionHttpUserSettingsRetries
    {
        internal ConnectionsConnectionHttpUserSettingsRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<uint?> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines a serial connection.
    ///</summary>
internal partial class ConnectionsConnectionSerial : ElementTag, IConnectionsConnectionSerial
    {
        internal ConnectionsConnectionSerial(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Serial")
        {
        }

        private ConnectionsConnectionSerialCommunicationOptions _communicationOptions;
        private ConnectionsConnectionSerialUserSettings _userSettings;
        private AttributeTag<bool?> _single;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public IConnectionsConnectionSerialCommunicationOptions CommunicationOptions => _communicationOptions;
        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettings UserSettings => _userSettings;
        ///<summary>
        /// Specifies whether this is a dedicated connection.
        ///</summary>
public IValueTag<bool?> Single => _single;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("single", nameof(Single), _single, value => _single = value);
            ParseElementTag("CommunicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerial(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialCommunicationOptions : ElementTag, IConnectionsConnectionSerialCommunicationOptions
    {
        internal ConnectionsConnectionSerialCommunicationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CommunicationOptions")
        {
        }

        private ElementValueTag<bool?> _chunkedHTML;
        private ElementValueTag<bool?> _closeConnectionOnResponse;
        private ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms _kexAlgorithms;
        private ElementValueTag<bool?> _makeCommandByProtocol;
        private ElementValueTag<bool?> _redundantPolling;
        public IValueTag<bool?> ChunkedHTML => _chunkedHTML;
        public IValueTag<bool?> CloseConnectionOnResponse => _closeConnectionOnResponse;
        public IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms KexAlgorithms => _kexAlgorithms;
        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
public IValueTag<bool?> MakeCommandByProtocol => _makeCommandByProtocol;
        public IValueTag<bool?> RedundantPolling => _redundantPolling;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("ChunkedHTML", nameof(ChunkedHTML), _chunkedHTML, value => _chunkedHTML = value);
            ParseElementTag("CloseConnectionOnResponse", nameof(CloseConnectionOnResponse), _closeConnectionOnResponse, value => _closeConnectionOnResponse = value);
            ParseElementTag("KexAlgorithms", nameof(KexAlgorithms), _kexAlgorithms, value => _kexAlgorithms = value);
            ParseElementTag("MakeCommandByProtocol", nameof(MakeCommandByProtocol), _makeCommandByProtocol, value => _makeCommandByProtocol = value);
            ParseElementTag("RedundantPolling", nameof(RedundantPolling), _redundantPolling, value => _redundantPolling = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialCommunicationOptions(this);
        }
    }

    internal partial class ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms : SimpleProtocolListNode<ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm>, IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms
    {
        internal ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms(ProtocolModel model, ProtocolTag parent) : base(model, parent, "KexAlgorithms", "KexAlgorithm")
        {
        }

        IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm IReadOnlyList<IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm> IEnumerable<IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialCommunicationOptionsKexAlgorithms(this);
        }
    }

    internal partial class ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm : ElementValueTag<string>, IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm
    {
        internal ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm(ProtocolModel model, ProtocolTag parent) : base(model, parent, "KexAlgorithm")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettings : ElementTag, IConnectionsConnectionSerialUserSettings
    {
        internal ConnectionsConnectionSerialUserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        private ConnectionsConnectionSerialUserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSerialUserSettingsIPport _iPport;
        private ConnectionsConnectionSerialUserSettingsBaudrate _baudrate;
        private ConnectionsConnectionSerialUserSettingsParity _parity;
        private ConnectionsConnectionSerialUserSettingsDatabits _databits;
        private ConnectionsConnectionSerialUserSettingsStopbits _stopbits;
        private ConnectionsConnectionSerialUserSettingsFlowcontrol _flowcontrol;
        private ConnectionsConnectionSerialUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSerialUserSettingsRetries _retries;
        private ConnectionsConnectionSerialUserSettingsPortTypeIP _portTypeIP;
        private ConnectionsConnectionSerialUserSettingsPortTypeSerial _portTypeSerial;
        private ConnectionsConnectionSerialUserSettingsPortTypeUDP _portTypeUDP;
        private ConnectionsConnectionSerialUserSettingsType _type;
        private ConnectionsConnectionSerialUserSettingsSslTlsEnabled _sslTlsEnabled;
        private ConnectionsConnectionSerialUserSettingsLocalIPport _localIPport;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsBusAddress BusAddress => _busAddress;
        ///<summary>
        /// Configures the port settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsIPport IPport => _iPport;
        public IConnectionsConnectionSerialUserSettingsBaudrate Baudrate => _baudrate;
        public IConnectionsConnectionSerialUserSettingsParity Parity => _parity;
        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsDatabits Databits => _databits;
        ///<summary>
        /// Specifies the stop bits settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsStopbits Stopbits => _stopbits;
        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsFlowcontrol Flowcontrol => _flowcontrol;
        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsRetries Retries => _retries;
        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsPortTypeIP PortTypeIP => _portTypeIP;
        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsPortTypeSerial PortTypeSerial => _portTypeSerial;
        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsPortTypeUDP PortTypeUDP => _portTypeUDP;
        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsType Type => _type;
        ///<summary>
        /// Specifies the SSL/TLS settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsSslTlsEnabled SslTlsEnabled => _sslTlsEnabled;
        ///<summary>
        /// Specifies the local port settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsLocalIPport LocalIPport => _localIPport;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("Baudrate", nameof(Baudrate), _baudrate, value => _baudrate = value);
            ParseElementTag("Parity", nameof(Parity), _parity, value => _parity = value);
            ParseElementTag("Databits", nameof(Databits), _databits, value => _databits = value);
            ParseElementTag("Stopbits", nameof(Stopbits), _stopbits, value => _stopbits = value);
            ParseElementTag("Flowcontrol", nameof(Flowcontrol), _flowcontrol, value => _flowcontrol = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
            ParseElementTag("PortTypeIP", nameof(PortTypeIP), _portTypeIP, value => _portTypeIP = value);
            ParseElementTag("PortTypeSerial", nameof(PortTypeSerial), _portTypeSerial, value => _portTypeSerial = value);
            ParseElementTag("PortTypeUDP", nameof(PortTypeUDP), _portTypeUDP, value => _portTypeUDP = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
            ParseElementTag("SslTlsEnabled", nameof(SslTlsEnabled), _sslTlsEnabled, value => _sslTlsEnabled = value);
            ParseElementTag("LocalIPport", nameof(LocalIPport), _localIPport, value => _localIPport = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsBusAddress : ElementTag, IConnectionsConnectionSerialUserSettingsBusAddress
    {
        internal ConnectionsConnectionSerialUserSettingsBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsBusAddressRange _range;
        private ConnectionsConnectionSerialUserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsBusAddressRange Range => _range;
        public IConnectionsConnectionSerialUserSettingsBusAddressValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsBusAddressRange : ElementTag, IConnectionsConnectionSerialUserSettingsBusAddressRange
    {
        internal ConnectionsConnectionSerialUserSettingsBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBusAddressRange(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsBusAddressValues : SimpleProtocolListNode<ConnectionsConnectionSerialUserSettingsBusAddressValuesValue>, IConnectionsConnectionSerialUserSettingsBusAddressValues
    {
        internal ConnectionsConnectionSerialUserSettingsBusAddressValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSerialUserSettingsBusAddressValuesValue IReadOnlyList<IConnectionsConnectionSerialUserSettingsBusAddressValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSerialUserSettingsBusAddressValuesValue> IEnumerable<IConnectionsConnectionSerialUserSettingsBusAddressValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsBusAddressValuesValue : ElementValueTag<string>, IConnectionsConnectionSerialUserSettingsBusAddressValuesValue
    {
        internal ConnectionsConnectionSerialUserSettingsBusAddressValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsIPport : ElementTag, IConnectionsConnectionSerialUserSettingsIPport
    {
        internal ConnectionsConnectionSerialUserSettingsIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsIPport(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsBaudrate : ElementTag, IConnectionsConnectionSerialUserSettingsBaudrate
    {
        internal ConnectionsConnectionSerialUserSettingsBaudrate(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Baudrate")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsBaudrateRange _range;
        private ConnectionsConnectionSerialUserSettingsBaudrateValues _values;
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsBaudrateRange Range => _range;
        public IConnectionsConnectionSerialUserSettingsBaudrateValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBaudrate(this);
        }
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsBaudrateRange : ElementTag, IConnectionsConnectionSerialUserSettingsBaudrateRange
    {
        internal ConnectionsConnectionSerialUserSettingsBaudrateRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<uint?> _from;
        private ElementValueTag<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
public IValueTag<uint?> From => _from;
        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
public IValueTag<uint?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBaudrateRange(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsBaudrateValues : SimpleProtocolListNode<ConnectionsConnectionSerialUserSettingsBaudrateValuesValue>, IConnectionsConnectionSerialUserSettingsBaudrateValues
    {
        internal ConnectionsConnectionSerialUserSettingsBaudrateValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSerialUserSettingsBaudrateValuesValue IReadOnlyList<IConnectionsConnectionSerialUserSettingsBaudrateValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSerialUserSettingsBaudrateValuesValue> IEnumerable<IConnectionsConnectionSerialUserSettingsBaudrateValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBaudrateValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsBaudrateValuesValue : ElementValueTag<string>, IConnectionsConnectionSerialUserSettingsBaudrateValuesValue
    {
        internal ConnectionsConnectionSerialUserSettingsBaudrateValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBaudrateValuesValue(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsParity : ElementTag, IConnectionsConnectionSerialUserSettingsParity
    {
        internal ConnectionsConnectionSerialUserSettingsParity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Parity")
        {
        }

        private ConnectionsConnectionSerialUserSettingsParityDefaultValue _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsParityRange _range;
        private ConnectionsConnectionSerialUserSettingsParityValues _values;
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsParity?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsParityRange Range => _range;
        public IConnectionsConnectionSerialUserSettingsParityValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsParity(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsParityDefaultValue : ElementValueTag<Enums.EnumPortSettingsParity?>
    {
        internal ConnectionsConnectionSerialUserSettingsParityDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsParityRange : ElementTag, IConnectionsConnectionSerialUserSettingsParityRange
    {
        internal ConnectionsConnectionSerialUserSettingsParityRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ConnectionsConnectionSerialUserSettingsParityRangeFrom _from;
        private ConnectionsConnectionSerialUserSettingsParityRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsParity?> From => _from;
        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsParity?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsParityRange(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsParityRangeFrom : ElementValueTag<Enums.EnumPortSettingsParity?>
    {
        internal ConnectionsConnectionSerialUserSettingsParityRangeFrom(ProtocolModel model, ProtocolTag parent) : base(model, parent, "From")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsParityRangeTo : ElementValueTag<Enums.EnumPortSettingsParity?>
    {
        internal ConnectionsConnectionSerialUserSettingsParityRangeTo(ProtocolModel model, ProtocolTag parent) : base(model, parent, "To")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsParityValues : SimpleProtocolListNode<ConnectionsConnectionSerialUserSettingsParityValuesValue>, IConnectionsConnectionSerialUserSettingsParityValues
    {
        internal ConnectionsConnectionSerialUserSettingsParityValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSerialUserSettingsParityValuesValue IReadOnlyList<IConnectionsConnectionSerialUserSettingsParityValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSerialUserSettingsParityValuesValue> IEnumerable<IConnectionsConnectionSerialUserSettingsParityValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsParityValues(this);
        }
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsParityValuesValue : ElementValueTag<Enums.EnumPortSettingsParity?>, IConnectionsConnectionSerialUserSettingsParityValuesValue
    {
        internal ConnectionsConnectionSerialUserSettingsParityValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsParityValuesValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsDatabits : ElementTag, IConnectionsConnectionSerialUserSettingsDatabits
    {
        internal ConnectionsConnectionSerialUserSettingsDatabits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Databits")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsDatabitsRange _range;
        private ConnectionsConnectionSerialUserSettingsDatabitsValues _values;
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsDatabitsRange Range => _range;
        public IConnectionsConnectionSerialUserSettingsDatabitsValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsDatabits(this);
        }
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsDatabitsRange : ElementTag, IConnectionsConnectionSerialUserSettingsDatabitsRange
    {
        internal ConnectionsConnectionSerialUserSettingsDatabitsRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<uint?> _from;
        private ElementValueTag<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
public IValueTag<uint?> From => _from;
        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
public IValueTag<uint?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsDatabitsRange(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsDatabitsValues : SimpleProtocolListNode<ConnectionsConnectionSerialUserSettingsDatabitsValuesValue>, IConnectionsConnectionSerialUserSettingsDatabitsValues
    {
        internal ConnectionsConnectionSerialUserSettingsDatabitsValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSerialUserSettingsDatabitsValuesValue IReadOnlyList<IConnectionsConnectionSerialUserSettingsDatabitsValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSerialUserSettingsDatabitsValuesValue> IEnumerable<IConnectionsConnectionSerialUserSettingsDatabitsValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsDatabitsValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsDatabitsValuesValue : ElementValueTag<uint?>, IConnectionsConnectionSerialUserSettingsDatabitsValuesValue
    {
        internal ConnectionsConnectionSerialUserSettingsDatabitsValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsDatabitsValuesValue(this);
        }
    }

    ///<summary>
    /// Specifies the stop bits settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsStopbits : ElementTag, IConnectionsConnectionSerialUserSettingsStopbits
    {
        internal ConnectionsConnectionSerialUserSettingsStopbits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Stopbits")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsStopbitsValues _values;
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        public IConnectionsConnectionSerialUserSettingsStopbitsValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsStopbits(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsStopbitsValues : SimpleProtocolListNode<ConnectionsConnectionSerialUserSettingsStopbitsValuesValue>, IConnectionsConnectionSerialUserSettingsStopbitsValues
    {
        internal ConnectionsConnectionSerialUserSettingsStopbitsValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSerialUserSettingsStopbitsValuesValue IReadOnlyList<IConnectionsConnectionSerialUserSettingsStopbitsValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSerialUserSettingsStopbitsValuesValue> IEnumerable<IConnectionsConnectionSerialUserSettingsStopbitsValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsStopbitsValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsStopbitsValuesValue : ElementValueTag<Enums.EnumPortSettingsStopBits?>, IConnectionsConnectionSerialUserSettingsStopbitsValuesValue
    {
        internal ConnectionsConnectionSerialUserSettingsStopbitsValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsStopBits? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsStopBitsConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsStopbitsValuesValue(this);
        }
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsFlowcontrol : ElementTag, IConnectionsConnectionSerialUserSettingsFlowcontrol
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrol(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Flowcontrol")
        {
        }

        private ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsFlowcontrolRange _range;
        private ConnectionsConnectionSerialUserSettingsFlowcontrolValues _values;
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsFlowControl?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
public IConnectionsConnectionSerialUserSettingsFlowcontrolRange Range => _range;
        public IConnectionsConnectionSerialUserSettingsFlowcontrolValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsFlowcontrol(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue : ElementValueTag<Enums.EnumPortSettingsFlowControl?>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsFlowcontrolRange : ElementTag, IConnectionsConnectionSerialUserSettingsFlowcontrolRange
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom _from;
        private ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsFlowControl?> From => _from;
        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsFlowControl?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsFlowcontrolRange(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom : ElementValueTag<Enums.EnumPortSettingsFlowControl?>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom(ProtocolModel model, ProtocolTag parent) : base(model, parent, "From")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo : ElementValueTag<Enums.EnumPortSettingsFlowControl?>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo(ProtocolModel model, ProtocolTag parent) : base(model, parent, "To")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsFlowcontrolValues : SimpleProtocolListNode<ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue>, IConnectionsConnectionSerialUserSettingsFlowcontrolValues
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue IReadOnlyList<IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue> IEnumerable<IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsFlowcontrolValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue : ElementValueTag<Enums.EnumPortSettingsFlowControl?>, IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsTimeoutTime : ElementTag, IConnectionsConnectionSerialUserSettingsTimeoutTime
    {
        internal ConnectionsConnectionSerialUserSettingsTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<uint?> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsRetries : ElementTag, IConnectionsConnectionSerialUserSettingsRetries
    {
        internal ConnectionsConnectionSerialUserSettingsRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<uint?> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsPortTypeIP : ElementTag, IConnectionsConnectionSerialUserSettingsPortTypeIP
    {
        internal ConnectionsConnectionSerialUserSettingsPortTypeIP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeIP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsPortTypeIP(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsPortTypeSerial : ElementTag, IConnectionsConnectionSerialUserSettingsPortTypeSerial
    {
        internal ConnectionsConnectionSerialUserSettingsPortTypeSerial(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeSerial")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsPortTypeSerial(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsPortTypeUDP : ElementTag, IConnectionsConnectionSerialUserSettingsPortTypeUDP
    {
        internal ConnectionsConnectionSerialUserSettingsPortTypeUDP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeUDP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsPortTypeUDP(this);
        }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsType : ElementTag, IConnectionsConnectionSerialUserSettingsType
    {
        internal ConnectionsConnectionSerialUserSettingsType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private ConnectionsConnectionSerialUserSettingsTypeDefaultValue _defaultValue;
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
public IValueTag<Enums.EnumPortTypes?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsType(this);
        }
    }

    internal partial class ConnectionsConnectionSerialUserSettingsTypeDefaultValue : ElementValueTag<Enums.EnumPortTypes?>
    {
        internal ConnectionsConnectionSerialUserSettingsTypeDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the SSL/TLS settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsSslTlsEnabled : ElementTag, IConnectionsConnectionSerialUserSettingsSslTlsEnabled
    {
        internal ConnectionsConnectionSerialUserSettingsSslTlsEnabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SslTlsEnabled")
        {
        }

        private ElementValueTag<bool?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public IValueTag<bool?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsSslTlsEnabled(this);
        }
    }

    ///<summary>
    /// Specifies the local port settings.
    ///</summary>
internal partial class ConnectionsConnectionSerialUserSettingsLocalIPport : ElementTag, IConnectionsConnectionSerialUserSettingsLocalIPport
    {
        internal ConnectionsConnectionSerialUserSettingsLocalIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LocalIPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsLocalIPport(this);
        }
    }

    ///<summary>
    /// Defines a smart-serial connection.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerial : ElementTag, IConnectionsConnectionSmartSerial
    {
        internal ConnectionsConnectionSmartSerial(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SmartSerial")
        {
        }

        private ConnectionsConnectionSmartSerialCommunicationOptions _communicationOptions;
        private ConnectionsConnectionSmartSerialUserSettings _userSettings;
        private AttributeTag<bool?> _single;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public IConnectionsConnectionSmartSerialCommunicationOptions CommunicationOptions => _communicationOptions;
        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettings UserSettings => _userSettings;
        ///<summary>
        /// Specifies whether this is a dedicated connection.
        ///</summary>
public IValueTag<bool?> Single => _single;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("single", nameof(Single), _single, value => _single = value);
            ParseElementTag("CommunicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerial(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialCommunicationOptions : ElementTag, IConnectionsConnectionSmartSerialCommunicationOptions
    {
        internal ConnectionsConnectionSmartSerialCommunicationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CommunicationOptions")
        {
        }

        private ElementValueTag<bool?> _makeCommandByProtocol;
        private ElementValueTag<uint?> _maxConcurrentConnections;
        private ElementValueTag<uint?> _maxReceiveBuffer;
        private ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs _notifyConnectionPIDs;
        private ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo _packetInfo;
        private ElementValueTag<bool?> _redundantPolling;
        private ElementValueTag<bool?> _smartIPHeader;
        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
public IValueTag<bool?> MakeCommandByProtocol => _makeCommandByProtocol;
        public IValueTag<uint?> MaxConcurrentConnections => _maxConcurrentConnections;
        public IValueTag<uint?> MaxReceiveBuffer => _maxReceiveBuffer;
        public IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs NotifyConnectionPIDs => _notifyConnectionPIDs;
        public IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo PacketInfo => _packetInfo;
        public IValueTag<bool?> RedundantPolling => _redundantPolling;
        public IValueTag<bool?> SmartIPHeader => _smartIPHeader;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("MakeCommandByProtocol", nameof(MakeCommandByProtocol), _makeCommandByProtocol, value => _makeCommandByProtocol = value);
            ParseElementTag("MaxConcurrentConnections", nameof(MaxConcurrentConnections), _maxConcurrentConnections, value => _maxConcurrentConnections = value);
            ParseElementTag("MaxReceiveBuffer", nameof(MaxReceiveBuffer), _maxReceiveBuffer, value => _maxReceiveBuffer = value);
            ParseElementTag("NotifyConnectionPIDs", nameof(NotifyConnectionPIDs), _notifyConnectionPIDs, value => _notifyConnectionPIDs = value);
            ParseElementTag("PacketInfo", nameof(PacketInfo), _packetInfo, value => _packetInfo = value);
            ParseElementTag("RedundantPolling", nameof(RedundantPolling), _redundantPolling, value => _redundantPolling = value);
            ParseElementTag("SmartIPHeader", nameof(SmartIPHeader), _smartIPHeader, value => _smartIPHeader = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialCommunicationOptions(this);
        }
    }

    internal partial class ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs : ElementTag, IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs
    {
        internal ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs(ProtocolModel model, ProtocolTag parent) : base(model, parent, "NotifyConnectionPIDs")
        {
        }

        private ElementValueTag<uint?> _connections;
        private ElementValueTag<uint?> _disconnections;
        public IValueTag<uint?> Connections => _connections;
        public IValueTag<uint?> Disconnections => _disconnections;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Connections", nameof(Connections), _connections, value => _connections = value);
            ParseElementTag("Disconnections", nameof(Disconnections), _disconnections, value => _disconnections = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs(this);
        }
    }

    internal partial class ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo : ElementTag, IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo
    {
        internal ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PacketInfo")
        {
        }

        private ElementValueTag<uint?> _lengthIdentifierOffset;
        private ElementValueTag<uint?> _lengthIdentifierLength;
        private ElementValueTag<bool?> _includeLengthIdentifier;
        private ElementValueTag<bool?> _littleEndian;
        public IValueTag<uint?> LengthIdentifierOffset => _lengthIdentifierOffset;
        public IValueTag<uint?> LengthIdentifierLength => _lengthIdentifierLength;
        public IValueTag<bool?> IncludeLengthIdentifier => _includeLengthIdentifier;
        public IValueTag<bool?> LittleEndian => _littleEndian;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("LengthIdentifierOffset", nameof(LengthIdentifierOffset), _lengthIdentifierOffset, value => _lengthIdentifierOffset = value);
            ParseElementTag("LengthIdentifierLength", nameof(LengthIdentifierLength), _lengthIdentifierLength, value => _lengthIdentifierLength = value);
            ParseElementTag("IncludeLengthIdentifier", nameof(IncludeLengthIdentifier), _includeLengthIdentifier, value => _includeLengthIdentifier = value);
            ParseElementTag("LittleEndian", nameof(LittleEndian), _littleEndian, value => _littleEndian = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettings : ElementTag, IConnectionsConnectionSmartSerialUserSettings
    {
        internal ConnectionsConnectionSmartSerialUserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        private ConnectionsConnectionSmartSerialUserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSmartSerialUserSettingsIPport _iPport;
        private ConnectionsConnectionSmartSerialUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSmartSerialUserSettingsRetries _retries;
        private ConnectionsConnectionSmartSerialUserSettingsPortTypeIP _portTypeIP;
        private ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP _portTypeUDP;
        private ConnectionsConnectionSmartSerialUserSettingsType _type;
        private ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled _sslTlsEnabled;
        private ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses _allowedIPAddresses;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsBusAddress BusAddress => _busAddress;
        ///<summary>
        /// Configures the port settings.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsIPport IPport => _iPport;
        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsRetries Retries => _retries;
        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsPortTypeIP PortTypeIP => _portTypeIP;
        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP PortTypeUDP => _portTypeUDP;
        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsType Type => _type;
        ///<summary>
        /// Specifies the SSL/TLS settings.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled SslTlsEnabled => _sslTlsEnabled;
        ///<summary>
        /// Specifies the local port settings.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses AllowedIPAddresses => _allowedIPAddresses;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
            ParseElementTag("PortTypeIP", nameof(PortTypeIP), _portTypeIP, value => _portTypeIP = value);
            ParseElementTag("PortTypeUDP", nameof(PortTypeUDP), _portTypeUDP, value => _portTypeUDP = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
            ParseElementTag("SslTlsEnabled", nameof(SslTlsEnabled), _sslTlsEnabled, value => _sslTlsEnabled = value);
            ParseElementTag("AllowedIPAddresses", nameof(AllowedIPAddresses), _allowedIPAddresses, value => _allowedIPAddresses = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsBusAddress : ElementTag, IConnectionsConnectionSmartSerialUserSettingsBusAddress
    {
        internal ConnectionsConnectionSmartSerialUserSettingsBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionSmartSerialUserSettingsBusAddressRange _range;
        private ConnectionsConnectionSmartSerialUserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IConnectionsConnectionSmartSerialUserSettingsBusAddressRange Range => _range;
        public IConnectionsConnectionSmartSerialUserSettingsBusAddressValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsBusAddressRange : ElementTag, IConnectionsConnectionSmartSerialUserSettingsBusAddressRange
    {
        internal ConnectionsConnectionSmartSerialUserSettingsBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsBusAddressRange(this);
        }
    }

    internal partial class ConnectionsConnectionSmartSerialUserSettingsBusAddressValues : SimpleProtocolListNode<ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue>, IConnectionsConnectionSmartSerialUserSettingsBusAddressValues
    {
        internal ConnectionsConnectionSmartSerialUserSettingsBusAddressValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue IReadOnlyList<IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue> IEnumerable<IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue : ElementValueTag<string>, IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue
    {
        internal ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsIPport : ElementTag, IConnectionsConnectionSmartSerialUserSettingsIPport
    {
        internal ConnectionsConnectionSmartSerialUserSettingsIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsTimeoutTime : ElementTag, IConnectionsConnectionSmartSerialUserSettingsTimeoutTime
    {
        internal ConnectionsConnectionSmartSerialUserSettingsTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<uint?> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsRetries : ElementTag, IConnectionsConnectionSmartSerialUserSettingsRetries
    {
        internal ConnectionsConnectionSmartSerialUserSettingsRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<uint?> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<uint?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsPortTypeIP : ElementTag, IConnectionsConnectionSmartSerialUserSettingsPortTypeIP
    {
        internal ConnectionsConnectionSmartSerialUserSettingsPortTypeIP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeIP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsPortTypeIP(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP : ElementTag, IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP
    {
        internal ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeUDP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsPortTypeUDP(this);
        }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsType : ElementTag, IConnectionsConnectionSmartSerialUserSettingsType
    {
        internal ConnectionsConnectionSmartSerialUserSettingsType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue _defaultValue;
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
public IValueTag<Enums.EnumPortTypes?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsType(this);
        }
    }

    internal partial class ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue : ElementValueTag<Enums.EnumPortTypes?>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the SSL/TLS settings.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled : ElementTag, IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled
    {
        internal ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SslTlsEnabled")
        {
        }

        private ElementValueTag<bool?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public IValueTag<bool?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled(this);
        }
    }

    ///<summary>
    /// Specifies the local port settings.
    ///</summary>
internal partial class ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses : ElementTag, IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses
    {
        internal ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AllowedIPAddresses")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether allowed IP addresses can be provided.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses(this);
        }
    }

    ///<summary>
    /// Defines a GPIB connection.
    ///</summary>
internal partial class ConnectionsConnectionGpib : ElementTag, IConnectionsConnectionGpib
    {
        internal ConnectionsConnectionGpib(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Gpib")
        {
        }

        private ConnectionsConnectionGpibCommunicationOptions _communicationOptions;
        private ConnectionsConnectionGpibUserSettings _userSettings;
        public IConnectionsConnectionGpibCommunicationOptions CommunicationOptions => _communicationOptions;
        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public IConnectionsConnectionGpibUserSettings UserSettings => _userSettings;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("CommunicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpib(this);
        }
    }

    internal partial class ConnectionsConnectionGpibCommunicationOptions : ElementTag, IConnectionsConnectionGpibCommunicationOptions
    {
        internal ConnectionsConnectionGpibCommunicationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CommunicationOptions")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibCommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
internal partial class ConnectionsConnectionGpibUserSettings : ElementTag, IConnectionsConnectionGpibUserSettings
    {
        internal ConnectionsConnectionGpibUserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        private ConnectionsConnectionGpibUserSettingsDeviceAddress _deviceAddress;
        private ConnectionsConnectionGpibUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionGpibUserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public IConnectionsConnectionGpibUserSettingsDeviceAddress DeviceAddress => _deviceAddress;
        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public IConnectionsConnectionGpibUserSettingsTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public IConnectionsConnectionGpibUserSettingsRetries Retries => _retries;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DeviceAddress", nameof(DeviceAddress), _deviceAddress, value => _deviceAddress = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
internal partial class ConnectionsConnectionGpibUserSettingsDeviceAddress : ElementTag, IConnectionsConnectionGpibUserSettingsDeviceAddress
    {
        internal ConnectionsConnectionGpibUserSettingsDeviceAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DeviceAddress")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private ConnectionsConnectionGpibUserSettingsDeviceAddressRange _range;
        private ConnectionsConnectionGpibUserSettingsDeviceAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IConnectionsConnectionGpibUserSettingsDeviceAddressRange Range => _range;
        public IConnectionsConnectionGpibUserSettingsDeviceAddressValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsDeviceAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class ConnectionsConnectionGpibUserSettingsDeviceAddressRange : ElementTag, IConnectionsConnectionGpibUserSettingsDeviceAddressRange
    {
        internal ConnectionsConnectionGpibUserSettingsDeviceAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsDeviceAddressRange(this);
        }
    }

    internal partial class ConnectionsConnectionGpibUserSettingsDeviceAddressValues : SimpleProtocolListNode<ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue>, IConnectionsConnectionGpibUserSettingsDeviceAddressValues
    {
        internal ConnectionsConnectionGpibUserSettingsDeviceAddressValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue IReadOnlyList<IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue> IEnumerable<IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsDeviceAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue : ElementValueTag<string>, IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue
    {
        internal ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
internal partial class ConnectionsConnectionGpibUserSettingsTimeoutTime : ElementTag, IConnectionsConnectionGpibUserSettingsTimeoutTime
    {
        internal ConnectionsConnectionGpibUserSettingsTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<string> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<string> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
internal partial class ConnectionsConnectionGpibUserSettingsRetries : ElementTag, IConnectionsConnectionGpibUserSettingsRetries
    {
        internal ConnectionsConnectionGpibUserSettingsRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<bool?> _disabled;
        private ElementValueTag<string> _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public IValueTag<string> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines a OPC connection.
    ///</summary>
internal partial class ConnectionsConnectionOpc : ElementTag, IConnectionsConnectionOpc
    {
        internal ConnectionsConnectionOpc(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Opc")
        {
        }

        private ConnectionsConnectionOpcCommunicationOptions _communicationOptions;
        private ConnectionsConnectionOpcUserSettings _userSettings;
        public IConnectionsConnectionOpcCommunicationOptions CommunicationOptions => _communicationOptions;
        public IConnectionsConnectionOpcUserSettings UserSettings => _userSettings;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("CommunicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionOpc(this);
        }
    }

    internal partial class ConnectionsConnectionOpcCommunicationOptions : ElementTag, IConnectionsConnectionOpcCommunicationOptions
    {
        internal ConnectionsConnectionOpcCommunicationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CommunicationOptions")
        {
        }

        private ElementValueTag<string> _progID;
        public IValueTag<string> ProgID => _progID;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("ProgID", nameof(ProgID), _progID, value => _progID = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionOpcCommunicationOptions(this);
        }
    }

    internal partial class ConnectionsConnectionOpcUserSettings : ElementTag, IConnectionsConnectionOpcUserSettings
    {
        internal ConnectionsConnectionOpcUserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionOpcUserSettings(this);
        }
    }

    ///<summary>
    /// Defines the layout and the order of the Data Display pages.
    ///</summary>
internal partial class Display : ElementTag, IDisplay
    {
        internal Display(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Display")
        {
        }

        private DisplayPages _pages;
        private AttributeTag<string> _defaultPage;
        private AttributeTag<string> _pageOptions;
        private AttributeTag<string> _pageOrder;
        private DisplayType _type;
        private AttributeTag<string> _wideColumnPages;
        ///<summary>
        /// Allows to define pages and specify their configuration (e.g. configure the visibility).
        ///</summary>
public IDisplayPages Pages => _pages;
        ///<summary>
        /// Defines the page that will be shown by default. Only one page name is allowed.
        /// If you do not specify a default page, the first page will be shown.
        ///</summary>
public IValueTag<string> DefaultPage => _defaultPage;
        ///<summary>
        /// Used for CPE elements in order to disable the possibility to open the Data Display page of the element.
        ///</summary>
public IValueTag<string> PageOptions => _pageOptions;
        ///<summary>
        /// Defines the order of the pages in DataMiner Cube or in the Element Display drop-down box.
        /// By default, the pages will be ordered alphabetically.
        /// In addition to the pages, you can add a reference to a web interface by specifying
        /// -	Webinterface#http://[Polling Ip], or
        /// -	WebInterface#http://[id:parameterID]
        ///</summary>
public IValueTag<string> PageOrder => _pageOrder;
        ///<summary>
        /// See the tooltips of the different options.
        ///</summary>
public IValueTag<Enums.EnumDisplayType?> Type => _type;
        ///<summary>
        /// Defines the pages that have only one column. Page names are separated by a semi-colon (";").
        /// By default, a page will have multiple columns. Use this attribute for pages that will contain e.g. a wide table.
        ///</summary>
public IValueTag<string> WideColumnPages => _wideColumnPages;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("defaultPage", nameof(DefaultPage), _defaultPage, value => _defaultPage = value);
            ParseAttributeTag("pageOptions", nameof(PageOptions), _pageOptions, value => _pageOptions = value);
            ParseAttributeTag("pageOrder", nameof(PageOrder), _pageOrder, value => _pageOrder = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseAttributeTag("wideColumnPages", nameof(WideColumnPages), _wideColumnPages, value => _wideColumnPages = value);
            ParseElementTag("Pages", nameof(Pages), _pages, value => _pages = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDisplay(this);
        }
    }

    ///<summary>
    /// Allows to define pages and specify their configuration (e.g. configure the visibility).
    ///</summary>
internal partial class DisplayPages : SimpleProtocolListNode<DisplayPagesPage>, IDisplayPages
    {
        internal DisplayPages(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Pages", "Page")
        {
        }

        IDisplayPagesPage IReadOnlyList<IDisplayPagesPage>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IDisplayPagesPage> IEnumerable<IDisplayPagesPage>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDisplayPages(this);
        }
    }

    ///<summary>
    /// Defines a page.
    ///</summary>
internal partial class DisplayPagesPage : ElementTag, IDisplayPagesPage
    {
        internal DisplayPagesPage(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Page")
        {
        }

        private ElementValueTag<string> _name;
        private DisplayPagesPageVisibility _visibility;
        ///<summary>
        /// Specifies the name of the page.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies the page visibility configuration.
        ///</summary>
public IDisplayPagesPageVisibility Visibility => _visibility;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Visibility", nameof(Visibility), _visibility, value => _visibility = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDisplayPagesPage(this);
        }
    }

    ///<summary>
    /// Specifies the page visibility configuration.
    ///</summary>
internal partial class DisplayPagesPageVisibility : ElementTag, IDisplayPagesPageVisibility
    {
        internal DisplayPagesPageVisibility(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Visibility")
        {
        }

        private AttributeTag<bool?> _default;
        private AttributeTag<uint?> _overridePID;
        private AttributeTag<string> _valueAttribute;
        ///<summary>
        /// Specifies the default visibility of the page.
        ///</summary>
public IValueTag<bool?> Default => _default;
        ///<summary>
        /// Specifies the ID of the parameter to use to compare its value with the value specified in the "value" attribute.
        ///</summary>
public IValueTag<uint?> OverridePID => _overridePID;
        ///<summary>
        /// Specifies the value the parameter referred to by the overridePID attribute should have in order to swap the visibility.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("default", nameof(Default), _default, value => _default = value);
            ParseAttributeTag("overridePID", nameof(OverridePID), _overridePID, value => _overridePID = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDisplayPagesPageVisibility(this);
        }
    }

    internal partial class DisplayType : AttributeTag<Enums.EnumDisplayType?>
    {
        internal DisplayType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumDisplayType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDisplayTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// This tag allows you to describe the behavior of Dynamic Virtual Elements.
    ///</summary>
internal partial class DVEs : ElementTag, IDVEs
    {
        internal DVEs(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DVEs")
        {
        }

        private DVEsDVEProtocols _dVEProtocols;
        private ExportRules _exportRules;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IDVEsDVEProtocols DVEProtocols => _dVEProtocols;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IExportRules ExportRules => _exportRules;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DVEProtocols", nameof(DVEProtocols), _dVEProtocols, value => _dVEProtocols = value);
            ParseElementTag("ExportRules", nameof(ExportRules), _exportRules, value => _exportRules = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDVEs(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class DVEsDVEProtocols : SimpleProtocolListNode<DVEsDVEProtocolsDVEProtocol>, IDVEsDVEProtocols
    {
        internal DVEsDVEProtocols(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DVEProtocols", "DVEProtocol")
        {
        }

        IDVEsDVEProtocolsDVEProtocol IReadOnlyList<IDVEsDVEProtocolsDVEProtocol>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IDVEsDVEProtocolsDVEProtocol> IEnumerable<IDVEsDVEProtocolsDVEProtocol>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDVEsDVEProtocols(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class DVEsDVEProtocolsDVEProtocol : ElementTag, IDVEsDVEProtocolsDVEProtocol
    {
        internal DVEsDVEProtocolsDVEProtocol(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DVEProtocol")
        {
        }

        private ElementValueTag<bool?> _elementPrefix;
        private AttributeTag<string> _name;
        private AttributeTag<uint?> _tablePID;
        ///<summary>
        /// Set to false to leave out the parent element name in the virtual element name.
        ///</summary>
public IValueTag<bool?> ElementPrefix => _elementPrefix;
        ///<summary>
        /// The name of the exported protocol.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Parameter ID of the table to be exported.
        ///</summary>
public IValueTag<uint?> TablePID => _tablePID;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("tablePID", nameof(TablePID), _tablePID, value => _tablePID = value);
            ParseElementTag("ElementPrefix", nameof(ElementPrefix), _elementPrefix, value => _elementPrefix = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDVEsDVEProtocolsDVEProtocol(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class ElementOptions : ElementTag, IElementOptions
    {
        internal ElementOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ElementOptions")
        {
        }

        private ElementOptionsUserSettings _userSettings;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IElementOptionsUserSettings UserSettings => _userSettings;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("UserSettings", nameof(UserSettings), _userSettings, value => _userSettings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitElementOptions(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class ElementOptionsUserSettings : ElementTag, IElementOptionsUserSettings
    {
        internal ElementOptionsUserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "UserSettings")
        {
        }

        private PingInterval _pingInterval;
        private SlowPoll _slowPoll;
        private SlowPollBase _slowPollBase;
        private SlowPoll _timeoutTimeElement;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IPingInterval PingInterval => _pingInterval;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ISlowPoll SlowPoll => _slowPoll;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ISlowPollBase SlowPollBase => _slowPollBase;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ISlowPoll TimeoutTimeElement => _timeoutTimeElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("PingInterval", nameof(PingInterval), _pingInterval, value => _pingInterval = value);
            ParseElementTag("SlowPoll", nameof(SlowPoll), _slowPoll, value => _slowPoll = value);
            ParseElementTag("SlowPollBase", nameof(SlowPollBase), _slowPollBase, value => _slowPollBase = value);
            ParseElementTag("TimeoutTimeElement", nameof(TimeoutTimeElement), _timeoutTimeElement, value => _timeoutTimeElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitElementOptionsUserSettings(this);
        }
    }

    ///<summary>
    /// Contains options that can be enabled or configured that change how the system will manage or interact with the element.
    ///</summary>
internal partial class SystemOptions : ElementTag, ISystemOptions
    {
        internal SystemOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SystemOptions")
        {
        }

        private ElementValueTag<bool?> _runInSeparateInstance;
        ///<summary>
        /// Set to true if any element running this protocol should be hosted in a separate SLProtocol and SLScripting process. Feature introduced in DataMiner 10.2.7 (RN 33358).
        ///</summary>
public IValueTag<bool?> RunInSeparateInstance => _runInSeparateInstance;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("RunInSeparateInstance", nameof(RunInSeparateInstance), _runInSeparateInstance, value => _runInSeparateInstance = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSystemOptions(this);
        }
    }

    ///<summary>
    /// Specifies which general parameter groups should be loaded or not. Feature introduced in DataMiner 9.0.1 (RN 12263).
    ///</summary>
internal partial class GeneralParameters : SimpleProtocolListNode<GeneralParametersGeneralParameter>, IGeneralParameters
    {
        internal GeneralParameters(ProtocolModel model, ProtocolTag parent) : base(model, parent, "GeneralParameters", "GeneralParameter")
        {
        }

        IGeneralParametersGeneralParameter IReadOnlyList<IGeneralParametersGeneralParameter>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IGeneralParametersGeneralParameter> IEnumerable<IGeneralParametersGeneralParameter>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGeneralParameters(this);
        }
    }

    ///<summary>
    /// Configures a general parameter group.
    ///</summary>
internal partial class GeneralParametersGeneralParameter : ElementTag, IGeneralParametersGeneralParameter
    {
        internal GeneralParametersGeneralParameter(ProtocolModel model, ProtocolTag parent) : base(model, parent, "GeneralParameter")
        {
        }

        private GeneralParametersGeneralParameterGroup _group;
        private AttributeTag<bool?> _enabled;
        ///<summary>
        /// Specifies the general parameter group.
        ///</summary>
public IValueTag<Enums.EnumGeneralParameterGroupType?> Group => _group;
        ///<summary>
        /// When set to false, the specified general parameter group will not be loaded.
        ///</summary>
public IValueTag<bool?> Enabled => _enabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("group", nameof(Group), _group, value => _group = value);
            ParseAttributeTag("enabled", nameof(Enabled), _enabled, value => _enabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGeneralParametersGeneralParameter(this);
        }
    }

    internal partial class GeneralParametersGeneralParameterGroup : AttributeTag<Enums.EnumGeneralParameterGroupType?>
    {
        internal GeneralParametersGeneralParameterGroup(ProtocolModel model, ProtocolTag parent) : base(model, parent, "group")
        {
        }

        public override Enums.EnumGeneralParameterGroupType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumGeneralParameterGroupTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains the groups defined in the protocol.
    ///</summary>
internal partial class Groups : SimpleProtocolListNode<GroupsGroup>, IGroups
    {
        internal Groups(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Groups", "Group")
        {
        }

        IGroupsGroup IReadOnlyList<IGroupsGroup>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IGroupsGroup> IEnumerable<IGroupsGroup>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroups(this);
        }
    }

    ///<summary>
    /// Groups are used to do the actual device polling.
    /// In a group, you can assemble different parameters, command/response pairs or actions. When a group is executed, all parameters, pairs or actions included in the group will be executed one after the other.
    /// Make sure that the "id" attribute contains a unique group ID.
    ///</summary>
internal partial class GroupsGroup : ElementTag, IGroupsGroup
    {
        internal GroupsGroup(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Group")
        {
        }

        private ElementValueTag<string> _condition;
        private GroupsGroupContent _content;
        private ElementValueTag<string> _description;
        private ElementValueTag<string> _name;
        private GroupsGroupType _type;
        private AttributeTag<uint?> _connection;
        private AttributeTag<uint?> _connectionPID;
        private AttributeTag<uint?> _id;
        private AttributeTag<bool?> _ping;
        ///<summary>
        /// Specifies a condition that must be met in order for the group to execute.
        ///</summary>
public IValueTag<string> Condition => _condition;
        ///<summary>
        /// Contains all actions, pairs, parameters, sessions, or triggers that have to be executed consecutively when the group is executed.
        /// In a /Protocol/Groups/Group/Content element, you are only allowed to specify items of the same type:
        /// - action items only,
        /// - pair items only,
        /// - parameter items only,
        /// - session items only,
        /// 
        /// - trigger items only.
        /// Recommendation: The content of a group should not exceed 10 items.
        ///</summary>
public IGroupsGroupContent Content => _content;
        ///<summary>
        /// Specifies the group description.
        ///</summary>
public IValueTag<string> Description => _description;
        ///<summary>
        /// Specifies the name of the group. This name could, for example, refer to the information that will be requested from the device.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// By default, a group includes parameters or pairs. However, if you want to include actions or triggers in a group, specify this here.
        /// If you specify "action" or "trigger", the group will be executed at once.
        /// If, however, you specify "poll", "poll action" or "poll trigger", the group will be added to the group execution queue, awaiting execution.
        ///</summary>
public IValueTag<Enums.EnumGroupType?> Type => _type;
        ///<summary>
        /// In case of multiple ports, use this attribute to specify the connection to be used.
        /// Default connection: 0
        ///</summary>
public IValueTag<uint?> Connection => _connection;
        ///<summary>
        /// Via this attribute it is possible to dynamically select an HTTP connection by referring to the connection by means of a parameter ID.
        /// This way, it is possible to switch connection at run-time.
        ///</summary>
public IValueTag<uint?> ConnectionPID => _connectionPID;
        ///<summary>
        /// The unique group ID.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies whether this is the group to be used when testing the connection in the element wizard.
        ///</summary>
public IValueTag<bool?> Ping => _ping;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("connection", nameof(Connection), _connection, value => _connection = value);
            ParseAttributeTag("connectionPID", nameof(ConnectionPID), _connectionPID, value => _connectionPID = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("ping", nameof(Ping), _ping, value => _ping = value);
            ParseElementTag("Condition", nameof(Condition), _condition, value => _condition = value);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroup(this);
        }
    }

    ///<summary>
    /// Contains all actions, pairs, parameters, sessions, or triggers that have to be executed consecutively when the group is executed.
    /// In a /Protocol/Groups/Group/Content element, you are only allowed to specify items of the same type:
    /// - action items only,
    /// - pair items only,
    /// - parameter items only,
    /// - session items only,
    /// 
    /// - trigger items only.
    /// Recommendation: The content of a group should not exceed 10 items.
    ///</summary>
internal partial class GroupsGroupContent : MultipleValueProtocolListNode<IGroupsGroupContentObject>, IGroupsGroupContent
    {
        internal GroupsGroupContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content", new Dictionary<string, Type>() { { "Action", typeof(GroupsGroupContentAction) }, { "Pair", typeof(GroupsGroupContentPair) }, { "Param", typeof(GroupsGroupContentParam) }, { "Session", typeof(GroupsGroupContentSession) }, { "Trigger", typeof(GroupsGroupContentTrigger) }, { "", typeof(GroupsGroupContentItem) } })
        {
        }

        private AttributeTag<bool?> _multipleGet;
        ///<summary>
        /// If "true", all parameters will be read in one SNMP Get operation.
        /// This "multipleGet" option cannot be used with parameters of Type "Array".
        ///</summary>
public IValueTag<bool?> MultipleGet => _multipleGet;

        IGroupsGroupContentItem IReadOnlyList<IGroupsGroupContentItem>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IGroupsGroupContentItem> IEnumerable<IGroupsGroupContentItem>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("multipleGet", nameof(MultipleGet), _multipleGet, value => _multipleGet = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContent(this);
        }
    }

    internal partial interface IGroupsGroupContentObject : IProtocolTag, Read.IGroupsGroupContentItem
    {
    }

    internal partial class GroupsGroupContentItem : ProtocolTag, IGroupsGroupContentObject
    {
        internal GroupsGroupContentItem(ProtocolModel model, ProtocolTag parent, string tagName) : base(model, parent, tagName)
        {
        }

        protected override void Parse(string notifyPropertyName)
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentItem(this);
        }
    }

    ///<summary>
    /// Specifies the ID of an action to include in the group.
    /// If you include actions in a group, do not forget to set the attribute /Protocol/Groups/Group@type to "action".
    ///</summary>
internal partial class GroupsGroupContentAction : ElementValueTag<string>, IGroupsGroupContentAction, IGroupsGroupContentObject
    {
        internal GroupsGroupContentAction(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Action")
        {
        }

        private AttributeTag<uint?> _next;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed action before executing the next action.
        ///</summary>
public IValueTag<uint?> Next => _next;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("next", nameof(Next), _next, value => _next = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentAction(this);
        }
    }

    ///<summary>
    /// Specifies the ID of a command/response pair to be included in a group.
    /// When a setting has to be changed, it is common practice to include in a group
    /// - a "SET" pair, directly followed by
    /// - a "GET" pair.
    /// That way, the DataMiner interface will immediately show the changed values.
    ///</summary>
internal partial class GroupsGroupContentPair : ElementValueTag<uint?>, IGroupsGroupContentPair, IGroupsGroupContentObject
    {
        internal GroupsGroupContentPair(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Pair")
        {
        }

        private AttributeTag<uint?> _next;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed pair before executing the next pair.
        ///</summary>
public IValueTag<uint?> Next => _next;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("next", nameof(Next), _next, value => _next = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentPair(this);
        }
    }

    ///<summary>
    /// Specifies the ID of a parameter to be included in the group.
    ///</summary>
internal partial class GroupsGroupContentParam : ElementValueTag<string>, IGroupsGroupContentParam, IGroupsGroupContentObject
    {
        internal GroupsGroupContentParam(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Param")
        {
        }

        private AttributeTag<uint?> _next;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait before reading the next parameter.
        ///</summary>
public IValueTag<uint?> Next => _next;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("next", nameof(Next), _next, value => _next = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentParam(this);
        }
    }

    ///<summary>
    /// Specifies the ID of an HTTP session to be included in the group.
    ///</summary>
internal partial class GroupsGroupContentSession : ElementValueTag<uint?>, IGroupsGroupContentSession, IGroupsGroupContentObject
    {
        internal GroupsGroupContentSession(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Session")
        {
        }

        private AttributeTag<uint?> _connection;
        private AttributeTag<uint?> _next;
        ///<summary>
        /// If you want to execute only a specific connection within a certain session, then use the connection attribute to specify the connection.
        /// Feature introduced in DataMiner 8.5.7 (RN 9928).
        ///</summary>
public IValueTag<uint?> Connection => _connection;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed session before executing the next session.
        /// If the last item in the group contains this attribute, it will also cause a delay before the next group is executed.
        ///</summary>
public IValueTag<uint?> Next => _next;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("connection", nameof(Connection), _connection, value => _connection = value);
            ParseAttributeTag("next", nameof(Next), _next, value => _next = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentSession(this);
        }
    }

    ///<summary>
    /// Specifies the ID of a trigger to be included in a group.
    /// If you include triggers in a group, do not forget to set the value of the "type" attribute of this group to “trigger”.
    ///</summary>
internal partial class GroupsGroupContentTrigger : ElementValueTag<string>, IGroupsGroupContentTrigger, IGroupsGroupContentObject
    {
        internal GroupsGroupContentTrigger(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Trigger")
        {
        }

        private AttributeTag<uint?> _next;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait before executing the next trigger.
        ///</summary>
public IValueTag<uint?> Next => _next;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("next", nameof(Next), _next, value => _next = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentTrigger(this);
        }
    }

    internal partial class GroupsGroupType : ElementValueTag<Enums.EnumGroupType?>
    {
        internal GroupsGroupType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        public override Enums.EnumGroupType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumGroupTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// The root of the HTTP-specific features in a protocol.
    ///</summary>
internal partial class HTTP : SimpleProtocolListNode<HTTPSession>, IHTTP
    {
        internal HTTP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "HTTP", "Session")
        {
        }

        IHTTPSession IReadOnlyList<IHTTPSession>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IHTTPSession> IEnumerable<IHTTPSession>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTP(this);
        }
    }

    ///<summary>
    /// Represents a particular HTTP session.
    ///</summary>
internal partial class HTTPSession : SimpleProtocolListNode<HTTPSessionConnection>, IHTTPSession
    {
        internal HTTPSession(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Session", "Connection")
        {
        }

        private AttributeTag<uint?> _id;
        private AttributeTag<bool?> _ignoreTimeout;
        private AttributeTag<bool?> _keepAlive;
        private HTTPSessionLoginMethod _loginMethod;
        private AttributeTag<string> _name;
        private AttributeTag<string> _password;
        private AttributeTag<string> _proxyPassword;
        private AttributeTag<string> _proxyServer;
        private AttributeTag<string> _proxyUser;
        private AttributeTag<uint?> _timeout;
        private AttributeTag<string> _userName;
        ///<summary>
        /// The unique session ID.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// If the HTTP connection should ignore timeout for this session, set this attribute to true.
        /// This works in a similar way as the serial pair ignoreTimeout option.
        /// Default value: false.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        /// 
        ///</summary>
public IValueTag<bool?> IgnoreTimeout => _ignoreTimeout;
        ///<summary>
        /// Specifies whether the session should be kept alive.
        /// Feature introduced in DataMiner 8.5.7 (RN 9929).
        ///</summary>
public IValueTag<bool?> KeepAlive => _keepAlive;
        ///<summary>
        /// Specifies the authentication method to use.
        ///</summary>
public IValueTag<Enums.EnumHttpLoginMethod?> LoginMethod => _loginMethod;
        ///<summary>
        /// Specifies the name of the session.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// If you set loginMethod to "credentials", then use this attribute to specify the password.
        ///</summary>
public IValueTag<string> Password => _password;
        ///<summary>
        /// If, in the proxyServer attribute, you specified a proxy server that requires authentication, then use this attribute to specify the password.
        ///</summary>
public IValueTag<string> ProxyPassword => _proxyPassword;
        ///<summary>
        /// Use this attribute to specify the proxy server through which the connection has to be set up.
        /// Note: If you do not specify a proxy server, then an attempt will be made to fetch the default proxy configuration using the Web Proxy Auto-Discovery Protocol (WPAD).
        ///</summary>
public IValueTag<string> ProxyServer => _proxyServer;
        ///<summary>
        /// If, in the proxyServer attribute, you specified a proxy server that requires authentication, then use this attribute to specify the user name.
        ///</summary>
public IValueTag<string> ProxyUser => _proxyUser;
        ///<summary>
        /// Specifies that DataMiner must use this timeout value (ms) instead of the default one when executing this session.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        ///</summary>
public IValueTag<uint?> Timeout => _timeout;
        ///<summary>
        /// If you set loginMethod to "credentials", then use this attribute to specify the user name.
        ///</summary>
public IValueTag<string> UserName => _userName;

        IHTTPSessionConnection IReadOnlyList<IHTTPSessionConnection>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IHTTPSessionConnection> IEnumerable<IHTTPSessionConnection>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("ignoreTimeout", nameof(IgnoreTimeout), _ignoreTimeout, value => _ignoreTimeout = value);
            ParseAttributeTag("keepAlive", nameof(KeepAlive), _keepAlive, value => _keepAlive = value);
            ParseAttributeTag("loginMethod", nameof(LoginMethod), _loginMethod, value => _loginMethod = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("password", nameof(Password), _password, value => _password = value);
            ParseAttributeTag("proxyPassword", nameof(ProxyPassword), _proxyPassword, value => _proxyPassword = value);
            ParseAttributeTag("proxyServer", nameof(ProxyServer), _proxyServer, value => _proxyServer = value);
            ParseAttributeTag("proxyUser", nameof(ProxyUser), _proxyUser, value => _proxyUser = value);
            ParseAttributeTag("timeout", nameof(Timeout), _timeout, value => _timeout = value);
            ParseAttributeTag("userName", nameof(UserName), _userName, value => _userName = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSession(this);
        }
    }

    ///<summary>
    /// Specifies a connection. This typically contains a request and a response.
    ///</summary>
internal partial class HTTPSessionConnection : ElementTag, IHTTPSessionConnection
    {
        internal HTTPSessionConnection(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Connection")
        {
        }

        private HTTPSessionConnectionRequest _request;
        private HTTPSessionConnectionResponse _response;
        private AttributeTag<uint?> _id;
        private AttributeTag<bool?> _ignoreTimeout;
        private AttributeTag<string> _name;
        private AttributeTag<uint?> _timeout;
        ///<summary>
        /// Defines the HTTP request to be sent.
        ///</summary>
public IHTTPSessionConnectionRequest Request => _request;
        ///<summary>
        /// Defines the response to the HTTP request you defined in ../Connection/Request.
        ///</summary>
public IHTTPSessionConnectionResponse Response => _response;
        ///<summary>
        /// The unique connection ID.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// If the HTTP connection should ignore timeout, set this attribute to true.
        /// This works in a similar way as the serial pair ignoreTimeout option.
        /// Default value: false.
        /// Feature introduced in DataMiner 9.0.2 (RN 10543).
        /// 
        ///</summary>
public IValueTag<bool?> IgnoreTimeout => _ignoreTimeout;
        ///<summary>
        /// Specifies the name of the connection.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies that DataMiner must use this timeout value (ms) )instead of the default one (or the one specified in the Session tag) when executing this connection of this session.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        ///</summary>
public IValueTag<uint?> Timeout => _timeout;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("ignoreTimeout", nameof(IgnoreTimeout), _ignoreTimeout, value => _ignoreTimeout = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("timeout", nameof(Timeout), _timeout, value => _timeout = value);
            ParseElementTag("Request", nameof(Request), _request, value => _request = value);
            ParseElementTag("Response", nameof(Response), _response, value => _response = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnection(this);
        }
    }

    ///<summary>
    /// Defines the HTTP request to be sent.
    ///</summary>
internal partial class HTTPSessionConnectionRequest : ElementTag, IHTTPSessionConnectionRequest
    {
        internal HTTPSessionConnectionRequest(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Request")
        {
        }

        private HttpRequestHeaders _headers;
        private HttpRequestData _data;
        private HttpRequestParameters _parameters;
        private AttributeTag<uint?> _pid;
        private HTTPSessionConnectionRequestVerb _verb;
        private AttributeTag<string> _url;
        public IHttpRequestHeaders Headers => _headers;
        public IHttpRequestData Data => _data;
        public IHttpRequestParameters Parameters => _parameters;
        ///<summary>
        /// Replaces the url attribute. The parameter value will be used as URL.
        ///</summary>
public IValueTag<uint?> Pid => _pid;
        ///<summary>
        /// Specifies the verb to be used in the HTTP request.
        /// If you do not specify this attribute, "GET" will be used by default.
        ///</summary>
public IValueTag<Enums.EnumHttpRequestVerb?> Verb => _verb;
        ///<summary>
        /// Specifies the URL of the request.
        /// If you do not specify this attribute, the root directory of the server specified in the element wizard will be used.
        ///</summary>
public IValueTag<string> Url => _url;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
            ParseAttributeTag("verb", nameof(Verb), _verb, value => _verb = value);
            ParseAttributeTag("url", nameof(Url), _url, value => _url = value);
            ParseElementTag("Headers", nameof(Headers), _headers, value => _headers = value);
            ParseElementTag("Data", nameof(Data), _data, value => _data = value);
            ParseElementTag("Parameters", nameof(Parameters), _parameters, value => _parameters = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionRequest(this);
        }
    }

    internal partial class HTTPSessionConnectionRequestVerb : AttributeTag<Enums.EnumHttpRequestVerb?>
    {
        internal HTTPSessionConnectionRequestVerb(ProtocolModel model, ProtocolTag parent) : base(model, parent, "verb")
        {
        }

        public override Enums.EnumHttpRequestVerb? ConvertRawValue(string rawValue)
        {
            return Enums.EnumHttpRequestVerbConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines the response to the HTTP request you defined in ../Connection/Request.
    ///</summary>
internal partial class HTTPSessionConnectionResponse : ElementTag, IHTTPSessionConnectionResponse
    {
        internal HTTPSessionConnectionResponse(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Response")
        {
        }

        private HTTPSessionConnectionResponseHeaders _headers;
        private HTTPSessionConnectionResponseContent _content;
        private AttributeTag<uint?> _statusCode;
        ///<summary>
        /// Specifies the response headers of which you want to store the contents in a parameter.
        ///</summary>
public IHTTPSessionConnectionResponseHeaders Headers => _headers;
        ///<summary>
        /// The pid attribute of this element specifies the ID of the parameter in which you want the contents of the response to be stored.
        ///</summary>
public IHTTPSessionConnectionResponseContent Content => _content;
        ///<summary>
        /// Specifies the ID of the parameter in which the HTTP status-line has to be stored ("e.g. HTTP/1.1 200 OK".
        ///</summary>
public IValueTag<uint?> StatusCode => _statusCode;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("statusCode", nameof(StatusCode), _statusCode, value => _statusCode = value);
            ParseElementTag("Headers", nameof(Headers), _headers, value => _headers = value);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionResponse(this);
        }
    }

    ///<summary>
    /// Specifies the response headers of which you want to store the contents in a parameter.
    ///</summary>
internal partial class HTTPSessionConnectionResponseHeaders : SimpleProtocolListNode<HTTPSessionConnectionResponseHeadersHeader>, IHTTPSessionConnectionResponseHeaders
    {
        internal HTTPSessionConnectionResponseHeaders(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Headers", "Header")
        {
        }

        IHTTPSessionConnectionResponseHeadersHeader IReadOnlyList<IHTTPSessionConnectionResponseHeadersHeader>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IHTTPSessionConnectionResponseHeadersHeader> IEnumerable<IHTTPSessionConnectionResponseHeadersHeader>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionResponseHeaders(this);
        }
    }

    ///<summary>
    /// Specifies that the contents of a particular response header has to be stored in a parameter.&lt;BR /&gt;
    /// In this context, this has to be done by means of a key/value pair.
    ///</summary>
internal partial class HTTPSessionConnectionResponseHeadersHeader : ElementTag, IHTTPSessionConnectionResponseHeadersHeader
    {
        internal HTTPSessionConnectionResponseHeadersHeader(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Header")
        {
        }

        private AttributeTag<string> _key;
        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the name of the header of which you want the contents to be stored in the parameter having the ID defined in the pid attribute.
        ///</summary>
public IValueTag<string> Key => _key;
        ///<summary>
        /// Specifies the ID of the parameter in which you want to store the contents of the header defined in the key attribute.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("key", nameof(Key), _key, value => _key = value);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionResponseHeadersHeader(this);
        }
    }

    ///<summary>
    /// The pid attribute of this element specifies the ID of the parameter in which you want the contents of the response to be stored.
    ///</summary>
internal partial class HTTPSessionConnectionResponseContent : ElementTag, IHTTPSessionConnectionResponseContent
    {
        internal HTTPSessionConnectionResponseContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content")
        {
        }

        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter in which you want the contents of the response to be stored.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionResponseContent(this);
        }
    }

    internal partial class HTTPSessionLoginMethod : AttributeTag<Enums.EnumHttpLoginMethod?>
    {
        internal HTTPSessionLoginMethod(ProtocolModel model, ProtocolTag parent) : base(model, parent, "loginMethod")
        {
        }

        public override Enums.EnumHttpLoginMethod? ConvertRawValue(string rawValue)
        {
            return Enums.EnumHttpLoginMethodConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Configures internal licensing.
    ///</summary>
internal partial class InternalLicenses : SimpleProtocolListNode<InternalLicensesInternalLicense>, IInternalLicenses
    {
        internal InternalLicenses(ProtocolModel model, ProtocolTag parent) : base(model, parent, "InternalLicenses", "InternalLicense")
        {
        }

        IInternalLicensesInternalLicense IReadOnlyList<IInternalLicensesInternalLicense>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IInternalLicensesInternalLicense> IEnumerable<IInternalLicensesInternalLicense>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitInternalLicenses(this);
        }
    }

    ///<summary>
    /// Configures internal licensing of the specified type.
    ///</summary>
internal partial class InternalLicensesInternalLicense : ElementTag, IInternalLicensesInternalLicense
    {
        internal InternalLicensesInternalLicense(ProtocolModel model, ProtocolTag parent) : base(model, parent, "InternalLicense")
        {
        }

        private AttributeTag<string> _type;
        public IValueTag<string> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitInternalLicensesInternalLicense(this);
        }
    }

    ///<summary>
    /// Groups NoTimeout elements.
    ///</summary>
internal partial class NoTimeouts : SimpleProtocolListNode<NoTimeoutsNoTimeout>, INoTimeouts
    {
        internal NoTimeouts(ProtocolModel model, ProtocolTag parent) : base(model, parent, "NoTimeouts", "NoTimeout")
        {
        }

        INoTimeoutsNoTimeout IReadOnlyList<INoTimeoutsNoTimeout>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<INoTimeoutsNoTimeout> IEnumerable<INoTimeoutsNoTimeout>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitNoTimeouts(this);
        }
    }

    ///<summary>
    /// Indicates that the specified error (response value) should not cause a timeout.
    ///</summary>
internal partial class NoTimeoutsNoTimeout : ElementValueTag<string>, INoTimeoutsNoTimeout
    {
        internal NoTimeoutsNoTimeout(ProtocolModel model, ProtocolTag parent) : base(model, parent, "NoTimeout")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitNoTimeoutsNoTimeout(this);
        }
    }

    ///<summary>
    /// Defines options for the protocol.
    ///</summary>
internal partial class Options : ElementTag, IOptions
    {
        internal Options(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Options")
        {
        }

        private OptionsDataBaseOptions _dataBaseOptions;
        private ElementValueTag<bool?> _disableViewRefresh;
        private OptionsEncoding _encoding;
        private ElementValueTag<bool?> _forceDefaultAlarming;
        private OptionsGenerateMIB _generateMIB;
        private Icon _icon;
        private OptionsNoTimeouts _noTimeouts;
        private ElementValueTag<string> _overrideTimeoutDVE;
        private ElementValueTag<bool?> _postPonePortInitialisation;
        private ElementValueTag<bool?> _useAgentBinding;
        public IOptionsDataBaseOptions DataBaseOptions => _dataBaseOptions;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<bool?> DisableViewRefresh => _disableViewRefresh;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<Enums.EnumEncoding?> Encoding => _encoding;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<bool?> ForceDefaultAlarming => _forceDefaultAlarming;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IOptionsGenerateMIB GenerateMIB => _generateMIB;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IIcon Icon => _icon;
        ///<summary>
        /// Groups NoTimeout elements of the protocol. Feature introduced in DataMiner 8.5.3 (RN 8775).
        ///</summary>
public IOptionsNoTimeouts NoTimeouts => _noTimeouts;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> OverrideTimeoutDVE => _overrideTimeoutDVE;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<bool?> PostPonePortInitialisation => _postPonePortInitialisation;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<bool?> UseAgentBinding => _useAgentBinding;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DataBaseOptions", nameof(DataBaseOptions), _dataBaseOptions, value => _dataBaseOptions = value);
            ParseElementTag("DisableViewRefresh", nameof(DisableViewRefresh), _disableViewRefresh, value => _disableViewRefresh = value);
            ParseElementTag("Encoding", nameof(Encoding), _encoding, value => _encoding = value);
            ParseElementTag("ForceDefaultAlarming", nameof(ForceDefaultAlarming), _forceDefaultAlarming, value => _forceDefaultAlarming = value);
            ParseElementTag("GenerateMIB", nameof(GenerateMIB), _generateMIB, value => _generateMIB = value);
            ParseElementTag("Icon", nameof(Icon), _icon, value => _icon = value);
            ParseElementTag("NoTimeouts", nameof(NoTimeouts), _noTimeouts, value => _noTimeouts = value);
            ParseElementTag("OverrideTimeoutDVE", nameof(OverrideTimeoutDVE), _overrideTimeoutDVE, value => _overrideTimeoutDVE = value);
            ParseElementTag("PostPonePortInitialisation", nameof(PostPonePortInitialisation), _postPonePortInitialisation, value => _postPonePortInitialisation = value);
            ParseElementTag("UseAgentBinding", nameof(UseAgentBinding), _useAgentBinding, value => _useAgentBinding = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptions(this);
        }
    }

    internal partial class OptionsDataBaseOptions : ElementTag, IOptionsDataBaseOptions
    {
        internal OptionsDataBaseOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DataBaseOptions")
        {
        }

        private ElementValueTag<bool?> _customDataIDs;
        private ElementValueTag<bool?> _partitionedTrending;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<bool?> CustomDataIDs => _customDataIDs;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<bool?> PartitionedTrending => _partitionedTrending;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("CustomDataIDs", nameof(CustomDataIDs), _customDataIDs, value => _customDataIDs = value);
            ParseElementTag("PartitionedTrending", nameof(PartitionedTrending), _partitionedTrending, value => _partitionedTrending = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptionsDataBaseOptions(this);
        }
    }

    internal partial class OptionsEncoding : ElementValueTag<Enums.EnumEncoding?>
    {
        internal OptionsEncoding(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Encoding")
        {
        }

        public override Enums.EnumEncoding? ConvertRawValue(string rawValue)
        {
            return Enums.EnumEncodingConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class OptionsGenerateMIB : ElementValueTag<Enums.EnumSNMP?>, IOptionsGenerateMIB
    {
        internal OptionsGenerateMIB(ProtocolModel model, ProtocolTag parent) : base(model, parent, "GenerateMIB")
        {
        }

        private AttributeTag<bool?> _includePages;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<bool?> IncludePages => _includePages;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("includePages", nameof(IncludePages), _includePages, value => _includePages = value);
        }

        public override Enums.EnumSNMP? ConvertRawValue(string rawValue)
        {
            return Enums.EnumSNMPConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptionsGenerateMIB(this);
        }
    }

    ///<summary>
    /// Groups NoTimeout elements of the protocol. Feature introduced in DataMiner 8.5.3 (RN 8775).
    ///</summary>
internal partial class OptionsNoTimeouts : SimpleProtocolListNode<OptionsNoTimeoutsNoTimeout>, IOptionsNoTimeouts
    {
        internal OptionsNoTimeouts(ProtocolModel model, ProtocolTag parent) : base(model, parent, "NoTimeouts", "NoTimeout")
        {
        }

        IOptionsNoTimeoutsNoTimeout IReadOnlyList<IOptionsNoTimeoutsNoTimeout>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IOptionsNoTimeoutsNoTimeout> IEnumerable<IOptionsNoTimeoutsNoTimeout>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptionsNoTimeouts(this);
        }
    }

    ///<summary>
    /// Suppresses a timeout in case the specified error (response value) occurs.
    ///</summary>
internal partial class OptionsNoTimeoutsNoTimeout : ElementValueTag<string>, IOptionsNoTimeoutsNoTimeout
    {
        internal OptionsNoTimeoutsNoTimeout(ProtocolModel model, ProtocolTag parent) : base(model, parent, "NoTimeout")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptionsNoTimeoutsNoTimeout(this);
        }
    }

    ///<summary>
    /// Specifies the level of access users will have to elements, views, services and redundancy groups created by elements based on this protocol.
    /// Feature introduced in DataMiner 9.0.3 (RN 13010).
    ///</summary>
internal partial class Ownership : ElementTag, IOwnership
    {
        internal Ownership(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Ownership")
        {
        }

        private OwnershipElements _elements;
        private OwnershipViews _views;
        private OwnershipServices _services;
        private OwnershipRedundancyGroups _redundancyGroups;
        ///<summary>
        /// Groups ownership declarations of DataMiner elements.
        ///</summary>
public IOwnershipElements Elements => _elements;
        ///<summary>
        /// Groups ownership declarations of view properties.
        ///</summary>
public IOwnershipViews Views => _views;
        ///<summary>
        /// Groups service ownership declarations.
        ///</summary>
public IOwnershipServices Services => _services;
        ///<summary>
        /// Groups redundancy group ownership declarations.
        ///</summary>
public IOwnershipRedundancyGroups RedundancyGroups => _redundancyGroups;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Elements", nameof(Elements), _elements, value => _elements = value);
            ParseElementTag("Views", nameof(Views), _views, value => _views = value);
            ParseElementTag("Services", nameof(Services), _services, value => _services = value);
            ParseElementTag("RedundancyGroups", nameof(RedundancyGroups), _redundancyGroups, value => _redundancyGroups = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnership(this);
        }
    }

    ///<summary>
    /// Groups ownership declarations of DataMiner elements.
    ///</summary>
internal partial class OwnershipElements : SimpleProtocolListNode<OwnershipElementsElement>, IOwnershipElements
    {
        internal OwnershipElements(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Elements", "Element")
        {
        }

        IOwnershipElementsElement IReadOnlyList<IOwnershipElementsElement>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IOwnershipElementsElement> IEnumerable<IOwnershipElementsElement>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElements(this);
        }
    }

    ///<summary>
    /// Declares ownership of specific DataMiner elements.
    ///</summary>
internal partial class OwnershipElementsElement : ElementTag, IOwnershipElementsElement
    {
        internal OwnershipElementsElement(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Element")
        {
        }

        private ElementValueTag<string> _protocol;
        private OwnershipElementsElementDescription _description;
        private OwnershipElementsElementProperties _properties;
        private OwnershipElementsElementAlarmTemplate _alarmTemplate;
        private OwnershipElementsElementTrendTemplate _trendTemplate;
        ///<summary>
        /// Declares ownership of DataMiner elements running the specified protocol. Supported wildcard characters: '*' and '?'.
        ///</summary>
public IValueTag<string> Protocol => _protocol;
        ///<summary>
        /// Declares ownership of the element description.
        ///</summary>
public IOwnershipElementsElementDescription Description => _description;
        ///<summary>
        /// Groups ownership declarations of element properties.
        ///</summary>
public IOwnershipElementsElementProperties Properties => _properties;
        ///<summary>
        /// Declares ownership of the alarm template.
        ///</summary>
public IOwnershipElementsElementAlarmTemplate AlarmTemplate => _alarmTemplate;
        ///<summary>
        /// Declares ownership of the trend template.
        ///</summary>
public IOwnershipElementsElementTrendTemplate TrendTemplate => _trendTemplate;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Protocol", nameof(Protocol), _protocol, value => _protocol = value);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("Properties", nameof(Properties), _properties, value => _properties = value);
            ParseElementTag("AlarmTemplate", nameof(AlarmTemplate), _alarmTemplate, value => _alarmTemplate = value);
            ParseElementTag("TrendTemplate", nameof(TrendTemplate), _trendTemplate, value => _trendTemplate = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElement(this);
        }
    }

    ///<summary>
    /// Declares ownership of the element description.
    ///</summary>
internal partial class OwnershipElementsElementDescription : ElementTag, IOwnershipElementsElementDescription
    {
        internal OwnershipElementsElementDescription(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Description")
        {
        }

        private OwnershipElementsElementDescriptionAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementDescription(this);
        }
    }

    internal partial class OwnershipElementsElementDescriptionAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipElementsElementDescriptionAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Groups ownership declarations of element properties.
    ///</summary>
internal partial class OwnershipElementsElementProperties : SimpleProtocolListNode<OwnershipElementsElementPropertiesProperty>, IOwnershipElementsElementProperties
    {
        internal OwnershipElementsElementProperties(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Properties", "Property")
        {
        }

        IOwnershipElementsElementPropertiesProperty IReadOnlyList<IOwnershipElementsElementPropertiesProperty>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IOwnershipElementsElementPropertiesProperty> IEnumerable<IOwnershipElementsElementPropertiesProperty>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementProperties(this);
        }
    }

    ///<summary>
    /// Declares ownership of the specified element property.
    ///</summary>
internal partial class OwnershipElementsElementPropertiesProperty : ElementTag, IOwnershipElementsElementPropertiesProperty
    {
        internal OwnershipElementsElementPropertiesProperty(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Property")
        {
        }

        private ElementValueTag<string> _name;
        private OwnershipElementsElementPropertiesPropertyAccessType _accessType;
        ///<summary>
        /// Specifies the name of the element property. Supported wildcard characters: '*' and '?'.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementPropertiesProperty(this);
        }
    }

    internal partial class OwnershipElementsElementPropertiesPropertyAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipElementsElementPropertiesPropertyAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Declares ownership of the alarm template.
    ///</summary>
internal partial class OwnershipElementsElementAlarmTemplate : ElementTag, IOwnershipElementsElementAlarmTemplate
    {
        internal OwnershipElementsElementAlarmTemplate(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AlarmTemplate")
        {
        }

        private OwnershipElementsElementAlarmTemplateAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementAlarmTemplate(this);
        }
    }

    internal partial class OwnershipElementsElementAlarmTemplateAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipElementsElementAlarmTemplateAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Declares ownership of the trend template.
    ///</summary>
internal partial class OwnershipElementsElementTrendTemplate : ElementTag, IOwnershipElementsElementTrendTemplate
    {
        internal OwnershipElementsElementTrendTemplate(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TrendTemplate")
        {
        }

        private OwnershipElementsElementTrendTemplateAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementTrendTemplate(this);
        }
    }

    internal partial class OwnershipElementsElementTrendTemplateAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipElementsElementTrendTemplateAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Groups ownership declarations of view properties.
    ///</summary>
internal partial class OwnershipViews : ElementTag, IOwnershipViews
    {
        internal OwnershipViews(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Views")
        {
        }

        private OwnershipViewsView _view;
        ///<summary>
        /// Declares ownership of view properties.
        ///</summary>
public IOwnershipViewsView View => _view;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("View", nameof(View), _view, value => _view = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipViews(this);
        }
    }

    ///<summary>
    /// Declares ownership of view properties.
    ///</summary>
internal partial class OwnershipViewsView : ElementTag, IOwnershipViewsView
    {
        internal OwnershipViewsView(ProtocolModel model, ProtocolTag parent) : base(model, parent, "View")
        {
        }

        private OwnershipViewsViewProperties _properties;
        ///<summary>
        /// Groups ownership declarations of view properties.
        ///</summary>
public IOwnershipViewsViewProperties Properties => _properties;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Properties", nameof(Properties), _properties, value => _properties = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipViewsView(this);
        }
    }

    ///<summary>
    /// Groups ownership declarations of view properties.
    ///</summary>
internal partial class OwnershipViewsViewProperties : SimpleProtocolListNode<OwnershipViewsViewPropertiesProperty>, IOwnershipViewsViewProperties
    {
        internal OwnershipViewsViewProperties(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Properties", "Property")
        {
        }

        IOwnershipViewsViewPropertiesProperty IReadOnlyList<IOwnershipViewsViewPropertiesProperty>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IOwnershipViewsViewPropertiesProperty> IEnumerable<IOwnershipViewsViewPropertiesProperty>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipViewsViewProperties(this);
        }
    }

    ///<summary>
    /// Declares ownership of the specified view property.
    ///</summary>
internal partial class OwnershipViewsViewPropertiesProperty : ElementTag, IOwnershipViewsViewPropertiesProperty
    {
        internal OwnershipViewsViewPropertiesProperty(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Property")
        {
        }

        private ElementValueTag<string> _name;
        private OwnershipViewsViewPropertiesPropertyAccessType _accessType;
        ///<summary>
        /// Specifies the name of the view property. Supported wildcard characters: '*' and '?'.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipViewsViewPropertiesProperty(this);
        }
    }

    internal partial class OwnershipViewsViewPropertiesPropertyAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipViewsViewPropertiesPropertyAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Groups service ownership declarations.
    ///</summary>
internal partial class OwnershipServices : ElementTag, IOwnershipServices
    {
        internal OwnershipServices(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Services")
        {
        }

        private OwnershipServicesService _service;
        ///<summary>
        /// Declares ownership of a service.
        ///</summary>
public IOwnershipServicesService Service => _service;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Service", nameof(Service), _service, value => _service = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServices(this);
        }
    }

    ///<summary>
    /// Declares ownership of a service.
    ///</summary>
internal partial class OwnershipServicesService : ElementTag, IOwnershipServicesService
    {
        internal OwnershipServicesService(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Service")
        {
        }

        private OwnershipServicesServiceDescription _description;
        private OwnershipServicesServiceProperties _properties;
        ///<summary>
        /// Declares ownership of the service description.
        ///</summary>
public IOwnershipServicesServiceDescription Description => _description;
        ///<summary>
        /// Groups ownership declarations of service properties.
        ///</summary>
public IOwnershipServicesServiceProperties Properties => _properties;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("Properties", nameof(Properties), _properties, value => _properties = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServicesService(this);
        }
    }

    ///<summary>
    /// Declares ownership of the service description.
    ///</summary>
internal partial class OwnershipServicesServiceDescription : ElementTag, IOwnershipServicesServiceDescription
    {
        internal OwnershipServicesServiceDescription(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Description")
        {
        }

        private OwnershipServicesServiceDescriptionAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServicesServiceDescription(this);
        }
    }

    internal partial class OwnershipServicesServiceDescriptionAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipServicesServiceDescriptionAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Groups ownership declarations of service properties.
    ///</summary>
internal partial class OwnershipServicesServiceProperties : SimpleProtocolListNode<OwnershipServicesServicePropertiesProperty>, IOwnershipServicesServiceProperties
    {
        internal OwnershipServicesServiceProperties(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Properties", "Property")
        {
        }

        IOwnershipServicesServicePropertiesProperty IReadOnlyList<IOwnershipServicesServicePropertiesProperty>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IOwnershipServicesServicePropertiesProperty> IEnumerable<IOwnershipServicesServicePropertiesProperty>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServicesServiceProperties(this);
        }
    }

    ///<summary>
    /// Declares ownership of the specified service property.
    ///</summary>
internal partial class OwnershipServicesServicePropertiesProperty : ElementTag, IOwnershipServicesServicePropertiesProperty
    {
        internal OwnershipServicesServicePropertiesProperty(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Property")
        {
        }

        private ElementValueTag<string> _name;
        private OwnershipServicesServicePropertiesPropertyAccessType _accessType;
        ///<summary>
        /// Specifies the name of the service property. Supported wildcard characters: '*' and '?'.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServicesServicePropertiesProperty(this);
        }
    }

    internal partial class OwnershipServicesServicePropertiesPropertyAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipServicesServicePropertiesPropertyAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Groups redundancy group ownership declarations.
    ///</summary>
internal partial class OwnershipRedundancyGroups : ElementTag, IOwnershipRedundancyGroups
    {
        internal OwnershipRedundancyGroups(ProtocolModel model, ProtocolTag parent) : base(model, parent, "RedundancyGroups")
        {
        }

        private OwnershipRedundancyGroupsRedundancyGroup _redundancyGroup;
        ///<summary>
        /// Declares ownership of a redundancy group.
        ///</summary>
public IOwnershipRedundancyGroupsRedundancyGroup RedundancyGroup => _redundancyGroup;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("RedundancyGroup", nameof(RedundancyGroup), _redundancyGroup, value => _redundancyGroup = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroups(this);
        }
    }

    ///<summary>
    /// Declares ownership of a redundancy group.
    ///</summary>
internal partial class OwnershipRedundancyGroupsRedundancyGroup : ElementTag, IOwnershipRedundancyGroupsRedundancyGroup
    {
        internal OwnershipRedundancyGroupsRedundancyGroup(ProtocolModel model, ProtocolTag parent) : base(model, parent, "RedundancyGroup")
        {
        }

        private OwnershipRedundancyGroupsRedundancyGroupDescription _description;
        private OwnershipRedundancyGroupsRedundancyGroupMaintenance _maintenance;
        private OwnershipRedundancyGroupsRedundancyGroupSwitching _switching;
        ///<summary>
        /// Declares ownership of the redundancy group description.
        ///</summary>
public IOwnershipRedundancyGroupsRedundancyGroupDescription Description => _description;
        ///<summary>
        /// Declares ownership of the redundancy group maintenance.
        ///</summary>
public IOwnershipRedundancyGroupsRedundancyGroupMaintenance Maintenance => _maintenance;
        ///<summary>
        /// Declares ownership of the redundancy group switching.
        ///</summary>
public IOwnershipRedundancyGroupsRedundancyGroupSwitching Switching => _switching;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("Maintenance", nameof(Maintenance), _maintenance, value => _maintenance = value);
            ParseElementTag("Switching", nameof(Switching), _switching, value => _switching = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroupsRedundancyGroup(this);
        }
    }

    ///<summary>
    /// Declares ownership of the redundancy group description.
    ///</summary>
internal partial class OwnershipRedundancyGroupsRedundancyGroupDescription : ElementTag, IOwnershipRedundancyGroupsRedundancyGroupDescription
    {
        internal OwnershipRedundancyGroupsRedundancyGroupDescription(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Description")
        {
        }

        private OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroupsRedundancyGroupDescription(this);
        }
    }

    internal partial class OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Declares ownership of the redundancy group maintenance.
    ///</summary>
internal partial class OwnershipRedundancyGroupsRedundancyGroupMaintenance : ElementTag, IOwnershipRedundancyGroupsRedundancyGroupMaintenance
    {
        internal OwnershipRedundancyGroupsRedundancyGroupMaintenance(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Maintenance")
        {
        }

        private OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroupsRedundancyGroupMaintenance(this);
        }
    }

    internal partial class OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Declares ownership of the redundancy group switching.
    ///</summary>
internal partial class OwnershipRedundancyGroupsRedundancyGroupSwitching : ElementTag, IOwnershipRedundancyGroupsRedundancyGroupSwitching
    {
        internal OwnershipRedundancyGroupsRedundancyGroupSwitching(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Switching")
        {
        }

        private OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public IValueTag<Enums.EnumOwnershipAccessType?> AccessType => _accessType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("AccessType", nameof(AccessType), _accessType, value => _accessType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroupsRedundancyGroupSwitching(this);
        }
    }

    internal partial class OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType : ElementValueTag<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "AccessType")
        {
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains all the pairs defined in the protocol.
    ///</summary>
internal partial class Pairs : SimpleProtocolListNode<PairsPair>, IPairs
    {
        internal Pairs(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Pairs", "Pair")
        {
        }

        IPairsPair IReadOnlyList<IPairsPair>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPairsPair> IEnumerable<IPairsPair>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairs(this);
        }
    }

    ///<summary>
    /// Defines a pair consisting of a command and optionally a response.
    ///</summary>
internal partial class PairsPair : ElementTag, IPairsPair
    {
        internal PairsPair(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Pair")
        {
        }

        private ElementValueTag<string> _condition;
        private PairsPairContent _content;
        private ElementValueTag<string> _description;
        private ElementValueTag<string> _name;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _options;
        private AttributeTag<bool?> _ping;
        private AttributeTag<uint?> _timeout;
        ///<summary>
        /// Specifies a condition that must be met in order for the pair to execute.
        ///</summary>
public IValueTag<string> Condition => _condition;
        ///<summary>
        /// Specifies the command to be sent and the expected response(s) (if any) after the command has been sent.
        /// You can specify only one command. The number of responses, however, can vary from none to several, depending on the device.
        /// - If no response is expected, then specify the command, but no response.
        /// - If only one single response is expected, then specify the command and the expected response.
        /// - If multiple responses are expected, then specify the command and all expected responses.
        /// 
        /// When DataMiner receives a response from the device after having sent a command, it will try to match the response to one of the responses
        /// defined in this tag. If several responses have been defined, it will check them top down.
        /// If a match is found, DataMiner will move on to the next command/response pair.
        /// If no match is found, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has
        /// occurred. The log files of the device will contain more detailed information. If the new response still does not match one of the defined
        /// responses, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
        /// will skip the command, and move to the next command/response pair.
        /// By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device
        /// in System Display.
        ///</summary>
public IPairsPairContent Content => _content;
        ///<summary>
        /// Contains a textual description of the pair.
        ///</summary>
public IValueTag<string> Description => _description;
        ///<summary>
        /// Specifies the name of the pair. This name is displayed in the stream viewer when the pair is executed.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies the unique ID of the pair.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";").
        /// For an overview of all options that can be specified in this tag, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// If set to "true", the pair will be executed when the device is in timeout and slow polling is activated.
        /// Note: This option cannot be used in protocols of type SNMP or OPC.
        ///</summary>
public IValueTag<bool?> Ping => _ping;
        ///<summary>
        /// Specifies the timeout value to use for this pair instead of the default value when executing the pair.
        /// Using this option, you can extend the period of time DataMiner will wait for a response after having sent a command.
        ///</summary>
public IValueTag<uint?> Timeout => _timeout;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("ping", nameof(Ping), _ping, value => _ping = value);
            ParseAttributeTag("timeout", nameof(Timeout), _timeout, value => _timeout = value);
            ParseElementTag("Condition", nameof(Condition), _condition, value => _condition = value);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPair(this);
        }
    }

    ///<summary>
    /// Specifies the command to be sent and the expected response(s) (if any) after the command has been sent.
    /// You can specify only one command. The number of responses, however, can vary from none to several, depending on the device.
    /// - If no response is expected, then specify the command, but no response.
    /// - If only one single response is expected, then specify the command and the expected response.
    /// - If multiple responses are expected, then specify the command and all expected responses.
    /// 
    /// When DataMiner receives a response from the device after having sent a command, it will try to match the response to one of the responses
    /// defined in this tag. If several responses have been defined, it will check them top down.
    /// If a match is found, DataMiner will move on to the next command/response pair.
    /// If no match is found, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has
    /// occurred. The log files of the device will contain more detailed information. If the new response still does not match one of the defined
    /// responses, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
    /// will skip the command, and move to the next command/response pair.
    /// By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device
    /// in System Display.
    ///</summary>
internal partial class PairsPairContent : MultipleValueProtocolListNode<IPairsPairContentObject>, IPairsPairContent
    {
        internal PairsPairContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content", new Dictionary<string, Type>() { { "Command", typeof(PairsPairContentCommand) }, { "Response", typeof(PairsPairContentResponse) }, { "ResponseOnBadCommand", typeof(PairsPairContentResponseOnBadCommand) }, { "", typeof(PairsPairContentItem) } })
        {
        }

        private PairsPairContentCommand _command;
        ///<summary>
        /// Specifies the ID of the command that will be sent when the pair is executed.
        ///</summary>
public IPairsPairContentCommand Command => _command;

        IPairsPairContentItem IReadOnlyList<IPairsPairContentItem>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPairsPairContentItem> IEnumerable<IPairsPairContentItem>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Command", nameof(Command), _command, value => _command = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContent(this);
        }
    }

    internal partial interface IPairsPairContentObject : IProtocolTag, Read.IPairsPairContentItem
    {
    }

    internal partial class PairsPairContentItem : ElementValueTag<uint?>, IPairsPairContentObject
    {
        internal PairsPairContentItem(ProtocolModel model, ProtocolTag parent, string tagName) : base(model, parent, tagName)
        {
        }

        protected override void Parse(string notifyPropertyName)
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContentItem(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the command that will be sent when the pair is executed.
    ///</summary>
internal partial class PairsPairContentCommand : ElementValueTag<uint?>, IPairsPairContentCommand, IPairsPairContentObject
    {
        internal PairsPairContentCommand(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Command")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContentCommand(this);
        }
    }

    ///<summary>
    /// Specifies the ID of an expected response.
    ///</summary>
internal partial class PairsPairContentResponse : ElementValueTag<uint?>, IPairsPairContentResponse, IPairsPairContentObject
    {
        internal PairsPairContentResponse(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Response")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContentResponse(this);
        }
    }

    ///<summary>
    /// Defines an error message coming from the device.
    /// If the device is able to return an error message, and if the structure of that error message is known, then you can create a response that
    /// matches that error message, and included that response in the command/response pair as a "ResponseOnBadCommand".
    /// When the device sends a response that matches the ResponseOnBadCommand, then this will be indicated in the communication indicator of the DataMiner user interface.
    /// The command, however, will not be executed again as the received response matched one of the defined responses.
    /// Also, the information received from the device in the error message can be used to inform users about the error that occurred.
    ///</summary>
internal partial class PairsPairContentResponseOnBadCommand : ElementValueTag<uint?>, IPairsPairContentResponseOnBadCommand, IPairsPairContentObject
    {
        internal PairsPairContentResponseOnBadCommand(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ResponseOnBadCommand")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContentResponseOnBadCommand(this);
        }
    }

    ///<summary>
    /// Defines the DataMiner Connectivity Framework (DCF) interfaces.
    /// Feature introduced in DataMiner 8.0.0 (RN 5663).
    ///</summary>
internal partial class ParameterGroups : SimpleProtocolListNode<ParameterGroupsGroup>, IParameterGroups
    {
        internal ParameterGroups(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ParameterGroups", "Group")
        {
        }

        IParameterGroupsGroup IReadOnlyList<IParameterGroupsGroup>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParameterGroupsGroup> IEnumerable<IParameterGroupsGroup>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParameterGroups(this);
        }
    }

    ///<summary>
    /// Defines a parameter group.
    ///</summary>
internal partial class ParameterGroupsGroup : ElementTag, IParameterGroupsGroup
    {
        internal ParameterGroupsGroup(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Group")
        {
        }

        private ParameterGroupsGroupParams _params;
        private AttributeTag<bool?> _calculateAlarmState;
        private AttributeTag<uint?> _dynamicId;
        private AttributeTag<string> _dynamicIndex;
        private AttributeTag<bool?> _dynamicUsePK;
        private AttributeTag<uint?> _id;
        private AttributeTag<bool?> _isInternal;
        private AttributeTag<string> _name;
        private ParameterGroupsGroupType _type;
        ///<summary>
        /// Specifies the parameters that are included in the group.
        ///</summary>
public IParameterGroupsGroupParams Params => _params;
        ///<summary>
        /// Specifies whether to disable the interface state calculation.
        ///</summary>
public IValueTag<bool?> CalculateAlarmState => _calculateAlarmState;
        ///<summary>
        /// Specifies the ID of the table parameter.
        ///</summary>
public IValueTag<uint?> DynamicId => _dynamicId;
        ///<summary>
        /// Specifies the display key, which can be used as a filter.
        ///</summary>
public IValueTag<string> DynamicIndex => _dynamicIndex;
        ///<summary>
        /// Specifies whether the display key or the primary key should be used in the interface name (Default: false).
        ///</summary>
public IValueTag<bool?> DynamicUsePK => _dynamicUsePK;
        ///<summary>
        /// Specifies the unique ID of the parameter group.
        /// A parameter group cannot have an ID equal to 10000 or higher. The IDs starting from 10000 are reserved for DCF dynamic interfaces. Feature introduced in DataMiner 8.5.3 (RN 8863). Since DataMiner 9.0.4 (RN 13161), DataMiner creates new dynamic interfaces in the range 100 000 - 199 999 (instead of starting from 10 000).
        /// 
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies whether this an internal interface (Default: false).
        ///</summary>
public IValueTag<bool?> IsInternal => _isInternal;
        ///<summary>
        /// Specifies the name of the parameter group.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies the type of the interface.
        ///</summary>
public IValueTag<Enums.EnumParamGroupType?> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("calculateAlarmState", nameof(CalculateAlarmState), _calculateAlarmState, value => _calculateAlarmState = value);
            ParseAttributeTag("dynamicId", nameof(DynamicId), _dynamicId, value => _dynamicId = value);
            ParseAttributeTag("dynamicIndex", nameof(DynamicIndex), _dynamicIndex, value => _dynamicIndex = value);
            ParseAttributeTag("dynamicUsePK", nameof(DynamicUsePK), _dynamicUsePK, value => _dynamicUsePK = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("isInternal", nameof(IsInternal), _isInternal, value => _isInternal = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseElementTag("Params", nameof(Params), _params, value => _params = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParameterGroupsGroup(this);
        }
    }

    ///<summary>
    /// Specifies the parameters that are included in the group.
    ///</summary>
internal partial class ParameterGroupsGroupParams : SimpleProtocolListNode<ParameterGroupsGroupParamsParam>, IParameterGroupsGroupParams
    {
        internal ParameterGroupsGroupParams(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Params", "Param")
        {
        }

        IParameterGroupsGroupParamsParam IReadOnlyList<IParameterGroupsGroupParamsParam>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParameterGroupsGroupParamsParam> IEnumerable<IParameterGroupsGroupParamsParam>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParameterGroupsGroupParams(this);
        }
    }

    ///<summary>
    /// Specifies a parameter that is included in the group.
    ///</summary>
internal partial class ParameterGroupsGroupParamsParam : ElementTag, IParameterGroupsGroupParamsParam
    {
        internal ParameterGroupsGroupParamsParam(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Param")
        {
        }

        private AttributeTag<uint?> _id;
        private AttributeTag<string> _index;
        ///<summary>
        /// Specifies the ID of the included parameter.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies the parameter ID of the index column (primary key).
        ///</summary>
public IValueTag<string> Index => _index;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("index", nameof(Index), _index, value => _index = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParameterGroupsGroupParamsParam(this);
        }
    }

    internal partial class ParameterGroupsGroupType : AttributeTag<Enums.EnumParamGroupType?>
    {
        internal ParameterGroupsGroupType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumParamGroupType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamGroupTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains all the parameters defined in the protocol.
    ///</summary>
internal partial class Params : SimpleProtocolListNode<ParamsParam>, IParams
    {
        internal Params(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Params", "Param")
        {
        }

        private AttributeTag<string> _loadSequence;
        ///<summary>
        /// Changes the order in which saved parameter data is retrieved when the element starts up.
        ///</summary>
public IValueTag<string> LoadSequence => _loadSequence;

        IParamsParam IReadOnlyList<IParamsParam>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParam> IEnumerable<IParamsParam>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("loadSequence", nameof(LoadSequence), _loadSequence, value => _loadSequence = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParams(this);
        }
    }

    ///<summary>
    /// Defines a parameter.
    ///</summary>
internal partial class ParamsParam : ElementTag, IParamsParam
    {
        internal ParamsParam(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Param")
        {
        }

        private ParamsParamAlarm _alarm;
        private ParamsParamArrayOptions _arrayOptions;
        private ParamsParamCRC _cRC;
        private ParamsParamCrossDriverOptions _crossDriverOptions;
        private ParamsParamDashboard _dashboard;
        private ParamsParamDatabase _database;
        private ParamsParamDependencies _dependencies;
        private ElementValueTag<string> _description;
        private ParamsParamDisplay _display;
        private ParamsParamHyperLinks _hyperLinks;
        private Icon _icon;
        private ParamsParamInformation _information;
        private ParamsParamInterprete _interprete;
        private ParamsParamLength _length;
        private ParamsParamMatrix _matrix;
        private ParamsParamMeasurement _measurement;
        private ParamsParamMediation _mediation;
        private ElementValueTag<string> _message;
        private ElementValueTag<string> _name;
        private ParamsParamReplication _replication;
        private ParamsParamSNMP _sNMP;
        private ParamsParamType _type;
        private ParamsParamConfirmPopup _confirmPopup;
        private AttributeTag<string> _duplicateAs;
        private AttributeTag<string> _export;
        private AttributeTag<bool?> _historySet;
        private AttributeTag<uint?> _id;
        private AttributeTag<uint?> _level;
        private AttributeTag<string> _options;
        private AttributeTag<uint?> _pollingInterval;
        private AttributeTag<bool?> _save;
        private AttributeTag<System.TimeSpan?> _saveInterval;
        private AttributeTag<bool?> _setter;
        private AttributeTag<bool?> _snapshot;
        private AttributeTag<string> _snmpSetAndGet;
        private AttributeTag<bool?> _trending;
        private AttributeTag<uint?> _verificationTimeout;
        ///<summary>
        /// Specifies the default parameter alarming configuration. Each alarm consists of two components:
        /// -	Severity: Critical, Major, Minor, Warning or Normal
        /// -	Severity Range: Low, Medium or High
        /// These are combined into the following alarm levels:
        /// -	Critical Low (CL)
        /// -	Major Low (MaL)
        /// -	Minor Low (MiL)
        /// -	Warning Low (WaL)
        /// -	Normal (Normal)
        /// -	Warning High (WaH)
        /// -	Minor High (MiH)
        /// -	Major High (MaH)
        /// -	Critical High (CH)
        /// Each alarm level is included in a /Protocol/Params/Param/Alarm element, so a value can be assigned to it. If the value of the monitored parameter is equal to or exceeds
        /// a value included in the /Protocol/Params/Param/Alarm element, DataMiner will process an alarm depending on the alarm level that corresponds to the
        /// value.
        /// These assigned values are not only accessible via the protocol, but also via DataMiner Cuber or System Display. The alarm values of a parameter can be altered by
        /// means of alarm templates, on condition that a /Protocol/Params/Param/Alarm element has been defined for the parameter in the protocol. The alarm
        /// levels of a parameter can be adapted at any moment, regardless of the values specified in the protocol.
        ///</summary>
public IParamsParamAlarm Alarm => _alarm;
        ///<summary>
        /// Defines all table columns.
        /// Each table column is defined by one or two Parameters:
        /// -	one for read, and/or
        /// -	one for write.
        ///</summary>
public IParamsParamArrayOptions ArrayOptions => _arrayOptions;
        ///<summary>
        /// If /Protocol/Params/Param/Type is set to "CRC", then this CRC element allows you to define the CRC used in the communication with the device.
        /// The information you specify here will be used to calculate the CRC of the command/response.
        ///</summary>
public IParamsParamCRC CRC => _cRC;
        ///<summary>
        /// Allows building a direct view table using multiple columns from multiple different protocols. Feature introduced in DataMiner 10.2.9 (RN 33253).
        ///</summary>
public IParamsParamCrossDriverOptions CrossDriverOptions => _crossDriverOptions;
        ///<summary>
        /// Specifies the configuration for use in dashboards.
        ///</summary>
public IParamsParamDashboard Dashboard => _dashboard;
        ///<summary>
        /// Specifies database-related configuration options.
        /// Feature introduced in DataMiner 9.0.0 (RN 11853).
        ///</summary>
public IParamsParamDatabase Database => _database;
        ///<summary>
        /// Allows you to link one or more parameters. This is mostly used for situations in which clicking a button executes a command that includes several parameters.
        /// Execution of such a command will only proceed if all dependent parameters have a valid value.
        ///</summary>
public IParamsParamDependencies Dependencies => _dependencies;
        ///<summary>
        /// Specifies the description of the parameter.
        /// Typically, the parameter name refers to the technical name of the parameter, while the parameter description provides a more common name or description.
        /// Preferably, the description should be unique throughout the protocol.
        ///</summary>
public IValueTag<string> Description => _description;
        ///<summary>
        /// Defines if and how a parameter will be displayed on the user interface.
        ///</summary>
public IParamsParamDisplay Display => _display;
        ///<summary>
        /// Contains the custom commands (i.e. “hyperlinks”) that have to appear on the shortcut menu when users right-click an alarm of this parameter.
        /// These custom commands are often hyperlinks pointing to a web page or an automation script.
        ///</summary>
public IParamsParamHyperLinks HyperLinks => _hyperLinks;
        ///<summary>
        /// Specifies the icon to be shown in a tree control.
        ///</summary>
public IIcon Icon => _icon;
        ///<summary>
        /// Specifies additional information about the parameter.
        /// DataMiner will show this additional information in tooltips.
        /// Note: Only parameters of type "read" or "read bit" will use /Protocol/Params/Param/Information. In some cases, however, also parameters of type "write" or "write bit" will have one.
        ///</summary>
public IParamsParamInformation Information => _information;
        ///<summary>
        /// Specifies how a parameter value is processed.
        ///</summary>
public IParamsParamInterprete Interprete => _interprete;
        ///<summary>
        /// Specifies the length of the command/response.
        ///</summary>
public IParamsParamLength Length => _length;
        ///<summary>
        /// If /Protocol/Params/Param/Type is set to "matrix", then this will allow you to define the matrix control. Feature introduced in DataMiner 10.3.1/10.4.0 (RN 34661).
        ///</summary>
public IParamsParamMatrix Matrix => _matrix;
        ///<summary>
        /// Specifies how the parameter has to be displayed on the user interface (depending on the parameter type).
        ///</summary>
public IParamsParamMeasurement Measurement => _measurement;
        ///<summary>
        /// Contains the links between parameters of a base protocol and parameters of this protocol.
        ///</summary>
public IParamsParamMediation Mediation => _mediation;
        ///<summary>
        /// Specifies a message to be displayed when users change the parameter on the user interface.
        /// Usually, this text will appear as a pop-up warning when a potentially dangerous setting has to be changed.
        ///</summary>
public IValueTag<string> Message => _message;
        ///<summary>
        /// Specifies the name of the parameter. Typically, the parameter name refers to the technical name of the parameter, while the parameter description provides a more common name or description.
        /// Although it is possible that the name is used in alarm notifications, typically the parameter description will be used. See /Protocol/Params/Param/Description.
        /// Important:
        /// -	The name must be unique throughout the protocol.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Used to replicate specific parameters from another element.
        ///</summary>
public IParamsParamReplication Replication => _replication;
        ///<summary>
        /// Specifies SNMP related functionality for this parameter.
        /// Only used in protocols for elements that are SNMP-compliant. In case of such an element, DataMiner will interrogate the SNMP agent specified in /Proto­col/Params/Param/SNMP/OID or capture traps defined in /Protocol/Params/Param/SNMP/TrapOID.
        ///</summary>
public IParamsParamSNMP SNMP => _sNMP;
        ///<summary>
        /// Specifies the parameter type.
        /// For more information about the different types, refer to the DataMiner Protocol Markup Language documentation.
        /// Parameters of type "elementid", "elementname", "elementdmaid" and "dataminer info" are the first parameters that are loaded by a protocol. Although they hold information, they cannot, as such,
        /// be displayed in Element Display. Therefore, for these types of parameters, always set /Protocol/Params/Param/Display/RTDisplay "false".
        /// If you do want to display the information in one of these parameters in Element Display, there is a workaround: create another parameter of type "read", and copy the value from its invisible parameter to this new parameter after protocol start-up. You can then display the "read" parameter in Element Display.
        ///</summary>
public IParamsParamType Type => _type;
        ///<summary>
        /// Overrides the "Never ask for confirmation after setting parameter value" setting in DataMiner Cube.
        /// Feature introduced in DataMiner 9.0.0 (RN 11133).
        ///</summary>
public IValueTag<Enums.EnumParamConfirmPopup?> ConfirmPopup => _confirmPopup;
        ///<summary>
        /// Specifies that the value of the parameter on which this attribute is specified should be shown in the specified view table column(s).
        ///</summary>
public IValueTag<string> DuplicateAs => _duplicateAs;
        ///<summary>
        /// Allows exporting a parameter to an exported protocol used by a dynamic virtual element (DVE).
        ///</summary>
public IValueTag<string> Export => _export;
        ///<summary>
        /// Specifies that this parameter is a history set parameter.
        /// If you mark a parameter as a history set parameter, its last set value will not be stored in the trending database when the element is restarted.
        ///</summary>
public IValueTag<bool?> HistorySet => _historySet;
        ///<summary>
        /// Specifies the ID of the parameter.
        /// -	Normal protocols: range 1-64000
        /// -	Spectrum analyzers: range 50000-59999
        /// Warning: Never change parameter IDs in existing protocols. This would severely affect alarms, trend displays, MS Visio files, etc.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies the security level of this parameter.
        /// All users of whom the security level is above the one specified in this attribute are able to change (i.e. set) the value of the parameter.
        ///</summary>
public IValueTag<uint?> Level => _level;
        ///<summary>
        /// Specifies the options applied to this parameter.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the polling interval (ms) as a hint for the real-time trend graph.
        ///</summary>
public IValueTag<uint?> PollingInterval => _pollingInterval;
        ///<summary>
        /// Specifies whether the parameter has to be saved each time its value changes.
        /// Default: false
        /// Note: Only applicable for standalone parameters. For column parameters, refer to the "save" option in the Protocol/Params/Param/ArrayOptions/ColumnOptions/ColumnOption@options attribute.
        ///</summary>
public IValueTag<bool?> Save => _save;
        ///<summary>
        /// Specifies the interval at which the parameter values should be saved.
        /// Feature introduced in DataMiner 9.5.7 (RN 16708).
        ///</summary>
public IValueTag<System.TimeSpan?> SaveInterval => _saveInterval;
        ///<summary>
        /// Specifies whether the value of the write parameter will be copied to the corresponding read parameter (with­out the need to add a trigger or an action).
        /// Default: false
        ///</summary>
public IValueTag<bool?> Setter => _setter;
        ///<summary>
        /// Specifies the offload of snapshots of a parameter to the central database.
        /// This option is never set on a table, but on the columns that a snapshot should be taken from.
        /// The behavior is the same as the trending attribute, but does not require a trend template. Also, the data will not be stored in the local database, but in the specified central database. This is done via settings in the Db.xml file.
        /// When this attribute is not present, the snapshot is set to false.
        /// 
        ///</summary>
public IValueTag<bool?> Snapshot => _snapshot;
        ///<summary>
        /// Performs a set and get on a "write" parameter.
        /// When defined on columns with the default value true, cells are retrieved via an Execute Next. The get will not be executed when the set failed.
        /// For a list of possible values, see dynamicSnmpGet.
        /// 
        ///</summary>
public IValueTag<string> SnmpSetAndGet => _snmpSetAndGet;
        ///<summary>
        /// Specifies whether the parameter supports trending.
        /// Default: true
        ///</summary>
public IValueTag<bool?> Trending => _trending;
        ///<summary>
        /// Overrides the default verification timeout (or the verification timeout value set in MaintenanceSettings.xml) for this parameter with the specified value (in milliseconds).
        ///</summary>
public IValueTag<uint?> VerificationTimeout => _verificationTimeout;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("confirmPopup", nameof(ConfirmPopup), _confirmPopup, value => _confirmPopup = value);
            ParseAttributeTag("duplicateAs", nameof(DuplicateAs), _duplicateAs, value => _duplicateAs = value);
            ParseAttributeTag("export", nameof(Export), _export, value => _export = value);
            ParseAttributeTag("historySet", nameof(HistorySet), _historySet, value => _historySet = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("level", nameof(Level), _level, value => _level = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("pollingInterval", nameof(PollingInterval), _pollingInterval, value => _pollingInterval = value);
            ParseAttributeTag("save", nameof(Save), _save, value => _save = value);
            ParseAttributeTag("saveInterval", nameof(SaveInterval), _saveInterval, value => _saveInterval = value);
            ParseAttributeTag("setter", nameof(Setter), _setter, value => _setter = value);
            ParseAttributeTag("snapshot", nameof(Snapshot), _snapshot, value => _snapshot = value);
            ParseAttributeTag("snmpSetAndGet", nameof(SnmpSetAndGet), _snmpSetAndGet, value => _snmpSetAndGet = value);
            ParseAttributeTag("trending", nameof(Trending), _trending, value => _trending = value);
            ParseAttributeTag("verificationTimeout", nameof(VerificationTimeout), _verificationTimeout, value => _verificationTimeout = value);
            ParseElementTag("Alarm", nameof(Alarm), _alarm, value => _alarm = value);
            ParseElementTag("ArrayOptions", nameof(ArrayOptions), _arrayOptions, value => _arrayOptions = value);
            ParseElementTag("CRC", nameof(CRC), _cRC, value => _cRC = value);
            ParseElementTag("CrossDriverOptions", nameof(CrossDriverOptions), _crossDriverOptions, value => _crossDriverOptions = value);
            ParseElementTag("Dashboard", nameof(Dashboard), _dashboard, value => _dashboard = value);
            ParseElementTag("Database", nameof(Database), _database, value => _database = value);
            ParseElementTag("Dependencies", nameof(Dependencies), _dependencies, value => _dependencies = value);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
            ParseElementTag("HyperLinks", nameof(HyperLinks), _hyperLinks, value => _hyperLinks = value);
            ParseElementTag("Icon", nameof(Icon), _icon, value => _icon = value);
            ParseElementTag("Information", nameof(Information), _information, value => _information = value);
            ParseElementTag("Interprete", nameof(Interprete), _interprete, value => _interprete = value);
            ParseElementTag("Length", nameof(Length), _length, value => _length = value);
            ParseElementTag("Matrix", nameof(Matrix), _matrix, value => _matrix = value);
            ParseElementTag("Measurement", nameof(Measurement), _measurement, value => _measurement = value);
            ParseElementTag("Mediation", nameof(Mediation), _mediation, value => _mediation = value);
            ParseElementTag("Message", nameof(Message), _message, value => _message = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Replication", nameof(Replication), _replication, value => _replication = value);
            ParseElementTag("SNMP", nameof(SNMP), _sNMP, value => _sNMP = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParam(this);
        }
    }

    ///<summary>
    /// Specifies the default parameter alarming configuration. Each alarm consists of two components:
    /// -	Severity: Critical, Major, Minor, Warning or Normal
    /// -	Severity Range: Low, Medium or High
    /// These are combined into the following alarm levels:
    /// -	Critical Low (CL)
    /// -	Major Low (MaL)
    /// -	Minor Low (MiL)
    /// -	Warning Low (WaL)
    /// -	Normal (Normal)
    /// -	Warning High (WaH)
    /// -	Minor High (MiH)
    /// -	Major High (MaH)
    /// -	Critical High (CH)
    /// Each alarm level is included in a /Protocol/Params/Param/Alarm element, so a value can be assigned to it. If the value of the monitored parameter is equal to or exceeds
    /// a value included in the /Protocol/Params/Param/Alarm element, DataMiner will process an alarm depending on the alarm level that corresponds to the
    /// value.
    /// These assigned values are not only accessible via the protocol, but also via DataMiner Cuber or System Display. The alarm values of a parameter can be altered by
    /// means of alarm templates, on condition that a /Protocol/Params/Param/Alarm element has been defined for the parameter in the protocol. The alarm
    /// levels of a parameter can be adapted at any moment, regardless of the values specified in the protocol.
    ///</summary>
internal partial class ParamsParamAlarm : ElementTag, IParamsParamAlarm
    {
        internal ParamsParamAlarm(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Alarm")
        {
        }

        private ElementValueTag<string> _cH;
        private ElementValueTag<string> _cL;
        private ElementValueTag<string> _info;
        private ElementValueTag<string> _maH;
        private ElementValueTag<string> _maL;
        private ElementValueTag<string> _miH;
        private ElementValueTag<string> _miL;
        private ParamsParamAlarmMonitored _monitored;
        private ElementValueTag<string> _normal;
        private ElementValueTag<string> _waH;
        private ElementValueTag<string> _waL;
        private AttributeTag<uint?> _activeTime;
        private AttributeTag<string> _options;
        private AttributeTag<string> _type;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "critical high" alarm.
        ///</summary>
public IValueTag<string> CH => _cH;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "critical low" alarm.
        ///</summary>
public IValueTag<string> CL => _cL;
        ///<summary>
        /// When the value of the alarm is equal to the value specified in this element, an information event is generated.
        ///</summary>
public IValueTag<string> Info => _info;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "major high" alarm.
        ///</summary>
public IValueTag<string> MaH => _maH;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "major low" alarm.
        ///</summary>
public IValueTag<string> MaL => _maL;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "minor high" alarm.
        ///</summary>
public IValueTag<string> MiH => _miH;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "minor low" alarm.
        ///</summary>
public IValueTag<string> MiL => _miL;
        ///<summary>
        /// Allows enabling or disabling the /Protocol/Params/Param/Alarm element assigned to the parameter.
        ///</summary>
public IParamsParamAlarmMonitored Monitored => _monitored;
        ///<summary>
        /// When the parameter value equals this value (Integer or String, depending on the type of the parameter) or does not exceed the
        /// specified warning limits, DataMiner will not generate an alarm. If an alarm was generated earlier, its type will be set to "dropped".
        ///</summary>
public IValueTag<string> Normal => _normal;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "warning high" alarm.
        ///</summary>
public IValueTag<string> WaH => _waH;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "warning low" alarm.
        ///</summary>
public IValueTag<string> WaL => _waL;
        ///<summary>
        /// In case of a constant alarm: the time (in milliseconds) before the alarm is cleared.
        ///</summary>
public IValueTag<uint?> ActiveTime => _activeTime;
        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";"). These options can only be used if the table is linked to another table.
        /// -	threshold: When using this option, specify two parameter IDs, separated by a comma. If the value of the second parameter is smaller than the value of the first parameter,
        /// no Alarm will be generated.
        /// -	propertyNames: In this option, specify the property labels to be added to the alarm tab. Multiple names are separated by a comma.
        /// -	properties: In this option, specify the format of the properties to be added to the alarm tab. Always start the properties string with the character used to separate the different formats.
        /// Each property in the string is either a parameter ID or a combination of text and parameter IDs separated by an asterisk ("*"). If the characters between * are numbers only, then they are considered a parameter ID.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// When the polled device is able to send a nominal value for the parameter, this attribute can be added to the /Protocol/Params/Param/Alarm.
        /// - If set to "absolute", the alarm values defined in /Protocol/Params/Param/Alarm will be calculated in accordance with the nominal value sent by the device.
        /// When the "Critical Low" tag contains the value 5, this value will be subtracted from the nominal value to calculate the actual alarm limit.
        /// -	If set to "relative", percentages will be taken instead of absolute values in order to calculate the actual alarm limits. Example: When the "Minor High" element contains 50,
        /// the alarm limit will contain the nominal value increased with 50% of its value.
        /// You can normalize an alarm by (optionally) adding two parameters, separated by a comma.
        /// -	First parameter: The ID of the parameter that holds the nominal value. This can be a dynamic table parameter or a normal parameter. In case of a table parameter,
        /// each row will be compared with the nominal value found in the same row of the specified column.
        /// -	Second parameter: The ID of the parameter that holds the value by which to multiply the nominal value.
        ///</summary>
public IValueTag<string> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("activeTime", nameof(ActiveTime), _activeTime, value => _activeTime = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseElementTag("CH", nameof(CH), _cH, value => _cH = value);
            ParseElementTag("CL", nameof(CL), _cL, value => _cL = value);
            ParseElementTag("Info", nameof(Info), _info, value => _info = value);
            ParseElementTag("MaH", nameof(MaH), _maH, value => _maH = value);
            ParseElementTag("MaL", nameof(MaL), _maL, value => _maL = value);
            ParseElementTag("MiH", nameof(MiH), _miH, value => _miH = value);
            ParseElementTag("MiL", nameof(MiL), _miL, value => _miL = value);
            ParseElementTag("Monitored", nameof(Monitored), _monitored, value => _monitored = value);
            ParseElementTag("Normal", nameof(Normal), _normal, value => _normal = value);
            ParseElementTag("WaH", nameof(WaH), _waH, value => _waH = value);
            ParseElementTag("WaL", nameof(WaL), _waL, value => _waL = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamAlarm(this);
        }
    }

    ///<summary>
    /// Allows enabling or disabling the /Protocol/Params/Param/Alarm element assigned to the parameter.
    ///</summary>
internal partial class ParamsParamAlarmMonitored : ElementValueTag<bool?>, IParamsParamAlarmMonitored
    {
        internal ParamsParamAlarmMonitored(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Monitored")
        {
        }

        private AttributeTag<string> _disabledIf;
        ///<summary>
        /// Allows monitoring to be disabled when a parameter contains a particular value. Format: "pid,value".
        ///</summary>
public IValueTag<string> DisabledIf => _disabledIf;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("disabledIf", nameof(DisabledIf), _disabledIf, value => _disabledIf = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamAlarmMonitored(this);
        }
    }

    ///<summary>
    /// Defines all table columns.
    /// Each table column is defined by one or two Parameters:
    /// -	one for read, and/or
    /// -	one for write.
    ///</summary>
internal partial class ParamsParamArrayOptions : SimpleProtocolListNode<TypeColumnOption>, IParamsParamArrayOptions
    {
        internal ParamsParamArrayOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ArrayOptions", "ColumnOption")
        {
        }

        private ParamsParamArrayOptionsNamingFormat _namingFormat;
        private AttributeTag<bool?> _deleteRow;
        private AttributeTag<uint?> _displayColumn;
        private AttributeTag<uint?> _index;
        private AttributeTag<string> _options;
        private AttributeTag<string> _partial;
        private AttributeTag<string> _snmpIndex;
        ///<summary>
        /// Defines the structure of the display key.
        /// The first character denotes the separator used.
        /// Integers between two separators will be used as column pids.
        /// Using any other alphanumeric string between separators will display this string in the row index.
        ///</summary>
public IParamsParamArrayOptionsNamingFormat NamingFormat => _namingFormat;
        ///<summary>
        /// Specifies how non-existing rows should be handled.
        /// This attribute is used in combination with snmpSetAndGet or dynamicSnmpGet functionality on tables.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        /// Feature introduced in DataMiner 8.5.7 (RN 10007).
        /// 
        ///</summary>
public IValueTag<bool?> DeleteRow => _deleteRow;
        ///<summary>
        /// Defines which column is used as an identifier for the user.
        /// This column can be updated, and normally contains a readable key which identifies the row for the user.
        ///</summary>
public IValueTag<uint?> DisplayColumn => _displayColumn;
        ///<summary>
        /// Defines which column contains the primary keys.
        /// The column containing the primary keys has to be of type "string". Once a row is created, the value of the primary key cannot be changed.
        ///</summary>
public IValueTag<uint?> Index => _index;
        ///<summary>
        /// Specifies a number of options.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        /// Note: In this attribute, you can specify multiple values separated by a character of choice (a semi-colon is recommended).
        /// This character has to be the first character in the value of the options attribute. If, for example, you want to separate the different options by a semi-colon, the first character of the options value has to be a semi-colon.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// If set to "true", the table will be subdivided into multiple pages (default: 1000 rows per page).
        /// A page navigator will be displayed at the bottom of the table.
        /// To manually set the number of rows per page, type a colon (":") after "true", followed by the number of rows per page. This value has to be a value between 10 and 5000.
        ///</summary>
public IValueTag<string> Partial => _partial;
        ///<summary>
        /// Defines the columns that are used when you retrieve the table using SNMP.
        /// If you want a concatenation of multiple columns, you can separate them with semicolons (";").
        ///</summary>
public IValueTag<string> SnmpIndex => _snmpIndex;

        ITypeColumnOption IReadOnlyList<ITypeColumnOption>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeColumnOption> IEnumerable<ITypeColumnOption>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("deleteRow", nameof(DeleteRow), _deleteRow, value => _deleteRow = value);
            ParseAttributeTag("displayColumn", nameof(DisplayColumn), _displayColumn, value => _displayColumn = value);
            ParseAttributeTag("index", nameof(Index), _index, value => _index = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("partial", nameof(Partial), _partial, value => _partial = value);
            ParseAttributeTag("snmpIndex", nameof(SnmpIndex), _snmpIndex, value => _snmpIndex = value);
            ParseElementTag("NamingFormat", nameof(NamingFormat), _namingFormat, value => _namingFormat = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamArrayOptions(this);
        }
    }

    ///<summary>
    /// Defines the structure of the display key.
    /// The first character denotes the separator used.
    /// Integers between two separators will be used as column pids.
    /// Using any other alphanumeric string between separators will display this string in the row index.
    ///</summary>
internal partial class ParamsParamArrayOptionsNamingFormat : ElementValueTag<string>, IParamsParamArrayOptionsNamingFormat
    {
        internal ParamsParamArrayOptionsNamingFormat(ProtocolModel model, ProtocolTag parent) : base(model, parent, "NamingFormat")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamArrayOptionsNamingFormat(this);
        }
    }

    ///<summary>
    /// If /Protocol/Params/Param/Type is set to "CRC", then this CRC element allows you to define the CRC used in the communication with the device.
    /// The information you specify here will be used to calculate the CRC of the command/response.
    ///</summary>
internal partial class ParamsParamCRC : ElementTag, IParamsParamCRC
    {
        internal ParamsParamCRC(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CRC")
        {
        }

        private ParamsParamCRCContent _content;
        private ParamsParamCRCType _type;
        ///<summary>
        /// Specifies the parameters of the command/response to be included in the CRC calculation. In other words, the operation specified in
        /// /Protocol/Params/Param/CRC/Type will only be performed on the parameters that make up the content.
        /// Note: The first parameter of the command/response has ID 0.
        ///</summary>
public IParamsParamCRCContent Content => _content;
        ///<summary>
        /// Defines the CRC calculation algorithm.
        ///</summary>
public IParamsParamCRCType Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCRC(this);
        }
    }

    ///<summary>
    /// Specifies the parameters of the command/response to be included in the CRC calculation. In other words, the operation specified in
    /// /Protocol/Params/Param/CRC/Type will only be performed on the parameters that make up the content.
    /// Note: The first parameter of the command/response has ID 0.
    ///</summary>
internal partial class ParamsParamCRCContent : SimpleProtocolListNode<ParamsParamCRCContentParam>, IParamsParamCRCContent
    {
        internal ParamsParamCRCContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content", "Param")
        {
        }

        IParamsParamCRCContentParam IReadOnlyList<IParamsParamCRCContentParam>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamCRCContentParam> IEnumerable<IParamsParamCRCContentParam>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCRCContent(this);
        }
    }

    ///<summary>
    /// Specifies a parameter of the command/response to be included in the CRC calculation.
    ///</summary>
internal partial class ParamsParamCRCContentParam : ElementValueTag<uint?>, IParamsParamCRCContentParam
    {
        internal ParamsParamCRCContentParam(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Param")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCRCContentParam(this);
        }
    }

    ///<summary>
    /// Defines the CRC calculation algorithm.
    ///</summary>
internal partial class ParamsParamCRCType : ElementValueTag<Enums.EnumParamCRCType?>, IParamsParamCRCType
    {
        internal ParamsParamCRCType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private AttributeTag<int?> _byteoffset;
        private AttributeTag<string> _groupbytes;
        private AttributeTag<uint?> _mod;
        private AttributeTag<int?> _off;
        private AttributeTag<string> _options;
        private AttributeTag<uint?> _totaloffset;
        ///<summary>
        /// Allows to add an offset to every single byte of the CRC.
        /// Can be used in combination with all possible CRC types.
        ///</summary>
public IValueTag<int?> Byteoffset => _byteoffset;
        ///<summary>
        /// Specifies the number of bytes on which to perform the operation.
        /// Only valid if the CRC type is set to one of the following values: LSB after subtract, LSB after sum, Exor, Sum
        ///</summary>
public IValueTag<string> Groupbytes => _groupbytes;
        ///<summary>
        /// Specifies that a modulo operation has to be performed on the CRC after it has been calculated.
        ///</summary>
public IValueTag<uint?> Mod => _mod;
        ///<summary>
        /// Specifies an offset value to be added to the calculated CRC.
        /// Only valid if the CRC type is set to one of the following values: LSB after subtract, LSB after sum, Rest, Subtract, Sum.
        ///</summary>
public IValueTag<int?> Off => _off;
        ///<summary>
        /// Specifies additional options, separated by semi-colons (";"). Available options:
        /// -	ones complement: each bit of the calculated CRC will be inverted. (Example: AAAA will become 5555)
        /// -	or totaloffset: the "totaloffset" value will not be added but "OR"-ed.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies an offset value to be added to the CRC after it has been calculated.
        ///</summary>
public IValueTag<uint?> Totaloffset => _totaloffset;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("byteoffset", nameof(Byteoffset), _byteoffset, value => _byteoffset = value);
            ParseAttributeTag("groupbytes", nameof(Groupbytes), _groupbytes, value => _groupbytes = value);
            ParseAttributeTag("mod", nameof(Mod), _mod, value => _mod = value);
            ParseAttributeTag("off", nameof(Off), _off, value => _off = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("totaloffset", nameof(Totaloffset), _totaloffset, value => _totaloffset = value);
        }

        public override Enums.EnumParamCRCType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamCRCTypeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCRCType(this);
        }
    }

    ///<summary>
    /// Allows building a direct view table using multiple columns from multiple different protocols. Feature introduced in DataMiner 10.2.9 (RN 33253).
    ///</summary>
internal partial class ParamsParamCrossDriverOptions : SimpleProtocolListNode<ParamsParamCrossDriverOptionsCrossDriverOption>, IParamsParamCrossDriverOptions
    {
        internal ParamsParamCrossDriverOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CrossDriverOptions", "CrossDriverOption")
        {
        }

        IParamsParamCrossDriverOptionsCrossDriverOption IReadOnlyList<IParamsParamCrossDriverOptionsCrossDriverOption>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamCrossDriverOptionsCrossDriverOption> IEnumerable<IParamsParamCrossDriverOptionsCrossDriverOption>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCrossDriverOptions(this);
        }
    }

    ///<summary>
    /// Specifies column mappings from a remote protocol to this protocol.
    ///</summary>
internal partial class ParamsParamCrossDriverOptionsCrossDriverOption : SimpleProtocolListNode<ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation>, IParamsParamCrossDriverOptionsCrossDriverOption
    {
        internal ParamsParamCrossDriverOptionsCrossDriverOption(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CrossDriverOption", "PIDTranslation")
        {
        }

        private AttributeTag<string> _protocol;
        private AttributeTag<uint?> _remoteTablePID;
        ///<summary>
        /// Specifies the name of the protocol.
        ///</summary>
public IValueTag<string> Protocol => _protocol;
        ///<summary>
        /// Specifies the parameter ID of the remote table.
        ///</summary>
public IValueTag<uint?> RemoteTablePID => _remoteTablePID;

        IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation IReadOnlyList<IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation> IEnumerable<IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("protocol", nameof(Protocol), _protocol, value => _protocol = value);
            ParseAttributeTag("remoteTablePID", nameof(RemoteTablePID), _remoteTablePID, value => _remoteTablePID = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCrossDriverOptionsCrossDriverOption(this);
        }
    }

    ///<summary>
    /// Maps a column parameter ID from the remote protocol to this protocol.
    ///</summary>
internal partial class ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation : ElementTag, IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation
    {
        internal ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PIDTranslation")
        {
        }

        private AttributeTag<uint?> _local;
        private AttributeTag<uint?> _remote;
        ///<summary>
        /// Specifies the parameter ID of the column in this protocol.
        ///</summary>
public IValueTag<uint?> Local => _local;
        ///<summary>
        /// Specifies the parameter ID of the column in the remote protocol.
        ///</summary>
public IValueTag<uint?> Remote => _remote;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("local", nameof(Local), _local, value => _local = value);
            ParseAttributeTag("remote", nameof(Remote), _remote, value => _remote = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation(this);
        }
    }

    ///<summary>
    /// Specifies the configuration for use in dashboards.
    ///</summary>
internal partial class ParamsParamDashboard : ElementTag, IParamsParamDashboard
    {
        internal ParamsParamDashboard(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Dashboard")
        {
        }

        private ElementValueTag<string> _type;
        private ParamsParamDashboardDashboardOptions _dashboardOptions;
        ///<summary>
        /// Indicates the type of button panel.
        ///</summary>
public IValueTag<string> Type => _type;
        ///<summary>
        /// Groups the options that will determine how the button panel is displayed.
        ///</summary>
public IParamsParamDashboardDashboardOptions DashboardOptions => _dashboardOptions;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
            ParseElementTag("DashboardOptions", nameof(DashboardOptions), _dashboardOptions, value => _dashboardOptions = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDashboard(this);
        }
    }

    ///<summary>
    /// Groups the options that will determine how the button panel is displayed.
    ///</summary>
internal partial class ParamsParamDashboardDashboardOptions : SimpleProtocolListNode<ParamsParamDashboardDashboardOptionsDashboardOption>, IParamsParamDashboardDashboardOptions
    {
        internal ParamsParamDashboardDashboardOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DashboardOptions", "DashboardOption")
        {
        }

        IParamsParamDashboardDashboardOptionsDashboardOption IReadOnlyList<IParamsParamDashboardDashboardOptionsDashboardOption>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamDashboardDashboardOptionsDashboardOption> IEnumerable<IParamsParamDashboardDashboardOptionsDashboardOption>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDashboardDashboardOptions(this);
        }
    }

    ///<summary>
    /// Specifies how the button panel is displayed.
    ///</summary>
internal partial class ParamsParamDashboardDashboardOptionsDashboardOption : ElementValueTag<uint?>, IParamsParamDashboardDashboardOptionsDashboardOption
    {
        internal ParamsParamDashboardDashboardOptionsDashboardOption(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DashboardOption")
        {
        }

        private AttributeTag<string> _type;
        private AttributeTag<string> _name;
        ///<summary>
        /// Specifies whether the value denotes a column index or a parameter ID.
        ///</summary>
public IValueTag<string> Type => _type;
        ///<summary>
        /// Specifies the name of the option.
        ///</summary>
public IValueTag<string> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDashboardDashboardOptionsDashboardOption(this);
        }
    }

    ///<summary>
    /// Specifies database-related configuration options.
    /// Feature introduced in DataMiner 9.0.0 (RN 11853).
    ///</summary>
internal partial class ParamsParamDatabase : ElementTag, IParamsParamDatabase
    {
        internal ParamsParamDatabase(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Database")
        {
        }

        private ParamsParamDatabaseColumnDefinition _columnDefinition;
        private ParamsParamDatabaseConnection _connection;
        private ParamsParamDatabaseCQLOptions _cQLOptions;
        private ParamsParamDatabasePartition _partition;
        private ParamsParamDatabaseIndexingOptions _indexingOptions;
        ///<summary>
        /// Specifies the type of the corresponding column in the database table.
        ///</summary>
public IParamsParamDatabaseColumnDefinition ColumnDefinition => _columnDefinition;
        ///<summary>
        /// Specifies connection options.
        ///</summary>
public IParamsParamDatabaseConnection Connection => _connection;
        ///<summary>
        /// Specifies Cassandra-related database settings.
        /// Feature introduced in DataMiner 9.0.0 (RN 11853).
        ///</summary>
public IParamsParamDatabaseCQLOptions CQLOptions => _cQLOptions;
        ///<summary>
        /// Specifies the partitioning configuration.
        ///</summary>
public IParamsParamDatabasePartition Partition => _partition;
        ///<summary>
        /// Specifies indexing options (Elastic).
        /// Feature introduced in DataMiner 9.6.4 (RN 13552).
        ///</summary>
public IParamsParamDatabaseIndexingOptions IndexingOptions => _indexingOptions;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("ColumnDefinition", nameof(ColumnDefinition), _columnDefinition, value => _columnDefinition = value);
            ParseElementTag("Connection", nameof(Connection), _connection, value => _connection = value);
            ParseElementTag("CQLOptions", nameof(CQLOptions), _cQLOptions, value => _cQLOptions = value);
            ParseElementTag("Partition", nameof(Partition), _partition, value => _partition = value);
            ParseElementTag("IndexingOptions", nameof(IndexingOptions), _indexingOptions, value => _indexingOptions = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabase(this);
        }
    }

    ///<summary>
    /// Specifies the type of the corresponding column in the database table.
    ///</summary>
internal partial class ParamsParamDatabaseColumnDefinition : ElementValueTag<string>, IParamsParamDatabaseColumnDefinition
    {
        internal ParamsParamDatabaseColumnDefinition(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ColumnDefinition")
        {
        }

        private AttributeTag<string> _default;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public IValueTag<string> Default => _default;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("default", nameof(Default), _default, value => _default = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabaseColumnDefinition(this);
        }
    }

    ///<summary>
    /// Specifies connection options.
    ///</summary>
internal partial class ParamsParamDatabaseConnection : ElementTag, IParamsParamDatabaseConnection
    {
        internal ParamsParamDatabaseConnection(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Connection")
        {
        }

        private ElementValueTag<string> _type;
        ///<summary>
        /// Specifies the connection type.
        ///</summary>
public IValueTag<string> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabaseConnection(this);
        }
    }

    ///<summary>
    /// Specifies Cassandra-related database settings.
    /// Feature introduced in DataMiner 9.0.0 (RN 11853).
    ///</summary>
internal partial class ParamsParamDatabaseCQLOptions : ElementTag, IParamsParamDatabaseCQLOptions
    {
        internal ParamsParamDatabaseCQLOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "CQLOptions")
        {
        }

        private ElementValueTag<string> _clustering;
        private ElementValueTag<string> _finalizer;
        private ElementValueTag<string> _tableProperty;
        ///<summary>
        /// Specifies how the primary key of the table is defined.
        /// Contains a semicolon separated list of column idx values denoting the columns that form the primary key.
        ///</summary>
public IValueTag<string> Clustering => _clustering;
        ///<summary>
        /// Specifies the query that has to be executed after the creation of the table. This can for example be a query that will preload data or create indexes.
        ///</summary>
public IValueTag<string> Finalizer => _finalizer;
        ///<summary>
        /// Specifies the WITH clause that is to be used to set the necessary table properties.
        ///</summary>
public IValueTag<string> TableProperty => _tableProperty;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Clustering", nameof(Clustering), _clustering, value => _clustering = value);
            ParseElementTag("Finalizer", nameof(Finalizer), _finalizer, value => _finalizer = value);
            ParseElementTag("TableProperty", nameof(TableProperty), _tableProperty, value => _tableProperty = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabaseCQLOptions(this);
        }
    }

    ///<summary>
    /// Specifies the partitioning configuration.
    ///</summary>
internal partial class ParamsParamDatabasePartition : ElementValueTag<Enums.EnumDatabasePartition?>, IParamsParamDatabasePartition
    {
        internal ParamsParamDatabasePartition(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Partition")
        {
        }

        private AttributeTag<uint?> _partitionsToKeep;
        ///<summary>
        /// Specifies the number of partitions to keep.
        ///</summary>
public IValueTag<uint?> PartitionsToKeep => _partitionsToKeep;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("partitionsToKeep", nameof(PartitionsToKeep), _partitionsToKeep, value => _partitionsToKeep = value);
        }

        public override Enums.EnumDatabasePartition? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDatabasePartitionConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabasePartition(this);
        }
    }

    ///<summary>
    /// Specifies indexing options (Elastic).
    /// Feature introduced in DataMiner 9.6.4 (RN 13552).
    ///</summary>
internal partial class ParamsParamDatabaseIndexingOptions : ElementTag, IParamsParamDatabaseIndexingOptions
    {
        internal ParamsParamDatabaseIndexingOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IndexingOptions")
        {
        }

        private AttributeTag<bool?> _enabled;
        ///<summary>
        /// Indicates whether the data of the logger table will be stored in the Elastic database instead of Cassandra. When set to true, the data of the logger table will be stored in the Elastic database instead of Cassandra.
        ///</summary>
public IValueTag<bool?> Enabled => _enabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("enabled", nameof(Enabled), _enabled, value => _enabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabaseIndexingOptions(this);
        }
    }

    ///<summary>
    /// Allows you to link one or more parameters. This is mostly used for situations in which clicking a button executes a command that includes several parameters.
    /// Execution of such a command will only proceed if all dependent parameters have a valid value.
    ///</summary>
internal partial class ParamsParamDependencies : SimpleProtocolListNode<ParamsParamDependenciesId>, IParamsParamDependencies
    {
        internal ParamsParamDependencies(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Dependencies", "Id")
        {
        }

        IParamsParamDependenciesId IReadOnlyList<IParamsParamDependenciesId>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamDependenciesId> IEnumerable<IParamsParamDependenciesId>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDependencies(this);
        }
    }

    ///<summary>
    /// Specifies the IDs of the parameters that are linked to this parameter.
    ///</summary>
internal partial class ParamsParamDependenciesId : ElementValueTag<string>, IParamsParamDependenciesId
    {
        internal ParamsParamDependenciesId(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Id")
        {
        }

        private AttributeTag<bool?> _postSet;
        ///<summary>
        /// Specifies whether the dependency parameter acts as a preset or a post-set. Refer to the DataMiner Protocol Markup Language Documentation for more information.
        ///</summary>
public IValueTag<bool?> PostSet => _postSet;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("postSet", nameof(PostSet), _postSet, value => _postSet = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDependenciesId(this);
        }
    }

    ///<summary>
    /// Defines if and how a parameter will be displayed on the user interface.
    ///</summary>
internal partial class ParamsParamDisplay : ElementTag, IParamsParamDisplay
    {
        internal ParamsParamDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Display")
        {
        }

        private ParamsParamDisplayDynamicUnits _dynamicUnits;
        private ElementValueTag<uint?> _decimals;
        private ParamsParamDisplayParametersView _parametersView;
        private ParamsParamDisplayPositions _positions;
        private ParamsParamDisplayRange _range;
        private ParamsParamDisplayRTDisplay _rTDisplay;
        private ElementValueTag<decimal?> _steps;
        private ParamsParamDisplayTrending _trending;
        private ElementValueTag<string> _units;
        ///<summary>
        /// Specifies the dynamic units that can be used.
        ///</summary>
public IParamsParamDisplayDynamicUnits DynamicUnits => _dynamicUnits;
        ///<summary>
        /// Defines the number of decimals to be used to display the parameter value on the user inter­face.
        ///</summary>
public IValueTag<uint?> Decimals => _decimals;
        ///<summary>
        /// Allows displaying a parameter as a chart.
        /// The parameters holding the actual values to be displayed have to be specified in /Protocol/Params/Param/Display/ParametersView/Parameters.
        /// Note: When this is used, make sure to set /Protocol/Params/Param/Measurement/Type to “Chart”.
        ///</summary>
public IParamsParamDisplayParametersView ParametersView => _parametersView;
        ///<summary>
        /// Defines the position of the parameter on the user interface.
        /// Note: As a parameter can be displayed on several locations on the user interface, /Protocol/Params/Param/Display/Positions can contain more than
        /// one position.
        ///</summary>
public IParamsParamDisplayPositions Positions => _positions;
        ///<summary>
        /// Defines the parameter value range.
        ///</summary>
public IParamsParamDisplayRange Range => _range;
        ///<summary>
        /// Specifies whether the parameter should be pushed to the SLElement process.
        ///</summary>
public IParamsParamDisplayRTDisplay RTDisplay => _rTDisplay;
        ///<summary>
        /// Defines the step size of a write parameter.
        ///</summary>
public IValueTag<decimal?> Steps => _steps;
        ///<summary>
        /// Specifies the formula to be used for the average trending data of this parameter. By default, the average over a 5 minute timespan is stored.
        ///</summary>
public IParamsParamDisplayTrending Trending => _trending;
        ///<summary>
        /// Specifies a unit for a parameter value displayed on the user interface. This can be a unit like "Vac", "dBm", etc., but it can also be a string like "batteries"
        /// (for a parameter showing the number of batteries attached to a backup power supply).
        /// The specified unit will be used each time the value of the parameter is displayed: in a report, on the alarm display, etc.
        ///</summary>
public IValueTag<string> Units => _units;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DynamicUnits", nameof(DynamicUnits), _dynamicUnits, value => _dynamicUnits = value);
            ParseElementTag("Decimals", nameof(Decimals), _decimals, value => _decimals = value);
            ParseElementTag("ParametersView", nameof(ParametersView), _parametersView, value => _parametersView = value);
            ParseElementTag("Positions", nameof(Positions), _positions, value => _positions = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("RTDisplay", nameof(RTDisplay), _rTDisplay, value => _rTDisplay = value);
            ParseElementTag("Steps", nameof(Steps), _steps, value => _steps = value);
            ParseElementTag("Trending", nameof(Trending), _trending, value => _trending = value);
            ParseElementTag("Units", nameof(Units), _units, value => _units = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplay(this);
        }
    }

    ///<summary>
    /// Specifies the dynamic units that can be used.
    ///</summary>
internal partial class ParamsParamDisplayDynamicUnits : SimpleProtocolListNode<ParamsParamDisplayDynamicUnitsUnit>, IParamsParamDisplayDynamicUnits
    {
        internal ParamsParamDisplayDynamicUnits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DynamicUnits", "Unit")
        {
        }

        IParamsParamDisplayDynamicUnitsUnit IReadOnlyList<IParamsParamDisplayDynamicUnitsUnit>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamDisplayDynamicUnitsUnit> IEnumerable<IParamsParamDisplayDynamicUnitsUnit>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayDynamicUnits(this);
        }
    }

    ///<summary>
    /// Specifies a dynamic unit.
    ///</summary>
internal partial class ParamsParamDisplayDynamicUnitsUnit : ElementValueTag<string>, IParamsParamDisplayDynamicUnitsUnit
    {
        internal ParamsParamDisplayDynamicUnitsUnit(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Unit")
        {
        }

        private AttributeTag<uint?> _decimals;
        ///<summary>
        /// Specifies the number of decimals to be used to display the parameter value on the user interface with this unit.
        ///</summary>
public IValueTag<uint?> Decimals => _decimals;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("decimals", nameof(Decimals), _decimals, value => _decimals = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayDynamicUnitsUnit(this);
        }
    }

    ///<summary>
    /// Allows displaying a parameter as a chart.
    /// The parameters holding the actual values to be displayed have to be specified in /Protocol/Params/Param/Display/ParametersView/Parameters.
    /// Note: When this is used, make sure to set /Protocol/Params/Param/Measurement/Type to “Chart”.
    ///</summary>
internal partial class ParamsParamDisplayParametersView : ElementTag, IParamsParamDisplayParametersView
    {
        internal ParamsParamDisplayParametersView(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ParametersView")
        {
        }

        private ParamsParamDisplayParametersViewParameters _parameters;
        private AttributeTag<string> _options;
        private ParamsParamDisplayParametersViewType _type;
        ///<summary>
        /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then here you have to define the parameters holding the actual values to be displayed.
        ///</summary>
public IParamsParamDisplayParametersViewParameters Parameters => _parameters;
        ///<summary>
        /// A pipe-separated list of options:
        /// -	Height: Height of the chart (in pixels). If you do not specify a height, the chart will take up the rest of the page.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the chart type: Column, Pie, Row, StackedArea
        /// Note:
        /// -	Pie charts only work if the referenced values are either all positive or all negative.
        /// -	StackedArea charts should not be used to display values that are constantly changing.
        ///</summary>
public IValueTag<Enums.EnumParametersViewType?> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseElementTag("Parameters", nameof(Parameters), _parameters, value => _parameters = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayParametersView(this);
        }
    }

    ///<summary>
    /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then here you have to define the parameters holding the actual values to be displayed.
    ///</summary>
internal partial class ParamsParamDisplayParametersViewParameters : SimpleProtocolListNode<ParamsParamDisplayParametersViewParametersParameter>, IParamsParamDisplayParametersViewParameters
    {
        internal ParamsParamDisplayParametersViewParameters(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Parameters", "Parameter")
        {
        }

        IParamsParamDisplayParametersViewParametersParameter IReadOnlyList<IParamsParamDisplayParametersViewParametersParameter>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamDisplayParametersViewParametersParameter> IEnumerable<IParamsParamDisplayParametersViewParametersParameter>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayParametersViewParameters(this);
        }
    }

    ///<summary>
    /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then add a Parameter element to
    /// /Protocol/Params/Param/Display/ParametersView/Parameters for every parameter holding a value to be displayed.
    /// Note: Only specify parameters of type "double".
    ///</summary>
internal partial class ParamsParamDisplayParametersViewParametersParameter : ElementTag, IParamsParamDisplayParametersViewParametersParameter
    {
        internal ParamsParamDisplayParametersViewParametersParameter(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Parameter")
        {
        }

        private AttributeTag<uint?> _id;
        private AttributeTag<string> _options;
        private AttributeTag<string> _tableIndex;
        ///<summary>
        /// Specifies the ID of the parameter.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// *** Not yet implemented. ***
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the row index (in case the “id” attribute refers to a table parameter).
        ///</summary>
public IValueTag<string> TableIndex => _tableIndex;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("tableIndex", nameof(TableIndex), _tableIndex, value => _tableIndex = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayParametersViewParametersParameter(this);
        }
    }

    internal partial class ParamsParamDisplayParametersViewType : AttributeTag<Enums.EnumParametersViewType?>
    {
        internal ParamsParamDisplayParametersViewType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumParametersViewType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParametersViewTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines the position of the parameter on the user interface.
    /// Note: As a parameter can be displayed on several locations on the user interface, /Protocol/Params/Param/Display/Positions can contain more than
    /// one position.
    ///</summary>
internal partial class ParamsParamDisplayPositions : SimpleProtocolListNode<ParamsParamDisplayPositionsPosition>, IParamsParamDisplayPositions
    {
        internal ParamsParamDisplayPositions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Positions", "Position")
        {
        }

        IParamsParamDisplayPositionsPosition IReadOnlyList<IParamsParamDisplayPositionsPosition>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamDisplayPositionsPosition> IEnumerable<IParamsParamDisplayPositionsPosition>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayPositions(this);
        }
    }

    ///<summary>
    /// Defines the location of the parameter on the user interface.
    ///</summary>
internal partial class ParamsParamDisplayPositionsPosition : ElementTag, IParamsParamDisplayPositionsPosition
    {
        internal ParamsParamDisplayPositionsPosition(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Position")
        {
        }

        private ParamsParamDisplayPositionsPositionPage _page;
        private ElementValueTag<uint?> _column;
        private ElementValueTag<uint?> _row;
        ///<summary>
        /// Specifies on which page you want to display the parameter.
        /// All Data display pages specified in the protocol will appear in the page selection box at the top of the Data Display.
        ///</summary>
public IParamsParamDisplayPositionsPositionPage Page => _page;
        ///<summary>
        /// Specifies the horizontal position of the parameter on the page specified in
        /// /Protocol/Params/Param/Display/Positions/Position/Page.
        /// Data display pages are divided into rows and columns. In /Protocol/Params/Param/Display/Positions/Position/Column, you can specify the column on which you want the parameter to be displayed.
        /// Enter an integer value between 0 and 5.
        /// Note: It is recommended to divide the user interface into two columns: a left-hand column with column value 0, and a right-hand column with column value 1.
        ///</summary>
public IValueTag<uint?> Column => _column;
        ///<summary>
        /// Specifies the vertical position of the parameter on thepage specified in /Protocol/Params/Param/Display/Positions/Position/Page.
        /// Data display pages are divided into rows and columns. In /Protocol/Params/Param/Display/Positions/Position/Row, you can specify the row on which you want
        /// the parameter to be displayed.
        /// Note: 0 = first row
        ///</summary>
public IValueTag<uint?> Row => _row;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Page", nameof(Page), _page, value => _page = value);
            ParseElementTag("Column", nameof(Column), _column, value => _column = value);
            ParseElementTag("Row", nameof(Row), _row, value => _row = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayPositionsPosition(this);
        }
    }

    ///<summary>
    /// Specifies on which page you want to display the parameter.
    /// All Data display pages specified in the protocol will appear in the page selection box at the top of the Data Display.
    ///</summary>
internal partial class ParamsParamDisplayPositionsPositionPage : ElementValueTag<string>, IParamsParamDisplayPositionsPositionPage
    {
        internal ParamsParamDisplayPositionsPositionPage(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Page")
        {
        }

        private ParamsParamDisplayPositionsPositionPageMeasType _measType;
        ///<summary>
        /// This attribute allows you to display a parameter as a specific type of parameter on a particular page.
        ///</summary>
public IValueTag<Enums.EnumParamMeasurementType?> MeasType => _measType;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("measType", nameof(MeasType), _measType, value => _measType = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayPositionsPositionPage(this);
        }
    }

    internal partial class ParamsParamDisplayPositionsPositionPageMeasType : AttributeTag<Enums.EnumParamMeasurementType?>
    {
        internal ParamsParamDisplayPositionsPositionPageMeasType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "measType")
        {
        }

        public override Enums.EnumParamMeasurementType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamMeasurementTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines the parameter value range.
    ///</summary>
internal partial class ParamsParamDisplayRange : ElementTag, IParamsParamDisplayRange
    {
        internal ParamsParamDisplayRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<decimal?> _low;
        private ElementValueTag<decimal?> _high;
        ///<summary>
        /// Specifies the lower limit of the range, i.e. the minimum value of the parameter.
        ///</summary>
public IValueTag<decimal?> Low => _low;
        ///<summary>
        /// Specifies the upper limit of the value range, i.e. the maximum value of the parameter.
        ///</summary>
public IValueTag<decimal?> High => _high;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Low", nameof(Low), _low, value => _low = value);
            ParseElementTag("High", nameof(High), _high, value => _high = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayRange(this);
        }
    }

    ///<summary>
    /// Specifies whether the parameter should be pushed to the SLElement process.
    ///</summary>
internal partial class ParamsParamDisplayRTDisplay : ElementValueTag<bool?>, IParamsParamDisplayRTDisplay
    {
        internal ParamsParamDisplayRTDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "RTDisplay")
        {
        }

        private AttributeTag<bool?> _onAppLevel;
        ///<summary>
        /// Set this attribute to "true" if the parameter has no position but needs RTDisplay true for application purposes. For validation only.
        ///</summary>
public IValueTag<bool?> OnAppLevel => _onAppLevel;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("onAppLevel", nameof(OnAppLevel), _onAppLevel, value => _onAppLevel = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayRTDisplay(this);
        }
    }

    ///<summary>
    /// Specifies the formula to be used for the average trending data of this parameter. By default, the average over a 5 minute timespan is stored.
    ///</summary>
internal partial class ParamsParamDisplayTrending : ElementTag, IParamsParamDisplayTrending
    {
        internal ParamsParamDisplayTrending(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Trending")
        {
        }

        private ParamsParamDisplayTrendingType _type;
        private AttributeTag<bool?> _logarithmic;
        ///<summary>
        /// Specifies the formula used to determine the average trending data.
        ///</summary>
public IParamsParamDisplayTrendingType Type => _type;
        ///<summary>
        /// Set this attribute to "true" if you want to set the trend graph of the parameter to a logarithmic scale.
        ///</summary>
public IValueTag<bool?> Logarithmic => _logarithmic;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("logarithmic", nameof(Logarithmic), _logarithmic, value => _logarithmic = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayTrending(this);
        }
    }

    ///<summary>
    /// Specifies the formula used to determine the average trending data.
    ///</summary>
internal partial class ParamsParamDisplayTrendingType : ElementValueTag<Enums.EnumTrendingType?>, IParamsParamDisplayTrendingType
    {
        internal ParamsParamDisplayTrendingType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private AttributeTag<string> _operations;
        ///<summary>
        /// Option to choose a logarithmic scale for the vertical axis. The parameter’s real value should always be larger than 0 for log10(value) to be possible.
        ///</summary>
public IValueTag<string> Operations => _operations;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("operations", nameof(Operations), _operations, value => _operations = value);
        }

        public override Enums.EnumTrendingType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTrendingTypeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayTrendingType(this);
        }
    }

    ///<summary>
    /// Contains the custom commands (i.e. “hyperlinks”) that have to appear on the shortcut menu when users right-click an alarm of this parameter.
    /// These custom commands are often hyperlinks pointing to a web page or an automation script.
    ///</summary>
internal partial class ParamsParamHyperLinks : SimpleProtocolListNode<ParamsParamHyperLinksHyperLink>, IParamsParamHyperLinks
    {
        internal ParamsParamHyperLinks(ProtocolModel model, ProtocolTag parent) : base(model, parent, "HyperLinks", "HyperLink")
        {
        }

        IParamsParamHyperLinksHyperLink IReadOnlyList<IParamsParamHyperLinksHyperLink>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamHyperLinksHyperLink> IEnumerable<IParamsParamHyperLinksHyperLink>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamHyperLinks(this);
        }
    }

    ///<summary>
    /// Defines a custom command (i.e. “hyperlink”) that has to appear on the shortcut menu when users right-click an alarm of this parameter.
    ///</summary>
internal partial class ParamsParamHyperLinksHyperLink : ElementValueTag<string>, IParamsParamHyperLinksHyperLink
    {
        internal ParamsParamHyperLinksHyperLink(ProtocolModel model, ProtocolTag parent) : base(model, parent, "HyperLink")
        {
        }

        private AttributeTag<string> _valueParsing;
        ///<summary>
        /// Makes the command appear on the shortcut menu of specific alarms and information events.
        /// If you specify a string in this attribute, the command will only appear on the shortcut menu of alarms and information events of which the value matches the string you specified.
        /// If you leave this attribute empty, the command will appear on the shortcut menu of every alarm and information event.
        /// The string you specify in this valueParsing attribute can contain wildcards (question marks and asterisks) as well as placeholders.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> ValueParsing => _valueParsing;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("valueParsing", nameof(ValueParsing), _valueParsing, value => _valueParsing = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamHyperLinksHyperLink(this);
        }
    }

    ///<summary>
    /// Specifies additional information about the parameter.
    /// DataMiner will show this additional information in tooltips.
    /// Note: Only parameters of type "read" or "read bit" will use /Protocol/Params/Param/Information. In some cases, however, also parameters of type "write" or "write bit" will have one.
    ///</summary>
internal partial class ParamsParamInformation : ElementTag, IParamsParamInformation
    {
        internal ParamsParamInformation(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Information")
        {
        }

        private ElementValueTag<string> _alarmDescription;
        private ElementValueTag<string> _category;
        private ElementValueTag<string> _correctiveAction;
        private ParamsParamInformationIncludes _includes;
        private ElementValueTag<string> _subtext;
        private ElementValueTag<string> _text;
        ///<summary>
        /// Specifies an alarm description. When an alarm for this parameter is generated, the value specified here will be shown in the Alarm Description field of the alarm.
        ///</summary>
public IValueTag<string> AlarmDescription => _alarmDescription;
        ///<summary>
        /// Specifies a category. When an alarm for this parameter is generated, the value specified here will be shown in the Category field of the alarm.
        ///</summary>
public IValueTag<string> Category => _category;
        ///<summary>
        /// Specifies a corrective action. When an alarm for this parameter is generated, the value specified here will be shown in the Corrective Action field of the alarm.
        ///</summary>
public IValueTag<string> CorrectiveAction => _correctiveAction;
        ///<summary>
        /// Contains one or more /Protocol/Params/Param/Information/Include elements to indicate that you want additional information to be displayed in the tooltip.
        ///</summary>
public IParamsParamInformationIncludes Includes => _includes;
        ///<summary>
        /// Specifies the actual content of the tooltip.
        /// Next to the title of the tooltip, a drop-down arrow will allow users to enlarge the tooltip and display the text contained in /Protocol/Params/Param/Information/Subtext.
        ///</summary>
public IValueTag<string> Subtext => _subtext;
        ///<summary>
        /// Specifies the title of the tooltip.
        ///</summary>
public IValueTag<string> Text => _text;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("AlarmDescription", nameof(AlarmDescription), _alarmDescription, value => _alarmDescription = value);
            ParseElementTag("Category", nameof(Category), _category, value => _category = value);
            ParseElementTag("CorrectiveAction", nameof(CorrectiveAction), _correctiveAction, value => _correctiveAction = value);
            ParseElementTag("Includes", nameof(Includes), _includes, value => _includes = value);
            ParseElementTag("Subtext", nameof(Subtext), _subtext, value => _subtext = value);
            ParseElementTag("Text", nameof(Text), _text, value => _text = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInformation(this);
        }
    }

    ///<summary>
    /// Contains one or more /Protocol/Params/Param/Information/Include elements to indicate that you want additional information to be displayed in the tooltip.
    ///</summary>
internal partial class ParamsParamInformationIncludes : SimpleProtocolListNode<ParamsParamInformationIncludesInclude>, IParamsParamInformationIncludes
    {
        internal ParamsParamInformationIncludes(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Includes", "Include")
        {
        }

        IParamsParamInformationIncludesInclude IReadOnlyList<IParamsParamInformationIncludesInclude>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamInformationIncludesInclude> IEnumerable<IParamsParamInformationIncludesInclude>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInformationIncludes(this);
        }
    }

    ///<summary>
    /// Indicates that you want additional information to be displayed in the tooltip.
    /// Information specified in /Protocol/Params/Param/Information/Include elements will appear underneath the con­tents of the /Protocol/Params/Param/Information/Subtext element.
    /// Can contain one of the following values:
    /// - Range: The range of the parameter.
    /// - Units: The unit of the parameter.
    /// - Steps: The step size of the parameter.
    /// - Time: A time stamp that refers to either the last known change or the last time the Parameter was changed by its write parameter (if any).
    ///</summary>
internal partial class ParamsParamInformationIncludesInclude : ElementValueTag<Enums.EnumParamInformationInclude?>, IParamsParamInformationIncludesInclude
    {
        internal ParamsParamInformationIncludesInclude(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Include")
        {
        }

        public override Enums.EnumParamInformationInclude? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInformationIncludeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInformationIncludesInclude(this);
        }
    }

    ///<summary>
    /// Specifies how a parameter value is processed.
    ///</summary>
internal partial class ParamsParamInterprete : ElementTag, IParamsParamInterprete
    {
        internal ParamsParamInterprete(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Interprete")
        {
        }

        private ParamsParamInterpreteAlignment _alignment;
        private ElementValueTag<uint?> _base;
        private ElementValueTag<uint?> _bits;
        private ElementValueTag<uint?> _byteOffset;
        private ElementValueTag<uint?> _decimals;
        private ElementValueTag<string> _defaultValue;
        private ParamsParamInterpreteEndian _endian;
        private ParamsParamInterpreteExceptions _exceptions;
        private ElementValueTag<decimal?> _factor;
        private ElementValueTag<uint?> _length;
        private ParamsParamInterpreteLengthType _lengthType;
        private ElementValueTag<uint?> _nbrOfBits;
        private ParamsParamInterpreteOffSet _offSet;
        private ParamsParamInterpreteOthers _others;
        private ParamsParamInterpreteRange _range;
        private ParamsParamInterpreteRawType _rawType;
        private ParamsParamInterpreteRounding _rounding;
        private ParamsParamInterpreteScale _scale;
        private ParamsParamInterpreteSequence _sequence;
        private ElementValueTag<uint?> _startPosition;
        private ParamsParamInterpreteType _type;
        private ElementValueTag<string> _valueElement;
        ///<summary>
        /// Used to retrieve BCD numbers from an incoming stream.
        /// When a /Protocol/Params/Param/Interprete/Bits element is defined in a group, only a couple of bits will be used from each byte.
        /// When a read bit parameter, with its rawtype set to “bcd”, is assigned to that group and exists of multiple bytes, the Alignment element can be needed to specify the exact starting position
        /// of the first BCD.
        ///</summary>
public IValueTag<Enums.EnumParamInterpretAlignment?> Alignment => _alignment;
        ///<summary>
        /// Specifies the numeral system (decimal, hexadecimal, etc.).
        /// Contains a number between 2 and 36. Default: 10
        /// Note: In case of base 36, the letters "a" through "z" (or "A" through "Z") are assigned the values 10 through 35.
        ///</summary>
public IValueTag<uint?> Base => _base;
        ///<summary>
        /// Used when a group of multiple bytes has been defined, but only a couple of bits are used from each byte.
        /// For example, when only the lower 4 bits are used from each byte, a group can be defined with /Protocol/Params/Param/Interprete/Bits set to 4.
        /// When a "read bit" parameter of 8 bits is assigned to that group, 4 lower bits of 2 bytes will be taken instead of 1 complete byte.
        ///</summary>
public IValueTag<uint?> Bits => _bits;
        ///<summary>
        /// Specifies the byte offset.
        /// Each incoming byte of a group containing this ByteOffset element will be decremented with the specified byte offset, while each outgoing byte of the group will be incremented with the specified byte offset.
        ///</summary>
public IValueTag<uint?> ByteOffset => _byteOffset;
        ///<summary>
        /// Specifies the number of decimals that will be stored in memory.
        ///</summary>
public IValueTag<uint?> Decimals => _decimals;
        ///<summary>
        /// Specifies the default value to be assigned to the parameter if it is empty after startup. If this parameter is saved, the saved value will overrule the default value.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether DataMiner must reverse the byte order.
        /// When numbers are composed of multiple bytes, Intel processors reverse the byte order before writing them to memory.
        /// This optional element instructs DataMiner to either reverse the byte order or not (only relevant in case of unsigned numbers).
        /// - Big: The byte order will be reversed.
        /// - Little: The byte order will not be reversed.
        /// Note: By default, Little Endian is used.
        ///</summary>
public IValueTag<Enums.EnumParamInterpretEndian?> Endian => _endian;
        ///<summary>
        /// In /Protocol/Params/Param/Interprete/Others, you can define symbols that are not accepted by the rawtype.
        /// However, a rare condition of a parameter can also be expressed by a symbol that is allowed by the parameter's rawtype.
        /// In that case, you can use /Protocol/Params/Param/Interprete/Exceptions/Exception.
        /// In /Protocol/Params/Param/Interprete/Exceptions, you can specify several /Protocol/Params/Param/Interprete/Exceptions/Exception elements, each representing a different exceptional state.
        /// Note: Only useful for parameters of type "read".
        ///</summary>
public IParamsParamInterpreteExceptions Exceptions => _exceptions;
        ///<summary>
        /// Multiplies the parameter value with the specified factor.
        ///</summary>
public IValueTag<decimal?> Factor => _factor;
        ///<summary>
        /// Specifies the exact length of the parameter (in bytes). Used when /Protocol/Params/Param/Interprete/LengthType is set to "fixed".
        ///</summary>
public IValueTag<uint?> Length => _length;
        ///<summary>
        /// Specifies whether the parameter has a fixed length.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IParamsParamInterpreteLengthType LengthType => _lengthType;
        ///<summary>
        /// Specifies the number of bits needed.
        /// When this number exceeds the number of bits used in a byte, the /Protocol/Params/Param/Interprete/Endian element can be set to "big" to make DataMiner reverse the bit order when processing them.
        ///</summary>
public IValueTag<uint?> NbrOfBits => _nbrOfBits;
        ///<summary>
        /// In case the Sequence tag contains "OffSet " as an operation, to offset to be added can be specified using this tag.
        ///</summary>
public IParamsParamInterpreteOffSet OffSet => _offSet;
        ///<summary>
        /// Each parameter has a certain rawtype, but in some cases other characters are sent instead of the usual ones to indicate a rare condition.
        /// These symbols are often not allowed by the rawtype of the parameter. To catch those characters and display the singular state of the parameter, they can be specified in /Protocol/Params/Param/Interprete/Others.
        ///</summary>
public IParamsParamInterpreteOthers Others => _others;
        ///<summary>
        /// Defines a range for the parameter values. By adding a range to /Protocol/Params/Param/Interprete, a value outside this defined range will be ignored.
        /// The limits of the range are defined by /Protocol/Params/Param/Interprete/Range/Low and /Protocol/Params/Param/Interprete/Range/High.
        /// Note: This can also be used to specify a value range in case of a simulated element.
        ///</summary>
public IParamsParamInterpreteRange Range => _range;
        ///<summary>
        /// Specifies which type of content is allowed in the parameter.
        /// If an incoming parameter value does not match the expected rawtype, DataMiner will not process it.
        /// The rawtype setting can therefore be considered as a kind of filter.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<Enums.EnumParamInterpretRawType?> RawType => _rawType;
        ///<summary>
        /// Specifies how the parameter value is rounded (Default: down).
        /// Feature introduced in DataMiner 9.0.0 (Main Release) and DataMiner 9.0.4 (Feature Release) (RN 13519).
        ///</summary>
public IValueTag<Enums.EnumRounding?> Rounding => _rounding;
        ///<summary>
        /// Specifies that you want DataMiner to re-interpret the value range of a particular parameter.
        ///</summary>
public IParamsParamInterpreteScale Scale => _scale;
        ///<summary>
        /// Specifies a mathematical operation to be performed on the parameter value.
        /// Specify at least one mathematical operation. If you specify multiple operations, separate them using semi-colons (";").
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IParamsParamInterpreteSequence Sequence => _sequence;
        ///<summary>
        /// Specifies the start bit in the group to which the parameter refers to in case the parameter is of type "read/write bits".
        /// The most significant bit of the group is considered to be bit 0, and the counter is incremented as the significance of the bits decreases.
        ///</summary>
public IValueTag<uint?> StartPosition => _startPosition;
        ///<summary>
        /// In this tag, you can specify how the parameter should be processed and saved.
        /// Specify one of the following values:
        /// - string: The parameter will be processed as an ASCII string.
        /// - double: The parameter will be processed as a number.
        /// - high nibble: The parameter will be processed as the high nibble (i.e. first four bits) of a byte.
        ///</summary>
public IParamsParamInterpreteType Type => _type;
        ///<summary>
        /// In case of a parameter with a fixed length and a fixed value, set /Protocol/Params/Param/Inter­prete/LengthType to "fixed" and specify the fixed value here.
        ///</summary>
public IValueTag<string> ValueElement => _valueElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Alignment", nameof(Alignment), _alignment, value => _alignment = value);
            ParseElementTag("Base", nameof(Base), _base, value => _base = value);
            ParseElementTag("Bits", nameof(Bits), _bits, value => _bits = value);
            ParseElementTag("ByteOffset", nameof(ByteOffset), _byteOffset, value => _byteOffset = value);
            ParseElementTag("Decimals", nameof(Decimals), _decimals, value => _decimals = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Endian", nameof(Endian), _endian, value => _endian = value);
            ParseElementTag("Exceptions", nameof(Exceptions), _exceptions, value => _exceptions = value);
            ParseElementTag("Factor", nameof(Factor), _factor, value => _factor = value);
            ParseElementTag("Length", nameof(Length), _length, value => _length = value);
            ParseElementTag("LengthType", nameof(LengthType), _lengthType, value => _lengthType = value);
            ParseElementTag("NbrOfBits", nameof(NbrOfBits), _nbrOfBits, value => _nbrOfBits = value);
            ParseElementTag("OffSet", nameof(OffSet), _offSet, value => _offSet = value);
            ParseElementTag("Others", nameof(Others), _others, value => _others = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("RawType", nameof(RawType), _rawType, value => _rawType = value);
            ParseElementTag("Rounding", nameof(Rounding), _rounding, value => _rounding = value);
            ParseElementTag("Scale", nameof(Scale), _scale, value => _scale = value);
            ParseElementTag("Sequence", nameof(Sequence), _sequence, value => _sequence = value);
            ParseElementTag("StartPosition", nameof(StartPosition), _startPosition, value => _startPosition = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterprete(this);
        }
    }

    internal partial class ParamsParamInterpreteAlignment : ElementValueTag<Enums.EnumParamInterpretAlignment?>
    {
        internal ParamsParamInterpreteAlignment(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Alignment")
        {
        }

        public override Enums.EnumParamInterpretAlignment? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretAlignmentConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamInterpreteEndian : ElementValueTag<Enums.EnumParamInterpretEndian?>
    {
        internal ParamsParamInterpreteEndian(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Endian")
        {
        }

        public override Enums.EnumParamInterpretEndian? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretEndianConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// In /Protocol/Params/Param/Interprete/Others, you can define symbols that are not accepted by the rawtype.
    /// However, a rare condition of a parameter can also be expressed by a symbol that is allowed by the parameter's rawtype.
    /// In that case, you can use /Protocol/Params/Param/Interprete/Exceptions/Exception.
    /// In /Protocol/Params/Param/Interprete/Exceptions, you can specify several /Protocol/Params/Param/Interprete/Exceptions/Exception elements, each representing a different exceptional state.
    /// Note: Only useful for parameters of type "read".
    ///</summary>
internal partial class ParamsParamInterpreteExceptions : SimpleProtocolListNode<ParamsParamInterpreteExceptionsException>, IParamsParamInterpreteExceptions
    {
        internal ParamsParamInterpreteExceptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Exceptions", "Exception")
        {
        }

        IParamsParamInterpreteExceptionsException IReadOnlyList<IParamsParamInterpreteExceptionsException>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamInterpreteExceptionsException> IEnumerable<IParamsParamInterpreteExceptionsException>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteExceptions(this);
        }
    }

    ///<summary>
    /// Each exception is uniquely identified by its ID.
    /// If the parameter receives an incoming symbol that matches the value specified in /Protocol/Params/Param/Interprete/Exceptions/Exception, the contents of /Protocol/Params/Param/Interprete/Exceptions/Exception/Display will be shown.
    ///</summary>
internal partial class ParamsParamInterpreteExceptionsException : ElementTag, IParamsParamInterpreteExceptionsException
    {
        internal ParamsParamInterpreteExceptionsException(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Exception")
        {
        }

        private ParamsParamInterpreteExceptionsExceptionDisplay _display;
        private ElementValueTag<string> _valueElement;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _valueAttribute;
        ///<summary>
        /// Specifies the text that has to be displayed when the incoming value matches the contents of the value attribute of /Protocol/Params/Param/Interprete/Exceptions/Exception.
        ///</summary>
public IParamsParamInterpreteExceptionsExceptionDisplay Display => _display;
        ///<summary>
        /// Specifies the new value to which you want to internally map the incoming exception value specified in the value attribute of the /Protocol/Params/Param/Interprete/Exceptions/Exception element.
        ///</summary>
public IValueTag<string> ValueElement => _valueElement;
        ///<summary>
        /// Specifies the unique ID of the exception.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// When the parameter receives an incoming symbol that matches the contents of this tag, the contents of /Protocol/Params/Param/Interprete/Exceptions/Exception/Display will be displayed.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteExceptionsException(this);
        }
    }

    ///<summary>
    /// Specifies the text that has to be displayed when the incoming value matches the contents of the value attribute of /Protocol/Params/Param/Interprete/Exceptions/Exception.
    ///</summary>
internal partial class ParamsParamInterpreteExceptionsExceptionDisplay : ElementValueTag<string>, IParamsParamInterpreteExceptionsExceptionDisplay
    {
        internal ParamsParamInterpreteExceptionsExceptionDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Display")
        {
        }

        private ParamsParamInterpreteExceptionsExceptionDisplayState _state;
        ///<summary>
        /// To emphasize the rare condition of the parameter, you can set the state attribute to "disabled" to have the parameter displayed in gray.
        ///</summary>
public IValueTag<Enums.EnumDisplayState?> State => _state;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("state", nameof(State), _state, value => _state = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteExceptionsExceptionDisplay(this);
        }
    }

    internal partial class ParamsParamInterpreteExceptionsExceptionDisplayState : AttributeTag<Enums.EnumDisplayState?>
    {
        internal ParamsParamInterpreteExceptionsExceptionDisplayState(ProtocolModel model, ProtocolTag parent) : base(model, parent, "state")
        {
        }

        public override Enums.EnumDisplayState? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDisplayStateConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies whether the parameter has a fixed length.
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
internal partial class ParamsParamInterpreteLengthType : ElementValueTag<Enums.EnumParamInterpretLengthType?>, IParamsParamInterpreteLengthType
    {
        internal ParamsParamInterpreteLengthType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LengthType")
        {
        }

        private AttributeTag<uint?> _id;
        private AttributeTag<uint?> _times;
        ///<summary>
        /// If LengthType is set to "other param", this attribute has to contain the ID of the "other" parameter that contains the parameter length.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// If LengthType is "next param", then this attribute has to contain the number of times the next parameter should occur before it is considered to be the next parameter.
        ///</summary>
public IValueTag<uint?> Times => _times;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("times", nameof(Times), _times, value => _times = value);
        }

        public override Enums.EnumParamInterpretLengthType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretLengthTypeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteLengthType(this);
        }
    }

    ///<summary>
    /// In case the Sequence tag contains "OffSet " as an operation, to offset to be added can be specified using this tag.
    ///</summary>
internal partial class ParamsParamInterpreteOffSet : ElementValueTag<uint?>, IParamsParamInterpreteOffSet
    {
        internal ParamsParamInterpreteOffSet(ProtocolModel model, ProtocolTag parent) : base(model, parent, "OffSet")
        {
        }

        private AttributeTag<uint?> _id;
        ///<summary>
        /// Specifies the ID of the parameter that holds the offset value.
        ///</summary>
public IValueTag<uint?> Id => _id;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteOffSet(this);
        }
    }

    ///<summary>
    /// Each parameter has a certain rawtype, but in some cases other characters are sent instead of the usual ones to indicate a rare condition.
    /// These symbols are often not allowed by the rawtype of the parameter. To catch those characters and display the singular state of the parameter, they can be specified in /Protocol/Params/Param/Interprete/Others.
    ///</summary>
internal partial class ParamsParamInterpreteOthers : SimpleProtocolListNode<ParamsParamInterpreteOthersOther>, IParamsParamInterpreteOthers
    {
        internal ParamsParamInterpreteOthers(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Others", "Other")
        {
        }

        IParamsParamInterpreteOthersOther IReadOnlyList<IParamsParamInterpreteOthersOther>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamInterpreteOthersOther> IEnumerable<IParamsParamInterpreteOthersOther>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteOthers(this);
        }
    }

    ///<summary>
    /// When an incoming character does not match the rawtype of a Parameter, DataMiner will try to match the symbol to the rawtype of the Parameter to which a /Protocol/Params/Param/Interprete/Others/Other element refers to, if any.
    ///</summary>
internal partial class ParamsParamInterpreteOthersOther : ElementTag, IParamsParamInterpreteOthersOther
    {
        internal ParamsParamInterpreteOthersOther(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Other")
        {
        }

        private ParamsParamInterpreteOthersOtherDisplay _display;
        private ElementValueTag<decimal?> _valueElement;
        private AttributeTag<uint?> _id;
        ///<summary>
        /// When a /Protocol/Params/Param/Interprete/Others/Other element matches the incoming symbol, the contents of /Protocol/Params/Param/Interprete/Others/Other/Display will be shown.
        ///</summary>
public IParamsParamInterpreteOthersOtherDisplay Display => _display;
        ///<summary>
        /// Adds a numeric value (&gt;= 10) to the parameter , which can be useful in case you want to show an alarm when this rare condition occurs.
        ///</summary>
public IValueTag<decimal?> ValueElement => _valueElement;
        ///<summary>
        /// Specifies the ID of the parameter to which the incoming symbol will be compared.
        /// If the incoming symbol matches the referred parameter, the contents of the/Protocol/Params/Param/Inter­prete/Others/Other/Display element will be shown.
        ///</summary>
public IValueTag<uint?> Id => _id;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteOthersOther(this);
        }
    }

    ///<summary>
    /// When a /Protocol/Params/Param/Interprete/Others/Other element matches the incoming symbol, the contents of /Protocol/Params/Param/Interprete/Others/Other/Display will be shown.
    ///</summary>
internal partial class ParamsParamInterpreteOthersOtherDisplay : ElementValueTag<string>, IParamsParamInterpreteOthersOtherDisplay
    {
        internal ParamsParamInterpreteOthersOtherDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Display")
        {
        }

        private ParamsParamInterpreteOthersOtherDisplayState _state;
        ///<summary>
        /// If set to "disabled", the parameter will be displayed in gray.
        ///</summary>
public IValueTag<Enums.EnumDisplayState?> State => _state;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("state", nameof(State), _state, value => _state = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteOthersOtherDisplay(this);
        }
    }

    internal partial class ParamsParamInterpreteOthersOtherDisplayState : AttributeTag<Enums.EnumDisplayState?>
    {
        internal ParamsParamInterpreteOthersOtherDisplayState(ProtocolModel model, ProtocolTag parent) : base(model, parent, "state")
        {
        }

        public override Enums.EnumDisplayState? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDisplayStateConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines a range for the parameter values. By adding a range to /Protocol/Params/Param/Interprete, a value outside this defined range will be ignored.
    /// The limits of the range are defined by /Protocol/Params/Param/Interprete/Range/Low and /Protocol/Params/Param/Interprete/Range/High.
    /// Note: This can also be used to specify a value range in case of a simulated element.
    ///</summary>
internal partial class ParamsParamInterpreteRange : ElementTag, IParamsParamInterpreteRange
    {
        internal ParamsParamInterpreteRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<decimal?> _low;
        private ElementValueTag<decimal?> _high;
        ///<summary>
        /// Specifies the lower limit of the range, i.e. the minimum value of a parameter.
        ///</summary>
public IValueTag<decimal?> Low => _low;
        ///<summary>
        /// Specifies the upper limit of the range, i.e. the maximum value of a parameter.
        ///</summary>
public IValueTag<decimal?> High => _high;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Low", nameof(Low), _low, value => _low = value);
            ParseElementTag("High", nameof(High), _high, value => _high = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteRange(this);
        }
    }

    internal partial class ParamsParamInterpreteRawType : ElementValueTag<Enums.EnumParamInterpretRawType?>
    {
        internal ParamsParamInterpreteRawType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "RawType")
        {
        }

        public override Enums.EnumParamInterpretRawType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretRawTypeConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamInterpreteRounding : ElementValueTag<Enums.EnumRounding?>
    {
        internal ParamsParamInterpreteRounding(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Rounding")
        {
        }

        public override Enums.EnumRounding? ConvertRawValue(string rawValue)
        {
            return Enums.EnumRoundingConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies that you want DataMiner to re-interpret the value range of a particular parameter.
    ///</summary>
internal partial class ParamsParamInterpreteScale : ElementTag, IParamsParamInterpreteScale
    {
        internal ParamsParamInterpreteScale(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Scale")
        {
        }

        private AttributeTag<decimal?> _lowData;
        private AttributeTag<decimal?> _highData;
        private AttributeTag<decimal?> _low;
        private AttributeTag<decimal?> _high;
        ///<summary>
        /// Specifies the lowest value that can be returned by the device for the parameter in question.
        ///</summary>
public IValueTag<decimal?> LowData => _lowData;
        ///<summary>
        /// Specifies the highest value that can be returned by the device for the parameter in question.
        ///</summary>
public IValueTag<decimal?> HighData => _highData;
        ///<summary>
        /// Specifies the value to which DataMiner has to convert the lowest value that can be returned by the device.
        ///</summary>
public IValueTag<decimal?> Low => _low;
        ///<summary>
        /// Specifies the value to which DataMiner has to convert the highest value that can be returned by the device.
        ///</summary>
public IValueTag<decimal?> High => _high;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("lowData", nameof(LowData), _lowData, value => _lowData = value);
            ParseAttributeTag("highData", nameof(HighData), _highData, value => _highData = value);
            ParseAttributeTag("low", nameof(Low), _low, value => _low = value);
            ParseAttributeTag("high", nameof(High), _high, value => _high = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteScale(this);
        }
    }

    ///<summary>
    /// Specifies a mathematical operation to be performed on the parameter value.
    /// Specify at least one mathematical operation. If you specify multiple operations, separate them using semi-colons (";").
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
internal partial class ParamsParamInterpreteSequence : ElementValueTag<string>, IParamsParamInterpreteSequence
    {
        internal ParamsParamInterpreteSequence(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Sequence")
        {
        }

        private AttributeTag<uint?> _loop;
        private AttributeTag<bool?> _noset;
        ///<summary>
        /// Specifies the loop value for the sequence (integer).
        /// The value in the parameter will be automatically recalculated taking into account the loop (overflow) sequence.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<uint?> Loop => _loop;
        ///<summary>
        /// If you do not specify this attribute, or if you set it to "false", sequences will be taken into account when the parameter gets a new value.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<bool?> Noset => _noset;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("loop", nameof(Loop), _loop, value => _loop = value);
            ParseAttributeTag("noset", nameof(Noset), _noset, value => _noset = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteSequence(this);
        }
    }

    ///<summary>
    /// In this tag, you can specify how the parameter should be processed and saved.
    /// Specify one of the following values:
    /// - string: The parameter will be processed as an ASCII string.
    /// - double: The parameter will be processed as a number.
    /// - high nibble: The parameter will be processed as the high nibble (i.e. first four bits) of a byte.
    ///</summary>
internal partial class ParamsParamInterpreteType : ElementValueTag<Enums.EnumParamInterpretType?>, IParamsParamInterpreteType
    {
        internal ParamsParamInterpreteType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private AttributeTag<bool?> _filter;
        private ParamsParamInterpreteTypeTrim _trim;
        ///<summary>
        /// When set to "true", only printable characters will be displayed (default value: "false").
        ///</summary>
public IValueTag<bool?> Filter => _filter;
        ///<summary>
        /// Add this attribute to remove leading and/or trailing whitespace.
        /// You can specify the following values. If you add both values, separate them by a semi-colon (";").
        /// -	left: all leading whitespace will be removed
        /// -	right: all trailing whitespace will be removed.
        ///</summary>
public IValueTag<Enums.EnumInterpretTypeTrim?> Trim => _trim;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("filter", nameof(Filter), _filter, value => _filter = value);
            ParseAttributeTag("trim", nameof(Trim), _trim, value => _trim = value);
        }

        public override Enums.EnumParamInterpretType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretTypeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteType(this);
        }
    }

    internal partial class ParamsParamInterpreteTypeTrim : AttributeTag<Enums.EnumInterpretTypeTrim?>
    {
        internal ParamsParamInterpreteTypeTrim(ProtocolModel model, ProtocolTag parent) : base(model, parent, "trim")
        {
        }

        public override Enums.EnumInterpretTypeTrim? ConvertRawValue(string rawValue)
        {
            return Enums.EnumInterpretTypeTrimConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the length of the command/response.
    ///</summary>
internal partial class ParamsParamLength : ElementTag, IParamsParamLength
    {
        internal ParamsParamLength(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Length")
        {
        }

        private ParamsParamLengthContent _content;
        ///<summary>
        /// Specifies the parameters of the command/response that define the length of the com­mand/response.
        ///</summary>
public IParamsParamLengthContent Content => _content;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamLength(this);
        }
    }

    ///<summary>
    /// Specifies the parameters of the command/response that define the length of the com­mand/response.
    ///</summary>
internal partial class ParamsParamLengthContent : SimpleProtocolListNode<ParamsParamLengthContentParam>, IParamsParamLengthContent
    {
        internal ParamsParamLengthContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content", "Param")
        {
        }

        IParamsParamLengthContentParam IReadOnlyList<IParamsParamLengthContentParam>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamLengthContentParam> IEnumerable<IParamsParamLengthContentParam>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamLengthContent(this);
        }
    }

    ///<summary>
    /// Specifies a parameter of the command/response to be included in the length calculation.
    /// Note: The first parameter of the command/response has ID 0.
    ///</summary>
internal partial class ParamsParamLengthContentParam : ElementValueTag<uint?>, IParamsParamLengthContentParam
    {
        internal ParamsParamLengthContentParam(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Param")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamLengthContentParam(this);
        }
    }

    ///<summary>
    /// If /Protocol/Params/Param/Type is set to "matrix", then this will allow you to define the matrix control. Feature introduced in DataMiner 10.3.1/10.4.0 (RN 34661).
    ///</summary>
internal partial class ParamsParamMatrix : ElementTag, IParamsParamMatrix
    {
        internal ParamsParamMatrix(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Matrix")
        {
        }

        private ParamsParamMatrixInputs _inputs;
        private ParamsParamMatrixOutputs _outputs;
        private ParamsParamMatrixMatrixOptions _matrixOptions;
        ///<summary>
        /// Contains the linking between the inputs table and the matrix control.
        ///</summary>
public IParamsParamMatrixInputs Inputs => _inputs;
        ///<summary>
        /// Contains the linking between the outputs table and the matrix control.
        ///</summary>
public IParamsParamMatrixOutputs Outputs => _outputs;
        ///<summary>
        /// Contains additional options related to how the matrix should behave and look.
        ///</summary>
public IParamsParamMatrixMatrixOptions MatrixOptions => _matrixOptions;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Inputs", nameof(Inputs), _inputs, value => _inputs = value);
            ParseElementTag("Outputs", nameof(Outputs), _outputs, value => _outputs = value);
            ParseElementTag("MatrixOptions", nameof(MatrixOptions), _matrixOptions, value => _matrixOptions = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrix(this);
        }
    }

    ///<summary>
    /// Contains the linking between the inputs table and the matrix control.
    ///</summary>
internal partial class ParamsParamMatrixInputs : ElementTag, IParamsParamMatrixInputs
    {
        internal ParamsParamMatrixInputs(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Inputs")
        {
        }

        private ParamsParamMatrixInputsMappings _mappings;
        private AttributeTag<uint?> _tablePid;
        ///<summary>
        /// Specifies the linking between the columns of the inputs table and the matrix control.
        ///</summary>
public IParamsParamMatrixInputsMappings Mappings => _mappings;
        ///<summary>
        /// Specifies the ID of the inputs table.
        ///</summary>
public IValueTag<uint?> TablePid => _tablePid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("tablePid", nameof(TablePid), _tablePid, value => _tablePid = value);
            ParseElementTag("Mappings", nameof(Mappings), _mappings, value => _mappings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixInputs(this);
        }
    }

    ///<summary>
    /// Specifies the linking between the columns of the inputs table and the matrix control.
    ///</summary>
internal partial class ParamsParamMatrixInputsMappings : SimpleProtocolListNode<ParamsParamMatrixInputsMappingsMapping>, IParamsParamMatrixInputsMappings
    {
        internal ParamsParamMatrixInputsMappings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Mappings", "Mapping")
        {
        }

        IParamsParamMatrixInputsMappingsMapping IReadOnlyList<IParamsParamMatrixInputsMappingsMapping>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamMatrixInputsMappingsMapping> IEnumerable<IParamsParamMatrixInputsMappingsMapping>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixInputsMappings(this);
        }
    }

    ///<summary>
    /// Specifies the link between the column and the matrix column.
    ///</summary>
internal partial class ParamsParamMatrixInputsMappingsMapping : ElementValueTag<string>, IParamsParamMatrixInputsMappingsMapping
    {
        internal ParamsParamMatrixInputsMappingsMapping(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Mapping")
        {
        }

        private ParamsParamMatrixInputsMappingsMappingType _type;
        private ParamsParamMatrixInputsMappingsMappingName _name;
        ///<summary>
        /// Specifies the type of value of the mapping.
        ///</summary>
public IValueTag<Enums.EnumMatrixMappingType?> Type => _type;
        ///<summary>
        /// Specifies the mapping type.
        ///</summary>
public IValueTag<Enums.EnumMatrixInputsMappingNameType?> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixInputsMappingsMapping(this);
        }
    }

    internal partial class ParamsParamMatrixInputsMappingsMappingType : AttributeTag<Enums.EnumMatrixMappingType?>
    {
        internal ParamsParamMatrixInputsMappingsMappingType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumMatrixMappingType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixMappingTypeConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamMatrixInputsMappingsMappingName : AttributeTag<Enums.EnumMatrixInputsMappingNameType?>
    {
        internal ParamsParamMatrixInputsMappingsMappingName(ProtocolModel model, ProtocolTag parent) : base(model, parent, "name")
        {
        }

        public override Enums.EnumMatrixInputsMappingNameType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixInputsMappingNameTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains the linking between the outputs table and the matrix control.
    ///</summary>
internal partial class ParamsParamMatrixOutputs : ElementTag, IParamsParamMatrixOutputs
    {
        internal ParamsParamMatrixOutputs(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Outputs")
        {
        }

        private ParamsParamMatrixOutputsMappings _mappings;
        private AttributeTag<uint?> _tablePid;
        ///<summary>
        /// Specifies the linking between the columns of the outputs table and the matrix control.
        ///</summary>
public IParamsParamMatrixOutputsMappings Mappings => _mappings;
        ///<summary>
        /// Specifies the ID of the outputs table.
        ///</summary>
public IValueTag<uint?> TablePid => _tablePid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("tablePid", nameof(TablePid), _tablePid, value => _tablePid = value);
            ParseElementTag("Mappings", nameof(Mappings), _mappings, value => _mappings = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixOutputs(this);
        }
    }

    ///<summary>
    /// Specifies the linking between the columns of the outputs table and the matrix control.
    ///</summary>
internal partial class ParamsParamMatrixOutputsMappings : SimpleProtocolListNode<ParamsParamMatrixOutputsMappingsMapping>, IParamsParamMatrixOutputsMappings
    {
        internal ParamsParamMatrixOutputsMappings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Mappings", "Mapping")
        {
        }

        IParamsParamMatrixOutputsMappingsMapping IReadOnlyList<IParamsParamMatrixOutputsMappingsMapping>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamMatrixOutputsMappingsMapping> IEnumerable<IParamsParamMatrixOutputsMappingsMapping>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixOutputsMappings(this);
        }
    }

    ///<summary>
    /// Specifies the link between the column and the matrix column.
    ///</summary>
internal partial class ParamsParamMatrixOutputsMappingsMapping : ElementValueTag<string>, IParamsParamMatrixOutputsMappingsMapping
    {
        internal ParamsParamMatrixOutputsMappingsMapping(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Mapping")
        {
        }

        private ParamsParamMatrixOutputsMappingsMappingType _type;
        private ParamsParamMatrixOutputsMappingsMappingName _name;
        ///<summary>
        /// Specifies the type of value of the mapping.
        ///</summary>
public IValueTag<Enums.EnumMatrixMappingType?> Type => _type;
        ///<summary>
        /// Specifies the mapping type.
        ///</summary>
public IValueTag<Enums.EnumMatrixOutputsMappingNameType?> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixOutputsMappingsMapping(this);
        }
    }

    internal partial class ParamsParamMatrixOutputsMappingsMappingType : AttributeTag<Enums.EnumMatrixMappingType?>
    {
        internal ParamsParamMatrixOutputsMappingsMappingType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumMatrixMappingType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixMappingTypeConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamMatrixOutputsMappingsMappingName : AttributeTag<Enums.EnumMatrixOutputsMappingNameType?>
    {
        internal ParamsParamMatrixOutputsMappingsMappingName(ProtocolModel model, ProtocolTag parent) : base(model, parent, "name")
        {
        }

        public override Enums.EnumMatrixOutputsMappingNameType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixOutputsMappingNameTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains additional options related to how the matrix should behave and look.
    ///</summary>
internal partial class ParamsParamMatrixMatrixOptions : SimpleProtocolListNode<ParamsParamMatrixMatrixOptionsMatrixOption>, IParamsParamMatrixMatrixOptions
    {
        internal ParamsParamMatrixMatrixOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "MatrixOptions", "MatrixOption")
        {
        }

        IParamsParamMatrixMatrixOptionsMatrixOption IReadOnlyList<IParamsParamMatrixMatrixOptionsMatrixOption>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamMatrixMatrixOptionsMatrixOption> IEnumerable<IParamsParamMatrixMatrixOptionsMatrixOption>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixMatrixOptions(this);
        }
    }

    ///<summary>
    /// Specifies specific options for the look or behavior of the matrix.
    ///</summary>
internal partial class ParamsParamMatrixMatrixOptionsMatrixOption : ElementValueTag<string>, IParamsParamMatrixMatrixOptionsMatrixOption
    {
        internal ParamsParamMatrixMatrixOptionsMatrixOption(ProtocolModel model, ProtocolTag parent) : base(model, parent, "MatrixOption")
        {
        }

        private ParamsParamMatrixMatrixOptionsMatrixOptionType _type;
        private ParamsParamMatrixMatrixOptionsMatrixOptionName _name;
        ///<summary>
        /// Specifies the type of value of the matrix option.
        ///</summary>
public IValueTag<Enums.EnumMatrixMatrixOptionType?> Type => _type;
        ///<summary>
        /// Specifies the matrix option type.
        ///</summary>
public IValueTag<Enums.EnumMatrixMatrixOptionNameType?> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixMatrixOptionsMatrixOption(this);
        }
    }

    internal partial class ParamsParamMatrixMatrixOptionsMatrixOptionType : AttributeTag<Enums.EnumMatrixMatrixOptionType?>
    {
        internal ParamsParamMatrixMatrixOptionsMatrixOptionType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumMatrixMatrixOptionType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixMatrixOptionTypeConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamMatrixMatrixOptionsMatrixOptionName : AttributeTag<Enums.EnumMatrixMatrixOptionNameType?>
    {
        internal ParamsParamMatrixMatrixOptionsMatrixOptionName(ProtocolModel model, ProtocolTag parent) : base(model, parent, "name")
        {
        }

        public override Enums.EnumMatrixMatrixOptionNameType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixMatrixOptionNameTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies how the parameter has to be displayed on the user interface (depending on the parameter type).
    ///</summary>
internal partial class ParamsParamMeasurement : ElementTag, IParamsParamMeasurement
    {
        internal ParamsParamMeasurement(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Measurement")
        {
        }

        private ParamsParamMeasurementDiscreets _discreets;
        private ElementValueTag<double?> _threshold;
        private ParamsParamMeasurementType _type;
        ///<summary>
        /// Contains the displayed value(s) of the parameter.
        /// For every value, page button or button to be displayed, a separate /Protocol/Params/Param/Measure­ment/Discreets/Discreet element has to be specified.
        /// In Data Display, the values will be displayed in the order in which they are specified in the /Protocol/Params/Param/Measure­ment/Discreets element.
        /// Note: The /Protocol/Params/Param/Measurement/Discreets element only has to be used if /Proto­col/Params/Param/Measurement/Type is set to "discreet", "pagebutton", or "togglebutton".
        ///</summary>
public IParamsParamMeasurementDiscreets Discreets => _discreets;
        ///<summary>
        /// Should only be used in case /Protocol/Params/Param/Measurement/Type is set to "threshold digital".
        /// In some cases, when only two states are allowed (e.g. "On" and "Off") but the parameter value lies within a range of values, a turnover point has to be defined (i.e. when value
        /// "On" is changed to "Off" and vice versa). This turnover point can be defined here. The actual "On" and "Off" values are defined as discrete entries.
        ///</summary>
public IValueTag<double?> Threshold => _threshold;
        ///<summary>
        /// Specifies how the parameter has to be displayed on the user interface.
        /// For more information about the values that can be specified, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IParamsParamMeasurementType Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Discreets", nameof(Discreets), _discreets, value => _discreets = value);
            ParseElementTag("Threshold", nameof(Threshold), _threshold, value => _threshold = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurement(this);
        }
    }

    ///<summary>
    /// Contains the displayed value(s) of the parameter.
    /// For every value, page button or button to be displayed, a separate /Protocol/Params/Param/Measure­ment/Discreets/Discreet element has to be specified.
    /// In Data Display, the values will be displayed in the order in which they are specified in the /Protocol/Params/Param/Measure­ment/Discreets element.
    /// Note: The /Protocol/Params/Param/Measurement/Discreets element only has to be used if /Proto­col/Params/Param/Measurement/Type is set to "discreet", "pagebutton", or "togglebutton".
    ///</summary>
internal partial class ParamsParamMeasurementDiscreets : SimpleProtocolListNode<ParamsParamMeasurementDiscreetsDiscreet>, IParamsParamMeasurementDiscreets
    {
        internal ParamsParamMeasurementDiscreets(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Discreets", "Discreet")
        {
        }

        private AttributeTag<uint?> _dependencyId;
        private AttributeTag<string> _matrixLayout;
        ///<summary>
        /// If the discrete values of the parameter depend on the current state of another parameter, the ID of that other parameter can be specified using this attribute.
        ///</summary>
public IValueTag<uint?> DependencyId => _dependencyId;
        ///<summary>
        /// Configures the layout of the matrix. Default: InputLeftOutputTop.
        ///</summary>
public IValueTag<string> MatrixLayout => _matrixLayout;

        IParamsParamMeasurementDiscreetsDiscreet IReadOnlyList<IParamsParamMeasurementDiscreetsDiscreet>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamMeasurementDiscreetsDiscreet> IEnumerable<IParamsParamMeasurementDiscreetsDiscreet>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("dependencyId", nameof(DependencyId), _dependencyId, value => _dependencyId = value);
            ParseAttributeTag("matrixLayout", nameof(MatrixLayout), _matrixLayout, value => _matrixLayout = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementDiscreets(this);
        }
    }

    ///<summary>
    /// Specifies a value and a text string.
    /// The latter will be displayed on the user interface if the former matches the value of the parameter.
    ///</summary>
internal partial class ParamsParamMeasurementDiscreetsDiscreet : ElementTag, IParamsParamMeasurementDiscreetsDiscreet
    {
        internal ParamsParamMeasurementDiscreetsDiscreet(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Discreet")
        {
        }

        private ParamsParamMeasurementDiscreetsDiscreetDisplay _display;
        private ParamsParamMeasurementDiscreetsDiscreetValue _valueElement;
        private ElementValueTag<string> _tooltip;
        private AttributeTag<string> _dependencyValues;
        private AttributeTag<bool?> _displayIconAndLabel;
        private AttributeTag<string> _export;
        private ParamsParamMeasurementDiscreetsDiscreetIconRef _iconRef;
        private AttributeTag<string> _options;
        ///<summary>
        /// Specifies the string to be displayed when the value of the parameter matches the contents of /Protocol/Params/Param/Measurement/Discreets/Discreet/Value.
        ///</summary>
public IParamsParamMeasurementDiscreetsDiscreetDisplay Display => _display;
        ///<summary>
        /// Specifies the discrete value has to be displayed.
        /// If the value of the parameter matches the value in this element, the contents of ../Discreet/Display will be displayed.
        ///</summary>
public IParamsParamMeasurementDiscreetsDiscreetValue ValueElement => _valueElement;
        ///<summary>
        /// Specifies the tooltip to be displayed when the mouse pointer hovers over the icon displayed in a table cell containing the discrete parameter value to which it is linked.
        ///</summary>
public IValueTag<string> Tooltip => _tooltip;
        ///<summary>
        /// When the parameter depends on the current value of another parameter, the dependencyValues attribute can be used to specify whether or not the discreet value
        /// should be available. If the other parameter has one of the values specified in the attribute, the discreet will be displayed, otherwise it will not. In case of a ContextMenu parameter (of which the name is identical to that of the table with “_ContextMenu” suffix), the dependencyValues will first ask the user to enter the value of each parameter specified in this attribute.
        ///</summary>
public IValueTag<string> DependencyValues => _dependencyValues;
        ///<summary>
        /// Specifies whether to show only the icon (false) or to show the icon together with the display value of the discrete entry (true). Default: false.
        /// Feature introduced in DataMiner 9.5.7.
        ///</summary>
public IValueTag<bool?> DisplayIconAndLabel => _displayIconAndLabel;
        ///<summary>
        /// Specifies the parameter values that have to be exported.
        ///</summary>
public IValueTag<string> Export => _export;
        ///<summary>
        /// Specifies the key of the icon as defined in the Icons.xml file.
        /// Using this attribute in a column parameter of a table will display an icon in the tree control.
        /// 
        ///</summary>
public IValueTag<Enums.EnumIcons?> IconRef => _iconRef;
        ///<summary>
        /// Specifies the options to be used. Refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> Options => _options;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("dependencyValues", nameof(DependencyValues), _dependencyValues, value => _dependencyValues = value);
            ParseAttributeTag("displayIconAndLabel", nameof(DisplayIconAndLabel), _displayIconAndLabel, value => _displayIconAndLabel = value);
            ParseAttributeTag("export", nameof(Export), _export, value => _export = value);
            ParseAttributeTag("iconRef", nameof(IconRef), _iconRef, value => _iconRef = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
            ParseElementTag("Tooltip", nameof(Tooltip), _tooltip, value => _tooltip = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementDiscreetsDiscreet(this);
        }
    }

    ///<summary>
    /// Specifies the string to be displayed when the value of the parameter matches the contents of /Protocol/Params/Param/Measurement/Discreets/Discreet/Value.
    ///</summary>
internal partial class ParamsParamMeasurementDiscreetsDiscreetDisplay : ElementValueTag<string>, IParamsParamMeasurementDiscreetsDiscreetDisplay
    {
        internal ParamsParamMeasurementDiscreetsDiscreetDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Display")
        {
        }

        private ParamsParamMeasurementDiscreetsDiscreetDisplayState _state;
        ///<summary>
        /// When /Protocol/Params/Param/Interprete/Exceptions/Exception is used the same state needs to be placed in the write parameter.
        ///</summary>
public IValueTag<Enums.EnumDisplayState?> State => _state;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("state", nameof(State), _state, value => _state = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementDiscreetsDiscreetDisplay(this);
        }
    }

    internal partial class ParamsParamMeasurementDiscreetsDiscreetDisplayState : AttributeTag<Enums.EnumDisplayState?>
    {
        internal ParamsParamMeasurementDiscreetsDiscreetDisplayState(ProtocolModel model, ProtocolTag parent) : base(model, parent, "state")
        {
        }

        public override Enums.EnumDisplayState? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDisplayStateConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the discrete value has to be displayed.
    /// If the value of the parameter matches the value in this element, the contents of ../Discreet/Display will be displayed.
    ///</summary>
internal partial class ParamsParamMeasurementDiscreetsDiscreetValue : ElementValueTag<string>, IParamsParamMeasurementDiscreetsDiscreetValue
    {
        internal ParamsParamMeasurementDiscreetsDiscreetValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        private AttributeTag<string> _location;
        private ParamsParamMeasurementDiscreetsDiscreetValueType _type;
        ///<summary>
        /// If type is “dll”, the location of the DLL file.
        ///</summary>
public IValueTag<string> Location => _location;
        ///<summary>
        /// Specifies the type.
        ///</summary>
public IValueTag<Enums.EnumDiscreteValue?> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("location", nameof(Location), _location, value => _location = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementDiscreetsDiscreetValue(this);
        }
    }

    internal partial class ParamsParamMeasurementDiscreetsDiscreetValueType : AttributeTag<Enums.EnumDiscreteValue?>
    {
        internal ParamsParamMeasurementDiscreetsDiscreetValueType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumDiscreteValue? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDiscreteValueConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamMeasurementDiscreetsDiscreetIconRef : AttributeTag<Enums.EnumIcons?>
    {
        internal ParamsParamMeasurementDiscreetsDiscreetIconRef(ProtocolModel model, ProtocolTag parent) : base(model, parent, "iconRef")
        {
        }

        public override Enums.EnumIcons? ConvertRawValue(string rawValue)
        {
            return Enums.EnumIconsConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies how the parameter has to be displayed on the user interface.
    /// For more information about the values that can be specified, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
internal partial class ParamsParamMeasurementType : ElementValueTag<Enums.EnumParamMeasurementType?>, IParamsParamMeasurementType
    {
        internal ParamsParamMeasurementType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private ParamsParamMeasurementTypeCase _case;
        private ParamsParamMeasurementTypeContinuous _continuous;
        private AttributeTag<bool?> _hex;
        private AttributeTag<uint?> _lines;
        private AttributeTag<string> _link;
        private AttributeTag<string> _number;
        private AttributeTag<string> _options;
        private ParamsParamMeasurementTypeScientificNotation _scientificNotation;
        private AttributeTag<decimal?> _verificationDeviation;
        private AttributeTag<uint?> _width;
        ///<summary>
        /// Specifies the casing to be used. Only to be specified in case of measurement type "string":
        /// -	upper: upper case
        /// -	lower: lower case
        ///</summary>
public IValueTag<Enums.EnumParamMeasurementTypeCase?> Case => _case;
        ///<summary>
        /// Only to be specified in case of measurement type "string":
        /// -	On
        /// -	Off
        ///</summary>
public IValueTag<Enums.EnumOnOff?> Continuous => _continuous;
        ///<summary>
        /// Specifies whether the parameter value should be displayed as a hexadecimal number.
        ///</summary>
public IValueTag<bool?> Hex => _hex;
        ///<summary>
        /// Specifies the number of lines that will be displayed. Only to be specified in case of measurement type "string".
        ///</summary>
public IValueTag<uint?> Lines => _lines;
        ///<summary>
        /// Specifies the file name in which the input and output labels are stored. Only to be specified in case of measurement type "matrix".
        ///</summary>
public IValueTag<string> Link => _link;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> Number => _number;
        ///<summary>
        /// The options that can be specified in this attribute depend on the specified measurement type.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        /// If you specify multiple options, separate these by semi-colons (";").
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the scientific notation to be used.
        ///</summary>
public IValueTag<Enums.EnumScientificNotation?> ScientificNotation => _scientificNotation;
        ///<summary>
        /// Specifies a deviation on analog parameters.
        ///</summary>
public IValueTag<decimal?> VerificationDeviation => _verificationDeviation;
        ///<summary>
        /// Specifies the width of a (page) button. Only to be specified in case of measurement types "pagebutton" or "button".
        ///</summary>
public IValueTag<uint?> Width => _width;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("case", nameof(Case), _case, value => _case = value);
            ParseAttributeTag("continuous", nameof(Continuous), _continuous, value => _continuous = value);
            ParseAttributeTag("hex", nameof(Hex), _hex, value => _hex = value);
            ParseAttributeTag("lines", nameof(Lines), _lines, value => _lines = value);
            ParseAttributeTag("link", nameof(Link), _link, value => _link = value);
            ParseAttributeTag("number", nameof(Number), _number, value => _number = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("scientificNotation", nameof(ScientificNotation), _scientificNotation, value => _scientificNotation = value);
            ParseAttributeTag("verificationDeviation", nameof(VerificationDeviation), _verificationDeviation, value => _verificationDeviation = value);
            ParseAttributeTag("width", nameof(Width), _width, value => _width = value);
        }

        public override Enums.EnumParamMeasurementType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamMeasurementTypeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementType(this);
        }
    }

    internal partial class ParamsParamMeasurementTypeCase : AttributeTag<Enums.EnumParamMeasurementTypeCase?>
    {
        internal ParamsParamMeasurementTypeCase(ProtocolModel model, ProtocolTag parent) : base(model, parent, "case")
        {
        }

        public override Enums.EnumParamMeasurementTypeCase? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamMeasurementTypeCaseConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamMeasurementTypeContinuous : AttributeTag<Enums.EnumOnOff?>
    {
        internal ParamsParamMeasurementTypeContinuous(ProtocolModel model, ProtocolTag parent) : base(model, parent, "continuous")
        {
        }

        public override Enums.EnumOnOff? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOnOffConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamMeasurementTypeScientificNotation : AttributeTag<Enums.EnumScientificNotation?>
    {
        internal ParamsParamMeasurementTypeScientificNotation(ProtocolModel model, ProtocolTag parent) : base(model, parent, "scientificNotation")
        {
        }

        public override Enums.EnumScientificNotation? ConvertRawValue(string rawValue)
        {
            return Enums.EnumScientificNotationConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains the links between parameters of a base protocol and parameters of this protocol.
    ///</summary>
internal partial class ParamsParamMediation : SimpleProtocolListNode<ParamsParamMediationLinkTo>, IParamsParamMediation
    {
        internal ParamsParamMediation(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Mediation", "LinkTo")
        {
        }

        IParamsParamMediationLinkTo IReadOnlyList<IParamsParamMediationLinkTo>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamMediationLinkTo> IEnumerable<IParamsParamMediationLinkTo>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMediation(this);
        }
    }

    ///<summary>
    /// Defines a link between a parameter of a base protocol and a parameter of this protocol.
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
internal partial class ParamsParamMediationLinkTo : SimpleProtocolListNode<ParamsParamMediationLinkToValueMapping>, IParamsParamMediationLinkTo
    {
        internal ParamsParamMediationLinkTo(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LinkTo", "ValueMapping")
        {
        }

        private AttributeTag<string> _description;
        private AttributeTag<string> _ops;
        private AttributeTag<uint?> _pid;
        private AttributeTag<string> _protocol;
        ///<summary>
        /// Allows to provide a description about the defined link.
        ///</summary>
public IValueTag<string> Description => _description;
        ///<summary>
        /// Specifies one or more conversion operations separated by semicolons (";").
        /// Supported operations:
        /// *: factor
        /// /: division
        /// -: minus
        /// +: offset
        /// %: remainder
        /// Example: &lt;LinkTo pid="176" protocol="Philips DVS3810" ops="*:1024;+:5" /&gt;
        ///</summary>
public IValueTag<string> Ops => _ops;
        ///<summary>
        /// Specifies the ID of the parameter this parameter is linked to.
        ///</summary>
public IValueTag<uint?> Pid => _pid;
        ///<summary>
        /// Specifies the name of the protocol that holds the parameter to which this parameter is linked.
        ///</summary>
public IValueTag<string> Protocol => _protocol;

        IParamsParamMediationLinkToValueMapping IReadOnlyList<IParamsParamMediationLinkToValueMapping>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamMediationLinkToValueMapping> IEnumerable<IParamsParamMediationLinkToValueMapping>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("description", nameof(Description), _description, value => _description = value);
            ParseAttributeTag("ops", nameof(Ops), _ops, value => _ops = value);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
            ParseAttributeTag("protocol", nameof(Protocol), _protocol, value => _protocol = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMediationLinkTo(this);
        }
    }

    ///<summary>
    /// Defines a value mapping.
    ///</summary>
internal partial class ParamsParamMediationLinkToValueMapping : ElementTag, IParamsParamMediationLinkToValueMapping
    {
        internal ParamsParamMediationLinkToValueMapping(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ValueMapping")
        {
        }

        private AttributeTag<string> _remoteValue;
        private AttributeTag<string> _valueAttribute;
        ///<summary>
        /// Specifies the value in the other protocol.
        ///</summary>
public IValueTag<string> RemoteValue => _remoteValue;
        ///<summary>
        /// Specifies the value in the current protocol.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("remoteValue", nameof(RemoteValue), _remoteValue, value => _remoteValue = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMediationLinkToValueMapping(this);
        }
    }

    ///<summary>
    /// Used to replicate specific parameters from another element.
    ///</summary>
internal partial class ParamsParamReplication : ElementTag, IParamsParamReplication
    {
        internal ParamsParamReplication(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Replication")
        {
        }

        private ParamsParamReplicationElement _element;
        private ParamsParamReplicationParameter _parameter;
        private AttributeTag<string> _ip;
        private AttributeTag<string> _uid;
        private AttributeTag<string> _pwd;
        private AttributeTag<string> _domain;
        ///<summary>
        /// Specifies the DataMiner Agent ID/element ID of the replicated element.
        ///</summary>
public IParamsParamReplicationElement Element => _element;
        ///<summary>
        /// Specifies the ID of the parameter that has to be replicated.
        ///</summary>
public IParamsParamReplicationParameter Parameter => _parameter;
        ///<summary>
        /// Specifies the IP address of the DataMiner Agent on which the element is located.
        ///</summary>
public IValueTag<string> Ip => _ip;
        ///<summary>
        /// Specifies the user name to log on to the DataMiner Agent on which the element is located.
        ///</summary>
public IValueTag<string> Uid => _uid;
        ///<summary>
        /// Specifies the password to log on to the DataMiner Agent on which the element is located.
        ///</summary>
public IValueTag<string> Pwd => _pwd;
        ///<summary>
        /// Specifies the domain containing the DataMiner Agent on which the element is located..
        ///</summary>
public IValueTag<string> Domain => _domain;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("ip", nameof(Ip), _ip, value => _ip = value);
            ParseAttributeTag("uid", nameof(Uid), _uid, value => _uid = value);
            ParseAttributeTag("pwd", nameof(Pwd), _pwd, value => _pwd = value);
            ParseAttributeTag("domain", nameof(Domain), _domain, value => _domain = value);
            ParseElementTag("Element", nameof(Element), _element, value => _element = value);
            ParseElementTag("Parameter", nameof(Parameter), _parameter, value => _parameter = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamReplication(this);
        }
    }

    ///<summary>
    /// Specifies the DataMiner Agent ID/element ID of the replicated element.
    ///</summary>
internal partial class ParamsParamReplicationElement : ElementValueTag<string>, IParamsParamReplicationElement
    {
        internal ParamsParamReplicationElement(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Element")
        {
        }

        private AttributeTag<uint?> _dynamic;
        ///<summary>
        /// Specifies the ID of the parameter that holds the element ID (DMA ID/element ID) of the element from which the parameter should be replicated. Feature introduced in DataMiner 9.6.1 (RN 19311).
        ///</summary>
public IValueTag<uint?> Dynamic => _dynamic;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("dynamic", nameof(Dynamic), _dynamic, value => _dynamic = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamReplicationElement(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the parameter that has to be replicated.
    ///</summary>
internal partial class ParamsParamReplicationParameter : ElementValueTag<string>, IParamsParamReplicationParameter
    {
        internal ParamsParamReplicationParameter(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Parameter")
        {
        }

        private AttributeTag<uint?> _dynamic;
        ///<summary>
        /// Specifies the ID of the parameter that holds the ID of the parameter that should be replicated. Feature introduced in DataMiner 9.6.1 (RN 19311).
        ///</summary>
public IValueTag<uint?> Dynamic => _dynamic;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("dynamic", nameof(Dynamic), _dynamic, value => _dynamic = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamReplicationParameter(this);
        }
    }

    ///<summary>
    /// Specifies SNMP related functionality for this parameter.
    /// Only used in protocols for elements that are SNMP-compliant. In case of such an element, DataMiner will interrogate the SNMP agent specified in /Proto­col/Params/Param/SNMP/OID or capture traps defined in /Protocol/Params/Param/SNMP/TrapOID.
    ///</summary>
internal partial class ParamsParamSNMP : ElementTag, IParamsParamSNMP
    {
        internal ParamsParamSNMP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SNMP")
        {
        }

        private ElementValueTag<bool?> _enabled;
        private ElementValueTag<uint?> _factor;
        private ParamsParamSNMPInvalidResponseHandling _invalidResponseHandling;
        private ParamsParamSNMPOID _oID;
        private ParamsParamSNMPTrapMappings _trapMappings;
        private ParamsParamSNMPTrapOID _trapOID;
        private ParamsParamSNMPType _type;
        private AttributeTag<string> _options;
        ///<summary>
        /// Specifies whether DataMiner is allowed to interrogate the SNMP Agent.
        ///</summary>
public IValueTag<bool?> Enabled => _enabled;
        ///<summary>
        /// Specifies that all values will be divided by the specified factor. By default, SNMP does not support decimal values. In a DataMiner protocol, however, you can use this Factor element to produce decimal values.
        /// If you specify a factor, all values will be divided by that factor.
        /// Default factor: 1
        ///</summary>
public IValueTag<uint?> Factor => _factor;
        ///<summary>
        /// Specifies the invalid response handling strategy.
        ///</summary>
public IParamsParamSNMPInvalidResponseHandling InvalidResponseHandling => _invalidResponseHandling;
        ///<summary>
        /// Specifies the OID.
        ///</summary>
public IParamsParamSNMPOID OID => _oID;
        ///<summary>
        /// Specifies trap mappings. Use this if the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute is too limited.
        /// If you want to make more advanced Alarm mappings, add one or more /Protocol/Params/Param/SNMP/Trap­Mappings/TrapMapping elements to this TrapMappings element.
        /// Note that it is possible to combine the TrapMappings element with the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute.
        ///</summary>
public IParamsParamSNMPTrapMappings TrapMappings => _trapMappings;
        ///<summary>
        /// Specifies the SNMP traps DataMiner has to capture via this parameter.
        ///</summary>
public IParamsParamSNMPTrapOID TrapOID => _trapOID;
        ///<summary>
        /// Specifies the SNMP type.
        ///</summary>
public IValueTag<Enums.EnumSNMPType?> Type => _type;
        ///<summary>
        /// Use this attribute to change the community get or the community set string for a particular connection.
        /// Specify 'GetCommunity:' or 'SetCommunity:', followed by the connection. Example: options="GetCommunity:0"
        ///</summary>
public IValueTag<string> Options => _options;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseElementTag("Enabled", nameof(Enabled), _enabled, value => _enabled = value);
            ParseElementTag("Factor", nameof(Factor), _factor, value => _factor = value);
            ParseElementTag("InvalidResponseHandling", nameof(InvalidResponseHandling), _invalidResponseHandling, value => _invalidResponseHandling = value);
            ParseElementTag("OID", nameof(OID), _oID, value => _oID = value);
            ParseElementTag("TrapMappings", nameof(TrapMappings), _trapMappings, value => _trapMappings = value);
            ParseElementTag("TrapOID", nameof(TrapOID), _trapOID, value => _trapOID = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMP(this);
        }
    }

    ///<summary>
    /// Specifies the invalid response handling strategy.
    ///</summary>
internal partial class ParamsParamSNMPInvalidResponseHandling : ElementTag, IParamsParamSNMPInvalidResponseHandling
    {
        internal ParamsParamSNMPInvalidResponseHandling(ProtocolModel model, ProtocolTag parent) : base(model, parent, "InvalidResponseHandling")
        {
        }

        private ElementValueTag<string> _infiniteLoop;
        ///<summary>
        /// Specifies the response handling in case an infinite loop was detected when polling a table.
        ///</summary>
public IValueTag<string> InfiniteLoop => _infiniteLoop;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("InfiniteLoop", nameof(InfiniteLoop), _infiniteLoop, value => _infiniteLoop = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPInvalidResponseHandling(this);
        }
    }

    ///<summary>
    /// Specifies the OID.
    ///</summary>
internal partial class ParamsParamSNMPOID : ElementValueTag<string>, IParamsParamSNMPOID
    {
        internal ParamsParamSNMPOID(ProtocolModel model, ProtocolTag parent) : base(model, parent, "OID")
        {
        }

        private AttributeTag<uint?> _id;
        private AttributeTag<uint?> _ipid;
        private AttributeTag<string> _options;
        private AttributeTag<bool?> _skipDynamicSNMPGet;
        private ParamsParamSNMPOIDType _type;
        ///<summary>
        /// Specifies the ID of the parameter holding the (partial) OID.
        /// The OID (or a part of it) can be made variable. To do so, replace the variable part of the OID by an asterisk (*), and specify the ID of the parameter holding (part of) the OID in the id attribute.
        /// In case of options=subtable, “id” has to contain the ID of the parameter holding the instance filter for the table.
        /// 
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies the ID of the parameter holding the IP address that needs to be used to poll this SNMP parameter.
        ///</summary>
public IValueTag<uint?> Ipid => _ipid;
        ///<summary>
        /// Specifies some options.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies that the evaluation of a certain parameter is skipped if it needs to be retrieved via a dynamic SNMP Get.
        ///</summary>
public IValueTag<bool?> SkipDynamicSNMPGet => _skipDynamicSNMPGet;
        ///<summary>
        /// Specifies how the OID is constructed.
        /// For more information refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<Enums.EnumOIDType?> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("ipid", nameof(Ipid), _ipid, value => _ipid = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("skipDynamicSNMPGet", nameof(SkipDynamicSNMPGet), _skipDynamicSNMPGet, value => _skipDynamicSNMPGet = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPOID(this);
        }
    }

    internal partial class ParamsParamSNMPOIDType : AttributeTag<Enums.EnumOIDType?>
    {
        internal ParamsParamSNMPOIDType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumOIDType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOIDTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies trap mappings. Use this if the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute is too limited.
    /// If you want to make more advanced Alarm mappings, add one or more /Protocol/Params/Param/SNMP/Trap­Mappings/TrapMapping elements to this TrapMappings element.
    /// Note that it is possible to combine the TrapMappings element with the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute.
    ///</summary>
internal partial class ParamsParamSNMPTrapMappings : SimpleProtocolListNode<ParamsParamSNMPTrapMappingsTrapMapping>, IParamsParamSNMPTrapMappings
    {
        internal ParamsParamSNMPTrapMappings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TrapMappings", "TrapMapping")
        {
        }

        IParamsParamSNMPTrapMappingsTrapMapping IReadOnlyList<IParamsParamSNMPTrapMappingsTrapMapping>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IParamsParamSNMPTrapMappingsTrapMapping> IEnumerable<IParamsParamSNMPTrapMappingsTrapMapping>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPTrapMappings(this);
        }
    }

    ///<summary>
    /// Specifies a trap mapping. When a trap is received, all TrapMapping elements will be evaluated top down. When a TrapMapping element matches the incoming trap, the severity
    /// and/or the value specified in that mapping will be kept in memory. As soon as both the severity and the value are known, the search will stop and the alarm will be generated.
    /// At the end of the list of /Protocol/Params/Param/SNMP/TrapMappings/TrapMapping elements, you can add a TrapMapping element in which you specify a wildcard. In the event that severity or value still
    /// cannot be determined, the method with the mapAlarm attribute on the /Protocol/Params/Param/SNMP/TrapOID element will be executed in order to try to determine the severity and value.
    ///</summary>
internal partial class ParamsParamSNMPTrapMappingsTrapMapping : ElementTag, IParamsParamSNMPTrapMappingsTrapMapping
    {
        internal ParamsParamSNMPTrapMappingsTrapMapping(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TrapMapping")
        {
        }

        private AttributeTag<string> _bindingMatch;
        private AttributeTag<string> _severity;
        private AttributeTag<string> _valueAttribute;
        ///<summary>
        /// Specifies one or more values for a specific binding.
        /// This attribute consists of two parts, separated by a colon:
        /// -	The number of the binding, and
        /// -	A pipe-separated enumeration of values you want to compare to the value of the binding.
        /// Note: Wildcards are allowed.
        ///</summary>
public IValueTag<string> BindingMatch => _bindingMatch;
        ///<summary>
        /// Specifies a DataMiner severity level.
        /// Instead, you can also specify "NoAlarm" (or "NoTrap") to indicate that no Alarm should be generated.
        /// Note: The severity level information will always overwrite previously assigned severity levels.
        ///</summary>
public IValueTag<string> Severity => _severity;
        ///<summary>
        /// This attribute contains an alarm value, specified in the same way as the alarm value in the mapAlarm attribute of the /Protocol/Params/Param/SNMP/TrapOID element.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("bindingMatch", nameof(BindingMatch), _bindingMatch, value => _bindingMatch = value);
            ParseAttributeTag("severity", nameof(Severity), _severity, value => _severity = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPTrapMappingsTrapMapping(this);
        }
    }

    ///<summary>
    /// Specifies the SNMP traps DataMiner has to capture via this parameter.
    ///</summary>
internal partial class ParamsParamSNMPTrapOID : ElementValueTag<string>, IParamsParamSNMPTrapOID
    {
        internal ParamsParamSNMPTrapOID(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TrapOID")
        {
        }

        private AttributeTag<string> _checkBindings;
        private AttributeTag<string> _ipid;
        private AttributeTag<string> _mapAlarm;
        private AttributeTag<string> _setBindings;
        private ParamsParamSNMPTrapOIDType _type;
        ///<summary>
        /// Specifies basic filtering on the trap bindings.
        /// You can compare a certain binding to a fixed string (which optionally contains wildcards), or you can compare it to the value of another parameter.
        /// Checks must be separated by pipe characters.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> CheckBindings => _checkBindings;
        ///<summary>
        /// Specifies the ID of the parameter holding IP addresses.
        /// By default, only the traps received from the polling IP address of an element will be captured. However, using the ipid attribute, you can point to a parameter that contains another IP address.
        /// If you use the ipid attribute, only traps received from the IP address found in the parameter referenced by the ipid attribute will be captured. Traps originating from the polling IP address will be disregarded.
        ///</summary>
public IValueTag<string> Ipid => _ipid;
        ///<summary>
        /// Allows an alarm to be generated when a trap is received.
        /// - The first part must be "true" or "false", to enable or disable the mapping of alarms.
        /// - The order of the following items (separated by pipe characters) is irrelevant: Severity, Value, Link, IgnoreSingleClear
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> MapAlarm => _mapAlarm;
        ///<summary>
        /// Specifies that the value of a certain binding should be set as the value of another parameter.
        /// Use this attribute to take the value of a certain binding and immediately set (copy) it to another parameter.
        /// Set pairs have to be separated by semi-colons. Every set pair consists of a binding position (1-based) containing the value to be set and the ID of the parameter to set,
        /// separated by a comma. If you want to set a dynamic table parameter, you can add more items to the set pair (which will then be concatenated with a "." to build an index).
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> SetBindings => _setBindings;
        ///<summary>
        /// Specifies how the OID is constructed.
        /// For more information refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<Enums.EnumTrapOIDType?> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("checkBindings", nameof(CheckBindings), _checkBindings, value => _checkBindings = value);
            ParseAttributeTag("ipid", nameof(Ipid), _ipid, value => _ipid = value);
            ParseAttributeTag("mapAlarm", nameof(MapAlarm), _mapAlarm, value => _mapAlarm = value);
            ParseAttributeTag("setBindings", nameof(SetBindings), _setBindings, value => _setBindings = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPTrapOID(this);
        }
    }

    internal partial class ParamsParamSNMPTrapOIDType : AttributeTag<Enums.EnumTrapOIDType?>
    {
        internal ParamsParamSNMPTrapOIDType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumTrapOIDType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTrapOIDTypeConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamSNMPType : ElementValueTag<Enums.EnumSNMPType?>
    {
        internal ParamsParamSNMPType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        public override Enums.EnumSNMPType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumSNMPTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the parameter type.
    /// For more information about the different types, refer to the DataMiner Protocol Markup Language documentation.
    /// Parameters of type "elementid", "elementname", "elementdmaid" and "dataminer info" are the first parameters that are loaded by a protocol. Although they hold information, they cannot, as such,
    /// be displayed in Element Display. Therefore, for these types of parameters, always set /Protocol/Params/Param/Display/RTDisplay "false".
    /// If you do want to display the information in one of these parameters in Element Display, there is a workaround: create another parameter of type "read", and copy the value from its invisible parameter to this new parameter after protocol start-up. You can then display the "read" parameter in Element Display.
    ///</summary>
internal partial class ParamsParamType : ElementValueTag<Enums.EnumParamType?>, IParamsParamType
    {
        internal ParamsParamType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private AttributeTag<string> _alarmRegistration;
        private AttributeTag<string> _distribution;
        private AttributeTag<string> _dynamicSnmpGet;
        private AttributeTag<string> _id;
        private AttributeTag<string> _options;
        private ParamsParamTypeRelativeTimers _relativeTimers;
        private AttributeTag<uint?> _times;
        private AttributeTag<string> _virtual;
        ///<summary>
        /// Allows to trigger a QAction when specific parameters go into alarm.
        ///</summary>
public IValueTag<string> AlarmRegistration => _alarmRegistration;
        ///<summary>
        /// This attribute is used in situations in which elements of a certain type are linked to each-other as parent and child.
        /// By using data distribution, you can prevent data from being retrieved more than once, and also make sure that the data in your master and child are the same.
        /// In a protocol, these data distribution parameters can be defined in either a fixed or a dynamic way.
        /// To use data distribution, you have to add the "distribution" attribute to a Parameter in your master element. This parameter can be a "simple" parameter, or a column parameter from a table.
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> Distribution => _distribution;
        ///<summary>
        /// Specifies what to retrieve (cell, row, etc.) and the way this request is added to the group execution queue.
        ///</summary>
public IValueTag<string> DynamicSnmpGet => _dynamicSnmpGet;
        ///<summary>
        /// If Type is "read bit" or "response", this attribute specifies the ID of the parameter or response to which to refer, respectively.
        ///</summary>
public IValueTag<string> Id => _id;
        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";").
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// In this attribute, you can specify "true" or "true with reset".
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<Enums.EnumProtocolTypeRelativeTimers?> RelativeTimers => _relativeTimers;
        ///<summary>
        /// If Type is "trailer", use this attribute to indicate how many times the trailer is allowed to occur before it is considered to be the trailer.
        ///</summary>
public IValueTag<uint?> Times => _times;
        ///<summary>
        /// Configures which virtual element connections are allowed to and from elements based on the protocol you are creating.
        /// You can specify multiple connection restraints, separated by a pipe character ("|").
        /// A connection restraint has the following format (building blocks separated by ":")
        /// -	keyword "source" or "destination",
        /// -	optionally followed by one or more Protocol definitions ("Protocol=...") and one or more parameter descriptions ("Parameterdescription=...").
        ///</summary>
public IValueTag<string> Virtual => _virtual;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("alarmRegistration", nameof(AlarmRegistration), _alarmRegistration, value => _alarmRegistration = value);
            ParseAttributeTag("distribution", nameof(Distribution), _distribution, value => _distribution = value);
            ParseAttributeTag("dynamicSnmpGet", nameof(DynamicSnmpGet), _dynamicSnmpGet, value => _dynamicSnmpGet = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("relativeTimers", nameof(RelativeTimers), _relativeTimers, value => _relativeTimers = value);
            ParseAttributeTag("times", nameof(Times), _times, value => _times = value);
            ParseAttributeTag("virtual", nameof(Virtual), _virtual, value => _virtual = value);
        }

        public override Enums.EnumParamType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamTypeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamType(this);
        }
    }

    internal partial class ParamsParamTypeRelativeTimers : AttributeTag<Enums.EnumProtocolTypeRelativeTimers?>
    {
        internal ParamsParamTypeRelativeTimers(ProtocolModel model, ProtocolTag parent) : base(model, parent, "relativeTimers")
        {
        }

        public override Enums.EnumProtocolTypeRelativeTimers? ConvertRawValue(string rawValue)
        {
            return Enums.EnumProtocolTypeRelativeTimersConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class ParamsParamConfirmPopup : AttributeTag<Enums.EnumParamConfirmPopup?>
    {
        internal ParamsParamConfirmPopup(ProtocolModel model, ProtocolTag parent) : base(model, parent, "confirmPopup")
        {
        }

        public override Enums.EnumParamConfirmPopup? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamConfirmPopupConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// For every protocol, you have to specify its type in /Protocol/Type, and its port settings in /Protocol/Portsettings.
    /// In case of a multi-type protocol, the /Protocol/Type@advanced attribute is used to any additional protocol types.
    /// The port settings for those additional protocol types then have to be specified in a /Protocol/Ports/Portsettings element in which the name attribute contains the name of the additional type as specified in the /Protocol/Type@advanced attribute.
    ///</summary>
internal partial class Ports : SimpleProtocolListNode<PortSettings>, IPorts
    {
        internal Ports(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Ports", "PortSettings")
        {
        }

        IPortSettings IReadOnlyList<IPortSettings>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettings> IEnumerable<IPortSettings>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPorts(this);
        }
    }

    internal partial class ProcessAutomation : ElementTag, IProcessAutomation
    {
        internal ProcessAutomation(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ProcessAutomation")
        {
        }

        private ProcessAutomationProcessAutomationOptions _processAutomationOptions;
        ///<summary>
        /// Additional options for the Process Automation Queue.
        ///</summary>
public IProcessAutomationProcessAutomationOptions ProcessAutomationOptions => _processAutomationOptions;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("ProcessAutomationOptions", nameof(ProcessAutomationOptions), _processAutomationOptions, value => _processAutomationOptions = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProcessAutomation(this);
        }
    }

    ///<summary>
    /// Additional options for the Process Automation Queue.
    ///</summary>
internal partial class ProcessAutomationProcessAutomationOptions : SimpleProtocolListNode<ProcessAutomationProcessAutomationOptionsProcessAutomationOption>, IProcessAutomationProcessAutomationOptions
    {
        internal ProcessAutomationProcessAutomationOptions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ProcessAutomationOptions", "ProcessAutomationOption")
        {
        }

        IProcessAutomationProcessAutomationOptionsProcessAutomationOption IReadOnlyList<IProcessAutomationProcessAutomationOptionsProcessAutomationOption>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IProcessAutomationProcessAutomationOptionsProcessAutomationOption> IEnumerable<IProcessAutomationProcessAutomationOptionsProcessAutomationOption>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProcessAutomationProcessAutomationOptions(this);
        }
    }

    ///<summary>
    /// The additional options for the Process Automation Queue.
    ///</summary>
internal partial class ProcessAutomationProcessAutomationOptionsProcessAutomationOption : ElementTag, IProcessAutomationProcessAutomationOptionsProcessAutomationOption
    {
        internal ProcessAutomationProcessAutomationOptionsProcessAutomationOption(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ProcessAutomationOption")
        {
        }

        private AttributeTag<string> _name;
        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Name of the option.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Parameter ID of the parameter that will contain the option value.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProcessAutomationProcessAutomationOptionsProcessAutomationOption(this);
        }
    }

    ///<summary>
    /// Contains all the QActions defined in the protocol.
    /// A QAction (i.e. Quick Action) is a script that can be executed when a parameter or a row changes. Inside a QAction, the following scripting languages can be used:
    /// -	JScript
    /// -	VBScript
    /// -	C#
    ///</summary>
internal partial class QActions : SimpleProtocolListNode<QActionsQAction>, IQActions
    {
        internal QActions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "QActions", "QAction")
        {
        }

        IQActionsQAction IReadOnlyList<IQActionsQAction>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IQActionsQAction> IEnumerable<IQActionsQAction>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitQActions(this);
        }
    }

    ///<summary>
    /// A QAction is a script that can be executed when a parameter or a row has changed.
    /// The actual script code of a QAction must be placed inside a CDATA section.
    /// By placing code inside a CDATA section, characters like "&lt;" and "&amp;", which are normally illegal when placed inside normal XML elements, will no longer be considered as such.
    /// In order to interact with SLProtocol (e.g. to access parameters or to notify DataMiner of certain events)
    /// - in JScript or VBScript code, use the SLScript object
    /// - in C# code, use the Skyline.DataMiner.Scripting namespace
    /// For information on how to use C# in protocols, refer to the appendices of the DaaMiner Protocol Development Guide.
    ///</summary>
internal partial class QActionsQAction : ElementValueTag<string>, IQActionsQAction
    {
        internal QActionsQAction(ProtocolModel model, ProtocolTag parent) : base(model, parent, "QAction")
        {
        }

        private ElementValueTag<string> _condition;
        private AttributeTag<string> _dllImport;
        private QActionsQActionEncoding _encoding;
        private AttributeTag<string> _entryPoint;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _include;
        private AttributeTag<string> _inputParameters;
        private AttributeTag<string> _name;
        private AttributeTag<string> _options;
        private AttributeTag<bool?> _row;
        private AttributeTag<string> _triggers;
        ///<summary>
        /// Specifies a condition that must be met in order for the QAction to execute.
        ///</summary>
public IValueTag<string> Condition => _condition;
        ///<summary>
        /// Specifies external DLL files used by the QAction.
        /// Multiple values have to be separated by semi-colons (";").
        /// System DLL files must be stored in the system dll directory; all other DLL files must be stored in the C:\Skyline DataMiner\ProtocolScripts directory.
        /// Note: The following DLL files do not have to be specified in this dllImport attribute. They are loaded by default.
        /// -	System.dll
        /// -	SLManagedScripting.dll
        /// -	Interop.sldms.dll
        ///</summary>
public IValueTag<string> DllImport => _dllImport;
        ///<summary>
        /// Specifies the language in which the script has been written:
        /// -	JScript
        /// -	VBScript
        /// -	CSharp
        /// (case insensitive)
        ///</summary>
public IValueTag<Enums.EnumQActionEncoding?> Encoding => _encoding;
        ///<summary>
        /// Defines the entry point method(s) corresponding with the parameter(s) triggering the QAction execution.
        ///</summary>
public IValueTag<string> EntryPoint => _entryPoint;
        ///<summary>
        /// Specifies the unique QAction ID.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies the name of the external script to be executed.
        ///</summary>
public IValueTag<string> Include => _include;
        ///<summary>
        /// Specifies the IDs of the parameters that will be passed to functions inside the QAction script.
        /// Multiple values have to be separated by semi-colons (";").
        ///</summary>
public IValueTag<string> InputParameters => _inputParameters;
        ///<summary>
        /// Specifies the name of the QAction.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies a number of options (multiple options can be separated by semicolons (';'). Possible options:
        /// - binary: If specified, all values in “inputParameters” are forwarded to the QAction as a byte array holding the raw content of the parameter.
        /// - debug: Compiles the QAction in debug mode.
        /// - dllName=name: With this option, the specified name will be included in the DLL name. The name of the DLL will be as follows: [ProtocolName].[ProtocolVersion].[name].dll.
        /// - queued: The QAction will be executed asynchronously. This implies that the QAction is triggered and set in the background. Be careful when using this option and make sure to also implement thread synchronization when this QAction is called more than once.
        /// - group: When this option is specified, the "OldRow()" method will return the values retrieved by that group. This option can be used in case of high-volume polling. Use it with care.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// If "true", the QAction will be executed when a row of a table has changed.
        ///</summary>
public IValueTag<bool?> Row => _row;
        ///<summary>
        /// Specifies the IDs of the parameters that will cause the QAction to be executed each time their value changes.
        /// Multiple values have to be separated by semi-colons (";").
        ///</summary>
public IValueTag<string> Triggers => _triggers;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("dllImport", nameof(DllImport), _dllImport, value => _dllImport = value);
            ParseAttributeTag("encoding", nameof(Encoding), _encoding, value => _encoding = value);
            ParseAttributeTag("entryPoint", nameof(EntryPoint), _entryPoint, value => _entryPoint = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("include", nameof(Include), _include, value => _include = value);
            ParseAttributeTag("inputParameters", nameof(InputParameters), _inputParameters, value => _inputParameters = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("row", nameof(Row), _row, value => _row = value);
            ParseAttributeTag("triggers", nameof(Triggers), _triggers, value => _triggers = value);
            ParseElementTag("Condition", nameof(Condition), _condition, value => _condition = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitQActionsQAction(this);
        }
    }

    internal partial class QActionsQActionEncoding : AttributeTag<Enums.EnumQActionEncoding?>
    {
        internal QActionsQActionEncoding(ProtocolModel model, ProtocolTag parent) : base(model, parent, "encoding")
        {
        }

        public override Enums.EnumQActionEncoding? ConvertRawValue(string rawValue)
        {
            return Enums.EnumQActionEncodingConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Configures Root Cause Analysis (RCA).
    ///</summary>
internal partial class RCA : ElementTag, IRCA
    {
        internal RCA(ProtocolModel model, ProtocolTag parent) : base(model, parent, "RCA")
        {
        }

        private RCAProtocol _protocol;
        ///<summary>
        /// *** No documentation available yet. ***
        ///</summary>
public IRCAProtocol Protocol => _protocol;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Protocol", nameof(Protocol), _protocol, value => _protocol = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRCA(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet. ***
    ///</summary>
internal partial class RCAProtocol : SimpleProtocolListNode<RCAProtocolLink>, IRCAProtocol
    {
        internal RCAProtocol(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Protocol", "Link")
        {
        }

        IRCAProtocolLink IReadOnlyList<IRCAProtocolLink>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IRCAProtocolLink> IEnumerable<IRCAProtocolLink>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRCAProtocol(this);
        }
    }

    ///<summary>
    /// Defines an RCA chain by defining relations.
    ///</summary>
internal partial class RCAProtocolLink : ElementTag, IRCAProtocolLink
    {
        internal RCAProtocolLink(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Link")
        {
        }

        private AttributeTag<string> _distribute;
        private AttributeTag<string> _path;
        private AttributeTag<string> _valueFilter;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> Distribute => _distribute;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> Path => _path;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> ValueFilter => _valueFilter;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("distribute", nameof(Distribute), _distribute, value => _distribute = value);
            ParseAttributeTag("path", nameof(Path), _path, value => _path = value);
            ParseAttributeTag("valueFilter", nameof(ValueFilter), _valueFilter, value => _valueFilter = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRCAProtocolLink(this);
        }
    }

    ///<summary>
    /// Defines relations between tables.
    ///</summary>
internal partial class Relations : SimpleProtocolListNode<RelationsRelation>, IRelations
    {
        internal Relations(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Relations", "Relation")
        {
        }

        IRelationsRelation IReadOnlyList<IRelationsRelation>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IRelationsRelation> IEnumerable<IRelationsRelation>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRelations(this);
        }
    }

    ///<summary>
    /// Defines a relation between tables.
    ///</summary>
internal partial class RelationsRelation : ElementTag, IRelationsRelation
    {
        internal RelationsRelation(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Relation")
        {
        }

        private AttributeTag<string> _options;
        private AttributeTag<string> _path;
        private AttributeTag<string> _name;
        ///<summary>
        /// Defines a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the IDs of the tables that are linked to each other.
        ///</summary>
public IValueTag<string> Path => _path;
        ///<summary>
        /// Specifies the name of the relation.
        ///</summary>
public IValueTag<string> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("path", nameof(Path), _path, value => _path = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRelationsRelation(this);
        }
    }

    ///<summary>
    /// Contains all responses defined in the protocol.
    ///</summary>
internal partial class Responses : SimpleProtocolListNode<ResponsesResponse>, IResponses
    {
        internal Responses(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Responses", "Response")
        {
        }

        IResponsesResponse IReadOnlyList<IResponsesResponse>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IResponsesResponse> IEnumerable<IResponsesResponse>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitResponses(this);
        }
    }

    ///<summary>
    /// Specifies a response that DataMiner can expect after having sent a specific command to the device.
    /// Similar to a command, a response is a collection of parameters that describe the message that the device is expected to send back to DataMiner after having received a command.
    /// When it receives a response from the device, DataMiner will compare that response to the response definition specified in /Protocol/Responses/Response. If the response does not match
    /// the definition, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has occurred. The log files of the device will contain
    /// more detailed information. If the response still does not match, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
    /// will skip the command, and move to the next one.
    /// Note: By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device in System Display or DataMiner Cube.
    ///</summary>
internal partial class ResponsesResponse : ElementTag, IResponsesResponse
    {
        internal ResponsesResponse(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Response")
        {
        }

        private ResponsesResponseContent _content;
        private ElementValueTag<string> _description;
        private ElementValueTag<string> _name;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _options;
        ///<summary>
        /// Specifies the consecutive parameters that together form the response that is expected from the device.
        ///</summary>
public IResponsesResponseContent Content => _content;
        ///<summary>
        /// Specifies a textual description of the response.
        ///</summary>
public IValueTag<string> Description => _description;
        ///<summary>
        /// Specifies the name of the response. Often, the response will have the same name as the command with which it is associated.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies the unique response ID.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Defines a number of options. Possible values:
        /// - Connection: This option allows you to specify the ID of the connection (in case of multiple ports). Adding the connection ID at response level is only done in protocols of type "smart serial".
        ///</summary>
public IValueTag<string> Options => _options;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
            ParseElementTag("Description", nameof(Description), _description, value => _description = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitResponsesResponse(this);
        }
    }

    ///<summary>
    /// Specifies the consecutive parameters that together form the response that is expected from the device.
    ///</summary>
internal partial class ResponsesResponseContent : SimpleProtocolListNode<ResponsesResponseContentParam>, IResponsesResponseContent
    {
        internal ResponsesResponseContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content", "Param")
        {
        }

        private AttributeTag<string> _optional;
        ///<summary>
        /// Specifies that no error will occur if they are not found in the response received from the device.
        /// Parameters included in a response definition can be marked as optional. This means, that no error will occur if they are not found in the response received from the device.
        /// If a parameter matches, DataMiner will simply go on to the next parameter and check that one.
        /// If an optional parameter does not match, the following special characters can be included in the "optional" attribute of the /Protocol/Responses/Response element to tell DataMiner what to do:
        /// +: tells DataMiner to skip the next parameter. Multiple "+" characters can be entered to have several parameters skipped.
        /// *: tells DataMiner to skip the parameters in the response until it reaches the next optional parameter.
        ///</summary>
public IValueTag<string> Optional => _optional;

        IResponsesResponseContentParam IReadOnlyList<IResponsesResponseContentParam>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IResponsesResponseContentParam> IEnumerable<IResponsesResponseContentParam>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("optional", nameof(Optional), _optional, value => _optional = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitResponsesResponseContent(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the parameter that you want to include in the response.
    ///</summary>
internal partial class ResponsesResponseContentParam : ElementValueTag<uint?>, IResponsesResponseContentParam
    {
        internal ResponsesResponseContentParam(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Param")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitResponsesResponseContentParam(this);
        }
    }

    ///<summary>
    /// Used to pass alarm severities to linked tables.
    ///</summary>
internal partial class SeverityBubbleUp : SimpleProtocolListNode<SeverityBubbleUpPath>, ISeverityBubbleUp
    {
        internal SeverityBubbleUp(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SeverityBubbleUp", "Path")
        {
        }

        ISeverityBubbleUpPath IReadOnlyList<ISeverityBubbleUpPath>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ISeverityBubbleUpPath> IEnumerable<ISeverityBubbleUpPath>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSeverityBubbleUp(this);
        }
    }

    ///<summary>
    /// Specifies the table path that needs to be followed when passing alarm severities.
    ///</summary>
internal partial class SeverityBubbleUpPath : ElementValueTag<string>, ISeverityBubbleUpPath
    {
        internal SeverityBubbleUpPath(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Path")
        {
        }

        private AttributeTag<uint?> _statePid;
        ///<summary>
        /// Refers to a parameter that indicates whether the bubble-up path is disabled or enabled.
        /// The referred parameter must have 0 and 1 as possible values.
        /// While the element is running, if the parameter value is set to 0, the bubble-up path will be disabled.
        /// If the parameter value is set to 1, the bubble-up path will be enabled.
        /// If this attribute is absent, the bubble-up path will be enabled by default.
        /// Feature introduced in DataMiner 9.5.3 (RN 15103, RN 15843).
        /// 
        ///</summary>
public IValueTag<uint?> StatePid => _statePid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("statePid", nameof(StatePid), _statePid, value => _statePid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSeverityBubbleUpPath(this);
        }
    }

    ///<summary>
    /// Specifies how the MIB file for the protocol will be created.
    ///</summary>
internal partial class SNMP : ElementValueTag<Enums.EnumSNMP?>, ISNMP
    {
        internal SNMP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SNMP")
        {
        }

        private AttributeTag<bool?> _includepages;
        ///<summary>
        /// If "true", the MIB of the protocol will contain several submaps: one for each page defined in the protocol.
        /// Example: When a number of parameters are placed on a page called "General", the MIB will automatically create a submap named "General", which will contain all the parameters on that page.
        ///</summary>
public IValueTag<bool?> Includepages => _includepages;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("includepages", nameof(Includepages), _includepages, value => _includepages = value);
        }

        public override Enums.EnumSNMP? ConvertRawValue(string rawValue)
        {
            return Enums.EnumSNMPConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSNMP(this);
        }
    }

    ///<summary>
    /// Specifies additional threads that will be used by the protocol. This allows you to separate time-critical actions from device-polling actions. Use with caution.
    ///</summary>
internal partial class Threads : SimpleProtocolListNode<ThreadsThread>, IThreads
    {
        internal Threads(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Threads", "Thread")
        {
        }

        IThreadsThread IReadOnlyList<IThreadsThread>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IThreadsThread> IEnumerable<IThreadsThread>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitThreads(this);
        }
    }

    ///<summary>
    /// Defines an additional thread. This will allow you to e.g. separate time-critical actions from device-polling actions.
    /// Each additional thread you create, has its own protocol group execution queue as well as its own run-time error thread registration.
    /// Note: The main protocol group execution queue will always be active, no matter how many additional threads you create.
    ///</summary>
internal partial class ThreadsThread : ElementTag, IThreadsThread
    {
        internal ThreadsThread(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Thread")
        {
        }

        private AttributeTag<string> _connection;
        ///<summary>
        /// When you create an additional thread, you have to link it to a particular connection.
        /// This can be either a real connection or a virtual connection. All groups linked to that connection will then be executed on that thread.
        /// In the connection attribute, you can specify a single connection ID or a comma-separated list of multiple connection IDs in case you want to combine a number of connections into one single thread).
        ///</summary>
public IValueTag<string> Connection => _connection;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("connection", nameof(Connection), _connection, value => _connection = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitThreadsThread(this);
        }
    }

    ///<summary>
    /// Contains all timers defined in the protocol.
    /// Timers are used to configure recurring events (group execution, device polling, ...). Basically, a timer defines the interval between two consecutive executions of a given event.
    /// By default, the interval specified in a timer is a fixed interval. However, in the protocol, you can make the interval dynamic.
    /// The interval can be modified by changing the value of the [Timer base] Parameter (ID: 65017). The value of this parameter is the factor by which the interval time is multiplied.
    /// So "1" means the original interval, "2" means twice as slow, "0.5" means twice as fast, etc.
    ///</summary>
internal partial class Timers : SimpleProtocolListNode<TimersTimer>, ITimers
    {
        internal Timers(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Timers", "Timer")
        {
        }

        private AttributeTag<bool?> _relativeTimers;
        public IValueTag<bool?> RelativeTimers => _relativeTimers;

        ITimersTimer IReadOnlyList<ITimersTimer>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITimersTimer> IEnumerable<ITimersTimer>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("relativeTimers", nameof(RelativeTimers), _relativeTimers, value => _relativeTimers = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimers(this);
        }
    }

    ///<summary>
    /// Specifies which groups have to be executed, and when.
    /// It is recommended to define multiple timers. That way, you can separate the important groups (which will be polled more frequently) from the less important groups
    /// (which will be polled less frequently).
    ///</summary>
internal partial class TimersTimer : ElementTag, ITimersTimer
    {
        internal TimersTimer(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Timer")
        {
        }

        private ElementValueTag<string> _condition;
        private ElementValueTag<string> _name;
        private TimersTimerContent _content;
        private ElementValueTag<uint?> _interval;
        private TimersTimerTime _time;
        private AttributeTag<uint?> _id;
        private AttributeTag<bool?> _fixedTimer;
        private AttributeTag<string> _options;
        ///<summary>
        /// Specifies a condition that must be met in order for the timer to execute. Note: Avoid using conditions on timers.
        ///</summary>
public IValueTag<string> Condition => _condition;
        ///<summary>
        /// Specifies the timer name.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Contains all the groups that have to be executed when the timer is triggered.
        /// Important: Do not include too much groups in one timer.
        ///</summary>
public ITimersTimerContent Content => _content;
        ///<summary>
        /// Specifies the interval (in milliseconds) between two consecutive executions of groups within a timer and also between two consecutive pairs within a timer group.
        ///</summary>
public IValueTag<uint?> Interval => _interval;
        ///<summary>
        /// Specifies how frequently the included groups will be executed.
        /// If you enter "loop", the included groups will be executed over and over again.
        /// If you enter an integer value &gt; 0, the included groups will be executed every X milliseconds.
        ///</summary>
public ITimersTimerTime Time => _time;
        ///<summary>
        /// Specifies the unique timer ID.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// If, in case of a relative-timer protocol, this attribute is set to "true", the user will not be able to change the interval.
        /// See also: The /Protocol/Type@relativeTimers attribute.
        ///</summary>
public IValueTag<bool?> FixedTimer => _fixedTimer;
        ///<summary>
        /// Specifies a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        /// 
        ///</summary>
public IValueTag<string> Options => _options;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("fixedTimer", nameof(FixedTimer), _fixedTimer, value => _fixedTimer = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseElementTag("Condition", nameof(Condition), _condition, value => _condition = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
            ParseElementTag("Interval", nameof(Interval), _interval, value => _interval = value);
            ParseElementTag("Time", nameof(Time), _time, value => _time = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimersTimer(this);
        }
    }

    ///<summary>
    /// Contains all the groups that have to be executed when the timer is triggered.
    /// Important: Do not include too much groups in one timer.
    ///</summary>
internal partial class TimersTimerContent : SimpleProtocolListNode<TimersTimerContentGroup>, ITimersTimerContent
    {
        internal TimersTimerContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content", "Group")
        {
        }

        ITimersTimerContentGroup IReadOnlyList<ITimersTimerContentGroup>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITimersTimerContentGroup> IEnumerable<ITimersTimerContentGroup>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimersTimerContent(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the group to be included.
    ///</summary>
internal partial class TimersTimerContentGroup : ElementValueTag<string>, ITimersTimerContentGroup
    {
        internal TimersTimerContentGroup(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Group")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimersTimerContentGroup(this);
        }
    }

    ///<summary>
    /// Specifies how frequently the included groups will be executed.
    /// If you enter "loop", the included groups will be executed over and over again.
    /// If you enter an integer value &gt; 0, the included groups will be executed every X milliseconds.
    ///</summary>
internal partial class TimersTimerTime : ElementValueTag<string>, ITimersTimerTime
    {
        internal TimersTimerTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Time")
        {
        }

        private AttributeTag<uint?> _dataDisplay;
        private AttributeTag<string> _initial;
        ///<summary>
        /// Specifies the execution frequency of the included groups when a Data Display has been opened.
        /// It is good practice to set this interval to 30000 (30 seconds).
        /// Note: If you set this attribute to "loop", the included groups will be executed as frequently as possible.
        /// In some cases, this can affect overall DataMiner performance.
        ///</summary>
public IValueTag<uint?> DataDisplay => _dataDisplay;
        ///<summary>
        /// Specifies whether the timer should be started when the element is started.
        /// - true: the timer will be started when the element is started.
        /// - false: the timer will not be started when the element is started. This allows you to dynamically start the timer by performing an action.
        /// - random=startvalue:endvalue : the timer will be started a random number of seconds after the start of the element. The random value will be a value between startvalue and endvalue.
        /// E.g. random=0:300
        /// By default, this attribute is omitted. As a consequence, the groups will be executed the moment the element is started.
        ///</summary>
public IValueTag<string> Initial => _initial;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("dataDisplay", nameof(DataDisplay), _dataDisplay, value => _dataDisplay = value);
            ParseAttributeTag("initial", nameof(Initial), _initial, value => _initial = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimersTimerTime(this);
        }
    }

    ///<summary>
    /// Groups topologies defined in the protocol.
    ///</summary>
internal partial class Topologies : SimpleProtocolListNode<TopologiesTopology>, ITopologies
    {
        internal Topologies(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Topologies", "Topology")
        {
        }

        ITopologiesTopology IReadOnlyList<ITopologiesTopology>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITopologiesTopology> IEnumerable<ITopologiesTopology>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologies(this);
        }
    }

    ///<summary>
    /// Defines a topology. In this element, you can specify several Cell elements, each representing a cell in the diagram displayed in the CPE Manager.
    ///</summary>
internal partial class TopologiesTopology : SimpleProtocolListNode<TopologiesTopologyCell>, ITopologiesTopology
    {
        internal TopologiesTopology(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Topology", "Cell")
        {
        }

        private AttributeTag<string> _name;
        ///<summary>
        /// Specifies the name of the topology (Service Overview Manager only).
        ///</summary>
public IValueTag<string> Name => _name;

        ITopologiesTopologyCell IReadOnlyList<ITopologiesTopologyCell>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITopologiesTopologyCell> IEnumerable<ITopologiesTopologyCell>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopology(this);
        }
    }

    ///<summary>
    /// Specifies a cell within a CPE topology.
    ///</summary>
internal partial class TopologiesTopologyCell : SimpleProtocolListNode<TypeTopologyCellLink>, ITopologiesTopologyCell
    {
        internal TopologiesTopologyCell(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Cell", "Link")
        {
        }

        private TopologiesTopologyCellExposer _exposer;
        private AttributeTag<string> _detailColumns;
        private AttributeTag<string> _listColumns;
        private AttributeTag<string> _name;
        private AttributeTag<string> _options;
        private AttributeTag<string> _table;
        ///<summary>
        /// Exposes this cell to the CPE crawler.
        ///</summary>
public ITopologiesTopologyCellExposer Exposer => _exposer;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> DetailColumns => _detailColumns;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> ListColumns => _listColumns;
        ///<summary>
        /// Specifies the name of the cell.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies a number of options (Deprecated).
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the table parameter to which the cell is linked.
        ///</summary>
public IValueTag<string> Table => _table;

        ITypeTopologyCellLink IReadOnlyList<ITypeTopologyCellLink>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeTopologyCellLink> IEnumerable<ITypeTopologyCellLink>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("detailColumns", nameof(DetailColumns), _detailColumns, value => _detailColumns = value);
            ParseAttributeTag("listColumns", nameof(ListColumns), _listColumns, value => _listColumns = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("table", nameof(Table), _table, value => _table = value);
            ParseElementTag("Exposer", nameof(Exposer), _exposer, value => _exposer = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopologyCell(this);
        }
    }

    ///<summary>
    /// Exposes this cell to the CPE crawler.
    ///</summary>
internal partial class TopologiesTopologyCellExposer : ElementTag, ITopologiesTopologyCellExposer
    {
        internal TopologiesTopologyCellExposer(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Exposer")
        {
        }

        private TopologiesTopologyCellExposerLinkedIds _linkedIds;
        private AttributeTag<bool?> _enabled;
        ///<summary>
        /// Specifies the linked tables.
        ///</summary>
public ITopologiesTopologyCellExposerLinkedIds LinkedIds => _linkedIds;
        ///<summary>
        /// Specifies whether the exposer is enabled.
        ///</summary>
public IValueTag<bool?> Enabled => _enabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("enabled", nameof(Enabled), _enabled, value => _enabled = value);
            ParseElementTag("LinkedIds", nameof(LinkedIds), _linkedIds, value => _linkedIds = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopologyCellExposer(this);
        }
    }

    ///<summary>
    /// Specifies the linked tables.
    ///</summary>
internal partial class TopologiesTopologyCellExposerLinkedIds : SimpleProtocolListNode<TopologiesTopologyCellExposerLinkedIdsLinkedId>, ITopologiesTopologyCellExposerLinkedIds
    {
        internal TopologiesTopologyCellExposerLinkedIds(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LinkedIds", "LinkedId")
        {
        }

        ITopologiesTopologyCellExposerLinkedIdsLinkedId IReadOnlyList<ITopologiesTopologyCellExposerLinkedIdsLinkedId>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITopologiesTopologyCellExposerLinkedIdsLinkedId> IEnumerable<ITopologiesTopologyCellExposerLinkedIdsLinkedId>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopologyCellExposerLinkedIds(this);
        }
    }

    ///<summary>
    /// Specifies the table parameter ID of the linked table.
    ///</summary>
internal partial class TopologiesTopologyCellExposerLinkedIdsLinkedId : ElementValueTag<int?>, ITopologiesTopologyCellExposerLinkedIdsLinkedId
    {
        internal TopologiesTopologyCellExposerLinkedIdsLinkedId(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LinkedId")
        {
        }

        private AttributeTag<int?> _columnPid;
        ///<summary>
        /// Specifies the ID of the column parameter that is used to link the specified table.
        ///</summary>
public IValueTag<int?> ColumnPid => _columnPid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("columnPid", nameof(ColumnPid), _columnPid, value => _columnPid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopologyCellExposerLinkedIdsLinkedId(this);
        }
    }

    ///<summary>
    /// Contains all the tree controls defined in the protocol.
    ///</summary>
internal partial class TreeControls : SimpleProtocolListNode<TreeControlsTreeControl>, ITreeControls
    {
        internal TreeControls(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TreeControls", "TreeControl")
        {
        }

        ITreeControlsTreeControl IReadOnlyList<ITreeControlsTreeControl>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITreeControlsTreeControl> IEnumerable<ITreeControlsTreeControl>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControls(this);
        }
    }

    ///<summary>
    /// Defines a tree control.
    ///</summary>
internal partial class TreeControlsTreeControl : ElementTag, ITreeControlsTreeControl
    {
        internal TreeControlsTreeControl(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TreeControl")
        {
        }

        private TreeControlsTreeControlExtraDetails _extraDetails;
        private TreeControlsTreeControlExtraTabs _extraTabs;
        private ElementValueTag<string> _hiddenColumns;
        private TreeControlsTreeControlHierarchy _hierarchy;
        private ElementValueTag<string> _readonlyColumns;
        private ElementValueTag<string> _overrideDisplayColumns;
        private ElementValueTag<string> _overrideIconColumns;
        private AttributeTag<uint?> _parameterId;
        private AttributeTag<bool?> _readOnly;
        ///<summary>
        /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
        ///</summary>
public ITreeControlsTreeControlExtraDetails ExtraDetails => _extraDetails;
        ///<summary>
        /// Contains additional tab definitions in the tree control.
        ///</summary>
public ITreeControlsTreeControlExtraTabs ExtraTabs => _extraTabs;
        ///<summary>
        /// Specifies the columns to be hidden.
        ///</summary>
public IValueTag<string> HiddenColumns => _hiddenColumns;
        ///<summary>
        /// Defines the relationship between the (visible) tables.
        /// Rows from these tables will become items in the tree.
        ///</summary>
public ITreeControlsTreeControlHierarchy Hierarchy => _hierarchy;
        ///<summary>
        /// Used to hide write controls for certain table columns.
        ///</summary>
public IValueTag<string> ReadonlyColumns => _readonlyColumns;
        ///<summary>
        /// Used to override the display key or the index of a row by a different column of the same table.
        ///</summary>
public IValueTag<string> OverrideDisplayColumns => _overrideDisplayColumns;
        ///<summary>
        /// By specifying a column in this element, you can apply a custom icon based on a cell value in a row.
        /// The column must be a parameter of type Discreet and all discreet values must have an IconRef referring to an icon. If not, a default icon will be displayed.
        ///</summary>
public IValueTag<string> OverrideIconColumns => _overrideIconColumns;
        ///<summary>
        /// Specifies the parameter ID of the tree control.
        ///</summary>
public IValueTag<uint?> ParameterId => _parameterId;
        ///<summary>
        /// If set to "true", disables all the write parameters in the tree control. Default: false.
        ///</summary>
public IValueTag<bool?> ReadOnly => _readOnly;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("parameterId", nameof(ParameterId), _parameterId, value => _parameterId = value);
            ParseAttributeTag("readOnly", nameof(ReadOnly), _readOnly, value => _readOnly = value);
            ParseElementTag("ExtraDetails", nameof(ExtraDetails), _extraDetails, value => _extraDetails = value);
            ParseElementTag("ExtraTabs", nameof(ExtraTabs), _extraTabs, value => _extraTabs = value);
            ParseElementTag("HiddenColumns", nameof(HiddenColumns), _hiddenColumns, value => _hiddenColumns = value);
            ParseElementTag("Hierarchy", nameof(Hierarchy), _hierarchy, value => _hierarchy = value);
            ParseElementTag("ReadonlyColumns", nameof(ReadonlyColumns), _readonlyColumns, value => _readonlyColumns = value);
            ParseElementTag("OverrideDisplayColumns", nameof(OverrideDisplayColumns), _overrideDisplayColumns, value => _overrideDisplayColumns = value);
            ParseElementTag("OverrideIconColumns", nameof(OverrideIconColumns), _overrideIconColumns, value => _overrideIconColumns = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControl(this);
        }
    }

    ///<summary>
    /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
    ///</summary>
internal partial class TreeControlsTreeControlExtraDetails : SimpleProtocolListNode<TreeControlsTreeControlExtraDetailsLinkedDetails>, ITreeControlsTreeControlExtraDetails
    {
        internal TreeControlsTreeControlExtraDetails(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ExtraDetails", "LinkedDetails")
        {
        }

        ITreeControlsTreeControlExtraDetailsLinkedDetails IReadOnlyList<ITreeControlsTreeControlExtraDetailsLinkedDetails>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITreeControlsTreeControlExtraDetailsLinkedDetails> IEnumerable<ITreeControlsTreeControlExtraDetailsLinkedDetails>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlExtraDetails(this);
        }
    }

    ///<summary>
    /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
    ///</summary>
internal partial class TreeControlsTreeControlExtraDetailsLinkedDetails : ElementTag, ITreeControlsTreeControlExtraDetailsLinkedDetails
    {
        internal TreeControlsTreeControlExtraDetailsLinkedDetails(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LinkedDetails")
        {
        }

        private AttributeTag<uint?> _detailsTableId;
        private AttributeTag<uint?> _discreetColumnId;
        private AttributeTag<string> _valueAttribute;
        ///<summary>
        /// Specifies the parameter ID of the table containing the additional information.
        /// If this table has multiple foreign keys, a foreign key column ID can be specified instead.
        ///</summary>
public IValueTag<uint?> DetailsTableId => _detailsTableId;
        ///<summary>
        /// Specifies a column in the main table.
        /// This must be a parameter of type Discreet. The value of this column determines from which other table(s) additional information can be retrieved.
        /// 
        ///</summary>
public IValueTag<uint?> DiscreetColumnId => _discreetColumnId;
        ///<summary>
        /// Specifies one of the possible discrete values.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("detailsTableId", nameof(DetailsTableId), _detailsTableId, value => _detailsTableId = value);
            ParseAttributeTag("discreetColumnId", nameof(DiscreetColumnId), _discreetColumnId, value => _discreetColumnId = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlExtraDetailsLinkedDetails(this);
        }
    }

    ///<summary>
    /// Contains additional tab definitions in the tree control.
    ///</summary>
internal partial class TreeControlsTreeControlExtraTabs : SimpleProtocolListNode<TreeControlsTreeControlExtraTabsTab>, ITreeControlsTreeControlExtraTabs
    {
        internal TreeControlsTreeControlExtraTabs(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ExtraTabs", "Tab")
        {
        }

        ITreeControlsTreeControlExtraTabsTab IReadOnlyList<ITreeControlsTreeControlExtraTabsTab>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITreeControlsTreeControlExtraTabsTab> IEnumerable<ITreeControlsTreeControlExtraTabsTab>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlExtraTabs(this);
        }
    }

    ///<summary>
    /// Defines an additional tab.
    ///</summary>
internal partial class TreeControlsTreeControlExtraTabsTab : ElementTag, ITreeControlsTreeControlExtraTabsTab
    {
        internal TreeControlsTreeControlExtraTabsTab(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Tab")
        {
        }

        private AttributeTag<string> _parameter;
        private AttributeTag<uint?> _tableId;
        private AttributeTag<string> _title;
        private AttributeTag<string> _type;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> Parameter => _parameter;
        ///<summary>
        /// Specifies the ID of the table this additional tab configuration relates to.
        ///</summary>
public IValueTag<uint?> TableId => _tableId;
        ///<summary>
        /// Specifies the title description of the tab.
        ///</summary>
public IValueTag<string> Title => _title;
        ///<summary>
        /// Specifies the tab type.
        ///</summary>
public IValueTag<string> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("parameter", nameof(Parameter), _parameter, value => _parameter = value);
            ParseAttributeTag("tableId", nameof(TableId), _tableId, value => _tableId = value);
            ParseAttributeTag("title", nameof(Title), _title, value => _title = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlExtraTabsTab(this);
        }
    }

    ///<summary>
    /// Defines the relationship between the (visible) tables.
    /// Rows from these tables will become items in the tree.
    ///</summary>
internal partial class TreeControlsTreeControlHierarchy : SimpleProtocolListNode<TreeControlsTreeControlHierarchyTable>, ITreeControlsTreeControlHierarchy
    {
        internal TreeControlsTreeControlHierarchy(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Hierarchy", "Table")
        {
        }

        private AttributeTag<string> _path;
        ///<summary>
        /// When no advanced hierarchy is needed, you can use this attribute to define the table links using a comma-separated list.
        ///</summary>
public IValueTag<string> Path => _path;

        ITreeControlsTreeControlHierarchyTable IReadOnlyList<ITreeControlsTreeControlHierarchyTable>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITreeControlsTreeControlHierarchyTable> IEnumerable<ITreeControlsTreeControlHierarchyTable>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("path", nameof(Path), _path, value => _path = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlHierarchy(this);
        }
    }

    ///<summary>
    /// Specifies the table links.
    /// When using a more advanced hierarchy, the table links can be defined using Table tags. In the hierarchy, the path attribute must be omitted or empty.
    ///</summary>
internal partial class TreeControlsTreeControlHierarchyTable : ElementTag, ITreeControlsTreeControlHierarchyTable
    {
        internal TreeControlsTreeControlHierarchyTable(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Table")
        {
        }

        private AttributeTag<string> _condition;
        private AttributeTag<uint?> _id;
        private AttributeTag<uint?> _parentAttribute;
        ///<summary>
        /// Specifies a condition.
        ///</summary>
public IValueTag<string> Condition => _condition;
        ///<summary>
        /// Specifies the parameter ID of the table that is needed in the tree.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Specifies the parameter ID of the table that is the parent of the table specified in the id attribute.
        ///</summary>
public IValueTag<uint?> ParentAttribute => _parentAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("condition", nameof(Condition), _condition, value => _condition = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("parent", nameof(ParentAttribute), _parentAttribute, value => _parentAttribute = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlHierarchyTable(this);
        }
    }

    ///<summary>
    /// Contains the triggers defined in the protocol.
    /// In a trigger, you define when it should go off, and which actions it should execute.
    ///</summary>
internal partial class Triggers : SimpleProtocolListNode<TriggersTrigger>, ITriggers
    {
        internal Triggers(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Triggers", "Trigger")
        {
        }

        ITriggersTrigger IReadOnlyList<ITriggersTrigger>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITriggersTrigger> IEnumerable<ITriggersTrigger>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggers(this);
        }
    }

    ///<summary>
    /// Defines a trigger.
    /// Triggers allow you to define the exact moment at which certain actions have to be executed.
    /// They can, for example, be used to set the exact time at which to perform a copy operation, to calculate a CRC, etc.
    ///</summary>
internal partial class TriggersTrigger : ElementTag, ITriggersTrigger
    {
        internal TriggersTrigger(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Trigger")
        {
        }

        private ElementValueTag<string> _condition;
        private TriggersTriggerContent _content;
        private ElementValueTag<string> _name;
        private TriggersTriggerOn _on;
        private TriggersTriggerTime _time;
        private TriggersTriggerType _type;
        private AttributeTag<uint?> _id;
        ///<summary>
        /// Specifies a condition that must be met in order for the trigger to go off.
        ///</summary>
public IValueTag<string> Condition => _condition;
        ///<summary>
        /// Specifies the actions to be executed, or triggers to be activated the moment the trigger goes off.
        /// Recommendation: Do not include more than 10 items tags.
        ///</summary>
public ITriggersTriggerContent Content => _content;
        ///<summary>
        /// Specifies the name of the trigger.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Defines what will set off the trigger. Used together with /Protocol/Triggers/Trigger/Time, which defines the exact moment the trigger has to go off.
        /// This /Protocol/Triggers/Trigger/On element is always used when defining a trigger, except when the trigger has to be activated by another trigger.
        /// In that case, the moment at which the trigger has to go off will already be defined in the initializing trigger. The /Protocol/Triggers/Trigger/Time element will then also be empty.
        ///</summary>
public ITriggersTriggerOn On => _on;
        ///<summary>
        /// Defines, together with /Protocol/Triggers/Trigger/On, the exact moment at which a trigger will go off.
        /// Note: Not all /Protocol/Triggers/Trigger/Time values can be used in combination with the different /Protocol/Trig­gers/Trigger/On types.
        /// Refer to the DataMiner Protocol Markup Language documentatio. for an overview of the possible combinations.
        ///</summary>
public ITriggersTriggerTime Time => _time;
        ///<summary>
        /// Specifies what should happen when the trigger goes off:
        /// - execute one or more actions, or
        /// - activate one or more triggers.
        ///</summary>
public IValueTag<Enums.EnumTriggerType?> Type => _type;
        ///<summary>
        /// Specifies the unique trigger ID.
        ///</summary>
public IValueTag<uint?> Id => _id;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseElementTag("Condition", nameof(Condition), _condition, value => _condition = value);
            ParseElementTag("Content", nameof(Content), _content, value => _content = value);
            ParseElementTag("Name", nameof(Name), _name, value => _name = value);
            ParseElementTag("On", nameof(On), _on, value => _on = value);
            ParseElementTag("Time", nameof(Time), _time, value => _time = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTrigger(this);
        }
    }

    ///<summary>
    /// Specifies the actions to be executed, or triggers to be activated the moment the trigger goes off.
    /// Recommendation: Do not include more than 10 items tags.
    ///</summary>
internal partial class TriggersTriggerContent : SimpleProtocolListNode<TriggersTriggerContentId>, ITriggersTriggerContent
    {
        internal TriggersTriggerContent(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Content", "Id")
        {
        }

        ITriggersTriggerContentId IReadOnlyList<ITriggersTriggerContentId>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITriggersTriggerContentId> IEnumerable<ITriggersTriggerContentId>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTriggerContent(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the action to be executed or the trigger to be activated when the trigger goes off.
    ///</summary>
internal partial class TriggersTriggerContentId : ElementValueTag<uint?>, ITriggersTriggerContentId
    {
        internal TriggersTriggerContentId(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Id")
        {
        }

        private AttributeTag<bool?> _else;
        ///<summary>
        /// When a condition has been added to the trigger, the action of which the ID is specified in this attribute will be executed when the condition is not met.
        ///</summary>
public IValueTag<bool?> Else => _else;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("else", nameof(Else), _else, value => _else = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTriggerContentId(this);
        }
    }

    ///<summary>
    /// Defines what will set off the trigger. Used together with /Protocol/Triggers/Trigger/Time, which defines the exact moment the trigger has to go off.
    /// This /Protocol/Triggers/Trigger/On element is always used when defining a trigger, except when the trigger has to be activated by another trigger.
    /// In that case, the moment at which the trigger has to go off will already be defined in the initializing trigger. The /Protocol/Triggers/Trigger/Time element will then also be empty.
    ///</summary>
internal partial class TriggersTriggerOn : ElementValueTag<Enums.EnumTriggerOn?>, ITriggersTriggerOn
    {
        internal TriggersTriggerOn(ProtocolModel model, ProtocolTag parent) : base(model, parent, "On")
        {
        }

        private AttributeTag<string> _id;
        ///<summary>
        /// Specifies the ID of the parameter, command, response, etc.
        /// If you do not specify an id attribute, the trigger will apply to all items of the type specified in the /Protocol/Triggers/Trigger/On element.
        ///</summary>
public IValueTag<string> Id => _id;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
        }

        public override Enums.EnumTriggerOn? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTriggerOnConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTriggerOn(this);
        }
    }

    ///<summary>
    /// Defines, together with /Protocol/Triggers/Trigger/On, the exact moment at which a trigger will go off.
    /// Note: Not all /Protocol/Triggers/Trigger/Time values can be used in combination with the different /Protocol/Trig­gers/Trigger/On types.
    /// Refer to the DataMiner Protocol Markup Language documentatio. for an overview of the possible combinations.
    ///</summary>
internal partial class TriggersTriggerTime : ElementValueTag<string>, ITriggersTriggerTime
    {
        internal TriggersTriggerTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Time")
        {
        }

        private AttributeTag<string> _case;
        private AttributeTag<uint?> _id;
        private AttributeTag<bool?> _nr;
        private AttributeTag<string> _valueAttribute;
        ///<summary>
        /// Specifies the condition: equal, not equal, greater, less, or a logical combination of those operators.
        ///</summary>
public IValueTag<string> Case => _case;
        ///<summary>
        /// The ID of the parameter, command, response, etc. (defined in /Protocol/Triggers/Trigger/On) of which the value will be checked.
        /// If this attribute is omitted, the ID specified in /Protocol/Triggers/Trigger/On will be taken.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// Set this attribute to "true" if the value attribute contains a parameter ID instead of a parameter value.
        ///</summary>
public IValueTag<bool?> Nr => _nr;
        ///<summary>
        /// Specifies the value that will be used as condition operand.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("case", nameof(Case), _case, value => _case = value);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("nr", nameof(Nr), _nr, value => _nr = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTriggerTime(this);
        }
    }

    internal partial class TriggersTriggerType : ElementValueTag<Enums.EnumTriggerType?>
    {
        internal TriggersTriggerType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        public override Enums.EnumTriggerType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTriggerTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the protocol type. In multi-connection protocols, it specifies the type of the main connection.
    ///</summary>
internal partial class ProtocolType : ElementValueTag<Enums.EnumProtocolType?>, IProtocolType
    {
        internal ProtocolType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private AttributeTag<string> _advanced;
        private AttributeTag<string> _communicationOptions;
        private AttributeTag<string> _databaseOptions;
        private AttributeTag<string> _options;
        private AttributeTag<bool?> _overrideTimeoutDVE;
        private ProtocolTypeRelativeTimers _relativeTimers;
        ///<summary>
        /// Specifies additional connections. This allows you to create e.g. a serial protocol containing some SNMP commands, or a protocol that is capable of communicating with multiple ports.
        /// Protocol types have to be separated by semi-colon (";").
        /// For more information on ports, see:	/Protocol/Ports and /Protocol/Portsettings.
        ///</summary>
public IValueTag<string> Advanced => _advanced;
        ///<summary>
        /// Specifies a number of communication options.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> CommunicationOptions => _communicationOptions;
        ///<summary>
        /// Specifies a number of database options.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> DatabaseOptions => _databaseOptions;
        ///<summary>
        /// Specifies a number of options. For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies whether the DVE will go into timeout when the main element is in timeout.
        ///</summary>
public IValueTag<bool?> OverrideTimeoutDVE => _overrideTimeoutDVE;
        ///<summary>
        /// This attribute can have one of two values:	"true"* and	"true with reset".
        /// *If the /Protocol/Timers/Timer@fixedTimer attribute is also set to "true", then users cannot change the timer interval.
        ///</summary>
public IValueTag<Enums.EnumProtocolTypeRelativeTimers?> RelativeTimers => _relativeTimers;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("advanced", nameof(Advanced), _advanced, value => _advanced = value);
            ParseAttributeTag("communicationOptions", nameof(CommunicationOptions), _communicationOptions, value => _communicationOptions = value);
            ParseAttributeTag("databaseOptions", nameof(DatabaseOptions), _databaseOptions, value => _databaseOptions = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("overrideTimeoutDVE", nameof(OverrideTimeoutDVE), _overrideTimeoutDVE, value => _overrideTimeoutDVE = value);
            ParseAttributeTag("relativeTimers", nameof(RelativeTimers), _relativeTimers, value => _relativeTimers = value);
        }

        public override Enums.EnumProtocolType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumProtocolTypeConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProtocolType(this);
        }
    }

    internal partial class ProtocolTypeRelativeTimers : AttributeTag<Enums.EnumProtocolTypeRelativeTimers?>
    {
        internal ProtocolTypeRelativeTimers(ProtocolModel model, ProtocolTag parent) : base(model, parent, "relativeTimers")
        {
        }

        public override Enums.EnumProtocolTypeRelativeTimers? ConvertRawValue(string rawValue)
        {
            return Enums.EnumProtocolTypeRelativeTimersConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains an overview of the version history of this protocol.
    /// Feature introduced in DataMiner 9.5.11 (RN 17697, RN 18360).
    ///</summary>
internal partial class VersionHistory : ElementTag, IVersionHistory
    {
        internal VersionHistory(ProtocolModel model, ProtocolTag parent) : base(model, parent, "VersionHistory")
        {
        }

        private VersionHistoryBranches _branches;
        ///<summary>
        /// Contains the different branches of this protocol.
        ///</summary>
public IVersionHistoryBranches Branches => _branches;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Branches", nameof(Branches), _branches, value => _branches = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistory(this);
        }
    }

    ///<summary>
    /// Contains the different branches of this protocol.
    ///</summary>
internal partial class VersionHistoryBranches : SimpleProtocolListNode<VersionHistoryBranchesBranch>, IVersionHistoryBranches
    {
        internal VersionHistoryBranches(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Branches", "Branch")
        {
        }

        IVersionHistoryBranchesBranch IReadOnlyList<IVersionHistoryBranchesBranch>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranch> IEnumerable<IVersionHistoryBranchesBranch>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranches(this);
        }
    }

    ///<summary>
    /// Defines a branch of this protocol.
    ///</summary>
internal partial class VersionHistoryBranchesBranch : ElementTag, IVersionHistoryBranchesBranch
    {
        internal VersionHistoryBranchesBranch(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Branch")
        {
        }

        private ElementValueTag<string> _comment;
        private VersionHistoryBranchesBranchFeatures _features;
        private VersionHistoryBranchesBranchSystemVersions _systemVersions;
        private AttributeTag<uint?> _id;
        ///<summary>
        /// Provides information about this branch.
        ///</summary>
public IValueTag<string> Comment => _comment;
        ///<summary>
        /// Provides information about the features this branch supports.
        ///</summary>
public IVersionHistoryBranchesBranchFeatures Features => _features;
        ///<summary>
        /// Contains the different SystemVersion entries.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersions SystemVersions => _systemVersions;
        ///<summary>
        /// The unique ID of the branch version component.
        ///</summary>
public IValueTag<uint?> Id => _id;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseElementTag("Comment", nameof(Comment), _comment, value => _comment = value);
            ParseElementTag("Features", nameof(Features), _features, value => _features = value);
            ParseElementTag("SystemVersions", nameof(SystemVersions), _systemVersions, value => _systemVersions = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranch(this);
        }
    }

    ///<summary>
    /// Provides information about the features this branch supports.
    ///</summary>
internal partial class VersionHistoryBranchesBranchFeatures : SimpleProtocolListNode<VersionHistoryBranchesBranchFeaturesFeature>, IVersionHistoryBranchesBranchFeatures
    {
        internal VersionHistoryBranchesBranchFeatures(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Features", "Feature")
        {
        }

        IVersionHistoryBranchesBranchFeaturesFeature IReadOnlyList<IVersionHistoryBranchesBranchFeaturesFeature>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchFeaturesFeature> IEnumerable<IVersionHistoryBranchesBranchFeaturesFeature>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchFeatures(this);
        }
    }

    ///<summary>
    /// Provides information about a specific feature of this branch.
    ///</summary>
internal partial class VersionHistoryBranchesBranchFeaturesFeature : ElementValueTag<string>, IVersionHistoryBranchesBranchFeaturesFeature
    {
        internal VersionHistoryBranchesBranchFeaturesFeature(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Feature")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchFeaturesFeature(this);
        }
    }

    ///<summary>
    /// Contains the different SystemVersion entries.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersions : SimpleProtocolListNode<VersionHistoryBranchesBranchSystemVersionsSystemVersion>, IVersionHistoryBranchesBranchSystemVersions
    {
        internal VersionHistoryBranchesBranchSystemVersions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SystemVersions", "SystemVersion")
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersion IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersion>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersion> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersion>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersions(this);
        }
    }

    ///<summary>
    /// Defines a SystemVersion entry.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersion : ElementTag, IVersionHistoryBranchesBranchSystemVersionsSystemVersion
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersion(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SystemVersion")
        {
        }

        private ElementValueTag<string> _comment;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions _majorVersions;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions _supportedVersions;
        private AttributeTag<uint?> _id;
        ///<summary>
        /// Provides information about this entry.
        ///</summary>
public IValueTag<string> Comment => _comment;
        ///<summary>
        /// Contains the different major versions within this branch of this protocol.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions MajorVersions => _majorVersions;
        ///<summary>
        /// Specifies the system version support.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions SupportedVersions => _supportedVersions;
        ///<summary>
        /// The unique ID of the system version component.
        ///</summary>
public IValueTag<uint?> Id => _id;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseElementTag("Comment", nameof(Comment), _comment, value => _comment = value);
            ParseElementTag("MajorVersions", nameof(MajorVersions), _majorVersions, value => _majorVersions = value);
            ParseElementTag("SupportedVersions", nameof(SupportedVersions), _supportedVersions, value => _supportedVersions = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersion(this);
        }
    }

    ///<summary>
    /// Contains the different major versions within this branch of this protocol.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions : SimpleProtocolListNode<VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "MajorVersions", "MajorVersion")
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions(this);
        }
    }

    ///<summary>
    /// Defines a major version of this protocol.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion : ElementTag, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion(ProtocolModel model, ProtocolTag parent) : base(model, parent, "MajorVersion")
        {
        }

        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges _changes;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions _minorVersions;
        private AttributeTag<uint?> _id;
        ///<summary>
        /// Contains information about the changes.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges Changes => _changes;
        ///<summary>
        /// Contains the different minor versions of this protocol within this major version of this protocol.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions MinorVersions => _minorVersions;
        ///<summary>
        /// The unique ID of the major version component.
        ///</summary>
public IValueTag<uint?> Id => _id;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseElementTag("Changes", nameof(Changes), _changes, value => _changes = value);
            ParseElementTag("MinorVersions", nameof(MinorVersions), _minorVersions, value => _minorVersions = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion(this);
        }
    }

    ///<summary>
    /// Contains information about the changes.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges : SimpleProtocolListNode<VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Changes", "Change")
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges(this);
        }
    }

    ///<summary>
    /// Describes a change.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange : ElementTag, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Change")
        {
        }

        private ElementValueTag<string> _impact;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake _actionsToTake;
        private AttributeTag<string> _coversMajorChanges;
        ///<summary>
        /// Describes the impact of this change.
        ///</summary>
public IValueTag<string> Impact => _impact;
        ///<summary>
        /// Lists the actions to take.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake ActionsToTake => _actionsToTake;
        ///<summary>
        /// Specifies the major changes this major change covers.
        ///</summary>
public IValueTag<string> CoversMajorChanges => _coversMajorChanges;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("coversMajorChanges", nameof(CoversMajorChanges), _coversMajorChanges, value => _coversMajorChanges = value);
            ParseElementTag("Impact", nameof(Impact), _impact, value => _impact = value);
            ParseElementTag("ActionsToTake", nameof(ActionsToTake), _actionsToTake, value => _actionsToTake = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange(this);
        }
    }

    ///<summary>
    /// Lists the actions to take.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake : SimpleProtocolListNode<VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ActionsToTake", "ActionToTake")
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake(this);
        }
    }

    ///<summary>
    /// Describes an action to take.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake : ElementValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ActionToTake")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake(this);
        }
    }

    ///<summary>
    /// Contains the different minor versions of this protocol within this major version of this protocol.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions : SimpleProtocolListNode<VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "MinorVersions", "MinorVersion")
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions(this);
        }
    }

    ///<summary>
    /// Defines a minor version of this protocol.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion : ElementTag, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion(ProtocolModel model, ProtocolTag parent) : base(model, parent, "MinorVersion")
        {
        }

        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges _changes;
        private ElementValueTag<System.DateTime?> _date;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider _provider;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences _references;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions _suppressions;
        private AttributeTag<uint?> _id;
        private AttributeTag<string> _basedOn;
        ///<summary>
        /// Contains information about the changes implemented in this minor version of this protocol.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges Changes => _changes;
        ///<summary>
        /// Specifies the date on which this version of this protocol has been released. (Format: YYYY-MM-DD)
        ///</summary>
public IValueTag<System.DateTime?> Date => _date;
        public IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider Provider => _provider;
        ///<summary>
        /// Provides references to e.g. registration systems.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences References => _references;
        ///<summary>
        /// List of all the suppressions for this version.
        ///</summary>
public IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions Suppressions => _suppressions;
        ///<summary>
        /// The unique ID of the minor version component.
        ///</summary>
public IValueTag<uint?> Id => _id;
        ///<summary>
        /// The version of the protocol on which this protocol is based.
        ///</summary>
public IValueTag<string> BasedOn => _basedOn;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("id", nameof(Id), _id, value => _id = value);
            ParseAttributeTag("basedOn", nameof(BasedOn), _basedOn, value => _basedOn = value);
            ParseElementTag("Changes", nameof(Changes), _changes, value => _changes = value);
            ParseElementTag("Date", nameof(Date), _date, value => _date = value);
            ParseElementTag("Provider", nameof(Provider), _provider, value => _provider = value);
            ParseElementTag("References", nameof(References), _references, value => _references = value);
            ParseElementTag("Suppressions", nameof(Suppressions), _suppressions, value => _suppressions = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion(this);
        }
    }

    ///<summary>
    /// Contains information about the changes implemented in this minor version of this protocol.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges : MultipleValueProtocolListNode<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesObject>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Changes", new Dictionary<string, Type>() { { "Fix", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix) }, { "Change", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange) }, { "NewFeature", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature) }, { "", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem) } })
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges(this);
        }
    }

    internal partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesObject : IProtocolTag, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem
    {
    }

    internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem : ElementValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesObject
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem(ProtocolModel model, ProtocolTag parent, string tagName) : base(model, parent, tagName)
        {
        }

        protected override void Parse(string notifyPropertyName)
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem(this);
        }
    }

    ///<summary>
    /// Describes a fix.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix : ElementValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesObject
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Fix")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix(this);
        }
    }

    ///<summary>
    /// Describes a change.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange : ElementValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesObject
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Change")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange(this);
        }
    }

    ///<summary>
    /// Describes a new feature.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature : ElementValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesObject
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature(ProtocolModel model, ProtocolTag parent) : base(model, parent, "NewFeature")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature(this);
        }
    }

    internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider : ElementTag, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Provider")
        {
        }

        private ElementValueTag<string> _company;
        private ElementValueTag<string> _author;
        ///<summary>
        /// Specifies the company providing this version of this protocol.
        ///</summary>
public IValueTag<string> Company => _company;
        ///<summary>
        /// Specifies the author of this version of this protocol.
        ///</summary>
public IValueTag<string> Author => _author;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Company", nameof(Company), _company, value => _company = value);
            ParseElementTag("Author", nameof(Author), _author, value => _author = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider(this);
        }
    }

    ///<summary>
    /// Provides references to e.g. registration systems.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences : MultipleValueProtocolListNode<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesObject>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences(ProtocolModel model, ProtocolTag parent) : base(model, parent, "References", new Dictionary<string, Type>() { { "TaskId", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId) }, { "Reference", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference) }, { "", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem) } })
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences(this);
        }
    }

    internal partial interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesObject : IProtocolTag, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem
    {
    }

    internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem : ProtocolTag, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesObject
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem(ProtocolModel model, ProtocolTag parent, string tagName) : base(model, parent, tagName)
        {
        }

        protected override void Parse(string notifyPropertyName)
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem(this);
        }
    }

    ///<summary>
    /// Provides a reference to a corresponding task.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId : ElementValueTag<uint?>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesObject
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TaskId")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId(this);
        }
    }

    ///<summary>
    /// Provides a reference to e.g. a registration system.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference : ElementValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesObject
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Reference")
        {
        }

        private AttributeTag<string> _type;
        ///<summary>
        /// Specifies the type of reference.
        ///</summary>
public IValueTag<string> Type => _type;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference(this);
        }
    }

    ///<summary>
    /// List of all the suppressions for this version.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions : SimpleProtocolListNode<VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Suppressions", "Suppression")
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions(this);
        }
    }

    ///<summary>
    /// A single suppression.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression : ElementTag, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Suppression")
        {
        }

        private ElementValueTag<string> _reason;
        private ElementValueTag<string> _location;
        private ElementValueTag<string> _resultId;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType _type;
        private AttributeTag<uint?> _taskId;
        ///<summary>
        /// Reason for the suppression.
        ///</summary>
public IValueTag<string> Reason => _reason;
        ///<summary>
        /// Location of the suppression.
        ///</summary>
public IValueTag<string> Location => _location;
        ///<summary>
        /// ID of the result that is being suppressed.
        ///</summary>
public IValueTag<string> ResultId => _resultId;
        ///<summary>
        /// Type of the suppression.
        ///</summary>
public IValueTag<Enums.EnumSuppressionType?> Type => _type;
        ///<summary>
        /// Task ID.
        ///</summary>
public IValueTag<uint?> TaskId => _taskId;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseAttributeTag("taskId", nameof(TaskId), _taskId, value => _taskId = value);
            ParseElementTag("Reason", nameof(Reason), _reason, value => _reason = value);
            ParseElementTag("Location", nameof(Location), _location, value => _location = value);
            ParseElementTag("ResultId", nameof(ResultId), _resultId, value => _resultId = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression(this);
        }
    }

    internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType : AttributeTag<Enums.EnumSuppressionType?>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumSuppressionType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumSuppressionTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the system version support.
    ///</summary>
internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions : SimpleProtocolListNode<VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SupportedVersions", "Version")
        {
        }

        IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion IReadOnlyList<IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion> IEnumerable<IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions(this);
        }
    }

    internal partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion : ElementValueTag<string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Version")
        {
        }

        private AttributeTag<string> _min;
        private AttributeTag<string> _max;
        ///<summary>
        /// The minimum system version supported by this protocol range.
        ///</summary>
public IValueTag<string> Min => _min;
        ///<summary>
        /// The maximum system version supported by this protocol range.
        ///</summary>
public IValueTag<string> Max => _max;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("min", nameof(Min), _min, value => _min = value);
            ParseAttributeTag("max", nameof(Max), _max, value => _max = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion(this);
        }
    }

    ///<summary>
    /// Defines a table column. Each table column is defined by one or two parameters: one for read, and/or one for write.
    ///</summary>
internal partial class TypeColumnOption : ElementTag, ITypeColumnOption
    {
        internal TypeColumnOption(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeColumnOption")
        {
        }

        private TypeColumnOptionCpeAlignment _cpeAlignment;
        private AttributeTag<uint?> _idx;
        private AttributeTag<string> _options;
        private AttributeTag<uint?> _pid;
        private AttributeTag<uint?> _pollingRate;
        private TypeColumnOptionType _type;
        private AttributeTag<string> _valueAttribute;
        ///<summary>
        /// Sets the alignment of KPI values in a CPE interface.
        /// Default value: right.
        /// Feature introduced in DataMiner 8.5.4.3 (RN 9430).
        ///</summary>
public IValueTag<Enums.EnumCpeAlignment?> CpeAlignment => _cpeAlignment;
        ///<summary>
        /// Defines the (0-based) position of the column in the table.
        /// Note: The ColumnOption elements have to be defined in order of their idx attribute.
        ///</summary>
public IValueTag<uint?> Idx => _idx;
        ///<summary>
        /// Defines different options.
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        /// Note: In this attribute, you can specify multiple values separated by a character of choice (a semicolon is recommended).
        /// This character has to be the first character in the value of the options attribute.
        /// If, for example, you want to separate the different options by a semi-colon, the first character of the options value has to be a semi-colon.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the parameter ID of the column data.
        ///</summary>
public IValueTag<uint?> Pid => _pid;
        ///<summary>
        /// Specifies the polling rate of this column (in ms).
        /// Feature introduced in DataMiner 9.5.6 (RN 16411).
        /// Refer to the DataMiner Protocol Markup Language documentation for more information.
        ///</summary>
public IValueTag<uint?> PollingRate => _pollingRate;
        ///<summary>
        /// Specifies column type options. For more information on the values allowed in this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public IValueTag<Enums.EnumColumnOptionType?> Type => _type;
        ///<summary>
        /// The interpretation of this attribute depends on the value of the "type" attribute:
        /// -	If type is "concatenation", then value is the comma-separated list of the indexes of the columns to be concatenated.
        /// -	If type is "autoincrement", then value is the offset for the automatic increment of the indexes.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("cpeAlignment", nameof(CpeAlignment), _cpeAlignment, value => _cpeAlignment = value);
            ParseAttributeTag("idx", nameof(Idx), _idx, value => _idx = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
            ParseAttributeTag("pollingRate", nameof(PollingRate), _pollingRate, value => _pollingRate = value);
            ParseAttributeTag("type", nameof(Type), _type, value => _type = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeColumnOption(this);
        }
    }

    internal partial class TypeColumnOptionCpeAlignment : AttributeTag<Enums.EnumCpeAlignment?>
    {
        internal TypeColumnOptionCpeAlignment(ProtocolModel model, ProtocolTag parent) : base(model, parent, "cpeAlignment")
        {
        }

        public override Enums.EnumCpeAlignment? ConvertRawValue(string rawValue)
        {
            return Enums.EnumCpeAlignmentConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class TypeColumnOptionType : AttributeTag<Enums.EnumColumnOptionType?>
    {
        internal TypeColumnOptionType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "type")
        {
        }

        public override Enums.EnumColumnOptionType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumColumnOptionTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Represents export rules.
    ///</summary>
internal partial class ExportRules : SimpleProtocolListNode<ExportRulesExportRule>, IExportRules
    {
        internal ExportRules(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ExportRules", "ExportRule")
        {
        }

        IExportRulesExportRule IReadOnlyList<IExportRulesExportRule>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IExportRulesExportRule> IEnumerable<IExportRulesExportRule>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitExportRules(this);
        }
    }

    ///<summary>
    /// Defines a rule that are used for changing the displayed items in a Dynamic Virtual Element (DVE), for example changing the location of a parameter.
    ///</summary>
internal partial class ExportRulesExportRule : ElementTag, IExportRulesExportRule
    {
        internal ExportRulesExportRule(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ExportRule")
        {
        }

        private AttributeTag<string> _attribute;
        private AttributeTag<string> _name;
        private AttributeTag<string> _regex;
        private AttributeTag<string> _table;
        private AttributeTag<string> _tag;
        private AttributeTag<string> _valueAttribute;
        private AttributeTag<string> _whereAttribute;
        private AttributeTag<string> _whereTag;
        private AttributeTag<string> _whereValue;
        ///<summary>
        /// Specifies the attribute of the XML element specified in the "tag" attribute on which to apply this rule.
        ///</summary>
public IValueTag<string> Attribute => _attribute;
        ///<summary>
        /// Specifies the name of the export rule.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies a regular expression to match particular values.
        ///</summary>
public IValueTag<string> Regex => _regex;
        ///<summary>
        /// Specifies the ID of table parameter that will generate the DVEs.
        ///</summary>
public IValueTag<string> Table => _table;
        ///<summary>
        /// Specifies the XML element on which to apply this rule.
        ///</summary>
public IValueTag<string> Tag => _tag;
        ///<summary>
        /// Specifies the value that needs to be set.
        ///</summary>
public IValueTag<string> ValueAttribute => _valueAttribute;
        ///<summary>
        /// Specifies, together with the whereTag and whereValue attributes, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
public IValueTag<string> WhereAttribute => _whereAttribute;
        ///<summary>
        /// Specifies, together with the whereValue attribute, and optionally the whereAttribute attribute, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
public IValueTag<string> WhereTag => _whereTag;
        ///<summary>
        /// Specifies, together with the whereTag attribute, and optionally the whereAttribute attribute, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
public IValueTag<string> WhereValue => _whereValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("attribute", nameof(Attribute), _attribute, value => _attribute = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("regex", nameof(Regex), _regex, value => _regex = value);
            ParseAttributeTag("table", nameof(Table), _table, value => _table = value);
            ParseAttributeTag("tag", nameof(Tag), _tag, value => _tag = value);
            ParseAttributeTag("value", nameof(ValueAttribute), _valueAttribute, value => _valueAttribute = value);
            ParseAttributeTag("whereAttribute", nameof(WhereAttribute), _whereAttribute, value => _whereAttribute = value);
            ParseAttributeTag("whereTag", nameof(WhereTag), _whereTag, value => _whereTag = value);
            ParseAttributeTag("whereValue", nameof(WhereValue), _whereValue, value => _whereValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitExportRulesExportRule(this);
        }
    }

    ///<summary>
    /// Specifies the request data to be sent.
    /// Alternatively, you can put this data in parameters, which you should then specify in the Parameters element.
    ///</summary>
internal partial class HttpRequestData : ElementValueTag<string>, IHttpRequestData
    {
        internal HttpRequestData(ProtocolModel model, ProtocolTag parent) : base(model, parent, "HttpRequestData")
        {
        }

        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the data to be sent.
        /// Note: either use this attribute (and provide the data to be sent in the referred parameter) or specify the data to be sent in Data (e.g. &lt;Data&gt;data&lt;/Data&gt;.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestData(this);
        }
    }

    ///<summary>
    /// Specifies additional headers that need to be sent as part of the HTTP request.
    ///</summary>
internal partial class HttpRequestHeaders : SimpleProtocolListNode<HttpRequestHeadersHeader>, IHttpRequestHeaders
    {
        internal HttpRequestHeaders(ProtocolModel model, ProtocolTag parent) : base(model, parent, "HttpRequestHeaders", "Header")
        {
        }

        IHttpRequestHeadersHeader IReadOnlyList<IHttpRequestHeadersHeader>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IHttpRequestHeadersHeader> IEnumerable<IHttpRequestHeadersHeader>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestHeaders(this);
        }
    }

    ///<summary>
    /// Specifies a parameter of which the contents will be put in one of the headers of the HTTP request.
    /// Via HTTP, this has to be done by means of key/value pairs.
    ///</summary>
internal partial class HttpRequestHeadersHeader : ElementValueTag<string>, IHttpRequestHeadersHeader
    {
        internal HttpRequestHeadersHeader(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Header")
        {
        }

        private AttributeTag<string> _key;
        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the key of the key/value pair.
        ///</summary>
public IValueTag<string> Key => _key;
        ///<summary>
        /// Specifies the ID of the parameter that contains the value to be put in the header.&lt;BR /&gt;
        /// If you do not specify the pid attribute, you have to provide a fixed value in the Header element.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("key", nameof(Key), _key, value => _key = value);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestHeadersHeader(this);
        }
    }

    ///<summary>
    /// If you do not want to specify a fixed block of data in Data, but rather a number of parameters containing the data to be sent, then use this element to define the list of parameters of which you want the contents to be sent in the HTTP request.
    ///</summary>
internal partial class HttpRequestParameters : SimpleProtocolListNode<HttpRequestParametersParameter>, IHttpRequestParameters
    {
        internal HttpRequestParameters(ProtocolModel model, ProtocolTag parent) : base(model, parent, "HttpRequestParameters", "Parameter")
        {
        }

        IHttpRequestParametersParameter IReadOnlyList<IHttpRequestParametersParameter>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IHttpRequestParametersParameter> IEnumerable<IHttpRequestParametersParameter>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestParameters(this);
        }
    }

    ///<summary>
    /// Specifies a parameter of which you want its content to be included in the HTTP request.
    /// Via HTTP, this has to be done by means of key/value pairs.
    ///</summary>
internal partial class HttpRequestParametersParameter : ElementValueTag<string>, IHttpRequestParametersParameter
    {
        internal HttpRequestParametersParameter(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Parameter")
        {
        }

        private AttributeTag<string> _key;
        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the key of the key/value pair.
        ///</summary>
public IValueTag<string> Key => _key;
        ///<summary>
        /// Specifies the ID of the parameter that contains the value to be sent.&lt;BR /&gt;
        /// If you do not specify the pid attribute, you have to provide a value in the Parameter element.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("key", nameof(Key), _key, value => _key = value);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestParametersParameter(this);
        }
    }

    ///<summary>
    /// Represents an icon.
    ///</summary>
internal partial class Icon : ElementValueTag<string>, IIcon
    {
        internal Icon(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Icon")
        {
        }

        private IconRef _ref;
        ///<summary>
        /// Specifies the key of the icon as defined in the Icons.xml file.
        /// Using this attribute in a table or table column parameter will display an icon in the tree control.
        ///</summary>
public IValueTag<Enums.EnumIcons?> Ref => _ref;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("ref", nameof(Ref), _ref, value => _ref = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitIcon(this);
        }
    }

    internal partial class IconRef : AttributeTag<Enums.EnumIcons?>
    {
        internal IconRef(ProtocolModel model, ProtocolTag parent) : base(model, parent, "ref")
        {
        }

        public override Enums.EnumIcons? ConvertRawValue(string rawValue)
        {
            return Enums.EnumIconsConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines a ping interval.
    ///</summary>
internal partial class PingInterval : ElementTag, IPingInterval
    {
        internal PingInterval(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PingInterval")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default ping interval in milliseconds. The specified value must be in the range [1000,300000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the ping interval can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPingInterval(this);
        }
    }

    ///<summary>
    /// Defines a slow poll configuration.
    ///</summary>
internal partial class SlowPoll : ElementTag, ISlowPoll
    {
        internal SlowPoll(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SlowPoll")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default slow poll settings.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the slow poll settings can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSlowPoll(this);
        }
    }

    ///<summary>
    /// Defines a slow poll base.
    ///</summary>
internal partial class SlowPollBase : ElementTag, ISlowPollBase
    {
        internal SlowPollBase(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SlowPollBase")
        {
        }

        private SlowPollBaseDefaultValue _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default slow poll base.
        ///</summary>
public IValueTag<Enums.EnumTypePortSlowPollBase?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the slow poll settings can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSlowPollBase(this);
        }
    }

    internal partial class SlowPollBaseDefaultValue : ElementValueTag<Enums.EnumTypePortSlowPollBase?>
    {
        internal SlowPollBaseDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumTypePortSlowPollBase? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTypePortSlowPollBaseConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines user settings.
    ///</summary>
internal partial class TypeUserSettings : ElementTag, ITypeUserSettings
    {
        internal TypeUserSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeUserSettings")
        {
        }

        private TypeUserSettingsValues _values;
        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private TypeUserSettingsRange _range;
        public ITypeUserSettingsValues Values => _values;
        public IValueTag<string> DefaultValue => _defaultValue;
        public IValueTag<bool?> Disabled => _disabled;
        public ITypeUserSettingsRange Range => _range;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeUserSettings(this);
        }
    }

    internal partial class TypeUserSettingsValues : SimpleProtocolListNode<TypeUserSettingsValuesValue>, ITypeUserSettingsValues
    {
        internal TypeUserSettingsValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values", "Value")
        {
        }

        ITypeUserSettingsValuesValue IReadOnlyList<ITypeUserSettingsValuesValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeUserSettingsValuesValue> IEnumerable<ITypeUserSettingsValuesValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeUserSettingsValues(this);
        }
    }

    internal partial class TypeUserSettingsValuesValue : ElementValueTag<string>, ITypeUserSettingsValuesValue
    {
        internal TypeUserSettingsValuesValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeUserSettingsValuesValue(this);
        }
    }

    internal partial class TypeUserSettingsRange : ElementTag, ITypeUserSettingsRange
    {
        internal TypeUserSettingsRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        public IValueTag<string> From => _from;
        public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeUserSettingsRange(this);
        }
    }

    ///<summary>
    /// Defines port settings.
    ///</summary>
internal partial class PortSettings : ElementTag, IPortSettings
    {
        internal PortSettings(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortSettings")
        {
        }

        private PortSettingsBaudrate _baudrate;
        private PortSettingsBusAddress _busAddress;
        private PortSettingsDatabits _databits;
        private PortSettingsFlowcontrol _flowcontrol;
        private ElementValueTag<bool?> _flushPerDatagram;
        private PortSettingsGetCommunity _getCommunity;
        private PortSettingsIPport _iPport;
        private PortSettingsLocalIPport _localIPport;
        private PortSettingsParity _parity;
        private PingInterval _pingInterval;
        private PortSettingsPortTypeIP _portTypeIP;
        private PortSettingsPortTypeSerial _portTypeSerial;
        private PortSettingsPortTypeUDP _portTypeUDP;
        private PortSettingsRetries _retries;
        private PortSettingsSetCommunity _setCommunity;
        private PortSettingsSSH _sSH;
        private PortSettingsStopbits _stopbits;
        private PortSettingsTimeoutTimeElement _timeoutTimeElement;
        private PortSettingsTimeoutTime _timeoutTime;
        private PortSettingsType _type;
        private AttributeTag<string> _name;
        private AttributeTag<bool?> _visibleInUi;
        ///<summary>
        /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public IPortSettingsBaudrate Baudrate => _baudrate;
        ///<summary>
        /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public IPortSettingsBusAddress BusAddress => _busAddress;
        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
public IPortSettingsDatabits Databits => _databits;
        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
public IPortSettingsFlowcontrol Flowcontrol => _flowcontrol;
        ///<summary>
        /// When set to true, any datagram received on the connection will be forwarded to SLProtocol immediately, which will then store it in the response parameter. Only applicable for a smart-serial UDP connection.
        ///</summary>
public IValueTag<bool?> FlushPerDatagram => _flushPerDatagram;
        ///<summary>
        /// Specifies the GetCommunity string of an SNMP protocol.
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
public IPortSettingsGetCommunity GetCommunity => _getCommunity;
        ///<summary>
        /// Specifies the IP port configuration.
        ///</summary>
public IPortSettingsIPport IPport => _iPport;
        ///<summary>
        /// Specifies the local IP port configuration.
        ///</summary>
public IPortSettingsLocalIPport LocalIPport => _localIPport;
        ///<summary>
        /// Allows to limit parity settings and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
public IPortSettingsParity Parity => _parity;
        ///<summary>
        /// Configures the ping interval.
        ///</summary>
public IPingInterval PingInterval => _pingInterval;
        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
public IPortSettingsPortTypeIP PortTypeIP => _portTypeIP;
        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
public IPortSettingsPortTypeSerial PortTypeSerial => _portTypeSerial;
        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
public IPortSettingsPortTypeUDP PortTypeUDP => _portTypeUDP;
        ///<summary>
        /// Configures the number of retries.
        ///</summary>
public IPortSettingsRetries Retries => _retries;
        ///<summary>
        /// Specifies the SNMP set community string.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
public IPortSettingsSetCommunity SetCommunity => _setCommunity;
        ///<summary>
        /// Specifies the SSH settings (only applicable for serial connections of type TCP).
        /// Feature introduced in DataMiner 9.5.9 (RN 17732).
        ///</summary>
public IPortSettingsSSH SSH => _sSH;
        ///<summary>
        /// Specifies the stop bits settings.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
public IPortSettingsStopbits Stopbits => _stopbits;
        ///<summary>
        /// Specifies settings related to the element timeout.
        ///</summary>
public IPortSettingsTimeoutTimeElement TimeoutTimeElement => _timeoutTimeElement;
        ///<summary>
        /// Specifies settings related to the timeout of a command/request.
        ///</summary>
public IPortSettingsTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
public IPortSettingsType Type => _type;
        ///<summary>
        /// Specifies the name of the additional protocol type as specified in the advanced attribute of the /Protocol/Type element.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// If set to “false”, users cannot see or change the port settings for this additional protocol type when creating or editing an element.
        ///</summary>
public IValueTag<bool?> VisibleInUi => _visibleInUi;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("visibleInUi", nameof(VisibleInUi), _visibleInUi, value => _visibleInUi = value);
            ParseElementTag("Baudrate", nameof(Baudrate), _baudrate, value => _baudrate = value);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("Databits", nameof(Databits), _databits, value => _databits = value);
            ParseElementTag("Flowcontrol", nameof(Flowcontrol), _flowcontrol, value => _flowcontrol = value);
            ParseElementTag("FlushPerDatagram", nameof(FlushPerDatagram), _flushPerDatagram, value => _flushPerDatagram = value);
            ParseElementTag("GetCommunity", nameof(GetCommunity), _getCommunity, value => _getCommunity = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("LocalIPport", nameof(LocalIPport), _localIPport, value => _localIPport = value);
            ParseElementTag("Parity", nameof(Parity), _parity, value => _parity = value);
            ParseElementTag("PingInterval", nameof(PingInterval), _pingInterval, value => _pingInterval = value);
            ParseElementTag("PortTypeIP", nameof(PortTypeIP), _portTypeIP, value => _portTypeIP = value);
            ParseElementTag("PortTypeSerial", nameof(PortTypeSerial), _portTypeSerial, value => _portTypeSerial = value);
            ParseElementTag("PortTypeUDP", nameof(PortTypeUDP), _portTypeUDP, value => _portTypeUDP = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
            ParseElementTag("SetCommunity", nameof(SetCommunity), _setCommunity, value => _setCommunity = value);
            ParseElementTag("SSH", nameof(SSH), _sSH, value => _sSH = value);
            ParseElementTag("Stopbits", nameof(Stopbits), _stopbits, value => _stopbits = value);
            ParseElementTag("TimeoutTimeElement", nameof(TimeoutTimeElement), _timeoutTimeElement, value => _timeoutTimeElement = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettings(this);
        }
    }

    ///<summary>
    /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
internal partial class PortSettingsBaudrate : SimpleProtocolListNode<PortSettingsBaudrateValue>, IPortSettingsBaudrate
    {
        internal PortSettingsBaudrate(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Baudrate", "Value")
        {
        }

        private PortSettingsBaudrateDefaultValue _defaultValue;
        private PortSettingsBaudrateDisabled _disabled;
        private PortSettingsBaudrateRange _range;
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
public IPortSettingsBaudrateDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsBaudrateDisabled Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
public IPortSettingsBaudrateRange Range => _range;

        IPortSettingsBaudrateValue IReadOnlyList<IPortSettingsBaudrateValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsBaudrateValue> IEnumerable<IPortSettingsBaudrateValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrate(this);
        }
    }

    ///<summary>
    /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
    ///</summary>
internal partial class PortSettingsBaudrateDefaultValue : ElementValueTag<uint?>, IPortSettingsBaudrateDefaultValue
    {
        internal PortSettingsBaudrateDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrateDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the baud rate can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsBaudrateDisabled : ElementValueTag<bool?>, IPortSettingsBaudrateDisabled
    {
        internal PortSettingsBaudrateDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrateDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
internal partial class PortSettingsBaudrateRange : ElementTag, IPortSettingsBaudrateRange
    {
        internal PortSettingsBaudrateRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<uint?> _from;
        private ElementValueTag<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
public IValueTag<uint?> From => _from;
        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
public IValueTag<uint?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrateRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
internal partial class PortSettingsBaudrateValue : ElementValueTag<string>, IPortSettingsBaudrateValue
    {
        internal PortSettingsBaudrateValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrateValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
internal partial class PortSettingsBusAddress : SimpleProtocolListNode<PortSettingsBusAddressValue>, IPortSettingsBusAddress
    {
        internal PortSettingsBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress", "Value")
        {
        }

        private PortSettingsBusAddressDefaultValue _defaultValue;
        private PortSettingsBusAddressDisabled _disabled;
        private PortSettingsBusAddressRange _range;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IPortSettingsBusAddressDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsBusAddressDisabled Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IPortSettingsBusAddressRange Range => _range;

        IPortSettingsBusAddressValue IReadOnlyList<IPortSettingsBusAddressValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsBusAddressValue> IEnumerable<IPortSettingsBusAddressValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
    /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
    ///</summary>
internal partial class PortSettingsBusAddressDefaultValue : ElementValueTag<string>, IPortSettingsBusAddressDefaultValue
    {
        internal PortSettingsBusAddressDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddressDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the bus address can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsBusAddressDisabled : ElementValueTag<bool?>, IPortSettingsBusAddressDisabled
    {
        internal PortSettingsBusAddressDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddressDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class PortSettingsBusAddressRange : ElementTag, IPortSettingsBusAddressRange
    {
        internal PortSettingsBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddressRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class PortSettingsBusAddressValue : ElementValueTag<string>, IPortSettingsBusAddressValue
    {
        internal PortSettingsBusAddressValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddressValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
internal partial class PortSettingsDatabits : SimpleProtocolListNode<PortSettingsDatabitsValue>, IPortSettingsDatabits
    {
        internal PortSettingsDatabits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Databits", "Value")
        {
        }

        private PortSettingsDatabitsDefaultValue _defaultValue;
        private PortSettingsDatabitsDisabled _disabled;
        private PortSettingsDatabitsRange _range;
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
public IPortSettingsDatabitsDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsDatabitsDisabled Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
public IPortSettingsDatabitsRange Range => _range;

        IPortSettingsDatabitsValue IReadOnlyList<IPortSettingsDatabitsValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsDatabitsValue> IEnumerable<IPortSettingsDatabitsValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabits(this);
        }
    }

    ///<summary>
    /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
    ///</summary>
internal partial class PortSettingsDatabitsDefaultValue : ElementValueTag<string>, IPortSettingsDatabitsDefaultValue
    {
        internal PortSettingsDatabitsDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabitsDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the databits can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsDatabitsDisabled : ElementValueTag<bool?>, IPortSettingsDatabitsDisabled
    {
        internal PortSettingsDatabitsDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabitsDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
internal partial class PortSettingsDatabitsRange : ElementTag, IPortSettingsDatabitsRange
    {
        internal PortSettingsDatabitsRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<uint?> _from;
        private ElementValueTag<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
public IValueTag<uint?> From => _from;
        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
public IValueTag<uint?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabitsRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class PortSettingsDatabitsValue : ElementValueTag<uint?>, IPortSettingsDatabitsValue
    {
        internal PortSettingsDatabitsValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabitsValue(this);
        }
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
internal partial class PortSettingsFlowcontrol : SimpleProtocolListNode<PortSettingsFlowcontrolValue>, IPortSettingsFlowcontrol
    {
        internal PortSettingsFlowcontrol(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Flowcontrol", "Value")
        {
        }

        private PortSettingsFlowcontrolDefaultValue _defaultValue;
        private PortSettingsFlowcontrolDisabled _disabled;
        private PortSettingsFlowcontrolRange _range;
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
public IPortSettingsFlowcontrolDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsFlowcontrolDisabled Disabled => _disabled;
        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
public IPortSettingsFlowcontrolRange Range => _range;

        IPortSettingsFlowcontrolValue IReadOnlyList<IPortSettingsFlowcontrolValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsFlowcontrolValue> IEnumerable<IPortSettingsFlowcontrolValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrol(this);
        }
    }

    ///<summary>
    /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
    ///</summary>
internal partial class PortSettingsFlowcontrolDefaultValue : ElementValueTag<Enums.EnumPortSettingsFlowControl?>, IPortSettingsFlowcontrolDefaultValue
    {
        internal PortSettingsFlowcontrolDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrolDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the flow control can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsFlowcontrolDisabled : ElementValueTag<bool?>, IPortSettingsFlowcontrolDisabled
    {
        internal PortSettingsFlowcontrolDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrolDisabled(this);
        }
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
internal partial class PortSettingsFlowcontrolRange : ElementTag, IPortSettingsFlowcontrolRange
    {
        internal PortSettingsFlowcontrolRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private PortSettingsFlowcontrolRangeFrom _from;
        private PortSettingsFlowcontrolRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsFlowControl?> From => _from;
        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsFlowControl?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrolRange(this);
        }
    }

    internal partial class PortSettingsFlowcontrolRangeFrom : ElementValueTag<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsFlowcontrolRangeFrom(ProtocolModel model, ProtocolTag parent) : base(model, parent, "From")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class PortSettingsFlowcontrolRangeTo : ElementValueTag<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsFlowcontrolRangeTo(ProtocolModel model, ProtocolTag parent) : base(model, parent, "To")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class PortSettingsFlowcontrolValue : ElementValueTag<Enums.EnumPortSettingsFlowControl?>, IPortSettingsFlowcontrolValue
    {
        internal PortSettingsFlowcontrolValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrolValue(this);
        }
    }

    ///<summary>
    /// Specifies the GetCommunity string of an SNMP protocol.
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
internal partial class PortSettingsGetCommunity : ElementTag, IPortSettingsGetCommunity
    {
        internal PortSettingsGetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "GetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value of the GetCommunity string that will be used in the DataMiner user interface for SNMP protocols.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the get community string can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsGetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies the IP port configuration.
    ///</summary>
internal partial class PortSettingsIPport : ElementTag, IPortSettingsIPport
    {
        internal PortSettingsIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the port number can be configured via the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsIPport(this);
        }
    }

    ///<summary>
    /// Specifies the local IP port configuration.
    ///</summary>
internal partial class PortSettingsLocalIPport : ElementTag, IPortSettingsLocalIPport
    {
        internal PortSettingsLocalIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LocalIPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the local port number can be configured via the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsLocalIPport(this);
        }
    }

    ///<summary>
    /// Allows to limit parity settings and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
internal partial class PortSettingsParity : SimpleProtocolListNode<PortSettingsParityValue>, IPortSettingsParity
    {
        internal PortSettingsParity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Parity", "Value")
        {
        }

        private PortSettingsParityDefaultValue _defaultValue;
        private PortSettingsParityDisabled _disabled;
        private PortSettingsParityRange _range;
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
public IPortSettingsParityDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsParityDisabled Disabled => _disabled;
        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
public IPortSettingsParityRange Range => _range;

        IPortSettingsParityValue IReadOnlyList<IPortSettingsParityValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsParityValue> IEnumerable<IPortSettingsParityValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParity(this);
        }
    }

    ///<summary>
    /// Specifies the default parity.
    ///</summary>
internal partial class PortSettingsParityDefaultValue : ElementValueTag<Enums.EnumPortSettingsParity?>, IPortSettingsParityDefaultValue
    {
        internal PortSettingsParityDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParityDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the parity can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsParityDisabled : ElementValueTag<bool?>, IPortSettingsParityDisabled
    {
        internal PortSettingsParityDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParityDisabled(this);
        }
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
internal partial class PortSettingsParityRange : ElementTag, IPortSettingsParityRange
    {
        internal PortSettingsParityRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private PortSettingsParityRangeFrom _from;
        private PortSettingsParityRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsParity?> From => _from;
        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsParity?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParityRange(this);
        }
    }

    internal partial class PortSettingsParityRangeFrom : ElementValueTag<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsParityRangeFrom(ProtocolModel model, ProtocolTag parent) : base(model, parent, "From")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class PortSettingsParityRangeTo : ElementValueTag<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsParityRangeTo(ProtocolModel model, ProtocolTag parent) : base(model, parent, "To")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
internal partial class PortSettingsParityValue : ElementValueTag<Enums.EnumPortSettingsParity?>, IPortSettingsParityValue
    {
        internal PortSettingsParityValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParityValue(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
internal partial class PortSettingsPortTypeIP : ElementTag, IPortSettingsPortTypeIP
    {
        internal PortSettingsPortTypeIP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeIP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsPortTypeIP(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
internal partial class PortSettingsPortTypeSerial : ElementTag, IPortSettingsPortTypeSerial
    {
        internal PortSettingsPortTypeSerial(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeSerial")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsPortTypeSerial(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
internal partial class PortSettingsPortTypeUDP : ElementTag, IPortSettingsPortTypeUDP
    {
        internal PortSettingsPortTypeUDP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeUDP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsPortTypeUDP(this);
        }
    }

    ///<summary>
    /// Configures the number of retries.
    ///</summary>
internal partial class PortSettingsRetries : ElementTag, IPortSettingsRetries
    {
        internal PortSettingsRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value for the maximum number of times that a request will be re-sent.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the maximum number of retries can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsRetries(this);
        }
    }

    ///<summary>
    /// Specifies the SNMP set community string.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
internal partial class PortSettingsSetCommunity : ElementTag, IPortSettingsSetCommunity
    {
        internal PortSettingsSetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value of the SNMP set community string that will be used.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the SetCommunity string can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies the SSH settings (only applicable for serial connections of type TCP).
    /// Feature introduced in DataMiner 9.5.9 (RN 17732).
    ///</summary>
internal partial class PortSettingsSSH : ElementTag, IPortSettingsSSH
    {
        internal PortSettingsSSH(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SSH")
        {
        }

        private PortSettingsSSHCredentials _credentials;
        private PortSettingsSSHIdentity _identity;
        ///<summary>
        /// Specifies the SSH credentials.
        ///</summary>
public IPortSettingsSSHCredentials Credentials => _credentials;
        ///<summary>
        /// Specifies the identity settings.
        ///</summary>
public IPortSettingsSSHIdentity Identity => _identity;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Credentials", nameof(Credentials), _credentials, value => _credentials = value);
            ParseElementTag("Identity", nameof(Identity), _identity, value => _identity = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSH(this);
        }
    }

    ///<summary>
    /// Specifies the SSH credentials.
    ///</summary>
internal partial class PortSettingsSSHCredentials : ElementTag, IPortSettingsSSHCredentials
    {
        internal PortSettingsSSHCredentials(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Credentials")
        {
        }

        private PortSettingsSSHCredentialsUsername _username;
        private PortSettingsSSHCredentialsPassword _password;
        ///<summary>
        /// Specifies the user name.
        ///</summary>
public IPortSettingsSSHCredentialsUsername Username => _username;
        ///<summary>
        /// Specifies the password.
        ///</summary>
public IPortSettingsSSHCredentialsPassword Password => _password;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Username", nameof(Username), _username, value => _username = value);
            ParseElementTag("Password", nameof(Password), _password, value => _password = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSHCredentials(this);
        }
    }

    ///<summary>
    /// Specifies the user name.
    ///</summary>
internal partial class PortSettingsSSHCredentialsUsername : ElementTag, IPortSettingsSSHCredentialsUsername
    {
        internal PortSettingsSSHCredentialsUsername(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Username")
        {
        }

        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the user name.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSHCredentialsUsername(this);
        }
    }

    ///<summary>
    /// Specifies the password.
    ///</summary>
internal partial class PortSettingsSSHCredentialsPassword : ElementTag, IPortSettingsSSHCredentialsPassword
    {
        internal PortSettingsSSHCredentialsPassword(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Password")
        {
        }

        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the password.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSHCredentialsPassword(this);
        }
    }

    ///<summary>
    /// Specifies the identity settings.
    ///</summary>
internal partial class PortSettingsSSHIdentity : ElementTag, IPortSettingsSSHIdentity
    {
        internal PortSettingsSSHIdentity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Identity")
        {
        }

        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the identity info.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSHIdentity(this);
        }
    }

    ///<summary>
    /// Specifies the stop bits settings.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
internal partial class PortSettingsStopbits : SimpleProtocolListNode<PortSettingsStopbitsValue>, IPortSettingsStopbits
    {
        internal PortSettingsStopbits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Stopbits", "Value")
        {
        }

        private PortSettingsStopbitsDefaultValue _defaultValue;
        private PortSettingsStopbitsDisabled _disabled;
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
public IPortSettingsStopbitsDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsStopbitsDisabled Disabled => _disabled;

        IPortSettingsStopbitsValue IReadOnlyList<IPortSettingsStopbitsValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsStopbitsValue> IEnumerable<IPortSettingsStopbitsValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsStopbits(this);
        }
    }

    ///<summary>
    /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
    /// Set the default to one of the following integer values: 1, 1.5 or 2
    ///</summary>
internal partial class PortSettingsStopbitsDefaultValue : ElementValueTag<string>, IPortSettingsStopbitsDefaultValue
    {
        internal PortSettingsStopbitsDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsStopbitsDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsStopbitsDisabled : ElementValueTag<bool?>, IPortSettingsStopbitsDisabled
    {
        internal PortSettingsStopbitsDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsStopbitsDisabled(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
internal partial class PortSettingsStopbitsValue : ElementValueTag<Enums.EnumPortSettingsStopBits?>, IPortSettingsStopbitsValue
    {
        internal PortSettingsStopbitsValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsStopBits? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsStopBitsConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsStopbitsValue(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the element timeout.
    ///</summary>
internal partial class PortSettingsTimeoutTimeElement : ElementTag, IPortSettingsTimeoutTimeElement
    {
        internal PortSettingsTimeoutTimeElement(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTimeElement")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default element timeout value (in milliseconds). The specified value must be in the range [1000, 120000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the element timeout time for this connection can be configured via the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsTimeoutTimeElement(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the timeout of a command/request.
    ///</summary>
internal partial class PortSettingsTimeoutTime : ElementTag, IPortSettingsTimeoutTime
    {
        internal PortSettingsTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default timeout value (in milliseconds).
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the timeout value can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
internal partial class PortSettingsType : ElementTag, IPortSettingsType
    {
        internal PortSettingsType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private PortSettingsTypeDefaultValue _defaultValue;
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
public IValueTag<Enums.EnumPortTypes?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsType(this);
        }
    }

    internal partial class PortSettingsTypeDefaultValue : ElementValueTag<Enums.EnumPortTypes?>
    {
        internal PortSettingsTypeDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines main port settings.
    ///</summary>
internal partial class PortSettingsMain : ElementTag, IPortSettingsMain
    {
        internal PortSettingsMain(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortSettingsMain")
        {
        }

        private PortSettingsMainBaudrate _baudrate;
        private PortSettingsMainBusAddress _busAddress;
        private PortSettingsMainDatabits _databits;
        private PortSettingsMainFlowcontrol _flowcontrol;
        private ElementValueTag<bool?> _flushPerDatagram;
        private PortSettingsMainGetCommunity _getCommunity;
        private PortSettingsMainIPport _iPport;
        private PortSettingsMainLocalIPport _localIPport;
        private PortSettingsMainParity _parity;
        private PingInterval _pingInterval;
        private PortSettingsMainPortTypeIP _portTypeIP;
        private PortSettingsMainPortTypeSerial _portTypeSerial;
        private PortSettingsMainPortTypeUDP _portTypeUDP;
        private PortSettingsMainRetries _retries;
        private PortSettingsMainSetCommunity _setCommunity;
        private SlowPoll _slowPoll;
        private SlowPollBase _slowPollBase;
        private PortSettingsMainSSH _sSH;
        private PortSettingsMainStopbits _stopbits;
        private PortSettingsMainTimeoutTimeElement _timeoutTimeElement;
        private PortSettingsMainTimeoutTime _timeoutTime;
        private PortSettingsMainType _type;
        private AttributeTag<string> _name;
        ///<summary>
        /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public IPortSettingsMainBaudrate Baudrate => _baudrate;
        ///<summary>
        /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public IPortSettingsMainBusAddress BusAddress => _busAddress;
        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
public IPortSettingsMainDatabits Databits => _databits;
        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
public IPortSettingsMainFlowcontrol Flowcontrol => _flowcontrol;
        ///<summary>
        /// When set to true, any datagram received on the connection will be forwarded to SLProtocol immediately, which will then store it in the response parameter. Only applicable for a smart-serial UDP connection.
        ///</summary>
public IValueTag<bool?> FlushPerDatagram => _flushPerDatagram;
        ///<summary>
        /// Specifies the GetCommunity string of an SNMP protocol.
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
public IPortSettingsMainGetCommunity GetCommunity => _getCommunity;
        ///<summary>
        /// Specifies the IP port configuration.
        ///</summary>
public IPortSettingsMainIPport IPport => _iPport;
        ///<summary>
        /// Specifies the local IP port configuration.
        ///</summary>
public IPortSettingsMainLocalIPport LocalIPport => _localIPport;
        ///<summary>
        /// Allows to limit parity settings and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
public IPortSettingsMainParity Parity => _parity;
        ///<summary>
        /// Configures the ping interval.
        ///</summary>
public IPingInterval PingInterval => _pingInterval;
        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
public IPortSettingsMainPortTypeIP PortTypeIP => _portTypeIP;
        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
public IPortSettingsMainPortTypeSerial PortTypeSerial => _portTypeSerial;
        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
public IPortSettingsMainPortTypeUDP PortTypeUDP => _portTypeUDP;
        ///<summary>
        /// Configures the number of retries.
        ///</summary>
public IPortSettingsMainRetries Retries => _retries;
        ///<summary>
        /// Specifies the SNMP set community string.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
public IPortSettingsMainSetCommunity SetCommunity => _setCommunity;
        ///<summary>
        /// Specifies the slow poll configuration.
        ///</summary>
public ISlowPoll SlowPoll => _slowPoll;
        ///<summary>
        /// Specifies the slow poll base settings.
        ///</summary>
public ISlowPollBase SlowPollBase => _slowPollBase;
        ///<summary>
        /// Specifies the SSH settings (only applicable for serial connections of type TCP).
        /// Feature introduced in DataMiner 9.5.9 (RN 17732).
        ///</summary>
public IPortSettingsMainSSH SSH => _sSH;
        ///<summary>
        /// Specifies the stop bits settings.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
public IPortSettingsMainStopbits Stopbits => _stopbits;
        ///<summary>
        /// Specifies settings related to the element timeout.
        ///</summary>
public IPortSettingsMainTimeoutTimeElement TimeoutTimeElement => _timeoutTimeElement;
        ///<summary>
        /// Specifies settings related to the timeout of a command/request.
        ///</summary>
public IPortSettingsMainTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
public IPortSettingsMainType Type => _type;
        ///<summary>
        /// Specifies the name of the additional protocol type as specified in the advanced attribute of the /Protocol/Type element.
        ///</summary>
public IValueTag<string> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Baudrate", nameof(Baudrate), _baudrate, value => _baudrate = value);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("Databits", nameof(Databits), _databits, value => _databits = value);
            ParseElementTag("Flowcontrol", nameof(Flowcontrol), _flowcontrol, value => _flowcontrol = value);
            ParseElementTag("FlushPerDatagram", nameof(FlushPerDatagram), _flushPerDatagram, value => _flushPerDatagram = value);
            ParseElementTag("GetCommunity", nameof(GetCommunity), _getCommunity, value => _getCommunity = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("LocalIPport", nameof(LocalIPport), _localIPport, value => _localIPport = value);
            ParseElementTag("Parity", nameof(Parity), _parity, value => _parity = value);
            ParseElementTag("PingInterval", nameof(PingInterval), _pingInterval, value => _pingInterval = value);
            ParseElementTag("PortTypeIP", nameof(PortTypeIP), _portTypeIP, value => _portTypeIP = value);
            ParseElementTag("PortTypeSerial", nameof(PortTypeSerial), _portTypeSerial, value => _portTypeSerial = value);
            ParseElementTag("PortTypeUDP", nameof(PortTypeUDP), _portTypeUDP, value => _portTypeUDP = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
            ParseElementTag("SetCommunity", nameof(SetCommunity), _setCommunity, value => _setCommunity = value);
            ParseElementTag("SlowPoll", nameof(SlowPoll), _slowPoll, value => _slowPoll = value);
            ParseElementTag("SlowPollBase", nameof(SlowPollBase), _slowPollBase, value => _slowPollBase = value);
            ParseElementTag("SSH", nameof(SSH), _sSH, value => _sSH = value);
            ParseElementTag("Stopbits", nameof(Stopbits), _stopbits, value => _stopbits = value);
            ParseElementTag("TimeoutTimeElement", nameof(TimeoutTimeElement), _timeoutTimeElement, value => _timeoutTimeElement = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMain(this);
        }
    }

    ///<summary>
    /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
internal partial class PortSettingsMainBaudrate : SimpleProtocolListNode<PortSettingsMainBaudrateValue>, IPortSettingsMainBaudrate
    {
        internal PortSettingsMainBaudrate(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Baudrate", "Value")
        {
        }

        private PortSettingsMainBaudrateDefaultValue _defaultValue;
        private PortSettingsMainBaudrateDisabled _disabled;
        private PortSettingsMainBaudrateRange _range;
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
public IPortSettingsMainBaudrateDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsMainBaudrateDisabled Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
public IPortSettingsMainBaudrateRange Range => _range;

        IPortSettingsMainBaudrateValue IReadOnlyList<IPortSettingsMainBaudrateValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsMainBaudrateValue> IEnumerable<IPortSettingsMainBaudrateValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrate(this);
        }
    }

    ///<summary>
    /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
    ///</summary>
internal partial class PortSettingsMainBaudrateDefaultValue : ElementValueTag<uint?>, IPortSettingsMainBaudrateDefaultValue
    {
        internal PortSettingsMainBaudrateDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrateDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the baud rate can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsMainBaudrateDisabled : ElementValueTag<bool?>, IPortSettingsMainBaudrateDisabled
    {
        internal PortSettingsMainBaudrateDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrateDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
internal partial class PortSettingsMainBaudrateRange : ElementTag, IPortSettingsMainBaudrateRange
    {
        internal PortSettingsMainBaudrateRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<uint?> _from;
        private ElementValueTag<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
public IValueTag<uint?> From => _from;
        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
public IValueTag<uint?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrateRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
internal partial class PortSettingsMainBaudrateValue : ElementValueTag<string>, IPortSettingsMainBaudrateValue
    {
        internal PortSettingsMainBaudrateValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrateValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
internal partial class PortSettingsMainBusAddress : SimpleProtocolListNode<PortSettingsMainBusAddressValue>, IPortSettingsMainBusAddress
    {
        internal PortSettingsMainBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress", "Value")
        {
        }

        private PortSettingsMainBusAddressDefaultValue _defaultValue;
        private PortSettingsMainBusAddressDisabled _disabled;
        private PortSettingsMainBusAddressRange _range;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IPortSettingsMainBusAddressDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsMainBusAddressDisabled Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public IPortSettingsMainBusAddressRange Range => _range;

        IPortSettingsMainBusAddressValue IReadOnlyList<IPortSettingsMainBusAddressValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsMainBusAddressValue> IEnumerable<IPortSettingsMainBusAddressValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddress(this);
        }
    }

    ///<summary>
    /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
    /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
    ///</summary>
internal partial class PortSettingsMainBusAddressDefaultValue : ElementValueTag<string>, IPortSettingsMainBusAddressDefaultValue
    {
        internal PortSettingsMainBusAddressDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddressDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the bus address can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsMainBusAddressDisabled : ElementValueTag<bool?>, IPortSettingsMainBusAddressDisabled
    {
        internal PortSettingsMainBusAddressDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddressDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
internal partial class PortSettingsMainBusAddressRange : ElementTag, IPortSettingsMainBusAddressRange
    {
        internal PortSettingsMainBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddressRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class PortSettingsMainBusAddressValue : ElementValueTag<string>, IPortSettingsMainBusAddressValue
    {
        internal PortSettingsMainBusAddressValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddressValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
internal partial class PortSettingsMainDatabits : SimpleProtocolListNode<PortSettingsMainDatabitsValue>, IPortSettingsMainDatabits
    {
        internal PortSettingsMainDatabits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Databits", "Value")
        {
        }

        private PortSettingsMainDatabitsDefaultValue _defaultValue;
        private PortSettingsMainDatabitsDisabled _disabled;
        private PortSettingsMainDatabitsRange _range;
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
public IPortSettingsMainDatabitsDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsMainDatabitsDisabled Disabled => _disabled;
        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
public IPortSettingsMainDatabitsRange Range => _range;

        IPortSettingsMainDatabitsValue IReadOnlyList<IPortSettingsMainDatabitsValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsMainDatabitsValue> IEnumerable<IPortSettingsMainDatabitsValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabits(this);
        }
    }

    ///<summary>
    /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
    ///</summary>
internal partial class PortSettingsMainDatabitsDefaultValue : ElementValueTag<string>, IPortSettingsMainDatabitsDefaultValue
    {
        internal PortSettingsMainDatabitsDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabitsDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the databits can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsMainDatabitsDisabled : ElementValueTag<bool?>, IPortSettingsMainDatabitsDisabled
    {
        internal PortSettingsMainDatabitsDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabitsDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
internal partial class PortSettingsMainDatabitsRange : ElementTag, IPortSettingsMainDatabitsRange
    {
        internal PortSettingsMainDatabitsRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<uint?> _from;
        private ElementValueTag<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
public IValueTag<uint?> From => _from;
        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
public IValueTag<uint?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabitsRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class PortSettingsMainDatabitsValue : ElementValueTag<uint?>, IPortSettingsMainDatabitsValue
    {
        internal PortSettingsMainDatabitsValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabitsValue(this);
        }
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
internal partial class PortSettingsMainFlowcontrol : SimpleProtocolListNode<PortSettingsMainFlowcontrolValue>, IPortSettingsMainFlowcontrol
    {
        internal PortSettingsMainFlowcontrol(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Flowcontrol", "Value")
        {
        }

        private PortSettingsMainFlowcontrolDefaultValue _defaultValue;
        private PortSettingsMainFlowcontrolDisabled _disabled;
        private PortSettingsMainFlowcontrolRange _range;
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
public IPortSettingsMainFlowcontrolDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsMainFlowcontrolDisabled Disabled => _disabled;
        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
public IPortSettingsMainFlowcontrolRange Range => _range;

        IPortSettingsMainFlowcontrolValue IReadOnlyList<IPortSettingsMainFlowcontrolValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsMainFlowcontrolValue> IEnumerable<IPortSettingsMainFlowcontrolValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrol(this);
        }
    }

    ///<summary>
    /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
    ///</summary>
internal partial class PortSettingsMainFlowcontrolDefaultValue : ElementValueTag<Enums.EnumPortSettingsFlowControl?>, IPortSettingsMainFlowcontrolDefaultValue
    {
        internal PortSettingsMainFlowcontrolDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrolDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the flow control can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsMainFlowcontrolDisabled : ElementValueTag<bool?>, IPortSettingsMainFlowcontrolDisabled
    {
        internal PortSettingsMainFlowcontrolDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrolDisabled(this);
        }
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
internal partial class PortSettingsMainFlowcontrolRange : ElementTag, IPortSettingsMainFlowcontrolRange
    {
        internal PortSettingsMainFlowcontrolRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private PortSettingsMainFlowcontrolRangeFrom _from;
        private PortSettingsMainFlowcontrolRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsFlowControl?> From => _from;
        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsFlowControl?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrolRange(this);
        }
    }

    internal partial class PortSettingsMainFlowcontrolRangeFrom : ElementValueTag<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsMainFlowcontrolRangeFrom(ProtocolModel model, ProtocolTag parent) : base(model, parent, "From")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class PortSettingsMainFlowcontrolRangeTo : ElementValueTag<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsMainFlowcontrolRangeTo(ProtocolModel model, ProtocolTag parent) : base(model, parent, "To")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
internal partial class PortSettingsMainFlowcontrolValue : ElementValueTag<Enums.EnumPortSettingsFlowControl?>, IPortSettingsMainFlowcontrolValue
    {
        internal PortSettingsMainFlowcontrolValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrolValue(this);
        }
    }

    ///<summary>
    /// Specifies the GetCommunity string of an SNMP protocol.
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
internal partial class PortSettingsMainGetCommunity : ElementTag, IPortSettingsMainGetCommunity
    {
        internal PortSettingsMainGetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "GetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value of the GetCommunity string that will be used in the DataMiner user interface for SNMP protocols.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the get community string can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainGetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies the IP port configuration.
    ///</summary>
internal partial class PortSettingsMainIPport : ElementTag, IPortSettingsMainIPport
    {
        internal PortSettingsMainIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the port number can be configured via the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainIPport(this);
        }
    }

    ///<summary>
    /// Specifies the local IP port configuration.
    ///</summary>
internal partial class PortSettingsMainLocalIPport : ElementTag, IPortSettingsMainLocalIPport
    {
        internal PortSettingsMainLocalIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LocalIPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the local port number can be configured via the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainLocalIPport(this);
        }
    }

    ///<summary>
    /// Allows to limit parity settings and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
internal partial class PortSettingsMainParity : SimpleProtocolListNode<PortSettingsMainParityValue>, IPortSettingsMainParity
    {
        internal PortSettingsMainParity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Parity", "Value")
        {
        }

        private PortSettingsMainParityDefaultValue _defaultValue;
        private PortSettingsMainParityDisabled _disabled;
        private PortSettingsMainParityRange _range;
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
public IPortSettingsMainParityDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsMainParityDisabled Disabled => _disabled;
        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
public IPortSettingsMainParityRange Range => _range;

        IPortSettingsMainParityValue IReadOnlyList<IPortSettingsMainParityValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsMainParityValue> IEnumerable<IPortSettingsMainParityValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParity(this);
        }
    }

    ///<summary>
    /// Specifies the default parity.
    ///</summary>
internal partial class PortSettingsMainParityDefaultValue : ElementValueTag<Enums.EnumPortSettingsParity?>, IPortSettingsMainParityDefaultValue
    {
        internal PortSettingsMainParityDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParityDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the parity can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsMainParityDisabled : ElementValueTag<bool?>, IPortSettingsMainParityDisabled
    {
        internal PortSettingsMainParityDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParityDisabled(this);
        }
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
internal partial class PortSettingsMainParityRange : ElementTag, IPortSettingsMainParityRange
    {
        internal PortSettingsMainParityRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private PortSettingsMainParityRangeFrom _from;
        private PortSettingsMainParityRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsParity?> From => _from;
        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
public IValueTag<Enums.EnumPortSettingsParity?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParityRange(this);
        }
    }

    internal partial class PortSettingsMainParityRangeFrom : ElementValueTag<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsMainParityRangeFrom(ProtocolModel model, ProtocolTag parent) : base(model, parent, "From")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    internal partial class PortSettingsMainParityRangeTo : ElementValueTag<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsMainParityRangeTo(ProtocolModel model, ProtocolTag parent) : base(model, parent, "To")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
internal partial class PortSettingsMainParityValue : ElementValueTag<Enums.EnumPortSettingsParity?>, IPortSettingsMainParityValue
    {
        internal PortSettingsMainParityValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParityValue(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
internal partial class PortSettingsMainPortTypeIP : ElementTag, IPortSettingsMainPortTypeIP
    {
        internal PortSettingsMainPortTypeIP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeIP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainPortTypeIP(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
internal partial class PortSettingsMainPortTypeSerial : ElementTag, IPortSettingsMainPortTypeSerial
    {
        internal PortSettingsMainPortTypeSerial(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeSerial")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainPortTypeSerial(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
internal partial class PortSettingsMainPortTypeUDP : ElementTag, IPortSettingsMainPortTypeUDP
    {
        internal PortSettingsMainPortTypeUDP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeUDP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainPortTypeUDP(this);
        }
    }

    ///<summary>
    /// Configures the number of retries.
    ///</summary>
internal partial class PortSettingsMainRetries : ElementTag, IPortSettingsMainRetries
    {
        internal PortSettingsMainRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value for the maximum number of times that a request will be re-sent.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the maximum number of retries can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainRetries(this);
        }
    }

    ///<summary>
    /// Specifies the SNMP set community string.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
internal partial class PortSettingsMainSetCommunity : ElementTag, IPortSettingsMainSetCommunity
    {
        internal PortSettingsMainSetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default value of the SNMP set community string that will be used.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the SetCommunity string can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies the SSH settings (only applicable for serial connections of type TCP).
    /// Feature introduced in DataMiner 9.5.9 (RN 17732).
    ///</summary>
internal partial class PortSettingsMainSSH : ElementTag, IPortSettingsMainSSH
    {
        internal PortSettingsMainSSH(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SSH")
        {
        }

        private PortSettingsMainSSHCredentials _credentials;
        private PortSettingsMainSSHIdentity _identity;
        ///<summary>
        /// Specifies the SSH credentials.
        ///</summary>
public IPortSettingsMainSSHCredentials Credentials => _credentials;
        ///<summary>
        /// Specifies the identity settings.
        ///</summary>
public IPortSettingsMainSSHIdentity Identity => _identity;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Credentials", nameof(Credentials), _credentials, value => _credentials = value);
            ParseElementTag("Identity", nameof(Identity), _identity, value => _identity = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSH(this);
        }
    }

    ///<summary>
    /// Specifies the SSH credentials.
    ///</summary>
internal partial class PortSettingsMainSSHCredentials : ElementTag, IPortSettingsMainSSHCredentials
    {
        internal PortSettingsMainSSHCredentials(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Credentials")
        {
        }

        private PortSettingsMainSSHCredentialsUsername _username;
        private PortSettingsMainSSHCredentialsPassword _password;
        ///<summary>
        /// Specifies the user name.
        ///</summary>
public IPortSettingsMainSSHCredentialsUsername Username => _username;
        ///<summary>
        /// Specifies the password.
        ///</summary>
public IPortSettingsMainSSHCredentialsPassword Password => _password;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Username", nameof(Username), _username, value => _username = value);
            ParseElementTag("Password", nameof(Password), _password, value => _password = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSHCredentials(this);
        }
    }

    ///<summary>
    /// Specifies the user name.
    ///</summary>
internal partial class PortSettingsMainSSHCredentialsUsername : ElementTag, IPortSettingsMainSSHCredentialsUsername
    {
        internal PortSettingsMainSSHCredentialsUsername(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Username")
        {
        }

        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the user name.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSHCredentialsUsername(this);
        }
    }

    ///<summary>
    /// Specifies the password.
    ///</summary>
internal partial class PortSettingsMainSSHCredentialsPassword : ElementTag, IPortSettingsMainSSHCredentialsPassword
    {
        internal PortSettingsMainSSHCredentialsPassword(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Password")
        {
        }

        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the password.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSHCredentialsPassword(this);
        }
    }

    ///<summary>
    /// Specifies the identity settings.
    ///</summary>
internal partial class PortSettingsMainSSHIdentity : ElementTag, IPortSettingsMainSSHIdentity
    {
        internal PortSettingsMainSSHIdentity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Identity")
        {
        }

        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the identity info.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSHIdentity(this);
        }
    }

    ///<summary>
    /// Specifies the stop bits settings.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
internal partial class PortSettingsMainStopbits : SimpleProtocolListNode<PortSettingsMainStopbitsValue>, IPortSettingsMainStopbits
    {
        internal PortSettingsMainStopbits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Stopbits", "Value")
        {
        }

        private PortSettingsMainStopbitsDefaultValue _defaultValue;
        private PortSettingsMainStopbitsDisabled _disabled;
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
public IPortSettingsMainStopbitsDefaultValue DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
public IPortSettingsMainStopbitsDisabled Disabled => _disabled;

        IPortSettingsMainStopbitsValue IReadOnlyList<IPortSettingsMainStopbitsValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<IPortSettingsMainStopbitsValue> IEnumerable<IPortSettingsMainStopbitsValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainStopbits(this);
        }
    }

    ///<summary>
    /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
    /// Set the default to one of the following integer values: 1, 1.5 or 2
    ///</summary>
internal partial class PortSettingsMainStopbitsDefaultValue : ElementValueTag<string>, IPortSettingsMainStopbitsDefaultValue
    {
        internal PortSettingsMainStopbitsDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainStopbitsDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
    ///</summary>
internal partial class PortSettingsMainStopbitsDisabled : ElementValueTag<bool?>, IPortSettingsMainStopbitsDisabled
    {
        internal PortSettingsMainStopbitsDisabled(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Disabled")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainStopbitsDisabled(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
internal partial class PortSettingsMainStopbitsValue : ElementValueTag<Enums.EnumPortSettingsStopBits?>, IPortSettingsMainStopbitsValue
    {
        internal PortSettingsMainStopbitsValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override Enums.EnumPortSettingsStopBits? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsStopBitsConverter.Convert(rawValue?.Trim());
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainStopbitsValue(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the element timeout.
    ///</summary>
internal partial class PortSettingsMainTimeoutTimeElement : ElementTag, IPortSettingsMainTimeoutTimeElement
    {
        internal PortSettingsMainTimeoutTimeElement(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTimeElement")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default element timeout value (in milliseconds). The specified value must be in the range [1000, 120000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the element timeout time for this connection can be configured via the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainTimeoutTimeElement(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the timeout of a command/request.
    ///</summary>
internal partial class PortSettingsMainTimeoutTime : ElementTag, IPortSettingsMainTimeoutTime
    {
        internal PortSettingsMainTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default timeout value (in milliseconds).
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the timeout value can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainTimeoutTime(this);
        }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
internal partial class PortSettingsMainType : ElementTag, IPortSettingsMainType
    {
        internal PortSettingsMainType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private PortSettingsMainTypeDefaultValue _defaultValue;
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
public IValueTag<Enums.EnumPortTypes?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainType(this);
        }
    }

    internal partial class PortSettingsMainTypeDefaultValue : ElementValueTag<Enums.EnumPortTypes?>
    {
        internal PortSettingsMainTypeDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines port settings with values.
    ///</summary>
internal partial class PortSettingsWithValues : ElementTag, IPortSettingsWithValues
    {
        internal PortSettingsWithValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortSettingsWithValues")
        {
        }

        private PortSettingsWithValuesBaudrate _baudrate;
        private PortSettingsWithValuesBusAddress _busAddress;
        private PortSettingsWithValuesDatabits _databits;
        private PortSettingsWithValuesFlowcontrol _flowcontrol;
        private PortSettingsWithValuesGetCommunity _getCommunity;
        private PortSettingsWithValuesIPport _iPport;
        private PortSettingsWithValuesLocalIPport _localIPport;
        private PortSettingsWithValuesParity _parity;
        private PingInterval _pingInterval;
        private PortSettingsWithValuesPortTypeIP _portTypeIP;
        private PortSettingsWithValuesPortTypeSerial _portTypeSerial;
        private PortSettingsWithValuesPortTypeUDP _portTypeUDP;
        private PortSettingsWithValuesRetries _retries;
        private PortSettingsWithValuesSetCommunity _setCommunity;
        private SlowPoll _slowPoll;
        private SlowPoll _slowPollBase;
        private PortSettingsWithValuesStopbits _stopbits;
        private SlowPoll _timeoutTimeElement;
        private PortSettingsWithValuesTimeoutTime _timeoutTime;
        private PortSettingsWithValuesType _type;
        private AttributeTag<string> _name;
        private AttributeTag<bool?> _visibleInUi;
        ///<summary>
        /// This tag allows you to limit the baud rate settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public IPortSettingsWithValuesBaudrate Baudrate => _baudrate;
        ///<summary>
        /// This tag allows you to limit the bus address settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public IPortSettingsWithValuesBusAddress BusAddress => _busAddress;
        ///<summary>
        /// This tag allows you to specify the possible databits settings, and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
public IPortSettingsWithValuesDatabits Databits => _databits;
        ///<summary>
        /// This tag allows you to specify the possible flow control settings, and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
public IPortSettingsWithValuesFlowcontrol Flowcontrol => _flowcontrol;
        ///<summary>
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
public IPortSettingsWithValuesGetCommunity GetCommunity => _getCommunity;
        ///<summary>
        /// Specifies settings related to the port.
        ///</summary>
public IPortSettingsWithValuesIPport IPport => _iPport;
        ///<summary>
        /// Specifies settings related to the local port.
        ///</summary>
public IPortSettingsWithValuesLocalIPport LocalIPport => _localIPport;
        ///<summary>
        /// This tag allows you to specify the possible parity settings, and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
public IPortSettingsWithValuesParity Parity => _parity;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IPingInterval PingInterval => _pingInterval;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IPortSettingsWithValuesPortTypeIP PortTypeIP => _portTypeIP;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IPortSettingsWithValuesPortTypeSerial PortTypeSerial => _portTypeSerial;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IPortSettingsWithValuesPortTypeUDP PortTypeUDP => _portTypeUDP;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IPortSettingsWithValuesRetries Retries => _retries;
        ///<summary>
        /// SetCommunity string for SNMP and SNMPv2 communication.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
public IPortSettingsWithValuesSetCommunity SetCommunity => _setCommunity;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ISlowPoll SlowPoll => _slowPoll;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ISlowPoll SlowPollBase => _slowPollBase;
        ///<summary>
        /// This tag allows you to specify the possible stopbits settings, and to define a default value.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
public IPortSettingsWithValuesStopbits Stopbits => _stopbits;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ISlowPoll TimeoutTimeElement => _timeoutTimeElement;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IPortSettingsWithValuesTimeoutTime TimeoutTime => _timeoutTime;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IPortSettingsWithValuesType Type => _type;
        ///<summary>
        /// Name of the port to which the port settings apply
        /// OR
        /// The name of the additional Protocol type as specified in the /Protocol/Type@advanced attribute.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// If you set this attribute to "false", users cannot see or change the port settings for this additional protocol type when creating or editing an element.
        ///</summary>
public IValueTag<bool?> VisibleInUi => _visibleInUi;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("visibleInUi", nameof(VisibleInUi), _visibleInUi, value => _visibleInUi = value);
            ParseElementTag("Baudrate", nameof(Baudrate), _baudrate, value => _baudrate = value);
            ParseElementTag("BusAddress", nameof(BusAddress), _busAddress, value => _busAddress = value);
            ParseElementTag("Databits", nameof(Databits), _databits, value => _databits = value);
            ParseElementTag("Flowcontrol", nameof(Flowcontrol), _flowcontrol, value => _flowcontrol = value);
            ParseElementTag("GetCommunity", nameof(GetCommunity), _getCommunity, value => _getCommunity = value);
            ParseElementTag("IPport", nameof(IPport), _iPport, value => _iPport = value);
            ParseElementTag("LocalIPport", nameof(LocalIPport), _localIPport, value => _localIPport = value);
            ParseElementTag("Parity", nameof(Parity), _parity, value => _parity = value);
            ParseElementTag("PingInterval", nameof(PingInterval), _pingInterval, value => _pingInterval = value);
            ParseElementTag("PortTypeIP", nameof(PortTypeIP), _portTypeIP, value => _portTypeIP = value);
            ParseElementTag("PortTypeSerial", nameof(PortTypeSerial), _portTypeSerial, value => _portTypeSerial = value);
            ParseElementTag("PortTypeUDP", nameof(PortTypeUDP), _portTypeUDP, value => _portTypeUDP = value);
            ParseElementTag("Retries", nameof(Retries), _retries, value => _retries = value);
            ParseElementTag("SetCommunity", nameof(SetCommunity), _setCommunity, value => _setCommunity = value);
            ParseElementTag("SlowPoll", nameof(SlowPoll), _slowPoll, value => _slowPoll = value);
            ParseElementTag("SlowPollBase", nameof(SlowPollBase), _slowPollBase, value => _slowPollBase = value);
            ParseElementTag("Stopbits", nameof(Stopbits), _stopbits, value => _stopbits = value);
            ParseElementTag("TimeoutTimeElement", nameof(TimeoutTimeElement), _timeoutTimeElement, value => _timeoutTimeElement = value);
            ParseElementTag("TimeoutTime", nameof(TimeoutTime), _timeoutTime, value => _timeoutTime = value);
            ParseElementTag("Type", nameof(Type), _type, value => _type = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValues(this);
        }
    }

    ///<summary>
    /// This tag allows you to limit the baud rate settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
internal partial class PortSettingsWithValuesBaudrate : ElementTag, IPortSettingsWithValuesBaudrate
    {
        internal PortSettingsWithValuesBaudrate(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Baudrate")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private PortSettingsWithValuesBaudrateRange _range;
        private PortSettingsWithValuesBaudrateValues _values;
        ///<summary>
        /// This tag can be used to define a default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// This tag allows you to define a range of possible baud rate settings.
        ///</summary>
public IPortSettingsWithValuesBaudrateRange Range => _range;
        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public IPortSettingsWithValuesBaudrateValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBaudrate(this);
        }
    }

    ///<summary>
    /// This tag allows you to define a range of possible baud rate settings.
    ///</summary>
internal partial class PortSettingsWithValuesBaudrateRange : ElementTag, IPortSettingsWithValuesBaudrateRange
    {
        internal PortSettingsWithValuesBaudrateRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<uint?> _from;
        private ElementValueTag<uint?> _to;
        ///<summary>
        /// In this tag, you can specify the first of a range of baud rates.
        ///</summary>
public IValueTag<uint?> From => _from;
        ///<summary>
        /// In this tag, you can specify the last of a range of baud rates.
        ///</summary>
public IValueTag<uint?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBaudrateRange(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
internal partial class PortSettingsWithValuesBaudrateValues : ElementTag, IPortSettingsWithValuesBaudrateValues
    {
        internal PortSettingsWithValuesBaudrateValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values")
        {
        }

        private ElementValueTag<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public IValueTag<string> ValueElement => _valueElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBaudrateValues(this);
        }
    }

    ///<summary>
    /// This tag allows you to limit the bus address settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
internal partial class PortSettingsWithValuesBusAddress : ElementTag, IPortSettingsWithValuesBusAddress
    {
        internal PortSettingsWithValuesBusAddress(ProtocolModel model, ProtocolTag parent) : base(model, parent, "BusAddress")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private PortSettingsWithValuesBusAddressRange _range;
        private PortSettingsWithValuesBusAddressValues _values;
        ///<summary>
        /// This tag can be used to define a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// This tag allows you to define a range of possible bus addresses.
        ///</summary>
public IPortSettingsWithValuesBusAddressRange Range => _range;
        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public IPortSettingsWithValuesBusAddressValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBusAddress(this);
        }
    }

    ///<summary>
    /// This tag allows you to define a range of possible bus addresses.
    ///</summary>
internal partial class PortSettingsWithValuesBusAddressRange : ElementTag, IPortSettingsWithValuesBusAddressRange
    {
        internal PortSettingsWithValuesBusAddressRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<string> _from;
        private ElementValueTag<string> _to;
        ///<summary>
        /// In this tag, you can specify the first of a range of bus addresses.
        ///</summary>
public IValueTag<string> From => _from;
        ///<summary>
        /// In this tag, you can specify the last of a range of bus addresses.
        ///</summary>
public IValueTag<string> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBusAddressRange(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
internal partial class PortSettingsWithValuesBusAddressValues : ElementTag, IPortSettingsWithValuesBusAddressValues
    {
        internal PortSettingsWithValuesBusAddressValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values")
        {
        }

        private ElementValueTag<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public IValueTag<string> ValueElement => _valueElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBusAddressValues(this);
        }
    }

    ///<summary>
    /// This tag allows you to specify the possible databits settings, and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
internal partial class PortSettingsWithValuesDatabits : ElementTag, IPortSettingsWithValuesDatabits
    {
        internal PortSettingsWithValuesDatabits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Databits")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private PortSettingsWithValuesDatabitsRange _range;
        private PortSettingsWithValuesDatabitsValues _values;
        ///<summary>
        /// This tag can be used to define a default databits value. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// This tag allows you to define a range of possible databits settings.
        ///</summary>
public IPortSettingsWithValuesDatabitsRange Range => _range;
        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public IPortSettingsWithValuesDatabitsValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Range", nameof(Range), _range, value => _range = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesDatabits(this);
        }
    }

    ///<summary>
    /// This tag allows you to define a range of possible databits settings.
    ///</summary>
internal partial class PortSettingsWithValuesDatabitsRange : ElementTag, IPortSettingsWithValuesDatabitsRange
    {
        internal PortSettingsWithValuesDatabitsRange(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Range")
        {
        }

        private ElementValueTag<uint?> _from;
        private ElementValueTag<uint?> _to;
        ///<summary>
        /// In this tag, you can specify the first of a range of databits settings.
        ///</summary>
public IValueTag<uint?> From => _from;
        ///<summary>
        /// In this tag, you can specify the last of a range of databits settings.
        ///</summary>
public IValueTag<uint?> To => _to;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("From", nameof(From), _from, value => _from = value);
            ParseElementTag("To", nameof(To), _to, value => _to = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesDatabitsRange(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
internal partial class PortSettingsWithValuesDatabitsValues : ElementTag, IPortSettingsWithValuesDatabitsValues
    {
        internal PortSettingsWithValuesDatabitsValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values")
        {
        }

        private ElementValueTag<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not need to defined here again.
        /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public IValueTag<string> ValueElement => _valueElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesDatabitsValues(this);
        }
    }

    ///<summary>
    /// This tag allows you to specify the possible flow control settings, and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
internal partial class PortSettingsWithValuesFlowcontrol : ElementTag, IPortSettingsWithValuesFlowcontrol
    {
        internal PortSettingsWithValuesFlowcontrol(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Flowcontrol")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private PortSettingsWithValuesFlowcontrolValues _values;
        ///<summary>
        /// This tag can be used to define a default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public IPortSettingsWithValuesFlowcontrolValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesFlowcontrol(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
internal partial class PortSettingsWithValuesFlowcontrolValues : ElementTag, IPortSettingsWithValuesFlowcontrolValues
    {
        internal PortSettingsWithValuesFlowcontrolValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values")
        {
        }

        private ElementValueTag<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public IValueTag<string> ValueElement => _valueElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesFlowcontrolValues(this);
        }
    }

    ///<summary>
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
internal partial class PortSettingsWithValuesGetCommunity : ElementTag, IPortSettingsWithValuesGetCommunity
    {
        internal PortSettingsWithValuesGetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "GetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesGetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the port.
    ///</summary>
internal partial class PortSettingsWithValuesIPport : ElementTag, IPortSettingsWithValuesIPport
    {
        internal PortSettingsWithValuesIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "IPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the user is be able to set the port number.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesIPport(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the local port.
    ///</summary>
internal partial class PortSettingsWithValuesLocalIPport : ElementTag, IPortSettingsWithValuesLocalIPport
    {
        internal PortSettingsWithValuesLocalIPport(ProtocolModel model, ProtocolTag parent) : base(model, parent, "LocalIPport")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// Specifies whether the user is able to set the local port number.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesLocalIPport(this);
        }
    }

    ///<summary>
    /// This tag allows you to specify the possible parity settings, and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
internal partial class PortSettingsWithValuesParity : ElementTag, IPortSettingsWithValuesParity
    {
        internal PortSettingsWithValuesParity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Parity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private PortSettingsWithValuesParityValues _values;
        ///<summary>
        /// This tag can be used to define a default parity. Each time a user adds an Element using the Element wizard, the parity will by default be set to this value.
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public IPortSettingsWithValuesParityValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesParity(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
internal partial class PortSettingsWithValuesParityValues : ElementTag, IPortSettingsWithValuesParityValues
    {
        internal PortSettingsWithValuesParityValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values")
        {
        }

        private ElementValueTag<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public IValueTag<string> ValueElement => _valueElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesParityValues(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class PortSettingsWithValuesPortTypeIP : ElementTag, IPortSettingsWithValuesPortTypeIP
    {
        internal PortSettingsWithValuesPortTypeIP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeIP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'TCP/IP'.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesPortTypeIP(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class PortSettingsWithValuesPortTypeSerial : ElementTag, IPortSettingsWithValuesPortTypeSerial
    {
        internal PortSettingsWithValuesPortTypeSerial(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeSerial")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'serial'.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesPortTypeSerial(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class PortSettingsWithValuesPortTypeUDP : ElementTag, IPortSettingsWithValuesPortTypeUDP
    {
        internal PortSettingsWithValuesPortTypeUDP(ProtocolModel model, ProtocolTag parent) : base(model, parent, "PortTypeUDP")
        {
        }

        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'UDP/IP'.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesPortTypeUDP(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class PortSettingsWithValuesRetries : ElementTag, IPortSettingsWithValuesRetries
    {
        internal PortSettingsWithValuesRetries(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Retries")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesRetries(this);
        }
    }

    ///<summary>
    /// SetCommunity string for SNMP and SNMPv2 communication.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
internal partial class PortSettingsWithValuesSetCommunity : ElementTag, IPortSettingsWithValuesSetCommunity
    {
        internal PortSettingsWithValuesSetCommunity(ProtocolModel model, ProtocolTag parent) : base(model, parent, "SetCommunity")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesSetCommunity(this);
        }
    }

    ///<summary>
    /// This tag allows you to specify the possible stopbits settings, and to define a default value.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
internal partial class PortSettingsWithValuesStopbits : ElementTag, IPortSettingsWithValuesStopbits
    {
        internal PortSettingsWithValuesStopbits(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Stopbits")
        {
        }

        private ElementValueTag<string> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        private PortSettingsWithValuesStopbitsValues _values;
        ///<summary>
        /// This tag can be used to define a default stopbits value. Each time a user adds an Element using the Element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values:	1, 1.5 or 2
        ///</summary>
public IValueTag<string> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;
        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public IPortSettingsWithValuesStopbitsValues Values => _values;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
            ParseElementTag("Values", nameof(Values), _values, value => _values = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesStopbits(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
internal partial class PortSettingsWithValuesStopbitsValues : ElementTag, IPortSettingsWithValuesStopbitsValues
    {
        internal PortSettingsWithValuesStopbitsValues(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Values")
        {
        }

        private ElementValueTag<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public IValueTag<string> ValueElement => _valueElement;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Value", nameof(ValueElement), _valueElement, value => _valueElement = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesStopbitsValues(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class PortSettingsWithValuesTimeoutTime : ElementTag, IPortSettingsWithValuesTimeoutTime
    {
        internal PortSettingsWithValuesTimeoutTime(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TimeoutTime")
        {
        }

        private ElementValueTag<uint?> _defaultValue;
        private ElementValueTag<bool?> _disabled;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<uint?> DefaultValue => _defaultValue;
        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public IValueTag<bool?> Disabled => _disabled;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
            ParseElementTag("Disabled", nameof(Disabled), _disabled, value => _disabled = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesTimeoutTime(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
internal partial class PortSettingsWithValuesType : ElementTag, IPortSettingsWithValuesType
    {
        internal PortSettingsWithValuesType(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Type")
        {
        }

        private PortSettingsWithValuesTypeDefaultValue _defaultValue;
        ///<summary>
        /// In this tag, specify which port type should be preselected.
        ///</summary>
public IValueTag<Enums.EnumPortTypes?> DefaultValue => _defaultValue;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("DefaultValue", nameof(DefaultValue), _defaultValue, value => _defaultValue = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesType(this);
        }
    }

    internal partial class PortSettingsWithValuesTypeDefaultValue : ElementValueTag<Enums.EnumPortTypes?>
    {
        internal PortSettingsWithValuesTypeDefaultValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "DefaultValue")
        {
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies how a cell in a CPE topology is linked to another cell in that topology, using foreign key relations (which can also be inside the same table).
    ///</summary>
internal partial class TypeTopologyCellLink : ElementTag, ITypeTopologyCellLink
    {
        internal TypeTopologyCellLink(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeTopologyCellLink")
        {
        }

        private AttributeTag<uint?> _dest;
        private AttributeTag<uint?> _source;
        ///<summary>
        /// (CPE) Specifies the ID of the parameter column if you want to make a topology with foreign key relations inside a table.
        ///</summary>
public IValueTag<uint?> Dest => _dest;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<uint?> Source => _source;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("dest", nameof(Dest), _dest, value => _dest = value);
            ParseAttributeTag("source", nameof(Source), _source, value => _source = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeTopologyCellLink(this);
        }
    }

    ///<summary>
    /// Configures chain display settings.
    ///</summary>
internal partial class TypeChainsChainDisplay : ElementTag, ITypeChainsChainDisplay
    {
        internal TypeChainsChainDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeChainsChainDisplay")
        {
        }

        private TypeChainsChainDisplayVisibility _visibility;
        public ITypeChainsChainDisplayVisibility Visibility => _visibility;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Visibility", nameof(Visibility), _visibility, value => _visibility = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainDisplay(this);
        }
    }

    internal partial class TypeChainsChainDisplayVisibility : SimpleProtocolListNode<TypeChainsChainDisplayVisibilityStandalone>, ITypeChainsChainDisplayVisibility
    {
        internal TypeChainsChainDisplayVisibility(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Visibility", "Standalone")
        {
        }

        private AttributeTag<bool?> _default;
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
public IValueTag<bool?> Default => _default;

        ITypeChainsChainDisplayVisibilityStandalone IReadOnlyList<ITypeChainsChainDisplayVisibilityStandalone>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsChainDisplayVisibilityStandalone> IEnumerable<ITypeChainsChainDisplayVisibilityStandalone>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("default", nameof(Default), _default, value => _default = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainDisplayVisibility(this);
        }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
internal partial class TypeChainsChainDisplayVisibilityStandalone : SimpleProtocolListNode<TypeChainsChainDisplayVisibilityStandaloneValue>, ITypeChainsChainDisplayVisibilityStandalone
    {
        internal TypeChainsChainDisplayVisibilityStandalone(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Standalone", "Value")
        {
        }

        private AttributeTag<uint?> _pid;
        public IValueTag<uint?> Pid => _pid;

        ITypeChainsChainDisplayVisibilityStandaloneValue IReadOnlyList<ITypeChainsChainDisplayVisibilityStandaloneValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsChainDisplayVisibilityStandaloneValue> IEnumerable<ITypeChainsChainDisplayVisibilityStandaloneValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainDisplayVisibilityStandalone(this);
        }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
internal partial class TypeChainsChainDisplayVisibilityStandaloneValue : ElementValueTag<string>, ITypeChainsChainDisplayVisibilityStandaloneValue
    {
        internal TypeChainsChainDisplayVisibilityStandaloneValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainDisplayVisibilityStandaloneValue(this);
        }
    }

    ///<summary>
    /// Configures chain display settings.
    ///</summary>
internal partial class TypeChainsSearchChainDisplay : ElementTag, ITypeChainsSearchChainDisplay
    {
        internal TypeChainsSearchChainDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeChainsSearchChainDisplay")
        {
        }

        private TypeChainsSearchChainDisplayVisibility _visibility;
        public ITypeChainsSearchChainDisplayVisibility Visibility => _visibility;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Visibility", nameof(Visibility), _visibility, value => _visibility = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainDisplay(this);
        }
    }

    internal partial class TypeChainsSearchChainDisplayVisibility : SimpleProtocolListNode<TypeChainsSearchChainDisplayVisibilityStandalone>, ITypeChainsSearchChainDisplayVisibility
    {
        internal TypeChainsSearchChainDisplayVisibility(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Visibility", "Standalone")
        {
        }

        private AttributeTag<bool?> _default;
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
public IValueTag<bool?> Default => _default;

        ITypeChainsSearchChainDisplayVisibilityStandalone IReadOnlyList<ITypeChainsSearchChainDisplayVisibilityStandalone>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsSearchChainDisplayVisibilityStandalone> IEnumerable<ITypeChainsSearchChainDisplayVisibilityStandalone>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("default", nameof(Default), _default, value => _default = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainDisplayVisibility(this);
        }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
internal partial class TypeChainsSearchChainDisplayVisibilityStandalone : SimpleProtocolListNode<TypeChainsSearchChainDisplayVisibilityStandaloneValue>, ITypeChainsSearchChainDisplayVisibilityStandalone
    {
        internal TypeChainsSearchChainDisplayVisibilityStandalone(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Standalone", "Value")
        {
        }

        private AttributeTag<uint?> _pid;
        public IValueTag<uint?> Pid => _pid;

        ITypeChainsSearchChainDisplayVisibilityStandaloneValue IReadOnlyList<ITypeChainsSearchChainDisplayVisibilityStandaloneValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsSearchChainDisplayVisibilityStandaloneValue> IEnumerable<ITypeChainsSearchChainDisplayVisibilityStandaloneValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainDisplayVisibilityStandalone(this);
        }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
internal partial class TypeChainsSearchChainDisplayVisibilityStandaloneValue : ElementValueTag<string>, ITypeChainsSearchChainDisplayVisibilityStandaloneValue
    {
        internal TypeChainsSearchChainDisplayVisibilityStandaloneValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainDisplayVisibilityStandaloneValue(this);
        }
    }

    ///<summary>
    /// Configures chain field display settings.
    ///</summary>
internal partial class TypeChainsChainFieldDisplay : ElementTag, ITypeChainsChainFieldDisplay
    {
        internal TypeChainsChainFieldDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeChainsChainFieldDisplay")
        {
        }

        private TypeChainsChainFieldDisplaySelection _selection;
        public ITypeChainsChainFieldDisplaySelection Selection => _selection;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Selection", nameof(Selection), _selection, value => _selection = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplay(this);
        }
    }

    internal partial class TypeChainsChainFieldDisplaySelection : ElementTag, ITypeChainsChainFieldDisplaySelection
    {
        internal TypeChainsChainFieldDisplaySelection(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Selection")
        {
        }

        private TypeChainsChainFieldDisplaySelectionVisibility _visibility;
        public ITypeChainsChainFieldDisplaySelectionVisibility Visibility => _visibility;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Visibility", nameof(Visibility), _visibility, value => _visibility = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplaySelection(this);
        }
    }

    internal partial class TypeChainsChainFieldDisplaySelectionVisibility : SimpleProtocolListNode<TypeChainsChainFieldDisplaySelectionVisibilityStandalone>, ITypeChainsChainFieldDisplaySelectionVisibility
    {
        internal TypeChainsChainFieldDisplaySelectionVisibility(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Visibility", "Standalone")
        {
        }

        private AttributeTag<bool?> _default;
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
public IValueTag<bool?> Default => _default;

        ITypeChainsChainFieldDisplaySelectionVisibilityStandalone IReadOnlyList<ITypeChainsChainFieldDisplaySelectionVisibilityStandalone>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsChainFieldDisplaySelectionVisibilityStandalone> IEnumerable<ITypeChainsChainFieldDisplaySelectionVisibilityStandalone>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("default", nameof(Default), _default, value => _default = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplaySelectionVisibility(this);
        }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
internal partial class TypeChainsChainFieldDisplaySelectionVisibilityStandalone : SimpleProtocolListNode<TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue>, ITypeChainsChainFieldDisplaySelectionVisibilityStandalone
    {
        internal TypeChainsChainFieldDisplaySelectionVisibilityStandalone(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Standalone", "Value")
        {
        }

        private AttributeTag<uint?> _pid;
        public IValueTag<uint?> Pid => _pid;

        ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue IReadOnlyList<ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue> IEnumerable<ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplaySelectionVisibilityStandalone(this);
        }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
internal partial class TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue : ElementValueTag<string>, ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue
    {
        internal TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue(this);
        }
    }

    ///<summary>
    /// Defines a field to be included in this tab of the search chain.
    ///</summary>
internal partial class TypeChainsSearchChainTabsTabField : ElementTag, ITypeChainsSearchChainTabsTabField
    {
        internal TypeChainsSearchChainTabsTabField(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeChainsSearchChainTabsTabField")
        {
        }

        private TypeChainsSearchChainFieldDisplay _display;
        private TypeChainsSearchChainTabsTabFieldSubstitutions _substitutions;
        private TypeChainsSearchChainTabsTabFieldValidation _validation;
        private AttributeTag<uint?> _columnPid;
        private AttributeTag<string> _name;
        public ITypeChainsSearchChainFieldDisplay Display => _display;
        ///<summary>
        /// Defines possible substitutions to be applied to the field content.
        ///</summary>
public ITypeChainsSearchChainTabsTabFieldSubstitutions Substitutions => _substitutions;
        public ITypeChainsSearchChainTabsTabFieldValidation Validation => _validation;
        ///<summary>
        /// Specifies the column parameter ID of a column of the table referred to by the tablePid attribute of the enclosing Tab, or a column of a table that is linked with this table.
        ///</summary>
public IValueTag<uint?> ColumnPid => _columnPid;
        ///<summary>
        /// Specifies the name of the search field.
        ///</summary>
public IValueTag<string> Name => _name;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("columnPid", nameof(ColumnPid), _columnPid, value => _columnPid = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
            ParseElementTag("Substitutions", nameof(Substitutions), _substitutions, value => _substitutions = value);
            ParseElementTag("Validation", nameof(Validation), _validation, value => _validation = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabField(this);
        }
    }

    ///<summary>
    /// Defines possible substitutions to be applied to the field content.
    ///</summary>
internal partial class TypeChainsSearchChainTabsTabFieldSubstitutions : SimpleProtocolListNode<TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution>, ITypeChainsSearchChainTabsTabFieldSubstitutions
    {
        internal TypeChainsSearchChainTabsTabFieldSubstitutions(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Substitutions", "Substitution")
        {
        }

        ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution IReadOnlyList<ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution> IEnumerable<ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution>.GetEnumerator()
        {
            return GetEnumerator();
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabFieldSubstitutions(this);
        }
    }

    ///<summary>
    /// Defines a substitution to be applied on the field content.
    ///</summary>
internal partial class TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution : ElementTag, ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution
    {
        internal TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Substitution")
        {
        }

        private TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex _regex;
        ///<summary>
        /// Defines a substitution based on a regular expression.
        ///</summary>
public ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex Regex => _regex;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Regex", nameof(Regex), _regex, value => _regex = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution(this);
        }
    }

    ///<summary>
    /// Defines a substitution based on a regular expression.
    ///</summary>
internal partial class TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex : ElementTag, ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex
    {
        internal TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Regex")
        {
        }

        private ElementValueTag<string> _input;
        private ElementValueTag<string> _output;
        ///<summary>
        /// Specifies the regular expression defining the pattern of the field content.
        ///</summary>
public IValueTag<string> Input => _input;
        ///<summary>
        /// Defines the output after substitution.
        ///</summary>
public IValueTag<string> Output => _output;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Input", nameof(Input), _input, value => _input = value);
            ParseElementTag("Output", nameof(Output), _output, value => _output = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex(this);
        }
    }

    internal partial class TypeChainsSearchChainTabsTabFieldValidation : ElementTag, ITypeChainsSearchChainTabsTabFieldValidation
    {
        internal TypeChainsSearchChainTabsTabFieldValidation(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Validation")
        {
        }

        private ElementValueTag<string> _errorMessage;
        private ElementValueTag<string> _regex;
        ///<summary>
        /// Defines the error message to be displayed in case the input is invalid.
        ///</summary>
public IValueTag<string> ErrorMessage => _errorMessage;
        ///<summary>
        /// Defines the regular expression defining the pattern of allowed field content.
        ///</summary>
public IValueTag<string> Regex => _regex;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("ErrorMessage", nameof(ErrorMessage), _errorMessage, value => _errorMessage = value);
            ParseElementTag("Regex", nameof(Regex), _regex, value => _regex = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabFieldValidation(this);
        }
    }

    ///<summary>
    /// Configures chain field display settings.
    ///</summary>
internal partial class TypeChainsSearchChainFieldDisplay : ElementTag, ITypeChainsSearchChainFieldDisplay
    {
        internal TypeChainsSearchChainFieldDisplay(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeChainsSearchChainFieldDisplay")
        {
        }

        private TypeChainsSearchChainFieldDisplayVisibility _visibility;
        public ITypeChainsSearchChainFieldDisplayVisibility Visibility => _visibility;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseElementTag("Visibility", nameof(Visibility), _visibility, value => _visibility = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainFieldDisplay(this);
        }
    }

    internal partial class TypeChainsSearchChainFieldDisplayVisibility : SimpleProtocolListNode<TypeChainsSearchChainFieldDisplayVisibilityStandalone>, ITypeChainsSearchChainFieldDisplayVisibility
    {
        internal TypeChainsSearchChainFieldDisplayVisibility(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Visibility", "Standalone")
        {
        }

        private AttributeTag<bool?> _default;
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
public IValueTag<bool?> Default => _default;

        ITypeChainsSearchChainFieldDisplayVisibilityStandalone IReadOnlyList<ITypeChainsSearchChainFieldDisplayVisibilityStandalone>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsSearchChainFieldDisplayVisibilityStandalone> IEnumerable<ITypeChainsSearchChainFieldDisplayVisibilityStandalone>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("default", nameof(Default), _default, value => _default = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainFieldDisplayVisibility(this);
        }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
internal partial class TypeChainsSearchChainFieldDisplayVisibilityStandalone : SimpleProtocolListNode<TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue>, ITypeChainsSearchChainFieldDisplayVisibilityStandalone
    {
        internal TypeChainsSearchChainFieldDisplayVisibilityStandalone(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Standalone", "Value")
        {
        }

        private AttributeTag<uint?> _pid;
        public IValueTag<uint?> Pid => _pid;

        ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue IReadOnlyList<ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue> IEnumerable<ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainFieldDisplayVisibilityStandalone(this);
        }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
internal partial class TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue : ElementValueTag<string>, ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue
    {
        internal TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Value")
        {
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainFieldDisplayVisibilityStandaloneValue(this);
        }
    }

    ///<summary>
    /// Each field in a chain is a possible block in the drill-down diagram displayed on the visual pages of a CPE Manager.
    ///</summary>
internal partial class TypeChainsChainField : ElementTag, ITypeChainsChainField
    {
        internal TypeChainsChainField(ProtocolModel model, ProtocolTag parent) : base(model, parent, "TypeChainsChainField")
        {
        }

        private ElementValueTag<string> _diagramPids;
        private ElementValueTag<string> _diagramSorting;
        private ElementValueTag<string> _diagramTitleFormat;
        private TypeChainsChainFieldDisplay _display;
        private AttributeTag<string> _displayTable;
        private AttributeTag<string> _name;
        private AttributeTag<string> _options;
        private AttributeTag<uint?> _pid;
        ///<summary>
        /// Specifies the IDs of the (read) parameters to be shown in the diagram box.
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        ///</summary>
public IValueTag<string> DiagramPids => _diagramPids;
        ///<summary>
        /// Specifies the diagram item sort order.
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        ///</summary>
public IValueTag<string> DiagramSorting => _diagramSorting;
        ///<summary>
        /// Specifies a custom title for the diagram box (By default, the title is the corresponding display key).
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        /// Refer to the DataMiner Protocol Markup Language documentation for more information.
        ///</summary>
public IValueTag<string> DiagramTitleFormat => _diagramTitleFormat;
        public ITypeChainsChainFieldDisplay Display => _display;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> DisplayTable => _displayTable;
        ///<summary>
        /// Specifies the name of the block in the drill-down diagram.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the parameter ID of the parameter to which the block is linked.
        /// From DataMiner 8.0.1 onwards (RN 5828), it is also possible to configure pid="0", in case you wish to dis­play lists when no filter is selected.
        ///</summary>
public IValueTag<uint?> Pid => _pid;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("displayTable", nameof(DisplayTable), _displayTable, value => _displayTable = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("pid", nameof(Pid), _pid, value => _pid = value);
            ParseElementTag("DiagramPids", nameof(DiagramPids), _diagramPids, value => _diagramPids = value);
            ParseElementTag("DiagramSorting", nameof(DiagramSorting), _diagramSorting, value => _diagramSorting = value);
            ParseElementTag("DiagramTitleFormat", nameof(DiagramTitleFormat), _diagramTitleFormat, value => _diagramTitleFormat = value);
            ParseElementTag("Display", nameof(Display), _display, value => _display = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainField(this);
        }
    }

    ///<summary>
    /// Defines a topology, representing the connections in a diagram displayed in a CPE manager.
    ///</summary>
internal partial class Topology : SimpleProtocolListNode<TopologyCell>, ITopology
    {
        internal Topology(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Topology", "Cell")
        {
        }

        private AttributeTag<string> _name;
        ///<summary>
        /// Specifies the name of the topology (Service Overview Manager only).
        ///</summary>
public IValueTag<string> Name => _name;

        ITopologyCell IReadOnlyList<ITopologyCell>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITopologyCell> IEnumerable<ITopologyCell>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopology(this);
        }
    }

    ///<summary>
    /// Specifies a cell within a CPE topology.
    ///</summary>
internal partial class TopologyCell : SimpleProtocolListNode<TopologyCellLink>, ITopologyCell
    {
        internal TopologyCell(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Cell", "Link")
        {
        }

        private AttributeTag<string> _detailColumns;
        private AttributeTag<string> _listColumns;
        private AttributeTag<string> _name;
        private AttributeTag<string> _options;
        private AttributeTag<string> _table;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> DetailColumns => _detailColumns;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<string> ListColumns => _listColumns;
        ///<summary>
        /// Specifies the name of the cell.
        ///</summary>
public IValueTag<string> Name => _name;
        ///<summary>
        /// Specifies a number of options (Deprecated).
        ///</summary>
public IValueTag<string> Options => _options;
        ///<summary>
        /// Specifies the table parameter to which the cell is linked.
        ///</summary>
public IValueTag<string> Table => _table;

        ITopologyCellLink IReadOnlyList<ITopologyCellLink>.this[int index]
        {
            get
            {
                return this[index];
            }
        }

        IEnumerator<ITopologyCellLink> IEnumerable<ITopologyCellLink>.GetEnumerator()
        {
            return GetEnumerator();
        }

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("detailColumns", nameof(DetailColumns), _detailColumns, value => _detailColumns = value);
            ParseAttributeTag("listColumns", nameof(ListColumns), _listColumns, value => _listColumns = value);
            ParseAttributeTag("name", nameof(Name), _name, value => _name = value);
            ParseAttributeTag("options", nameof(Options), _options, value => _options = value);
            ParseAttributeTag("table", nameof(Table), _table, value => _table = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologyCell(this);
        }
    }

    ///<summary>
    /// Specifies how a cell in a CPE topology is linked to another cell in that topology, using foreign key relations (which can also be inside the same table).
    ///</summary>
internal partial class TopologyCellLink : ElementTag, ITopologyCellLink
    {
        internal TopologyCellLink(ProtocolModel model, ProtocolTag parent) : base(model, parent, "Link")
        {
        }

        private AttributeTag<uint?> _dest;
        private AttributeTag<uint?> _source;
        ///<summary>
        /// (CPE) Specifies the ID of the parameter column if you want to make a topology with foreign key relations inside a table.
        ///</summary>
public IValueTag<uint?> Dest => _dest;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public IValueTag<uint?> Source => _source;

        protected override void Parse(string notifyPropertyName)
        {
            base.Parse(notifyPropertyName);
            ParseAttributeTag("dest", nameof(Dest), _dest, value => _dest = value);
            ParseAttributeTag("source", nameof(Source), _source, value => _source = value);
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologyCellLink(this);
        }
    }
}

// Auto-generated code
// <auto-generated>This is auto-generated code by DIS. Do not modify.</auto-generated>
#pragma warning disable CS1591
namespace Skyline.DataMiner.CICD.Models.Protocol.Edit
{
    using System;
    using System.Collections.Generic;
    using Skyline.DataMiner.CICD.Parsers.Common.XmlEdit;

    ///<summary>
    /// The root element of a DataMiner protocol.
    ///</summary>
public partial class Protocol : EditableElementNode<Read.IProtocol>
    {
        internal Protocol(Read.IProtocol read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Protocol node. None of it's properties will be set.
        ///</summary>
public Protocol() : base("Protocol")
        {
            OnCreated();
        }

        private Actions _actions;
        private Advanced _advanced;
        private AlarmLevelLinks _alarmLevelLinks;
        private App _app;
        private Chains _chains;
        private Commands _commands;
        private Compliancies _compliancies;
        private Connections _connections;
        private ElementValue<string> _description;
        private ElementValue<uint?> _deviceOID;
        private Display _display;
        private DVEs _dVEs;
        private ElementOptions _elementOptions;
        private SystemOptions _systemOptions;
        private ElementValue<string> _elementType;
        private ExportRules _exportRules;
        private GeneralParameters _generalParameters;
        private Groups _groups;
        private HTTP _hTTP;
        private ElementValue<string> _icon;
        private ElementValue<string> _integrationID;
        private InternalLicenses _internalLicenses;
        private ElementValue<string> _mib;
        private ElementValue<string> _name;
        private NoTimeouts _noTimeouts;
        private Options _options;
        private Ownership _ownership;
        private Pairs _pairs;
        private ParameterGroups _parameterGroups;
        private Params _params;
        private Ports _ports;
        private PortSettingsMain _portSettings;
        private ProcessAutomation _processAutomation;
        private ElementValue<string> _provider;
        private QActions _qActions;
        private RCA _rCA;
        private Relations _relations;
        private Responses _responses;
        private SeverityBubbleUp _severityBubbleUp;
        private SNMP _sNMP;
        private Threads _threads;
        private Timers _timers;
        private Topology _topology;
        private Topologies _topologies;
        private TreeControls _treeControls;
        private Triggers _triggers;
        private ProtocolType _type;
        private ElementValue<string> _vendor;
        private ElementValue<string> _vendorOID;
        private ElementValue<string> _version;
        private VersionHistory _versionHistory;
        private AttributeValue<string> _baseFor;
        ///<summary>
        /// Contains the actions defined in this protocol.
        ///</summary>
public Actions Actions
        {
            get
            {
                return _actions;
            }

            set
            {
                if (_actions != value)
                {
                    _actions = value;
                    CombinedTagHandler.Assign(value, this, "Actions");
                }
            }
        }

        ///<summary>
        /// Specifies a number of advanced settings with regard to the protocol's commands and responses.
        ///</summary>
public Advanced Advanced
        {
            get
            {
                return _advanced;
            }

            set
            {
                if (_advanced != value)
                {
                    _advanced = value;
                    CombinedTagHandler.Assign(value, this, "Advanced");
                }
            }
        }

        ///<summary>
        /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
        ///</summary>
public AlarmLevelLinks AlarmLevelLinks
        {
            get
            {
                return _alarmLevelLinks;
            }

            set
            {
                if (_alarmLevelLinks != value)
                {
                    _alarmLevelLinks = value;
                    CombinedTagHandler.Assign(value, this, "AlarmLevelLinks");
                }
            }
        }

        ///<summary>
        /// Add this element if you want to turn DataMiner elements executing this protocol into applications.
        /// In DataMiner Cube, protocol-based applications can be found in the Apps tab of the Surveyor.
        ///</summary>
public App App
        {
            get
            {
                return _app;
            }

            set
            {
                if (_app != value)
                {
                    _app = value;
                    CombinedTagHandler.Assign(value, this, "App");
                }
            }
        }

        ///<summary>
        /// Contains the chains defined in this protocol.
        ///</summary>
public Chains Chains
        {
            get
            {
                return _chains;
            }

            set
            {
                if (_chains != value)
                {
                    _chains = value;
                    CombinedTagHandler.Assign(value, this, "Chains");
                }
            }
        }

        ///<summary>
        /// Contains all commands defined in the protocol.
        /// Commands are sent from DataMiner to the device
        /// - to request information from the device, or
        /// - to change a device setting.
        ///</summary>
public Commands Commands
        {
            get
            {
                return _commands;
            }

            set
            {
                if (_commands != value)
                {
                    _commands = value;
                    CombinedTagHandler.Assign(value, this, "Commands");
                }
            }
        }

        ///<summary>
        /// Provides compliance information about this protocol.
        ///</summary>
public Compliancies Compliancies
        {
            get
            {
                return _compliancies;
            }

            set
            {
                if (_compliancies != value)
                {
                    _compliancies = value;
                    CombinedTagHandler.Assign(value, this, "Compliancies");
                }
            }
        }

        ///<summary>
        /// Defines communication connections.
        ///</summary>
public Connections Connections
        {
            get
            {
                return _connections;
            }

            set
            {
                if (_connections != value)
                {
                    _connections = value;
                    CombinedTagHandler.Assign(value, this, "Connections");
                }
            }
        }

        ///<summary>
        /// Specifies a description of the protocol.
        /// Can be used to specify some general information about the protocol. You could, for example, specify that the protocol has been
        /// developed for elements running a specific firmware version.
        /// In protocols of DataMiner elements that are used in automation, the description must be unique.
        ///</summary>
public ElementValue<string> Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    ElementHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Specifies an OID for the device that will be managed with the protocol.
        /// The device OID has to be specified right after the vendor OID. Note that the complete OID, i.e. the vendor OID followed by the device OID, must be unique.
        /// This means that for each device from the same vendor you have to use a new device OID.
        ///</summary>
public ElementValue<uint?> DeviceOID
        {
            get
            {
                return _deviceOID;
            }

            set
            {
                if (_deviceOID != value)
                {
                    _deviceOID = value;
                    ElementHandler.Assign(value, this, "DeviceOID");
                }
            }
        }

        ///<summary>
        /// Defines the layout and the order of the Data Display pages.
        ///</summary>
public Display Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// This tag allows you to describe the behavior of Dynamic Virtual Elements.
        ///</summary>
public DVEs DVEs
        {
            get
            {
                return _dVEs;
            }

            set
            {
                if (_dVEs != value)
                {
                    _dVEs = value;
                    CombinedTagHandler.Assign(value, this, "DVEs");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementOptions ElementOptions
        {
            get
            {
                return _elementOptions;
            }

            set
            {
                if (_elementOptions != value)
                {
                    _elementOptions = value;
                    CombinedTagHandler.Assign(value, this, "ElementOptions");
                }
            }
        }

        ///<summary>
        /// Contains options that can be enabled or configured that change how the system will manage or interact with the element.
        ///</summary>
public SystemOptions SystemOptions
        {
            get
            {
                return _systemOptions;
            }

            set
            {
                if (_systemOptions != value)
                {
                    _systemOptions = value;
                    CombinedTagHandler.Assign(value, this, "SystemOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the type of device for which the protocol will be used.
        /// The type will be shown whenever a DataMiner element is added or edited. It will also be shown in the Details section of System Display when a DataMiner element is
        /// selected.
        ///</summary>
public ElementValue<string> ElementType
        {
            get
            {
                return _elementType;
            }

            set
            {
                if (_elementType != value)
                {
                    _elementType = value;
                    ElementHandler.Assign(value, this, "ElementType");
                }
            }
        }

        ///<summary>
        /// Defines rules that are used for changing the displayed items in a Dynamic Virtual Element (DVE), for example changing the location of a parameter.
        ///</summary>
public ExportRules ExportRules
        {
            get
            {
                return _exportRules;
            }

            set
            {
                if (_exportRules != value)
                {
                    _exportRules = value;
                    CombinedTagHandler.Assign(value, this, "ExportRules");
                }
            }
        }

        ///<summary>
        /// Specifies which general parameter groups should be loaded or not. Feature introduced in DataMiner 9.0.1 (RN 12263).
        ///</summary>
public GeneralParameters GeneralParameters
        {
            get
            {
                return _generalParameters;
            }

            set
            {
                if (_generalParameters != value)
                {
                    _generalParameters = value;
                    CombinedTagHandler.Assign(value, this, "GeneralParameters");
                }
            }
        }

        ///<summary>
        /// Contains the groups defined in the protocol.
        ///</summary>
public Groups Groups
        {
            get
            {
                return _groups;
            }

            set
            {
                if (_groups != value)
                {
                    _groups = value;
                    CombinedTagHandler.Assign(value, this, "Groups");
                }
            }
        }

        ///<summary>
        /// The root of the HTTP-specific features in a protocol.
        ///</summary>
public HTTP HTTP
        {
            get
            {
                return _hTTP;
            }

            set
            {
                if (_hTTP != value)
                {
                    _hTTP = value;
                    CombinedTagHandler.Assign(value, this, "HTTP");
                }
            }
        }

        ///<summary>
        /// Defines an icon (via XAML content in a CDATA tag) to be used in the Applications list in the DataMiner Cube surveyor.
        ///</summary>
public ElementValue<string> Icon
        {
            get
            {
                return _icon;
            }

            set
            {
                if (_icon != value)
                {
                    _icon = value;
                    ElementHandler.Assign(value, this, "Icon");
                }
            }
        }

        ///<summary>
        /// Specifies the integration ID.
        ///</summary>
public ElementValue<string> IntegrationID
        {
            get
            {
                return _integrationID;
            }

            set
            {
                if (_integrationID != value)
                {
                    _integrationID = value;
                    ElementHandler.Assign(value, this, "IntegrationID");
                }
            }
        }

        ///<summary>
        /// Configures internal licensing.
        ///</summary>
public InternalLicenses InternalLicenses
        {
            get
            {
                return _internalLicenses;
            }

            set
            {
                if (_internalLicenses != value)
                {
                    _internalLicenses = value;
                    CombinedTagHandler.Assign(value, this, "InternalLicenses");
                }
            }
        }

        ///<summary>
        /// Allows providing additional content (conforming the SMI specification) that must be included in the generated MIB.
        ///</summary>
public ElementValue<string> Mib
        {
            get
            {
                return _mib;
            }

            set
            {
                if (_mib != value)
                {
                    _mib = value;
                    ElementHandler.Assign(value, this, "Mib");
                }
            }
        }

        ///<summary>
        /// Defines the name of the protocol.
        /// This name, which must be unique, will be used throughout the DataMiner System to identify the protocol.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Groups NoTimeout elements.
        ///</summary>
public NoTimeouts NoTimeouts
        {
            get
            {
                return _noTimeouts;
            }

            set
            {
                if (_noTimeouts != value)
                {
                    _noTimeouts = value;
                    CombinedTagHandler.Assign(value, this, "NoTimeouts");
                }
            }
        }

        ///<summary>
        /// Defines options for the protocol.
        ///</summary>
public Options Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    CombinedTagHandler.Assign(value, this, "Options");
                }
            }
        }

        ///<summary>
        /// Specifies the level of access users will have to elements, views, services and redundancy groups created by elements based on this protocol.
        /// Feature introduced in DataMiner 9.0.3 (RN 13010).
        ///</summary>
public Ownership Ownership
        {
            get
            {
                return _ownership;
            }

            set
            {
                if (_ownership != value)
                {
                    _ownership = value;
                    CombinedTagHandler.Assign(value, this, "Ownership");
                }
            }
        }

        ///<summary>
        /// Contains all the pairs defined in the protocol.
        ///</summary>
public Pairs Pairs
        {
            get
            {
                return _pairs;
            }

            set
            {
                if (_pairs != value)
                {
                    _pairs = value;
                    CombinedTagHandler.Assign(value, this, "Pairs");
                }
            }
        }

        ///<summary>
        /// Defines the DataMiner Connectivity Framework (DCF) interfaces.
        /// Feature introduced in DataMiner 8.0.0 (RN 5663).
        ///</summary>
public ParameterGroups ParameterGroups
        {
            get
            {
                return _parameterGroups;
            }

            set
            {
                if (_parameterGroups != value)
                {
                    _parameterGroups = value;
                    CombinedTagHandler.Assign(value, this, "ParameterGroups");
                }
            }
        }

        ///<summary>
        /// Contains all the parameters defined in the protocol.
        ///</summary>
public Params Params
        {
            get
            {
                return _params;
            }

            set
            {
                if (_params != value)
                {
                    _params = value;
                    CombinedTagHandler.Assign(value, this, "Params");
                }
            }
        }

        ///<summary>
        /// For every protocol, you have to specify its type in /Protocol/Type, and its port settings in /Protocol/Portsettings.
        /// In case of a multi-type protocol, the /Protocol/Type@advanced attribute is used to any additional protocol types.
        /// The port settings for those additional protocol types then have to be specified in a /Protocol/Ports/Portsettings element in which the name attribute contains the name of the additional type as specified in the /Protocol/Type@advanced attribute.
        ///</summary>
public Ports Ports
        {
            get
            {
                return _ports;
            }

            set
            {
                if (_ports != value)
                {
                    _ports = value;
                    CombinedTagHandler.Assign(value, this, "Ports");
                }
            }
        }

        ///<summary>
        /// Defines the default port settings of the main device port.
        /// It also allows you to restrict the capabilities of a device port, and to define the format and range of the bus address, if any.
        ///</summary>
public PortSettingsMain PortSettings
        {
            get
            {
                return _portSettings;
            }

            set
            {
                if (_portSettings != value)
                {
                    _portSettings = value;
                    CombinedTagHandler.Assign(value, this, "PortSettings");
                }
            }
        }

        public ProcessAutomation ProcessAutomation
        {
            get
            {
                return _processAutomation;
            }

            set
            {
                if (_processAutomation != value)
                {
                    _processAutomation = value;
                    CombinedTagHandler.Assign(value, this, "ProcessAutomation");
                }
            }
        }

        ///<summary>
        /// Specifies the protocol provider.
        /// Example: If a protocol was created by someone from Skyline Communications, this provider tag has to be set to "Skyline Communications".
        ///</summary>
public ElementValue<string> Provider
        {
            get
            {
                return _provider;
            }

            set
            {
                if (_provider != value)
                {
                    _provider = value;
                    ElementHandler.Assign(value, this, "Provider");
                }
            }
        }

        ///<summary>
        /// Contains all the QActions defined in the protocol.
        /// A QAction (i.e. Quick Action) is a script that can be executed when a parameter or a row changes. Inside a QAction, the following scripting languages can be used:
        /// -	JScript
        /// -	VBScript
        /// -	C#
        ///</summary>
public QActions QActions
        {
            get
            {
                return _qActions;
            }

            set
            {
                if (_qActions != value)
                {
                    _qActions = value;
                    CombinedTagHandler.Assign(value, this, "QActions");
                }
            }
        }

        ///<summary>
        /// Configures Root Cause Analysis (RCA).
        ///</summary>
public RCA RCA
        {
            get
            {
                return _rCA;
            }

            set
            {
                if (_rCA != value)
                {
                    _rCA = value;
                    CombinedTagHandler.Assign(value, this, "RCA");
                }
            }
        }

        ///<summary>
        /// Defines relations between tables.
        ///</summary>
public Relations Relations
        {
            get
            {
                return _relations;
            }

            set
            {
                if (_relations != value)
                {
                    _relations = value;
                    CombinedTagHandler.Assign(value, this, "Relations");
                }
            }
        }

        ///<summary>
        /// Contains all responses defined in the protocol.
        ///</summary>
public Responses Responses
        {
            get
            {
                return _responses;
            }

            set
            {
                if (_responses != value)
                {
                    _responses = value;
                    CombinedTagHandler.Assign(value, this, "Responses");
                }
            }
        }

        ///<summary>
        /// Used to pass alarm severities to linked tables.
        ///</summary>
public SeverityBubbleUp SeverityBubbleUp
        {
            get
            {
                return _severityBubbleUp;
            }

            set
            {
                if (_severityBubbleUp != value)
                {
                    _severityBubbleUp = value;
                    CombinedTagHandler.Assign(value, this, "SeverityBubbleUp");
                }
            }
        }

        ///<summary>
        /// Specifies how the MIB file for the protocol will be created.
        ///</summary>
public SNMP SNMP
        {
            get
            {
                return _sNMP;
            }

            set
            {
                if (_sNMP != value)
                {
                    _sNMP = value;
                    CombinedTagHandler.Assign(value, this, "SNMP");
                }
            }
        }

        ///<summary>
        /// Specifies additional threads that will be used by the protocol. This allows you to separate time-critical actions from device-polling actions. Use with caution.
        ///</summary>
public Threads Threads
        {
            get
            {
                return _threads;
            }

            set
            {
                if (_threads != value)
                {
                    _threads = value;
                    CombinedTagHandler.Assign(value, this, "Threads");
                }
            }
        }

        ///<summary>
        /// Contains all timers defined in the protocol.
        /// Timers are used to configure recurring events (group execution, device polling, ...). Basically, a timer defines the interval between two consecutive executions of a given event.
        /// By default, the interval specified in a timer is a fixed interval. However, in the protocol, you can make the interval dynamic.
        /// The interval can be modified by changing the value of the [Timer base] Parameter (ID: 65017). The value of this parameter is the factor by which the interval time is multiplied.
        /// So "1" means the original interval, "2" means twice as slow, "0.5" means twice as fast, etc.
        ///</summary>
public Timers Timers
        {
            get
            {
                return _timers;
            }

            set
            {
                if (_timers != value)
                {
                    _timers = value;
                    CombinedTagHandler.Assign(value, this, "Timers");
                }
            }
        }

        ///<summary>
        /// Defines a topology. In this element, you can specify several Cell elements, each representing a cell in the diagram displayed in the CPE Manager.
        ///</summary>
public Topology Topology
        {
            get
            {
                return _topology;
            }

            set
            {
                if (_topology != value)
                {
                    _topology = value;
                    CombinedTagHandler.Assign(value, this, "Topology");
                }
            }
        }

        ///<summary>
        /// Groups topologies defined in the protocol.
        ///</summary>
public Topologies Topologies
        {
            get
            {
                return _topologies;
            }

            set
            {
                if (_topologies != value)
                {
                    _topologies = value;
                    CombinedTagHandler.Assign(value, this, "Topologies");
                }
            }
        }

        ///<summary>
        /// Contains all the tree controls defined in the protocol.
        ///</summary>
public TreeControls TreeControls
        {
            get
            {
                return _treeControls;
            }

            set
            {
                if (_treeControls != value)
                {
                    _treeControls = value;
                    CombinedTagHandler.Assign(value, this, "TreeControls");
                }
            }
        }

        ///<summary>
        /// Contains the triggers defined in the protocol.
        /// In a trigger, you define when it should go off, and which actions it should execute.
        ///</summary>
public Triggers Triggers
        {
            get
            {
                return _triggers;
            }

            set
            {
                if (_triggers != value)
                {
                    _triggers = value;
                    CombinedTagHandler.Assign(value, this, "Triggers");
                }
            }
        }

        ///<summary>
        /// Specifies the protocol type. In multi-connection protocols, it specifies the type of the main connection.
        ///</summary>
public ProtocolType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the vendor of the monitored device.
        ///</summary>
public ElementValue<string> Vendor
        {
            get
            {
                return _vendor;
            }

            set
            {
                if (_vendor != value)
                {
                    _vendor = value;
                    ElementHandler.Assign(value, this, "Vendor");
                }
            }
        }

        ///<summary>
        /// Specifies the vendor OID of the monitored device.
        /// This OID, to be provided either by the vendor of the device or (on request) by Skyline Communications, must be unique, as it is used to define MIB objects for all Elements using the protocol.
        /// Typically, the vendor OID will start with the prefix 1.3.6.1.4.1, which identifies private enterprises.
        ///</summary>
public ElementValue<string> VendorOID
        {
            get
            {
                return _vendorOID;
            }

            set
            {
                if (_vendorOID != value)
                {
                    _vendorOID = value;
                    ElementHandler.Assign(value, this, "VendorOID");
                }
            }
        }

        ///<summary>
        /// Specifies the protocol version.
        /// Within one DataMiner system, you can maintain different versions of the same protocol and assign them to different elements. If you have to make modifications to a protocol, do not create a completely new protocol.
        /// Instead, make a new version of that same protocol.
        /// Version can be a number (e.g. 1.0.0.3) or a string (e.g. "high power").
        /// Tip: When you have two types of elements that are very similar (e.g. an optical transmitter: one with a high output power and another with a low output power), you can use the same protocol and create two
        /// versions (e.g. version "high power" and version "low power" for the protocol "optical transmitter". The only difference between the two versions would then be e.g. the range settings for the "output power" parameter).
        ///</summary>
public ElementValue<string> Version
        {
            get
            {
                return _version;
            }

            set
            {
                if (_version != value)
                {
                    _version = value;
                    ElementHandler.Assign(value, this, "Version");
                }
            }
        }

        ///<summary>
        /// Contains an overview of the version history of this protocol.
        /// Feature introduced in DataMiner 9.5.11 (RN 17697, RN 18360).
        ///</summary>
public VersionHistory VersionHistory
        {
            get
            {
                return _versionHistory;
            }

            set
            {
                if (_versionHistory != value)
                {
                    _versionHistory = value;
                    CombinedTagHandler.Assign(value, this, "VersionHistory");
                }
            }
        }

        ///<summary>
        /// Specifies the type of element for which this protocol serves as a base protocol.
        /// In case a value is defined in this attribute, the protocol is considered a base protocol.
        ///</summary>
public AttributeValue<string> BaseFor
        {
            get
            {
                return _baseFor;
            }

            set
            {
                if (_baseFor != value)
                {
                    _baseFor = value;
                    AttributeHandler.Assign(value, this, "baseFor");
                }
            }
        }

        public Actions GetOrCreateActions()
        {
            if (Actions == null)
                Actions = new Actions();
            return Actions;
        }

        public Advanced GetOrCreateAdvanced()
        {
            if (Advanced == null)
                Advanced = new Advanced();
            return Advanced;
        }

        public AlarmLevelLinks GetOrCreateAlarmLevelLinks()
        {
            if (AlarmLevelLinks == null)
                AlarmLevelLinks = new AlarmLevelLinks();
            return AlarmLevelLinks;
        }

        public App GetOrCreateApp()
        {
            if (App == null)
                App = new App();
            return App;
        }

        public Chains GetOrCreateChains()
        {
            if (Chains == null)
                Chains = new Chains();
            return Chains;
        }

        public Commands GetOrCreateCommands()
        {
            if (Commands == null)
                Commands = new Commands();
            return Commands;
        }

        public Compliancies GetOrCreateCompliancies()
        {
            if (Compliancies == null)
                Compliancies = new Compliancies();
            return Compliancies;
        }

        public Connections GetOrCreateConnections()
        {
            if (Connections == null)
                Connections = new Connections();
            return Connections;
        }

        public ElementValue<string> GetOrCreateDescription()
        {
            if (Description == null)
                Description = new ElementValue<string>();
            return Description;
        }

        public ElementValue<uint?> GetOrCreateDeviceOID()
        {
            if (DeviceOID == null)
                DeviceOID = new ElementValue<uint?>();
            return DeviceOID;
        }

        public Display GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new Display();
            return Display;
        }

        public DVEs GetOrCreateDVEs()
        {
            if (DVEs == null)
                DVEs = new DVEs();
            return DVEs;
        }

        public ElementOptions GetOrCreateElementOptions()
        {
            if (ElementOptions == null)
                ElementOptions = new ElementOptions();
            return ElementOptions;
        }

        public SystemOptions GetOrCreateSystemOptions()
        {
            if (SystemOptions == null)
                SystemOptions = new SystemOptions();
            return SystemOptions;
        }

        public ElementValue<string> GetOrCreateElementType()
        {
            if (ElementType == null)
                ElementType = new ElementValue<string>();
            return ElementType;
        }

        public ExportRules GetOrCreateExportRules()
        {
            if (ExportRules == null)
                ExportRules = new ExportRules("ExportRules");
            return ExportRules;
        }

        public GeneralParameters GetOrCreateGeneralParameters()
        {
            if (GeneralParameters == null)
                GeneralParameters = new GeneralParameters();
            return GeneralParameters;
        }

        public Groups GetOrCreateGroups()
        {
            if (Groups == null)
                Groups = new Groups();
            return Groups;
        }

        public HTTP GetOrCreateHTTP()
        {
            if (HTTP == null)
                HTTP = new HTTP();
            return HTTP;
        }

        public ElementValue<string> GetOrCreateIcon()
        {
            if (Icon == null)
                Icon = new ElementValue<string>();
            return Icon;
        }

        public ElementValue<string> GetOrCreateIntegrationID()
        {
            if (IntegrationID == null)
                IntegrationID = new ElementValue<string>();
            return IntegrationID;
        }

        public InternalLicenses GetOrCreateInternalLicenses()
        {
            if (InternalLicenses == null)
                InternalLicenses = new InternalLicenses();
            return InternalLicenses;
        }

        public ElementValue<string> GetOrCreateMib()
        {
            if (Mib == null)
                Mib = new ElementValue<string>();
            return Mib;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public NoTimeouts GetOrCreateNoTimeouts()
        {
            if (NoTimeouts == null)
                NoTimeouts = new NoTimeouts();
            return NoTimeouts;
        }

        public Options GetOrCreateOptions()
        {
            if (Options == null)
                Options = new Options();
            return Options;
        }

        public Ownership GetOrCreateOwnership()
        {
            if (Ownership == null)
                Ownership = new Ownership();
            return Ownership;
        }

        public Pairs GetOrCreatePairs()
        {
            if (Pairs == null)
                Pairs = new Pairs();
            return Pairs;
        }

        public ParameterGroups GetOrCreateParameterGroups()
        {
            if (ParameterGroups == null)
                ParameterGroups = new ParameterGroups();
            return ParameterGroups;
        }

        public Params GetOrCreateParams()
        {
            if (Params == null)
                Params = new Params();
            return Params;
        }

        public Ports GetOrCreatePorts()
        {
            if (Ports == null)
                Ports = new Ports();
            return Ports;
        }

        public PortSettingsMain GetOrCreatePortSettings()
        {
            if (PortSettings == null)
                PortSettings = new PortSettingsMain("PortSettings");
            return PortSettings;
        }

        public ProcessAutomation GetOrCreateProcessAutomation()
        {
            if (ProcessAutomation == null)
                ProcessAutomation = new ProcessAutomation();
            return ProcessAutomation;
        }

        public ElementValue<string> GetOrCreateProvider()
        {
            if (Provider == null)
                Provider = new ElementValue<string>();
            return Provider;
        }

        public QActions GetOrCreateQActions()
        {
            if (QActions == null)
                QActions = new QActions();
            return QActions;
        }

        public RCA GetOrCreateRCA()
        {
            if (RCA == null)
                RCA = new RCA();
            return RCA;
        }

        public Relations GetOrCreateRelations()
        {
            if (Relations == null)
                Relations = new Relations();
            return Relations;
        }

        public Responses GetOrCreateResponses()
        {
            if (Responses == null)
                Responses = new Responses();
            return Responses;
        }

        public SeverityBubbleUp GetOrCreateSeverityBubbleUp()
        {
            if (SeverityBubbleUp == null)
                SeverityBubbleUp = new SeverityBubbleUp();
            return SeverityBubbleUp;
        }

        public SNMP GetOrCreateSNMP()
        {
            if (SNMP == null)
                SNMP = new SNMP();
            return SNMP;
        }

        public Threads GetOrCreateThreads()
        {
            if (Threads == null)
                Threads = new Threads();
            return Threads;
        }

        public Timers GetOrCreateTimers()
        {
            if (Timers == null)
                Timers = new Timers();
            return Timers;
        }

        public Topology GetOrCreateTopology()
        {
            if (Topology == null)
                Topology = new Topology("Topology");
            return Topology;
        }

        public Topologies GetOrCreateTopologies()
        {
            if (Topologies == null)
                Topologies = new Topologies();
            return Topologies;
        }

        public TreeControls GetOrCreateTreeControls()
        {
            if (TreeControls == null)
                TreeControls = new TreeControls();
            return TreeControls;
        }

        public Triggers GetOrCreateTriggers()
        {
            if (Triggers == null)
                Triggers = new Triggers();
            return Triggers;
        }

        public ProtocolType GetOrCreateType()
        {
            if (Type == null)
                Type = new ProtocolType();
            return Type;
        }

        public ElementValue<string> GetOrCreateVendor()
        {
            if (Vendor == null)
                Vendor = new ElementValue<string>();
            return Vendor;
        }

        public ElementValue<string> GetOrCreateVendorOID()
        {
            if (VendorOID == null)
                VendorOID = new ElementValue<string>();
            return VendorOID;
        }

        public ElementValue<string> GetOrCreateVersion()
        {
            if (Version == null)
                Version = new ElementValue<string>();
            return Version;
        }

        public VersionHistory GetOrCreateVersionHistory()
        {
            if (VersionHistory == null)
                VersionHistory = new VersionHistory();
            return VersionHistory;
        }

        public AttributeValue<string> GetOrCreateBaseFor()
        {
            if (BaseFor == null)
                BaseFor = new AttributeValue<string>();
            return BaseFor;
        }

        protected override void Initialize(Read.IProtocol read, XmlElement editNode)
        {
            if (read == null)
                return;
            _actions = read.Actions != null ? new Actions(read.Actions, this, editNode.Element["Actions"]) : null;
            _advanced = read.Advanced != null ? new Advanced(read.Advanced, this, editNode.Element["Advanced"]) : null;
            _alarmLevelLinks = read.AlarmLevelLinks != null ? new AlarmLevelLinks(read.AlarmLevelLinks, this, editNode.Element["AlarmLevelLinks"]) : null;
            _app = read.App != null ? new App(read.App, this, editNode.Element["App"]) : null;
            _chains = read.Chains != null ? new Chains(read.Chains, this, editNode.Element["Chains"]) : null;
            _commands = read.Commands != null ? new Commands(read.Commands, this, editNode.Element["Commands"]) : null;
            _compliancies = read.Compliancies != null ? new Compliancies(read.Compliancies, this, editNode.Element["Compliancies"]) : null;
            _connections = read.Connections != null ? new Connections(read.Connections, this, editNode.Element["Connections"]) : null;
            _description = read.Description != null ? new ElementValue<string>(read.Description, this) : null;
            _deviceOID = read.DeviceOID != null ? new ElementValue<uint?>(read.DeviceOID, this) : null;
            _display = read.Display != null ? new Display(read.Display, this, editNode.Element["Display"]) : null;
            _dVEs = read.DVEs != null ? new DVEs(read.DVEs, this, editNode.Element["DVEs"]) : null;
            _elementOptions = read.ElementOptions != null ? new ElementOptions(read.ElementOptions, this, editNode.Element["ElementOptions"]) : null;
            _systemOptions = read.SystemOptions != null ? new SystemOptions(read.SystemOptions, this, editNode.Element["SystemOptions"]) : null;
            _elementType = read.ElementType != null ? new ElementValue<string>(read.ElementType, this) : null;
            _exportRules = read.ExportRules != null ? new ExportRules(read.ExportRules, this, editNode.Element["ExportRules"]) : null;
            _generalParameters = read.GeneralParameters != null ? new GeneralParameters(read.GeneralParameters, this, editNode.Element["GeneralParameters"]) : null;
            _groups = read.Groups != null ? new Groups(read.Groups, this, editNode.Element["Groups"]) : null;
            _hTTP = read.HTTP != null ? new HTTP(read.HTTP, this, editNode.Element["HTTP"]) : null;
            _icon = read.Icon != null ? new ElementValue<string>(read.Icon, this) : null;
            _integrationID = read.IntegrationID != null ? new ElementValue<string>(read.IntegrationID, this) : null;
            _internalLicenses = read.InternalLicenses != null ? new InternalLicenses(read.InternalLicenses, this, editNode.Element["InternalLicenses"]) : null;
            _mib = read.Mib != null ? new ElementValue<string>(read.Mib, this) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _noTimeouts = read.NoTimeouts != null ? new NoTimeouts(read.NoTimeouts, this, editNode.Element["NoTimeouts"]) : null;
            _options = read.Options != null ? new Options(read.Options, this, editNode.Element["Options"]) : null;
            _ownership = read.Ownership != null ? new Ownership(read.Ownership, this, editNode.Element["Ownership"]) : null;
            _pairs = read.Pairs != null ? new Pairs(read.Pairs, this, editNode.Element["Pairs"]) : null;
            _parameterGroups = read.ParameterGroups != null ? new ParameterGroups(read.ParameterGroups, this, editNode.Element["ParameterGroups"]) : null;
            _params = read.Params != null ? new Params(read.Params, this, editNode.Element["Params"]) : null;
            _ports = read.Ports != null ? new Ports(read.Ports, this, editNode.Element["Ports"]) : null;
            _portSettings = read.PortSettings != null ? new PortSettingsMain(read.PortSettings, this, editNode.Element["PortSettings"]) : null;
            _processAutomation = read.ProcessAutomation != null ? new ProcessAutomation(read.ProcessAutomation, this, editNode.Element["ProcessAutomation"]) : null;
            _provider = read.Provider != null ? new ElementValue<string>(read.Provider, this) : null;
            _qActions = read.QActions != null ? new QActions(read.QActions, this, editNode.Element["QActions"]) : null;
            _rCA = read.RCA != null ? new RCA(read.RCA, this, editNode.Element["RCA"]) : null;
            _relations = read.Relations != null ? new Relations(read.Relations, this, editNode.Element["Relations"]) : null;
            _responses = read.Responses != null ? new Responses(read.Responses, this, editNode.Element["Responses"]) : null;
            _severityBubbleUp = read.SeverityBubbleUp != null ? new SeverityBubbleUp(read.SeverityBubbleUp, this, editNode.Element["SeverityBubbleUp"]) : null;
            _sNMP = read.SNMP != null ? new SNMP(read.SNMP, this, editNode.Element["SNMP"]) : null;
            _threads = read.Threads != null ? new Threads(read.Threads, this, editNode.Element["Threads"]) : null;
            _timers = read.Timers != null ? new Timers(read.Timers, this, editNode.Element["Timers"]) : null;
            _topology = read.Topology != null ? new Topology(read.Topology, this, editNode.Element["Topology"]) : null;
            _topologies = read.Topologies != null ? new Topologies(read.Topologies, this, editNode.Element["Topologies"]) : null;
            _treeControls = read.TreeControls != null ? new TreeControls(read.TreeControls, this, editNode.Element["TreeControls"]) : null;
            _triggers = read.Triggers != null ? new Triggers(read.Triggers, this, editNode.Element["Triggers"]) : null;
            _type = read.Type != null ? new ProtocolType(read.Type, this, editNode.Element["Type"]) : null;
            _vendor = read.Vendor != null ? new ElementValue<string>(read.Vendor, this) : null;
            _vendorOID = read.VendorOID != null ? new ElementValue<string>(read.VendorOID, this) : null;
            _version = read.Version != null ? new ElementValue<string>(read.Version, this) : null;
            _versionHistory = read.VersionHistory != null ? new VersionHistory(read.VersionHistory, this, editNode.Element["VersionHistory"]) : null;
            _baseFor = read.BaseFor != null ? new AttributeValue<string>(read.BaseFor, this) : null;
        }

        public static Protocol FromRead(Read.IProtocol read)
        {
            if (read == null)
                return null;
            var item = new Protocol();
            item.Actions = Actions.FromRead(read.Actions);
            item.Advanced = Advanced.FromRead(read.Advanced);
            item.AlarmLevelLinks = AlarmLevelLinks.FromRead(read.AlarmLevelLinks);
            item.App = App.FromRead(read.App);
            item.Chains = Chains.FromRead(read.Chains);
            item.Commands = Commands.FromRead(read.Commands);
            item.Compliancies = Compliancies.FromRead(read.Compliancies);
            item.Connections = Connections.FromRead(read.Connections);
            item.Description = ElementValue<string>.FromRead(read.Description);
            item.DeviceOID = ElementValue<uint?>.FromRead(read.DeviceOID);
            item.Display = Display.FromRead(read.Display);
            item.DVEs = DVEs.FromRead(read.DVEs);
            item.ElementOptions = ElementOptions.FromRead(read.ElementOptions);
            item.SystemOptions = SystemOptions.FromRead(read.SystemOptions);
            item.ElementType = ElementValue<string>.FromRead(read.ElementType);
            item.ExportRules = ExportRules.FromRead(read.ExportRules);
            item.GeneralParameters = GeneralParameters.FromRead(read.GeneralParameters);
            item.Groups = Groups.FromRead(read.Groups);
            item.HTTP = HTTP.FromRead(read.HTTP);
            item.Icon = ElementValue<string>.FromRead(read.Icon);
            item.IntegrationID = ElementValue<string>.FromRead(read.IntegrationID);
            item.InternalLicenses = InternalLicenses.FromRead(read.InternalLicenses);
            item.Mib = ElementValue<string>.FromRead(read.Mib);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.NoTimeouts = NoTimeouts.FromRead(read.NoTimeouts);
            item.Options = Options.FromRead(read.Options);
            item.Ownership = Ownership.FromRead(read.Ownership);
            item.Pairs = Pairs.FromRead(read.Pairs);
            item.ParameterGroups = ParameterGroups.FromRead(read.ParameterGroups);
            item.Params = Params.FromRead(read.Params);
            item.Ports = Ports.FromRead(read.Ports);
            item.PortSettings = PortSettingsMain.FromRead(read.PortSettings);
            item.ProcessAutomation = ProcessAutomation.FromRead(read.ProcessAutomation);
            item.Provider = ElementValue<string>.FromRead(read.Provider);
            item.QActions = QActions.FromRead(read.QActions);
            item.RCA = RCA.FromRead(read.RCA);
            item.Relations = Relations.FromRead(read.Relations);
            item.Responses = Responses.FromRead(read.Responses);
            item.SeverityBubbleUp = SeverityBubbleUp.FromRead(read.SeverityBubbleUp);
            item.SNMP = SNMP.FromRead(read.SNMP);
            item.Threads = Threads.FromRead(read.Threads);
            item.Timers = Timers.FromRead(read.Timers);
            item.Topology = Topology.FromRead(read.Topology);
            item.Topologies = Topologies.FromRead(read.Topologies);
            item.TreeControls = TreeControls.FromRead(read.TreeControls);
            item.Triggers = Triggers.FromRead(read.Triggers);
            item.Type = ProtocolType.FromRead(read.Type);
            item.Vendor = ElementValue<string>.FromRead(read.Vendor);
            item.VendorOID = ElementValue<string>.FromRead(read.VendorOID);
            item.Version = ElementValue<string>.FromRead(read.Version);
            item.VersionHistory = VersionHistory.FromRead(read.VersionHistory);
            item.BaseFor = AttributeValue<string>.FromRead(read.BaseFor);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProtocol(this);
        }
    }

    ///<summary>
    /// Contains the actions defined in this protocol.
    ///</summary>
public partial class Actions : EditableListNode<Read.IActions, Read.IActionsAction, ActionsAction>
    {
        internal Actions(Read.IActions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Actions node. None of it's properties will be set.
        ///</summary>
public Actions() : base("Actions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IActions read, XmlElement editNode)
        {
        }

        public static Actions FromRead(Read.IActions read)
        {
            if (read == null)
                return null;
            var item = new Actions();
            foreach (var x in read)
            {
                item.Add(ActionsAction.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitActions(this);
        }
    }

    ///<summary>
    /// Defines an action.
    ///</summary>
public partial class ActionsAction : EditableElementNode<Read.IActionsAction>
    {
        internal ActionsAction(Read.IActionsAction read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Action node. None of it's properties will be set.
        ///</summary>
public ActionsAction() : base("Action")
        {
            OnCreated();
        }

        private ElementValue<string> _condition;
        private ElementValue<string> _name;
        private ActionsActionOn _on;
        private ActionsActionType _type;
        private AttributeValue<uint?> _id;
        ///<summary>
        /// Specifies a condition that must be met in order for the action to execute.
        ///</summary>
public ElementValue<string> Condition
        {
            get
            {
                return _condition;
            }

            set
            {
                if (_condition != value)
                {
                    _condition = value;
                    ElementHandler.Assign(value, this, "Condition");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the action.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Defines, together with Action/Type, how the action is executed.
        /// Not all Action/Type values can be used in combination with the different Action/On types.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
        ///</summary>
public ActionsActionOn On
        {
            get
            {
                return _on;
            }

            set
            {
                if (_on != value)
                {
                    _on = value;
                    CombinedTagHandler.Assign(value, this, "On");
                }
            }
        }

        ///<summary>
        /// Defines, together with Action/On, how the action is executed.
        /// Not all Action/Type values can be used in combination with the different Action/On types.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
        ///</summary>
public ActionsActionType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Specifies the unique action ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        public ElementValue<string> GetOrCreateCondition()
        {
            if (Condition == null)
                Condition = new ElementValue<string>();
            return Condition;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public ActionsActionOn GetOrCreateOn()
        {
            if (On == null)
                On = new ActionsActionOn();
            return On;
        }

        public ActionsActionType GetOrCreateType()
        {
            if (Type == null)
                Type = new ActionsActionType();
            return Type;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        protected override void Initialize(Read.IActionsAction read, XmlElement editNode)
        {
            if (read == null)
                return;
            _condition = read.Condition != null ? new ElementValue<string>(read.Condition, this) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _on = read.On != null ? new ActionsActionOn(read.On, this, editNode.Element["On"]) : null;
            _type = read.Type != null ? new ActionsActionType(read.Type, this, editNode.Element["Type"]) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
        }

        public static ActionsAction FromRead(Read.IActionsAction read)
        {
            if (read == null)
                return null;
            var item = new ActionsAction();
            item.Condition = ElementValue<string>.FromRead(read.Condition);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.On = ActionsActionOn.FromRead(read.On);
            item.Type = ActionsActionType.FromRead(read.Type);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitActionsAction(this);
        }
    }

    ///<summary>
    /// Defines, together with Action/Type, how the action is executed.
    /// Not all Action/Type values can be used in combination with the different Action/On types.
    /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
    ///</summary>
public partial class ActionsActionOn : EditableElementValueNode<Read.IActionsActionOn, Enums.EnumActionOn?>
    {
        internal ActionsActionOn(Read.IActionsActionOn read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a On node. None of it's properties will be set.
        ///</summary>
public ActionsActionOn() : base("On")
        {
            OnCreated();
        }

        public ActionsActionOn(Enums.EnumActionOn? value) : base("On", value)
        {
        }

        private AttributeValue<string> _id;
        private AttributeValue<string> _nr;
        ///<summary>
        /// The ID of the parameter, command, response, etc.
        /// In case the "id" attribute is not present, the trigger will apply to all items of the type specified in /Protocol/Actions/Action/On.
        ///</summary>
public AttributeValue<string> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "reverse", this attribute specifies the (0-based) position(s) of the parameter(s) in the command/response.
        /// If Action/Type is "set next", this attribute specifies the (1-based) position(s) of the pair(s) in the group.
        /// In any case, separate multiple positions with semicolons.
        ///</summary>
public AttributeValue<string> Nr
        {
            get
            {
                return _nr;
            }

            set
            {
                if (_nr != value)
                {
                    _nr = value;
                    AttributeHandler.Assign(value, this, "nr");
                }
            }
        }

        public AttributeValue<string> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<string>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateNr()
        {
            if (Nr == null)
                Nr = new AttributeValue<string>();
            return Nr;
        }

        protected override void Initialize(Read.IActionsActionOn read, XmlElement editNode)
        {
            if (read == null)
                return;
            _id = read.Id != null ? new AttributeValue<string>(read.Id, this) : null;
            _nr = read.Nr != null ? new AttributeValue<string>(read.Nr, this) : null;
        }

        public static ActionsActionOn FromRead(Read.IActionsActionOn read)
        {
            if (read == null)
                return null;
            var item = new ActionsActionOn();
            item.Value = read.Value;
            item.Id = AttributeValue<string>.FromRead(read.Id);
            item.Nr = AttributeValue<string>.FromRead(read.Nr);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitActionsActionOn(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumActionOnConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumActionOn? ConvertRawValue(string rawValue)
        {
            return Enums.EnumActionOnConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines, together with Action/On, how the action is executed.
    /// Not all Action/Type values can be used in combination with the different Action/On types.
    /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the possible combinations.
    ///</summary>
public partial class ActionsActionType : EditableElementValueNode<Read.IActionsActionType, Enums.EnumActionType?>
    {
        internal ActionsActionType(Read.IActionsActionType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ActionsActionType() : base("Type")
        {
            OnCreated();
        }

        public ActionsActionType(Enums.EnumActionType? value) : base("Type", value)
        {
        }

        private AttributeValue<string> _allowed;
        private AttributeValue<string> _arguments;
        private AttributeValue<uint?> _endoffset;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _nr;
        private AttributeValue<string> _options;
        private AttributeValue<bool?> _reschedule;
        private AttributeValue<string> _returnValue;
        private AttributeValue<string> _regex;
        private AttributeValue<string> _scale;
        private AttributeValue<string> _script;
        private AttributeValue<string> _sequence;
        private AttributeValue<uint?> _startoffset;
        private AttributeValue<string> _valueAttribute;
        ///<summary>
        /// If Action/Type is "stuffing": If the byte specified in the "value" attribute is followed by one of the characters specified in this attri­bute, then it will not be repeated.
        ///</summary>
public AttributeValue<string> Allowed
        {
            get
            {
                return _allowed;
            }

            set
            {
                if (_allowed != value)
                {
                    _allowed = value;
                    AttributeHandler.Assign(value, this, "allowed");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "wmi", this attribute specifies the names of the columns to be returned (separated by semicolons).
        ///</summary>
public AttributeValue<string> Arguments
        {
            get
            {
                return _arguments;
            }

            set
            {
                if (_arguments != value)
                {
                    _arguments = value;
                    AttributeHandler.Assign(value, this, "arguments");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "stuffing", this attribute specifies the (fixed) end position that delimits the part of the data block in which stuffing has to be performed.
        ///</summary>
public AttributeValue<uint?> Endoffset
        {
            get
            {
                return _endoffset;
            }

            set
            {
                if (_endoffset != value)
                {
                    _endoffset = value;
                    AttributeHandler.Assign(value, this, "endoffset");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter containing the directory in which the file can be found.
        /// If Action/Type is "replace", this attribute specifies the ID of the parameter that contains the ID of the parameter that has to be put in the command/response.
        /// If Action/Type is "increment", this attribute specifies the ID of the parameter that holds the increment value.
        /// 
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the number of bytes to be read.
        /// If Action/Type is "replace", this attribute specifies the (0-based) position of the parameter in the command/response.
        /// If Action/Type is "set", "set and get with wait", "set with wait", "open", "close", "lock", "unlock", "priority lock" or "priority unlock", this attribute sepcifies the (0-based) connection ID.
        /// 
        ///</summary>
public AttributeValue<string> Nr
        {
            get
            {
                return _nr;
            }

            set
            {
                if (_nr != value)
                {
                    _nr = value;
                    AttributeHandler.Assign(value, this, "nr");
                }
            }
        }

        ///<summary>
        /// This attribute allows defining different options depending on the Action/Type.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options for a given type.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "restart timer" and this attribute is set to “true”, then the timer will immediately start again. Feature introduced in DataMiner 8.5.4 (RN 9189).
        ///</summary>
public AttributeValue<bool?> Reschedule
        {
            get
            {
                return _reschedule;
            }

            set
            {
                if (_reschedule != value)
                {
                    _reschedule = value;
                    AttributeHandler.Assign(value, this, "reschedule");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter in which to store the retrieved file content.
        /// If Type is "wmi", this attribute specifies the ID of the parameter containing the returned values (if "table" is set to "true", this ID should be the ID of a parameter of type "array").
        ///</summary>
public AttributeValue<string> ReturnValue
        {
            get
            {
                return _returnValue;
            }

            set
            {
                if (_returnValue != value)
                {
                    _returnValue = value;
                    AttributeHandler.Assign(value, this, "returnValue");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "aggregate", this attribute allows to specify the regular expression to use for filtering.
        /// Feature introduced in DataMiner 10.1.8 (RN 30199).
        ///</summary>
public AttributeValue<string> Regex
        {
            get
            {
                return _regex;
            }

            set
            {
                if (_regex != value)
                {
                    _regex = value;
                    AttributeHandler.Assign(value, this, "regex");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "set info", this attribute specifies the scale to be set on the parameter.
        /// Expected format: lowdata;highdata;low;high (for example: scale="0;65535;-10;10").
        ///</summary>
public AttributeValue<string> Scale
        {
            get
            {
                return _scale;
            }

            set
            {
                if (_scale != value)
                {
                    _scale = value;
                    AttributeHandler.Assign(value, this, "scale");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "wmi", this attribute specifies the WMI class (e.g. Win32_PerfRawData_PerfOS_Memory).
        ///</summary>
public AttributeValue<string> Script
        {
            get
            {
                return _script;
            }

            set
            {
                if (_script != value)
                {
                    _script = value;
                    AttributeHandler.Assign(value, this, "script");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "set info", this attribute specifies the sequence to be set on the parameter.
        ///</summary>
public AttributeValue<string> Sequence
        {
            get
            {
                return _sequence;
            }

            set
            {
                if (_sequence != value)
                {
                    _sequence = value;
                    AttributeHandler.Assign(value, this, "sequence");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "read file", this attribute specifies the ID of the parameter containing the start offset (i.e. the number of bytes to skip before starting to read the file).
        /// If Action/Type is "stuffing", this attribute specifies the (fixed) start position that delimits the part of the data block in which stuffing has to be performed.
        /// 
        ///</summary>
public AttributeValue<uint?> Startoffset
        {
            get
            {
                return _startoffset;
            }

            set
            {
                if (_startoffset != value)
                {
                    _startoffset = value;
                    AttributeHandler.Assign(value, this, "startoffset");
                }
            }
        }

        ///<summary>
        /// If Action/Type is "stuffing", this attribute specifies the actual stuffing character, i.e. the byte that has to be repeated.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        public AttributeValue<string> GetOrCreateAllowed()
        {
            if (Allowed == null)
                Allowed = new AttributeValue<string>();
            return Allowed;
        }

        public AttributeValue<string> GetOrCreateArguments()
        {
            if (Arguments == null)
                Arguments = new AttributeValue<string>();
            return Arguments;
        }

        public AttributeValue<uint?> GetOrCreateEndoffset()
        {
            if (Endoffset == null)
                Endoffset = new AttributeValue<uint?>();
            return Endoffset;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateNr()
        {
            if (Nr == null)
                Nr = new AttributeValue<string>();
            return Nr;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<bool?> GetOrCreateReschedule()
        {
            if (Reschedule == null)
                Reschedule = new AttributeValue<bool?>();
            return Reschedule;
        }

        public AttributeValue<string> GetOrCreateReturnValue()
        {
            if (ReturnValue == null)
                ReturnValue = new AttributeValue<string>();
            return ReturnValue;
        }

        public AttributeValue<string> GetOrCreateRegex()
        {
            if (Regex == null)
                Regex = new AttributeValue<string>();
            return Regex;
        }

        public AttributeValue<string> GetOrCreateScale()
        {
            if (Scale == null)
                Scale = new AttributeValue<string>();
            return Scale;
        }

        public AttributeValue<string> GetOrCreateScript()
        {
            if (Script == null)
                Script = new AttributeValue<string>();
            return Script;
        }

        public AttributeValue<string> GetOrCreateSequence()
        {
            if (Sequence == null)
                Sequence = new AttributeValue<string>();
            return Sequence;
        }

        public AttributeValue<uint?> GetOrCreateStartoffset()
        {
            if (Startoffset == null)
                Startoffset = new AttributeValue<uint?>();
            return Startoffset;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        protected override void Initialize(Read.IActionsActionType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _allowed = read.Allowed != null ? new AttributeValue<string>(read.Allowed, this) : null;
            _arguments = read.Arguments != null ? new AttributeValue<string>(read.Arguments, this) : null;
            _endoffset = read.Endoffset != null ? new AttributeValue<uint?>(read.Endoffset, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _nr = read.Nr != null ? new AttributeValue<string>(read.Nr, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _reschedule = read.Reschedule != null ? new AttributeValue<bool?>(read.Reschedule, this) : null;
            _returnValue = read.ReturnValue != null ? new AttributeValue<string>(read.ReturnValue, this) : null;
            _regex = read.Regex != null ? new AttributeValue<string>(read.Regex, this) : null;
            _scale = read.Scale != null ? new AttributeValue<string>(read.Scale, this) : null;
            _script = read.Script != null ? new AttributeValue<string>(read.Script, this) : null;
            _sequence = read.Sequence != null ? new AttributeValue<string>(read.Sequence, this) : null;
            _startoffset = read.Startoffset != null ? new AttributeValue<uint?>(read.Startoffset, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
        }

        public static ActionsActionType FromRead(Read.IActionsActionType read)
        {
            if (read == null)
                return null;
            var item = new ActionsActionType();
            item.Value = read.Value;
            item.Allowed = AttributeValue<string>.FromRead(read.Allowed);
            item.Arguments = AttributeValue<string>.FromRead(read.Arguments);
            item.Endoffset = AttributeValue<uint?>.FromRead(read.Endoffset);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Nr = AttributeValue<string>.FromRead(read.Nr);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Reschedule = AttributeValue<bool?>.FromRead(read.Reschedule);
            item.ReturnValue = AttributeValue<string>.FromRead(read.ReturnValue);
            item.Regex = AttributeValue<string>.FromRead(read.Regex);
            item.Scale = AttributeValue<string>.FromRead(read.Scale);
            item.Script = AttributeValue<string>.FromRead(read.Script);
            item.Sequence = AttributeValue<string>.FromRead(read.Sequence);
            item.Startoffset = AttributeValue<uint?>.FromRead(read.Startoffset);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitActionsActionType(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumActionTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumActionType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumActionTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies a number of advanced settings with regard to the protocol's commands and responses.
    ///</summary>
public partial class Advanced : EditableElementNode<Read.IAdvanced>
    {
        internal Advanced(Read.IAdvanced read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Advanced node. None of it's properties will be set.
        ///</summary>
public Advanced() : base("Advanced")
        {
            OnCreated();
        }

        private AttributeValue<bool?> _ignoreEqualResponse;
        private AttributeValue<string> _stuffing;
        ///<summary>
        /// If you set this attribute to "true", then a received response will be ignored if it is identical to the response received previously (for the same pair).
        /// In other words, the trigger associated with a response will not go off if that response is identical to the previous one.
        /// Note: Use this option with extreme care, as it can have a profound impact on the general behavior of the protocol.
        ///</summary>
public AttributeValue<bool?> IgnoreEqualResponse
        {
            get
            {
                return _ignoreEqualResponse;
            }

            set
            {
                if (_ignoreEqualResponse != value)
                {
                    _ignoreEqualResponse = value;
                    AttributeHandler.Assign(value, this, "ignoreEqualResponse");
                }
            }
        }

        ///<summary>
        /// In this attribute, you can specify a number of settings with regard to stuffing. Separate these by semicolons.
        ///</summary>
public AttributeValue<string> Stuffing
        {
            get
            {
                return _stuffing;
            }

            set
            {
                if (_stuffing != value)
                {
                    _stuffing = value;
                    AttributeHandler.Assign(value, this, "stuffing");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateIgnoreEqualResponse()
        {
            if (IgnoreEqualResponse == null)
                IgnoreEqualResponse = new AttributeValue<bool?>();
            return IgnoreEqualResponse;
        }

        public AttributeValue<string> GetOrCreateStuffing()
        {
            if (Stuffing == null)
                Stuffing = new AttributeValue<string>();
            return Stuffing;
        }

        protected override void Initialize(Read.IAdvanced read, XmlElement editNode)
        {
            if (read == null)
                return;
            _ignoreEqualResponse = read.IgnoreEqualResponse != null ? new AttributeValue<bool?>(read.IgnoreEqualResponse, this) : null;
            _stuffing = read.Stuffing != null ? new AttributeValue<string>(read.Stuffing, this) : null;
        }

        public static Advanced FromRead(Read.IAdvanced read)
        {
            if (read == null)
                return null;
            var item = new Advanced();
            item.IgnoreEqualResponse = AttributeValue<bool?>.FromRead(read.IgnoreEqualResponse);
            item.Stuffing = AttributeValue<string>.FromRead(read.Stuffing);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitAdvanced(this);
        }
    }

    ///<summary>
    /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
    ///</summary>
public partial class AlarmLevelLinks : EditableListNode<Read.IAlarmLevelLinks, Read.IAlarmLevelLinksAlarmLevelLink, AlarmLevelLinksAlarmLevelLink>
    {
        internal AlarmLevelLinks(Read.IAlarmLevelLinks read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AlarmLevelLinks node. None of it's properties will be set.
        ///</summary>
public AlarmLevelLinks() : base("AlarmLevelLinks")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IAlarmLevelLinks read, XmlElement editNode)
        {
        }

        public static AlarmLevelLinks FromRead(Read.IAlarmLevelLinks read)
        {
            if (read == null)
                return null;
            var item = new AlarmLevelLinks();
            foreach (var x in read)
            {
                item.Add(AlarmLevelLinksAlarmLevelLink.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitAlarmLevelLinks(this);
        }
    }

    ///<summary>
    /// Defines an alarm level link.
    /// An alarm level link allows aggregating alarms from DataMiner elements or table rows at runtime.
    /// Contains the source and the destination of the element in alarm and where the result needs to be placed.
    /// The source and destination are table columns.
    ///</summary>
public partial class AlarmLevelLinksAlarmLevelLink : EditableElementNode<Read.IAlarmLevelLinksAlarmLevelLink>
    {
        internal AlarmLevelLinksAlarmLevelLink(Read.IAlarmLevelLinksAlarmLevelLink read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AlarmLevelLink node. None of it's properties will be set.
        ///</summary>
public AlarmLevelLinksAlarmLevelLink() : base("AlarmLevelLink")
        {
            OnCreated();
        }

        private AttributeValue<string> _destination;
        private AttributeValue<string> _filters;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _remoteElement;
        ///<summary>
        /// Specifies the column parameter ID where the result of the alarm level needs to be set.
        ///</summary>
public AttributeValue<string> Destination
        {
            get
            {
                return _destination;
            }

            set
            {
                if (_destination != value)
                {
                    _destination = value;
                    AttributeHandler.Assign(value, this, "destination");
                }
            }
        }

        ///<summary>
        /// By default, alarm level linking is done via primary key or display key. For every key, a link is made with the aggregator element.
        /// If you enter a filter in the filters attribute, the link will only be made if the condition is met. Example: filters="VALUE=204 === 1"
        ///</summary>
public AttributeValue<string> Filters
        {
            get
            {
                return _filters;
            }

            set
            {
                if (_filters != value)
                {
                    _filters = value;
                    AttributeHandler.Assign(value, this, "filters");
                }
            }
        }

        ///<summary>
        /// The unique ID of the AlarmLevelLink.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Used to retrieve the alarm state of a different element.
        ///</summary>
public AttributeValue<string> RemoteElement
        {
            get
            {
                return _remoteElement;
            }

            set
            {
                if (_remoteElement != value)
                {
                    _remoteElement = value;
                    AttributeHandler.Assign(value, this, "remoteElement");
                }
            }
        }

        public AttributeValue<string> GetOrCreateDestination()
        {
            if (Destination == null)
                Destination = new AttributeValue<string>();
            return Destination;
        }

        public AttributeValue<string> GetOrCreateFilters()
        {
            if (Filters == null)
                Filters = new AttributeValue<string>();
            return Filters;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateRemoteElement()
        {
            if (RemoteElement == null)
                RemoteElement = new AttributeValue<string>();
            return RemoteElement;
        }

        protected override void Initialize(Read.IAlarmLevelLinksAlarmLevelLink read, XmlElement editNode)
        {
            if (read == null)
                return;
            _destination = read.Destination != null ? new AttributeValue<string>(read.Destination, this) : null;
            _filters = read.Filters != null ? new AttributeValue<string>(read.Filters, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _remoteElement = read.RemoteElement != null ? new AttributeValue<string>(read.RemoteElement, this) : null;
        }

        public static AlarmLevelLinksAlarmLevelLink FromRead(Read.IAlarmLevelLinksAlarmLevelLink read)
        {
            if (read == null)
                return null;
            var item = new AlarmLevelLinksAlarmLevelLink();
            item.Destination = AttributeValue<string>.FromRead(read.Destination);
            item.Filters = AttributeValue<string>.FromRead(read.Filters);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.RemoteElement = AttributeValue<string>.FromRead(read.RemoteElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitAlarmLevelLinksAlarmLevelLink(this);
        }
    }

    ///<summary>
    /// Add this element if you want to turn DataMiner elements executing this protocol into applications.
    /// In DataMiner Cube, protocol-based applications can be found in the Apps tab of the Surveyor.
    ///</summary>
public partial class App : EditableElementNode<Read.IApp>
    {
        internal App(Read.IApp read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a App node. None of it's properties will be set.
        ///</summary>
public App() : base("App")
        {
            OnCreated();
        }

        private AttributeValue<string> _type;
        ///<summary>
        /// Specifies the name of the app.
        ///</summary>
public AttributeValue<string> Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public AttributeValue<string> GetOrCreateType()
        {
            if (Type == null)
                Type = new AttributeValue<string>();
            return Type;
        }

        protected override void Initialize(Read.IApp read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new AttributeValue<string>(read.Type, this) : null;
        }

        public static App FromRead(Read.IApp read)
        {
            if (read == null)
                return null;
            var item = new App();
            item.Type = AttributeValue<string>.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitApp(this);
        }
    }

    ///<summary>
    /// Contains the chains defined in this protocol.
    ///</summary>
public partial class Chains : ComplexEditableListNode<Read.IChains, Read.IChainsItem, IChainsItem>
    {
        internal Chains(Read.IChains read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode, new Dictionary<string, Type>() { { "Chain", typeof(ChainsChain) }, { "SearchChain", typeof(ChainsSearchChain) }, { "", typeof(ChainsItem) } })
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Chains node. None of it's properties will be set.
        ///</summary>
public Chains() : base("Chains", new Dictionary<string, Type>() { { "Chain", typeof(ChainsChain) }, { "SearchChain", typeof(ChainsSearchChain) }, { "", typeof(ChainsItem) } })
        {
            OnCreated();
        }

        private ChainsFilters _filters;
        ///<summary>
        /// Determines the layout of the filters.
        ///</summary>
public ChainsFilters Filters
        {
            get
            {
                return _filters;
            }

            set
            {
                if (_filters != value)
                {
                    _filters = value;
                    AttributeHandler.Assign(value, this, "filters");
                }
            }
        }

        public ChainsFilters GetOrCreateFilters()
        {
            if (Filters == null)
                Filters = new ChainsFilters();
            return Filters;
        }

        protected override void Initialize(Read.IChains read, XmlElement editNode)
        {
            if (read == null)
                return;
            _filters = read.Filters != null ? new ChainsFilters(read.Filters, this) : null;
        }

        public static Chains FromRead(Read.IChains read)
        {
            if (read == null)
                return null;
            var item = new Chains();
            item.Filters = ChainsFilters.FromRead(read.Filters);
            foreach (var x in read)
            {
                item.Add(ChainsItem.ItemFromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChains(this);
        }
    }

    public interface IChainsItem : IEditableNode
    {
    }

    public partial class ChainsItem : EditableElementNode<Read.IChainsItem>, IChainsItem
    {
        protected ChainsItem(string tagName) : base(tagName)
        {
        }

        internal ChainsItem(Read.IChainsItem read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        protected override void Initialize(Read.IChainsItem read, XmlElement editNode)
        {
        }

        public static IChainsItem ItemFromRead(Read.IChainsItem read)
        {
            if (read == null)
                return null;
            switch (read.TagName)
            {
                case "Chain":
                    return ChainsChain.FromRead(read as Read.IChainsChain);
                case "SearchChain":
                    return ChainsSearchChain.FromRead(read as Read.IChainsSearchChain);
                default:
                    return new ChainsItem(read.TagName);
            }
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsItem(this);
        }
    }

    ///<summary>
    /// Represents a different topology view of a CPE manager or Service Over­view Manager (SOM) element.
    ///</summary>
public partial class ChainsChain : EditableListNode<Read.IChainsChain, Read.ITypeChainsChainField, TypeChainsChainField>, IChainsItem
    {
        internal ChainsChain(Read.IChainsChain read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Chain node. None of it's properties will be set.
        ///</summary>
public ChainsChain() : base("Chain")
        {
            OnCreated();
        }

        private TypeChainsChainDisplay _display;
        private AttributeValue<string> _defaultSelectionField;
        private AttributeValue<string> _groupingName;
        private AttributeValue<string> _name;
        private AttributeValue<string> _options;
        private AttributeValue<string> _topology;
        public TypeChainsChainDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the field for which selection should be applied.
        ///</summary>
public AttributeValue<string> DefaultSelectionField
        {
            get
            {
                return _defaultSelectionField;
            }

            set
            {
                if (_defaultSelectionField != value)
                {
                    _defaultSelectionField = value;
                    AttributeHandler.Assign(value, this, "defaultSelectionField");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the group to which this Chain belongs. Feature introduced in DataMiner 10.1.3 (RN 28751, RN 28834, RN 28846).
        ///</summary>
public AttributeValue<string> GroupingName
        {
            get
            {
                return _groupingName;
            }

            set
            {
                if (_groupingName != value)
                {
                    _groupingName = value;
                    AttributeHandler.Assign(value, this, "groupingName");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the chain, which is used as the name of the corresponding tab page in DataMiner.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options (separated by semicolons).
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Contains the name defined in the /Protocol/Topologies/Topology@name attribute (only Service Overview Manager). See Protocol/Topologies/Topology@name.
        ///</summary>
public AttributeValue<string> Topology
        {
            get
            {
                return _topology;
            }

            set
            {
                if (_topology != value)
                {
                    _topology = value;
                    AttributeHandler.Assign(value, this, "topology");
                }
            }
        }

        public TypeChainsChainDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new TypeChainsChainDisplay("Display");
            return Display;
        }

        public AttributeValue<string> GetOrCreateDefaultSelectionField()
        {
            if (DefaultSelectionField == null)
                DefaultSelectionField = new AttributeValue<string>();
            return DefaultSelectionField;
        }

        public AttributeValue<string> GetOrCreateGroupingName()
        {
            if (GroupingName == null)
                GroupingName = new AttributeValue<string>();
            return GroupingName;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<string> GetOrCreateTopology()
        {
            if (Topology == null)
                Topology = new AttributeValue<string>();
            return Topology;
        }

        protected override void Initialize(Read.IChainsChain read, XmlElement editNode)
        {
            if (read == null)
                return;
            _display = read.Display != null ? new TypeChainsChainDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _defaultSelectionField = read.DefaultSelectionField != null ? new AttributeValue<string>(read.DefaultSelectionField, this) : null;
            _groupingName = read.GroupingName != null ? new AttributeValue<string>(read.GroupingName, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _topology = read.Topology != null ? new AttributeValue<string>(read.Topology, this) : null;
        }

        public static ChainsChain FromRead(Read.IChainsChain read)
        {
            if (read == null)
                return null;
            var item = new ChainsChain();
            item.Display = TypeChainsChainDisplay.FromRead(read.Display);
            item.DefaultSelectionField = AttributeValue<string>.FromRead(read.DefaultSelectionField);
            item.GroupingName = AttributeValue<string>.FromRead(read.GroupingName);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Topology = AttributeValue<string>.FromRead(read.Topology);
            foreach (var x in read)
            {
                item.Add(TypeChainsChainField.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsChain(this);
        }
    }

    ///<summary>
    /// Defines a search chain in a CPE environment.
    ///</summary>
public partial class ChainsSearchChain : EditableElementNode<Read.IChainsSearchChain>, IChainsItem
    {
        internal ChainsSearchChain(Read.IChainsSearchChain read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SearchChain node. None of it's properties will be set.
        ///</summary>
public ChainsSearchChain() : base("SearchChain")
        {
            OnCreated();
        }

        private TypeChainsSearchChainDisplay _display;
        private ChainsSearchChainTabs _tabs;
        private AttributeValue<string> _name;
        public TypeChainsSearchChainDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        public ChainsSearchChainTabs Tabs
        {
            get
            {
                return _tabs;
            }

            set
            {
                if (_tabs != value)
                {
                    _tabs = value;
                    CombinedTagHandler.Assign(value, this, "Tabs");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the search chain.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public TypeChainsSearchChainDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new TypeChainsSearchChainDisplay("Display");
            return Display;
        }

        public ChainsSearchChainTabs GetOrCreateTabs()
        {
            if (Tabs == null)
                Tabs = new ChainsSearchChainTabs();
            return Tabs;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.IChainsSearchChain read, XmlElement editNode)
        {
            if (read == null)
                return;
            _display = read.Display != null ? new TypeChainsSearchChainDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _tabs = read.Tabs != null ? new ChainsSearchChainTabs(read.Tabs, this, editNode.Element["Tabs"]) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static ChainsSearchChain FromRead(Read.IChainsSearchChain read)
        {
            if (read == null)
                return null;
            var item = new ChainsSearchChain();
            item.Display = TypeChainsSearchChainDisplay.FromRead(read.Display);
            item.Tabs = ChainsSearchChainTabs.FromRead(read.Tabs);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsSearchChain(this);
        }
    }

    public partial class ChainsSearchChainTabs : EditableListNode<Read.IChainsSearchChainTabs, Read.IChainsSearchChainTabsTab, ChainsSearchChainTabsTab>
    {
        internal ChainsSearchChainTabs(Read.IChainsSearchChainTabs read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Tabs node. None of it's properties will be set.
        ///</summary>
public ChainsSearchChainTabs() : base("Tabs")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IChainsSearchChainTabs read, XmlElement editNode)
        {
        }

        public static ChainsSearchChainTabs FromRead(Read.IChainsSearchChainTabs read)
        {
            if (read == null)
                return null;
            var item = new ChainsSearchChainTabs();
            foreach (var x in read)
            {
                item.Add(ChainsSearchChainTabsTab.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsSearchChainTabs(this);
        }
    }

    ///<summary>
    /// Defines a tab.
    ///</summary>
public partial class ChainsSearchChainTabsTab : EditableElementNode<Read.IChainsSearchChainTabsTab>
    {
        internal ChainsSearchChainTabsTab(Read.IChainsSearchChainTabsTab read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Tab node. None of it's properties will be set.
        ///</summary>
public ChainsSearchChainTabsTab() : base("Tab")
        {
            OnCreated();
        }

        private TypeChainsSearchChainFieldDisplay _display;
        private ChainsSearchChainTabsTabFields _fields;
        private AttributeValue<uint?> _tablePid;
        private AttributeValue<string> _name;
        public TypeChainsSearchChainFieldDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// Contains the definition of the fields to be included in this search tab.
        ///</summary>
public ChainsSearchChainTabsTabFields Fields
        {
            get
            {
                return _fields;
            }

            set
            {
                if (_fields != value)
                {
                    _fields = value;
                    CombinedTagHandler.Assign(value, this, "Fields");
                }
            }
        }

        ///<summary>
        /// Specifies the table parameter ID of the table for which a search Tab will be defined.
        ///</summary>
public AttributeValue<uint?> TablePid
        {
            get
            {
                return _tablePid;
            }

            set
            {
                if (_tablePid != value)
                {
                    _tablePid = value;
                    AttributeHandler.Assign(value, this, "tablePid");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the search tab.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public TypeChainsSearchChainFieldDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new TypeChainsSearchChainFieldDisplay("Display");
            return Display;
        }

        public ChainsSearchChainTabsTabFields GetOrCreateFields()
        {
            if (Fields == null)
                Fields = new ChainsSearchChainTabsTabFields();
            return Fields;
        }

        public AttributeValue<uint?> GetOrCreateTablePid()
        {
            if (TablePid == null)
                TablePid = new AttributeValue<uint?>();
            return TablePid;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.IChainsSearchChainTabsTab read, XmlElement editNode)
        {
            if (read == null)
                return;
            _display = read.Display != null ? new TypeChainsSearchChainFieldDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _fields = read.Fields != null ? new ChainsSearchChainTabsTabFields(read.Fields, this, editNode.Element["Fields"]) : null;
            _tablePid = read.TablePid != null ? new AttributeValue<uint?>(read.TablePid, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static ChainsSearchChainTabsTab FromRead(Read.IChainsSearchChainTabsTab read)
        {
            if (read == null)
                return null;
            var item = new ChainsSearchChainTabsTab();
            item.Display = TypeChainsSearchChainFieldDisplay.FromRead(read.Display);
            item.Fields = ChainsSearchChainTabsTabFields.FromRead(read.Fields);
            item.TablePid = AttributeValue<uint?>.FromRead(read.TablePid);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsSearchChainTabsTab(this);
        }
    }

    ///<summary>
    /// Contains the definition of the fields to be included in this search tab.
    ///</summary>
public partial class ChainsSearchChainTabsTabFields : EditableListNode<Read.IChainsSearchChainTabsTabFields, Read.ITypeChainsSearchChainTabsTabField, TypeChainsSearchChainTabsTabField>
    {
        internal ChainsSearchChainTabsTabFields(Read.IChainsSearchChainTabsTabFields read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Fields node. None of it's properties will be set.
        ///</summary>
public ChainsSearchChainTabsTabFields() : base("Fields")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IChainsSearchChainTabsTabFields read, XmlElement editNode)
        {
        }

        public static ChainsSearchChainTabsTabFields FromRead(Read.IChainsSearchChainTabsTabFields read)
        {
            if (read == null)
                return null;
            var item = new ChainsSearchChainTabsTabFields();
            foreach (var x in read)
            {
                item.Add(TypeChainsSearchChainTabsTabField.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitChainsSearchChainTabsTabFields(this);
        }
    }

    public partial class ChainsFilters : AttributeValue<Enums.EnumChainsFilters?>
    {
        internal ChainsFilters(Read.IValueTag<Enums.EnumChainsFilters?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a filters node. None of it's properties will be set.
        ///</summary>
public ChainsFilters() : base()
        {
            OnCreated();
        }

        public ChainsFilters(Enums.EnumChainsFilters? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumChainsFiltersConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumChainsFilters? ConvertRawValue(string rawValue)
        {
            return Enums.EnumChainsFiltersConverter.Convert(rawValue?.Trim());
        }

        public new static ChainsFilters FromRead(Read.IValueTag<Enums.EnumChainsFilters?> read)
        {
            if (read == null)
                return null;
            var item = new ChainsFilters();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Contains all commands defined in the protocol.
    /// Commands are sent from DataMiner to the device
    /// - to request information from the device, or
    /// - to change a device setting.
    ///</summary>
public partial class Commands : EditableListNode<Read.ICommands, Read.ICommandsCommand, CommandsCommand>
    {
        internal Commands(Read.ICommands read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Commands node. None of it's properties will be set.
        ///</summary>
public Commands() : base("Commands")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ICommands read, XmlElement editNode)
        {
        }

        public static Commands FromRead(Read.ICommands read)
        {
            if (read == null)
                return null;
            var item = new Commands();
            foreach (var x in read)
            {
                item.Add(CommandsCommand.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCommands(this);
        }
    }

    ///<summary>
    /// Defines a complete command.
    /// DataMiner sends a command to the device
    /// - to request information, or
    /// - to change a device setting.
    /// In both cases, DataMiner will expect a response from the device. If it requests information, it will expect a response that contains that
    /// information, and if it changes a setting, it will expect a confirmation (although, in some cases, none is returned).
    ///</summary>
public partial class CommandsCommand : EditableElementNode<Read.ICommandsCommand>
    {
        internal CommandsCommand(Read.ICommandsCommand read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Command node. None of it's properties will be set.
        ///</summary>
public CommandsCommand() : base("Command")
        {
            OnCreated();
        }

        private CommandsCommandContent _content;
        private ElementValue<string> _description;
        private ElementValue<string> _name;
        private CommandsCommandWebSocketMessageType _webSocketMessageType;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _ascii;
        ///<summary>
        /// Specifies the consecutive parameters that together form the command to be sent to the device.
        /// Quite often, commands have a header parameter and a trailer parameter that demarcate the beginning and the end of the command.
        ///</summary>
public CommandsCommandContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        ///<summary>
        /// Specifies the command description.
        ///</summary>
public ElementValue<string> Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    ElementHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Specifies the command name.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Specifies the format in which the message should be sent.
        /// By default, the message is sent in binary format.
        /// Feature introduced in DataMiner 9.5.1.
        ///</summary>
public CommandsCommandWebSocketMessageType WebSocketMessageType
        {
            get
            {
                return _webSocketMessageType;
            }

            set
            {
                if (_webSocketMessageType != value)
                {
                    _webSocketMessageType = value;
                    ElementHandler.Assign(value, this, "WebSocketMessageType");
                }
            }
        }

        ///<summary>
        /// Specifies the command ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Only applicable for Unicode protocols. Set to "true" if all parameters of the command should be sent as ASCII.
        /// Use semicolon-separated parameter IDs if only certain parameters should be sent as ASCII.
        ///</summary>
public AttributeValue<string> Ascii
        {
            get
            {
                return _ascii;
            }

            set
            {
                if (_ascii != value)
                {
                    _ascii = value;
                    AttributeHandler.Assign(value, this, "ascii");
                }
            }
        }

        public CommandsCommandContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new CommandsCommandContent();
            return Content;
        }

        public ElementValue<string> GetOrCreateDescription()
        {
            if (Description == null)
                Description = new ElementValue<string>();
            return Description;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public CommandsCommandWebSocketMessageType GetOrCreateWebSocketMessageType()
        {
            if (WebSocketMessageType == null)
                WebSocketMessageType = new CommandsCommandWebSocketMessageType();
            return WebSocketMessageType;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateAscii()
        {
            if (Ascii == null)
                Ascii = new AttributeValue<string>();
            return Ascii;
        }

        protected override void Initialize(Read.ICommandsCommand read, XmlElement editNode)
        {
            if (read == null)
                return;
            _content = read.Content != null ? new CommandsCommandContent(read.Content, this, editNode.Element["Content"]) : null;
            _description = read.Description != null ? new ElementValue<string>(read.Description, this) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _webSocketMessageType = read.WebSocketMessageType != null ? new CommandsCommandWebSocketMessageType(read.WebSocketMessageType, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _ascii = read.Ascii != null ? new AttributeValue<string>(read.Ascii, this) : null;
        }

        public static CommandsCommand FromRead(Read.ICommandsCommand read)
        {
            if (read == null)
                return null;
            var item = new CommandsCommand();
            item.Content = CommandsCommandContent.FromRead(read.Content);
            item.Description = ElementValue<string>.FromRead(read.Description);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.WebSocketMessageType = CommandsCommandWebSocketMessageType.FromRead(read.WebSocketMessageType);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Ascii = AttributeValue<string>.FromRead(read.Ascii);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCommandsCommand(this);
        }
    }

    ///<summary>
    /// Specifies the consecutive parameters that together form the command to be sent to the device.
    /// Quite often, commands have a header parameter and a trailer parameter that demarcate the beginning and the end of the command.
    ///</summary>
public partial class CommandsCommandContent : EditableListNode<Read.ICommandsCommandContent, Read.ICommandsCommandContentParam, CommandsCommandContentParam>
    {
        internal CommandsCommandContent(Read.ICommandsCommandContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public CommandsCommandContent() : base("Content")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ICommandsCommandContent read, XmlElement editNode)
        {
        }

        public static CommandsCommandContent FromRead(Read.ICommandsCommandContent read)
        {
            if (read == null)
                return null;
            var item = new CommandsCommandContent();
            foreach (var x in read)
            {
                item.Add(CommandsCommandContentParam.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCommandsCommandContent(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the parameter to include in the command.
    ///</summary>
public partial class CommandsCommandContentParam : EditableElementValueNode<Read.ICommandsCommandContentParam, uint?>
    {
        internal CommandsCommandContentParam(Read.ICommandsCommandContentParam read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Param node. None of it's properties will be set.
        ///</summary>
public CommandsCommandContentParam() : base("Param")
        {
            OnCreated();
        }

        public CommandsCommandContentParam(uint? value) : base("Param", value)
        {
        }

        protected override void Initialize(Read.ICommandsCommandContentParam read, XmlElement editNode)
        {
        }

        public static CommandsCommandContentParam FromRead(Read.ICommandsCommandContentParam read)
        {
            if (read == null)
                return null;
            var item = new CommandsCommandContentParam();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCommandsCommandContentParam(this);
        }
    }

    public partial class CommandsCommandWebSocketMessageType : ElementValue<Enums.EnumWebSocketMessageType?>
    {
        internal CommandsCommandWebSocketMessageType(Read.IValueTag<Enums.EnumWebSocketMessageType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a WebSocketMessageType node. None of it's properties will be set.
        ///</summary>
public CommandsCommandWebSocketMessageType() : base()
        {
            OnCreated();
        }

        public CommandsCommandWebSocketMessageType(Enums.EnumWebSocketMessageType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumWebSocketMessageTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumWebSocketMessageType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumWebSocketMessageTypeConverter.Convert(rawValue?.Trim());
        }

        public new static CommandsCommandWebSocketMessageType FromRead(Read.IValueTag<Enums.EnumWebSocketMessageType?> read)
        {
            if (read == null)
                return null;
            var item = new CommandsCommandWebSocketMessageType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Provides compliance information about this protocol.
    ///</summary>
public partial class Compliancies : EditableElementNode<Read.ICompliancies>
    {
        internal Compliancies(Read.ICompliancies read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Compliancies node. None of it's properties will be set.
        ///</summary>
public Compliancies() : base("Compliancies")
        {
            OnCreated();
        }

        private ElementValue<bool?> _cassandraReady;
        private ElementValue<bool?> _cassandraRequired;
        private ElementValue<string> _minimumRequiredVersion;
        private ElementValue<string> _maximumSupportedVersion;
        ///<summary>
        /// True if the protocol is compatible with a Cassandra database; otherwise, false.
        ///</summary>
public ElementValue<bool?> CassandraReady
        {
            get
            {
                return _cassandraReady;
            }

            set
            {
                if (_cassandraReady != value)
                {
                    _cassandraReady = value;
                    ElementHandler.Assign(value, this, "CassandraReady");
                }
            }
        }

        ///<summary>
        /// Specifies whether a Cassandra database is required to execute the protocol. True if Cassandra is required to use this protocol; otherwise, false.
        ///</summary>
public ElementValue<bool?> CassandraRequired
        {
            get
            {
                return _cassandraRequired;
            }

            set
            {
                if (_cassandraRequired != value)
                {
                    _cassandraRequired = value;
                    ElementHandler.Assign(value, this, "CassandraRequired");
                }
            }
        }

        ///<summary>
        /// Indicates the minimum DataMiner version that the driver is compatible with.
        /// Expected format: [MainVersion].[MainVersionIncrement].[FeatureVersionIncrement].[CurrentlyUnused] - [BuildNumber] (in which [BuildNumber] is a four-digit number) (e.g. 10.0.7.0 - 9247)
        ///</summary>
public ElementValue<string> MinimumRequiredVersion
        {
            get
            {
                return _minimumRequiredVersion;
            }

            set
            {
                if (_minimumRequiredVersion != value)
                {
                    _minimumRequiredVersion = value;
                    ElementHandler.Assign(value, this, "MinimumRequiredVersion");
                }
            }
        }

        ///<summary>
        /// Specifies the maximum DataMiner version this protocol supports.
        /// Expected format: [MainVersion].[MainVersionIncrement].[FeatureVersionIncrement].[CurrentlyUnused] - [BuildNumber] (in which [BuildNumber] is a four-digit number) (e.g. 10.0.7.0 - 9247)
        ///</summary>
public ElementValue<string> MaximumSupportedVersion
        {
            get
            {
                return _maximumSupportedVersion;
            }

            set
            {
                if (_maximumSupportedVersion != value)
                {
                    _maximumSupportedVersion = value;
                    ElementHandler.Assign(value, this, "MaximumSupportedVersion");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateCassandraReady()
        {
            if (CassandraReady == null)
                CassandraReady = new ElementValue<bool?>();
            return CassandraReady;
        }

        public ElementValue<bool?> GetOrCreateCassandraRequired()
        {
            if (CassandraRequired == null)
                CassandraRequired = new ElementValue<bool?>();
            return CassandraRequired;
        }

        public ElementValue<string> GetOrCreateMinimumRequiredVersion()
        {
            if (MinimumRequiredVersion == null)
                MinimumRequiredVersion = new ElementValue<string>();
            return MinimumRequiredVersion;
        }

        public ElementValue<string> GetOrCreateMaximumSupportedVersion()
        {
            if (MaximumSupportedVersion == null)
                MaximumSupportedVersion = new ElementValue<string>();
            return MaximumSupportedVersion;
        }

        protected override void Initialize(Read.ICompliancies read, XmlElement editNode)
        {
            if (read == null)
                return;
            _cassandraReady = read.CassandraReady != null ? new ElementValue<bool?>(read.CassandraReady, this) : null;
            _cassandraRequired = read.CassandraRequired != null ? new ElementValue<bool?>(read.CassandraRequired, this) : null;
            _minimumRequiredVersion = read.MinimumRequiredVersion != null ? new ElementValue<string>(read.MinimumRequiredVersion, this) : null;
            _maximumSupportedVersion = read.MaximumSupportedVersion != null ? new ElementValue<string>(read.MaximumSupportedVersion, this) : null;
        }

        public static Compliancies FromRead(Read.ICompliancies read)
        {
            if (read == null)
                return null;
            var item = new Compliancies();
            item.CassandraReady = ElementValue<bool?>.FromRead(read.CassandraReady);
            item.CassandraRequired = ElementValue<bool?>.FromRead(read.CassandraRequired);
            item.MinimumRequiredVersion = ElementValue<string>.FromRead(read.MinimumRequiredVersion);
            item.MaximumSupportedVersion = ElementValue<string>.FromRead(read.MaximumSupportedVersion);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitCompliancies(this);
        }
    }

    ///<summary>
    /// Defines communication connections.
    ///</summary>
public partial class Connections : EditableListNode<Read.IConnections, Read.IConnectionsConnection, ConnectionsConnection>
    {
        internal Connections(Read.IConnections read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Connections node. None of it's properties will be set.
        ///</summary>
public Connections() : base("Connections")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnections read, XmlElement editNode)
        {
        }

        public static Connections FromRead(Read.IConnections read)
        {
            if (read == null)
                return null;
            var item = new Connections();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnection.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnections(this);
        }
    }

    ///<summary>
    /// Defines a connection.
    ///</summary>
public partial class ConnectionsConnection : EditableElementNode<Read.IConnectionsConnection>
    {
        internal ConnectionsConnection(Read.IConnectionsConnection read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Connection node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnection() : base("Connection")
        {
            OnCreated();
        }

        private ConnectionsConnectionVirtual _virtual;
        private ConnectionsConnectionSnmp _snmp;
        private ConnectionsConnectionSnmpV2 _snmpV2;
        private ConnectionsConnectionSnmpV3 _snmpV3;
        private ConnectionsConnectionHttp _http;
        private ConnectionsConnectionSerial _serial;
        private ConnectionsConnectionSmartSerial _smartSerial;
        private ConnectionsConnectionGpib _gpib;
        private ConnectionsConnectionOpc _opc;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _name;
        ///<summary>
        /// Defines a Virtual connection.
        ///</summary>
public ConnectionsConnectionVirtual Virtual
        {
            get
            {
                return _virtual;
            }

            set
            {
                if (_virtual != value)
                {
                    _virtual = value;
                    CombinedTagHandler.Assign(value, this, "Virtual");
                }
            }
        }

        ///<summary>
        /// Defines an SNMP connection.
        ///</summary>
public ConnectionsConnectionSnmp Snmp
        {
            get
            {
                return _snmp;
            }

            set
            {
                if (_snmp != value)
                {
                    _snmp = value;
                    CombinedTagHandler.Assign(value, this, "Snmp");
                }
            }
        }

        ///<summary>
        /// Defines an SNMPv2 connection.
        ///</summary>
public ConnectionsConnectionSnmpV2 SnmpV2
        {
            get
            {
                return _snmpV2;
            }

            set
            {
                if (_snmpV2 != value)
                {
                    _snmpV2 = value;
                    CombinedTagHandler.Assign(value, this, "SnmpV2");
                }
            }
        }

        ///<summary>
        /// Defines an SNMPv3 connection.
        ///</summary>
public ConnectionsConnectionSnmpV3 SnmpV3
        {
            get
            {
                return _snmpV3;
            }

            set
            {
                if (_snmpV3 != value)
                {
                    _snmpV3 = value;
                    CombinedTagHandler.Assign(value, this, "SnmpV3");
                }
            }
        }

        ///<summary>
        /// Defines an HTTP connection.
        ///</summary>
public ConnectionsConnectionHttp Http
        {
            get
            {
                return _http;
            }

            set
            {
                if (_http != value)
                {
                    _http = value;
                    CombinedTagHandler.Assign(value, this, "Http");
                }
            }
        }

        ///<summary>
        /// Defines a serial connection.
        ///</summary>
public ConnectionsConnectionSerial Serial
        {
            get
            {
                return _serial;
            }

            set
            {
                if (_serial != value)
                {
                    _serial = value;
                    CombinedTagHandler.Assign(value, this, "Serial");
                }
            }
        }

        ///<summary>
        /// Defines a smart-serial connection.
        ///</summary>
public ConnectionsConnectionSmartSerial SmartSerial
        {
            get
            {
                return _smartSerial;
            }

            set
            {
                if (_smartSerial != value)
                {
                    _smartSerial = value;
                    CombinedTagHandler.Assign(value, this, "SmartSerial");
                }
            }
        }

        ///<summary>
        /// Defines a GPIB connection.
        ///</summary>
public ConnectionsConnectionGpib Gpib
        {
            get
            {
                return _gpib;
            }

            set
            {
                if (_gpib != value)
                {
                    _gpib = value;
                    CombinedTagHandler.Assign(value, this, "Gpib");
                }
            }
        }

        ///<summary>
        /// Defines a OPC connection.
        ///</summary>
public ConnectionsConnectionOpc Opc
        {
            get
            {
                return _opc;
            }

            set
            {
                if (_opc != value)
                {
                    _opc = value;
                    CombinedTagHandler.Assign(value, this, "Opc");
                }
            }
        }

        ///<summary>
        /// Specifies the connection ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies the connection name.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public ConnectionsConnectionVirtual GetOrCreateVirtual()
        {
            if (Virtual == null)
                Virtual = new ConnectionsConnectionVirtual();
            return Virtual;
        }

        public ConnectionsConnectionSnmp GetOrCreateSnmp()
        {
            if (Snmp == null)
                Snmp = new ConnectionsConnectionSnmp();
            return Snmp;
        }

        public ConnectionsConnectionSnmpV2 GetOrCreateSnmpV2()
        {
            if (SnmpV2 == null)
                SnmpV2 = new ConnectionsConnectionSnmpV2();
            return SnmpV2;
        }

        public ConnectionsConnectionSnmpV3 GetOrCreateSnmpV3()
        {
            if (SnmpV3 == null)
                SnmpV3 = new ConnectionsConnectionSnmpV3();
            return SnmpV3;
        }

        public ConnectionsConnectionHttp GetOrCreateHttp()
        {
            if (Http == null)
                Http = new ConnectionsConnectionHttp();
            return Http;
        }

        public ConnectionsConnectionSerial GetOrCreateSerial()
        {
            if (Serial == null)
                Serial = new ConnectionsConnectionSerial();
            return Serial;
        }

        public ConnectionsConnectionSmartSerial GetOrCreateSmartSerial()
        {
            if (SmartSerial == null)
                SmartSerial = new ConnectionsConnectionSmartSerial();
            return SmartSerial;
        }

        public ConnectionsConnectionGpib GetOrCreateGpib()
        {
            if (Gpib == null)
                Gpib = new ConnectionsConnectionGpib();
            return Gpib;
        }

        public ConnectionsConnectionOpc GetOrCreateOpc()
        {
            if (Opc == null)
                Opc = new ConnectionsConnectionOpc();
            return Opc;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.IConnectionsConnection read, XmlElement editNode)
        {
            if (read == null)
                return;
            _virtual = read.Virtual != null ? new ConnectionsConnectionVirtual(read.Virtual, this, editNode.Element["Virtual"]) : null;
            _snmp = read.Snmp != null ? new ConnectionsConnectionSnmp(read.Snmp, this, editNode.Element["Snmp"]) : null;
            _snmpV2 = read.SnmpV2 != null ? new ConnectionsConnectionSnmpV2(read.SnmpV2, this, editNode.Element["SnmpV2"]) : null;
            _snmpV3 = read.SnmpV3 != null ? new ConnectionsConnectionSnmpV3(read.SnmpV3, this, editNode.Element["SnmpV3"]) : null;
            _http = read.Http != null ? new ConnectionsConnectionHttp(read.Http, this, editNode.Element["Http"]) : null;
            _serial = read.Serial != null ? new ConnectionsConnectionSerial(read.Serial, this, editNode.Element["Serial"]) : null;
            _smartSerial = read.SmartSerial != null ? new ConnectionsConnectionSmartSerial(read.SmartSerial, this, editNode.Element["SmartSerial"]) : null;
            _gpib = read.Gpib != null ? new ConnectionsConnectionGpib(read.Gpib, this, editNode.Element["Gpib"]) : null;
            _opc = read.Opc != null ? new ConnectionsConnectionOpc(read.Opc, this, editNode.Element["Opc"]) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static ConnectionsConnection FromRead(Read.IConnectionsConnection read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnection();
            item.Virtual = ConnectionsConnectionVirtual.FromRead(read.Virtual);
            item.Snmp = ConnectionsConnectionSnmp.FromRead(read.Snmp);
            item.SnmpV2 = ConnectionsConnectionSnmpV2.FromRead(read.SnmpV2);
            item.SnmpV3 = ConnectionsConnectionSnmpV3.FromRead(read.SnmpV3);
            item.Http = ConnectionsConnectionHttp.FromRead(read.Http);
            item.Serial = ConnectionsConnectionSerial.FromRead(read.Serial);
            item.SmartSerial = ConnectionsConnectionSmartSerial.FromRead(read.SmartSerial);
            item.Gpib = ConnectionsConnectionGpib.FromRead(read.Gpib);
            item.Opc = ConnectionsConnectionOpc.FromRead(read.Opc);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnection(this);
        }
    }

    ///<summary>
    /// Defines a Virtual connection.
    ///</summary>
public partial class ConnectionsConnectionVirtual : EditableElementNode<Read.IConnectionsConnectionVirtual>
    {
        internal ConnectionsConnectionVirtual(Read.IConnectionsConnectionVirtual read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Virtual node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionVirtual() : base("Virtual")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionVirtual read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionVirtual FromRead(Read.IConnectionsConnectionVirtual read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionVirtual();
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionVirtual(this);
        }
    }

    ///<summary>
    /// Defines an SNMP connection.
    ///</summary>
public partial class ConnectionsConnectionSnmp : EditableElementNode<Read.IConnectionsConnectionSnmp>
    {
        internal ConnectionsConnectionSnmp(Read.IConnectionsConnectionSnmp read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Snmp node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmp() : base("Snmp")
        {
            OnCreated();
        }

        private ConnectionsConnectionSnmpCommunicationOptions _communicationOptions;
        private ConnectionsConnectionSnmpUserSettings _userSettings;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public ConnectionsConnectionSnmpCommunicationOptions CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    CombinedTagHandler.Assign(value, this, "CommunicationOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public ConnectionsConnectionSnmpUserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        public ConnectionsConnectionSnmpCommunicationOptions GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new ConnectionsConnectionSnmpCommunicationOptions();
            return CommunicationOptions;
        }

        public ConnectionsConnectionSnmpUserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ConnectionsConnectionSnmpUserSettings();
            return UserSettings;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmp read, XmlElement editNode)
        {
            if (read == null)
                return;
            _communicationOptions = read.CommunicationOptions != null ? new ConnectionsConnectionSnmpCommunicationOptions(read.CommunicationOptions, this, editNode.Element["CommunicationOptions"]) : null;
            _userSettings = read.UserSettings != null ? new ConnectionsConnectionSnmpUserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
        }

        public static ConnectionsConnectionSnmp FromRead(Read.IConnectionsConnectionSnmp read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmp();
            item.CommunicationOptions = ConnectionsConnectionSnmpCommunicationOptions.FromRead(read.CommunicationOptions);
            item.UserSettings = ConnectionsConnectionSnmpUserSettings.FromRead(read.UserSettings);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmp(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpCommunicationOptions : EditableElementNode<Read.IConnectionsConnectionSnmpCommunicationOptions>
    {
        internal ConnectionsConnectionSnmpCommunicationOptions(Read.IConnectionsConnectionSnmpCommunicationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CommunicationOptions node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpCommunicationOptions() : base("CommunicationOptions")
        {
            OnCreated();
        }

        private ElementValue<bool?> _redundantPolling;
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
public ElementValue<bool?> RedundantPolling
        {
            get
            {
                return _redundantPolling;
            }

            set
            {
                if (_redundantPolling != value)
                {
                    _redundantPolling = value;
                    ElementHandler.Assign(value, this, "RedundantPolling");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateRedundantPolling()
        {
            if (RedundantPolling == null)
                RedundantPolling = new ElementValue<bool?>();
            return RedundantPolling;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpCommunicationOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _redundantPolling = read.RedundantPolling != null ? new ElementValue<bool?>(read.RedundantPolling, this) : null;
        }

        public static ConnectionsConnectionSnmpCommunicationOptions FromRead(Read.IConnectionsConnectionSnmpCommunicationOptions read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpCommunicationOptions();
            item.RedundantPolling = ElementValue<bool?>.FromRead(read.RedundantPolling);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpCommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettings : EditableElementNode<Read.IConnectionsConnectionSnmpUserSettings>
    {
        internal ConnectionsConnectionSnmpUserSettings(Read.IConnectionsConnectionSnmpUserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        private ConnectionsConnectionSnmpUserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSnmpUserSettingsIPport _iPport;
        private ConnectionsConnectionSnmpUserSettingsGetCommunity _getCommunity;
        private ConnectionsConnectionSnmpUserSettingsSetCommunity _setCommunity;
        private ConnectionsConnectionSnmpUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSnmpUserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        ///<summary>
        /// Configures the get community string.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsGetCommunity GetCommunity
        {
            get
            {
                return _getCommunity;
            }

            set
            {
                if (_getCommunity != value)
                {
                    _getCommunity = value;
                    CombinedTagHandler.Assign(value, this, "GetCommunity");
                }
            }
        }

        ///<summary>
        /// Configures the get community string.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsSetCommunity SetCommunity
        {
            get
            {
                return _setCommunity;
            }

            set
            {
                if (_setCommunity != value)
                {
                    _setCommunity = value;
                    CombinedTagHandler.Assign(value, this, "SetCommunity");
                }
            }
        }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        public ConnectionsConnectionSnmpUserSettingsBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new ConnectionsConnectionSnmpUserSettingsBusAddress();
            return BusAddress;
        }

        public ConnectionsConnectionSnmpUserSettingsIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new ConnectionsConnectionSnmpUserSettingsIPport();
            return IPport;
        }

        public ConnectionsConnectionSnmpUserSettingsGetCommunity GetOrCreateGetCommunity()
        {
            if (GetCommunity == null)
                GetCommunity = new ConnectionsConnectionSnmpUserSettingsGetCommunity();
            return GetCommunity;
        }

        public ConnectionsConnectionSnmpUserSettingsSetCommunity GetOrCreateSetCommunity()
        {
            if (SetCommunity == null)
                SetCommunity = new ConnectionsConnectionSnmpUserSettingsSetCommunity();
            return SetCommunity;
        }

        public ConnectionsConnectionSnmpUserSettingsTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new ConnectionsConnectionSnmpUserSettingsTimeoutTime();
            return TimeoutTime;
        }

        public ConnectionsConnectionSnmpUserSettingsRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new ConnectionsConnectionSnmpUserSettingsRetries();
            return Retries;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _busAddress = read.BusAddress != null ? new ConnectionsConnectionSnmpUserSettingsBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _iPport = read.IPport != null ? new ConnectionsConnectionSnmpUserSettingsIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _getCommunity = read.GetCommunity != null ? new ConnectionsConnectionSnmpUserSettingsGetCommunity(read.GetCommunity, this, editNode.Element["GetCommunity"]) : null;
            _setCommunity = read.SetCommunity != null ? new ConnectionsConnectionSnmpUserSettingsSetCommunity(read.SetCommunity, this, editNode.Element["SetCommunity"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new ConnectionsConnectionSnmpUserSettingsTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _retries = read.Retries != null ? new ConnectionsConnectionSnmpUserSettingsRetries(read.Retries, this, editNode.Element["Retries"]) : null;
        }

        public static ConnectionsConnectionSnmpUserSettings FromRead(Read.IConnectionsConnectionSnmpUserSettings read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettings();
            item.BusAddress = ConnectionsConnectionSnmpUserSettingsBusAddress.FromRead(read.BusAddress);
            item.IPport = ConnectionsConnectionSnmpUserSettingsIPport.FromRead(read.IPport);
            item.GetCommunity = ConnectionsConnectionSnmpUserSettingsGetCommunity.FromRead(read.GetCommunity);
            item.SetCommunity = ConnectionsConnectionSnmpUserSettingsSetCommunity.FromRead(read.SetCommunity);
            item.TimeoutTime = ConnectionsConnectionSnmpUserSettingsTimeoutTime.FromRead(read.TimeoutTime);
            item.Retries = ConnectionsConnectionSnmpUserSettingsRetries.FromRead(read.Retries);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettingsBusAddress : EditableElementNode<Read.IConnectionsConnectionSnmpUserSettingsBusAddress>
    {
        internal ConnectionsConnectionSnmpUserSettingsBusAddress(Read.IConnectionsConnectionSnmpUserSettingsBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSnmpUserSettingsBusAddressRange _range;
        private ConnectionsConnectionSnmpUserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSnmpUserSettingsBusAddressValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSnmpUserSettingsBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSnmpUserSettingsBusAddressRange();
            return Range;
        }

        public ConnectionsConnectionSnmpUserSettingsBusAddressValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSnmpUserSettingsBusAddressValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSnmpUserSettingsBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSnmpUserSettingsBusAddressValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSnmpUserSettingsBusAddress FromRead(Read.IConnectionsConnectionSnmpUserSettingsBusAddress read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSnmpUserSettingsBusAddressRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSnmpUserSettingsBusAddressValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettingsBusAddressRange : EditableElementNode<Read.IConnectionsConnectionSnmpUserSettingsBusAddressRange>
    {
        internal ConnectionsConnectionSnmpUserSettingsBusAddressRange(Read.IConnectionsConnectionSnmpUserSettingsBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static ConnectionsConnectionSnmpUserSettingsBusAddressRange FromRead(Read.IConnectionsConnectionSnmpUserSettingsBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsBusAddressRange(this);
        }
    }

    public partial class ConnectionsConnectionSnmpUserSettingsBusAddressValues : EditableListNode<Read.IConnectionsConnectionSnmpUserSettingsBusAddressValues, Read.IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue, ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue>
    {
        internal ConnectionsConnectionSnmpUserSettingsBusAddressValues(Read.IConnectionsConnectionSnmpUserSettingsBusAddressValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsBusAddressValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsBusAddressValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSnmpUserSettingsBusAddressValues FromRead(Read.IConnectionsConnectionSnmpUserSettingsBusAddressValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsBusAddressValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue, string>
    {
        internal ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue(Read.IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue FromRead(Read.IConnectionsConnectionSnmpUserSettingsBusAddressValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettingsIPport : EditableElementNode<Read.IConnectionsConnectionSnmpUserSettingsIPport>
    {
        internal ConnectionsConnectionSnmpUserSettingsIPport(Read.IConnectionsConnectionSnmpUserSettingsIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpUserSettingsIPport FromRead(Read.IConnectionsConnectionSnmpUserSettingsIPport read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettingsGetCommunity : EditableElementNode<Read.IConnectionsConnectionSnmpUserSettingsGetCommunity>
    {
        internal ConnectionsConnectionSnmpUserSettingsGetCommunity(Read.IConnectionsConnectionSnmpUserSettingsGetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a GetCommunity node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsGetCommunity() : base("GetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsGetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpUserSettingsGetCommunity FromRead(Read.IConnectionsConnectionSnmpUserSettingsGetCommunity read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsGetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsGetCommunity(this);
        }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettingsSetCommunity : EditableElementNode<Read.IConnectionsConnectionSnmpUserSettingsSetCommunity>
    {
        internal ConnectionsConnectionSnmpUserSettingsSetCommunity(Read.IConnectionsConnectionSnmpUserSettingsSetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SetCommunity node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsSetCommunity() : base("SetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsSetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpUserSettingsSetCommunity FromRead(Read.IConnectionsConnectionSnmpUserSettingsSetCommunity read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsSetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsSetCommunity(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettingsTimeoutTime : EditableElementNode<Read.IConnectionsConnectionSnmpUserSettingsTimeoutTime>
    {
        internal ConnectionsConnectionSnmpUserSettingsTimeoutTime(Read.IConnectionsConnectionSnmpUserSettingsTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpUserSettingsTimeoutTime FromRead(Read.IConnectionsConnectionSnmpUserSettingsTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsTimeoutTime();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpUserSettingsRetries : EditableElementNode<Read.IConnectionsConnectionSnmpUserSettingsRetries>
    {
        internal ConnectionsConnectionSnmpUserSettingsRetries(Read.IConnectionsConnectionSnmpUserSettingsRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpUserSettingsRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpUserSettingsRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpUserSettingsRetries FromRead(Read.IConnectionsConnectionSnmpUserSettingsRetries read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpUserSettingsRetries();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines an SNMPv2 connection.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2 : EditableElementNode<Read.IConnectionsConnectionSnmpV2>
    {
        internal ConnectionsConnectionSnmpV2(Read.IConnectionsConnectionSnmpV2 read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SnmpV2 node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2() : base("SnmpV2")
        {
            OnCreated();
        }

        private ConnectionsConnectionSnmpV2CommunicationOptions _communicationOptions;
        private ConnectionsConnectionSnmpV2UserSettings _userSettings;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public ConnectionsConnectionSnmpV2CommunicationOptions CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    CombinedTagHandler.Assign(value, this, "CommunicationOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        public ConnectionsConnectionSnmpV2CommunicationOptions GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new ConnectionsConnectionSnmpV2CommunicationOptions();
            return CommunicationOptions;
        }

        public ConnectionsConnectionSnmpV2UserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ConnectionsConnectionSnmpV2UserSettings();
            return UserSettings;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2 read, XmlElement editNode)
        {
            if (read == null)
                return;
            _communicationOptions = read.CommunicationOptions != null ? new ConnectionsConnectionSnmpV2CommunicationOptions(read.CommunicationOptions, this, editNode.Element["CommunicationOptions"]) : null;
            _userSettings = read.UserSettings != null ? new ConnectionsConnectionSnmpV2UserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
        }

        public static ConnectionsConnectionSnmpV2 FromRead(Read.IConnectionsConnectionSnmpV2 read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2();
            item.CommunicationOptions = ConnectionsConnectionSnmpV2CommunicationOptions.FromRead(read.CommunicationOptions);
            item.UserSettings = ConnectionsConnectionSnmpV2UserSettings.FromRead(read.UserSettings);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2CommunicationOptions : EditableElementNode<Read.IConnectionsConnectionSnmpV2CommunicationOptions>
    {
        internal ConnectionsConnectionSnmpV2CommunicationOptions(Read.IConnectionsConnectionSnmpV2CommunicationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CommunicationOptions node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2CommunicationOptions() : base("CommunicationOptions")
        {
            OnCreated();
        }

        private ElementValue<bool?> _redundantPolling;
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
public ElementValue<bool?> RedundantPolling
        {
            get
            {
                return _redundantPolling;
            }

            set
            {
                if (_redundantPolling != value)
                {
                    _redundantPolling = value;
                    ElementHandler.Assign(value, this, "RedundantPolling");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateRedundantPolling()
        {
            if (RedundantPolling == null)
                RedundantPolling = new ElementValue<bool?>();
            return RedundantPolling;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2CommunicationOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _redundantPolling = read.RedundantPolling != null ? new ElementValue<bool?>(read.RedundantPolling, this) : null;
        }

        public static ConnectionsConnectionSnmpV2CommunicationOptions FromRead(Read.IConnectionsConnectionSnmpV2CommunicationOptions read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2CommunicationOptions();
            item.RedundantPolling = ElementValue<bool?>.FromRead(read.RedundantPolling);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2CommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettings : EditableElementNode<Read.IConnectionsConnectionSnmpV2UserSettings>
    {
        internal ConnectionsConnectionSnmpV2UserSettings(Read.IConnectionsConnectionSnmpV2UserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        private ConnectionsConnectionSnmpV2UserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSnmpV2UserSettingsIPport _iPport;
        private ConnectionsConnectionSnmpV2UserSettingsGetCommunity _getCommunity;
        private ConnectionsConnectionSnmpV2UserSettingsSetCommunity _setCommunity;
        private ConnectionsConnectionSnmpV2UserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSnmpV2UserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        ///<summary>
        /// Configures the get community string.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsGetCommunity GetCommunity
        {
            get
            {
                return _getCommunity;
            }

            set
            {
                if (_getCommunity != value)
                {
                    _getCommunity = value;
                    CombinedTagHandler.Assign(value, this, "GetCommunity");
                }
            }
        }

        ///<summary>
        /// Configures the get community string.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsSetCommunity SetCommunity
        {
            get
            {
                return _setCommunity;
            }

            set
            {
                if (_setCommunity != value)
                {
                    _setCommunity = value;
                    CombinedTagHandler.Assign(value, this, "SetCommunity");
                }
            }
        }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        public ConnectionsConnectionSnmpV2UserSettingsBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new ConnectionsConnectionSnmpV2UserSettingsBusAddress();
            return BusAddress;
        }

        public ConnectionsConnectionSnmpV2UserSettingsIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new ConnectionsConnectionSnmpV2UserSettingsIPport();
            return IPport;
        }

        public ConnectionsConnectionSnmpV2UserSettingsGetCommunity GetOrCreateGetCommunity()
        {
            if (GetCommunity == null)
                GetCommunity = new ConnectionsConnectionSnmpV2UserSettingsGetCommunity();
            return GetCommunity;
        }

        public ConnectionsConnectionSnmpV2UserSettingsSetCommunity GetOrCreateSetCommunity()
        {
            if (SetCommunity == null)
                SetCommunity = new ConnectionsConnectionSnmpV2UserSettingsSetCommunity();
            return SetCommunity;
        }

        public ConnectionsConnectionSnmpV2UserSettingsTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new ConnectionsConnectionSnmpV2UserSettingsTimeoutTime();
            return TimeoutTime;
        }

        public ConnectionsConnectionSnmpV2UserSettingsRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new ConnectionsConnectionSnmpV2UserSettingsRetries();
            return Retries;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _busAddress = read.BusAddress != null ? new ConnectionsConnectionSnmpV2UserSettingsBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _iPport = read.IPport != null ? new ConnectionsConnectionSnmpV2UserSettingsIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _getCommunity = read.GetCommunity != null ? new ConnectionsConnectionSnmpV2UserSettingsGetCommunity(read.GetCommunity, this, editNode.Element["GetCommunity"]) : null;
            _setCommunity = read.SetCommunity != null ? new ConnectionsConnectionSnmpV2UserSettingsSetCommunity(read.SetCommunity, this, editNode.Element["SetCommunity"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new ConnectionsConnectionSnmpV2UserSettingsTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _retries = read.Retries != null ? new ConnectionsConnectionSnmpV2UserSettingsRetries(read.Retries, this, editNode.Element["Retries"]) : null;
        }

        public static ConnectionsConnectionSnmpV2UserSettings FromRead(Read.IConnectionsConnectionSnmpV2UserSettings read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettings();
            item.BusAddress = ConnectionsConnectionSnmpV2UserSettingsBusAddress.FromRead(read.BusAddress);
            item.IPport = ConnectionsConnectionSnmpV2UserSettingsIPport.FromRead(read.IPport);
            item.GetCommunity = ConnectionsConnectionSnmpV2UserSettingsGetCommunity.FromRead(read.GetCommunity);
            item.SetCommunity = ConnectionsConnectionSnmpV2UserSettingsSetCommunity.FromRead(read.SetCommunity);
            item.TimeoutTime = ConnectionsConnectionSnmpV2UserSettingsTimeoutTime.FromRead(read.TimeoutTime);
            item.Retries = ConnectionsConnectionSnmpV2UserSettingsRetries.FromRead(read.Retries);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettingsBusAddress : EditableElementNode<Read.IConnectionsConnectionSnmpV2UserSettingsBusAddress>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsBusAddress(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSnmpV2UserSettingsBusAddressRange _range;
        private ConnectionsConnectionSnmpV2UserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSnmpV2UserSettingsBusAddressValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSnmpV2UserSettingsBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSnmpV2UserSettingsBusAddressRange();
            return Range;
        }

        public ConnectionsConnectionSnmpV2UserSettingsBusAddressValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSnmpV2UserSettingsBusAddressValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSnmpV2UserSettingsBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSnmpV2UserSettingsBusAddressValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSnmpV2UserSettingsBusAddress FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddress read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSnmpV2UserSettingsBusAddressRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSnmpV2UserSettingsBusAddressValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettingsBusAddressRange : EditableElementNode<Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressRange>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsBusAddressRange(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static ConnectionsConnectionSnmpV2UserSettingsBusAddressRange FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsBusAddressRange(this);
        }
    }

    public partial class ConnectionsConnectionSnmpV2UserSettingsBusAddressValues : EditableListNode<Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValues, Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue, ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsBusAddressValues(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsBusAddressValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSnmpV2UserSettingsBusAddressValues FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsBusAddressValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue, string>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettingsIPport : EditableElementNode<Read.IConnectionsConnectionSnmpV2UserSettingsIPport>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsIPport(Read.IConnectionsConnectionSnmpV2UserSettingsIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpV2UserSettingsIPport FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsIPport read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettingsGetCommunity : EditableElementNode<Read.IConnectionsConnectionSnmpV2UserSettingsGetCommunity>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsGetCommunity(Read.IConnectionsConnectionSnmpV2UserSettingsGetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a GetCommunity node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsGetCommunity() : base("GetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsGetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpV2UserSettingsGetCommunity FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsGetCommunity read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsGetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsGetCommunity(this);
        }
    }

    ///<summary>
    /// Configures the get community string.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettingsSetCommunity : EditableElementNode<Read.IConnectionsConnectionSnmpV2UserSettingsSetCommunity>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsSetCommunity(Read.IConnectionsConnectionSnmpV2UserSettingsSetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SetCommunity node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsSetCommunity() : base("SetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsSetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpV2UserSettingsSetCommunity FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsSetCommunity read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsSetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsSetCommunity(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettingsTimeoutTime : EditableElementNode<Read.IConnectionsConnectionSnmpV2UserSettingsTimeoutTime>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsTimeoutTime(Read.IConnectionsConnectionSnmpV2UserSettingsTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpV2UserSettingsTimeoutTime FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsTimeoutTime();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV2UserSettingsRetries : EditableElementNode<Read.IConnectionsConnectionSnmpV2UserSettingsRetries>
    {
        internal ConnectionsConnectionSnmpV2UserSettingsRetries(Read.IConnectionsConnectionSnmpV2UserSettingsRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV2UserSettingsRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV2UserSettingsRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpV2UserSettingsRetries FromRead(Read.IConnectionsConnectionSnmpV2UserSettingsRetries read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV2UserSettingsRetries();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV2UserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines an SNMPv3 connection.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3 : EditableElementNode<Read.IConnectionsConnectionSnmpV3>
    {
        internal ConnectionsConnectionSnmpV3(Read.IConnectionsConnectionSnmpV3 read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SnmpV3 node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3() : base("SnmpV3")
        {
            OnCreated();
        }

        private ConnectionsConnectionSnmpV3CommunicationOptions _communicationOptions;
        private ConnectionsConnectionSnmpV3UserSettings _userSettings;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public ConnectionsConnectionSnmpV3CommunicationOptions CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    CombinedTagHandler.Assign(value, this, "CommunicationOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        public ConnectionsConnectionSnmpV3CommunicationOptions GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new ConnectionsConnectionSnmpV3CommunicationOptions();
            return CommunicationOptions;
        }

        public ConnectionsConnectionSnmpV3UserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ConnectionsConnectionSnmpV3UserSettings();
            return UserSettings;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3 read, XmlElement editNode)
        {
            if (read == null)
                return;
            _communicationOptions = read.CommunicationOptions != null ? new ConnectionsConnectionSnmpV3CommunicationOptions(read.CommunicationOptions, this, editNode.Element["CommunicationOptions"]) : null;
            _userSettings = read.UserSettings != null ? new ConnectionsConnectionSnmpV3UserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
        }

        public static ConnectionsConnectionSnmpV3 FromRead(Read.IConnectionsConnectionSnmpV3 read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3();
            item.CommunicationOptions = ConnectionsConnectionSnmpV3CommunicationOptions.FromRead(read.CommunicationOptions);
            item.UserSettings = ConnectionsConnectionSnmpV3UserSettings.FromRead(read.UserSettings);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3CommunicationOptions : EditableElementNode<Read.IConnectionsConnectionSnmpV3CommunicationOptions>
    {
        internal ConnectionsConnectionSnmpV3CommunicationOptions(Read.IConnectionsConnectionSnmpV3CommunicationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CommunicationOptions node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3CommunicationOptions() : base("CommunicationOptions")
        {
            OnCreated();
        }

        private ElementValue<bool?> _redundantPolling;
        private ElementValue<string> _dynamicContextName;
        private ElementValue<string> _dynamicContextID;
        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
public ElementValue<bool?> RedundantPolling
        {
            get
            {
                return _redundantPolling;
            }

            set
            {
                if (_redundantPolling != value)
                {
                    _redundantPolling = value;
                    ElementHandler.Assign(value, this, "RedundantPolling");
                }
            }
        }

        ///<summary>
        /// Specifies the dynamic context name.
        ///</summary>
public ElementValue<string> DynamicContextName
        {
            get
            {
                return _dynamicContextName;
            }

            set
            {
                if (_dynamicContextName != value)
                {
                    _dynamicContextName = value;
                    ElementHandler.Assign(value, this, "DynamicContextName");
                }
            }
        }

        ///<summary>
        /// Specifies the dynamic context ID.
        ///</summary>
public ElementValue<string> DynamicContextID
        {
            get
            {
                return _dynamicContextID;
            }

            set
            {
                if (_dynamicContextID != value)
                {
                    _dynamicContextID = value;
                    ElementHandler.Assign(value, this, "DynamicContextID");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateRedundantPolling()
        {
            if (RedundantPolling == null)
                RedundantPolling = new ElementValue<bool?>();
            return RedundantPolling;
        }

        public ElementValue<string> GetOrCreateDynamicContextName()
        {
            if (DynamicContextName == null)
                DynamicContextName = new ElementValue<string>();
            return DynamicContextName;
        }

        public ElementValue<string> GetOrCreateDynamicContextID()
        {
            if (DynamicContextID == null)
                DynamicContextID = new ElementValue<string>();
            return DynamicContextID;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3CommunicationOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _redundantPolling = read.RedundantPolling != null ? new ElementValue<bool?>(read.RedundantPolling, this) : null;
            _dynamicContextName = read.DynamicContextName != null ? new ElementValue<string>(read.DynamicContextName, this) : null;
            _dynamicContextID = read.DynamicContextID != null ? new ElementValue<string>(read.DynamicContextID, this) : null;
        }

        public static ConnectionsConnectionSnmpV3CommunicationOptions FromRead(Read.IConnectionsConnectionSnmpV3CommunicationOptions read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3CommunicationOptions();
            item.RedundantPolling = ElementValue<bool?>.FromRead(read.RedundantPolling);
            item.DynamicContextName = ElementValue<string>.FromRead(read.DynamicContextName);
            item.DynamicContextID = ElementValue<string>.FromRead(read.DynamicContextID);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3CommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettings : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettings>
    {
        internal ConnectionsConnectionSnmpV3UserSettings(Read.IConnectionsConnectionSnmpV3UserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        private ConnectionsConnectionSnmpV3UserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSnmpV3UserSettingsIPport _iPport;
        private ConnectionsConnectionSnmpV3UserSettingsSecurityLevel _securityLevel;
        private ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm _authenticationAlgorithm;
        private ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm _encryptionAlgorithm;
        private ConnectionsConnectionSnmpV3UserSettingsUserName _userName;
        private ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword _authenticationPassword;
        private ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword _encryptionPassword;
        private ConnectionsConnectionSnmpV3UserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSnmpV3UserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        ///<summary>
        /// Specifies the security level settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsSecurityLevel SecurityLevel
        {
            get
            {
                return _securityLevel;
            }

            set
            {
                if (_securityLevel != value)
                {
                    _securityLevel = value;
                    CombinedTagHandler.Assign(value, this, "SecurityLevel");
                }
            }
        }

        ///<summary>
        /// Specifies the authentication algorithm settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm AuthenticationAlgorithm
        {
            get
            {
                return _authenticationAlgorithm;
            }

            set
            {
                if (_authenticationAlgorithm != value)
                {
                    _authenticationAlgorithm = value;
                    CombinedTagHandler.Assign(value, this, "AuthenticationAlgorithm");
                }
            }
        }

        ///<summary>
        /// Specifies the encryption algorithm settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm EncryptionAlgorithm
        {
            get
            {
                return _encryptionAlgorithm;
            }

            set
            {
                if (_encryptionAlgorithm != value)
                {
                    _encryptionAlgorithm = value;
                    CombinedTagHandler.Assign(value, this, "EncryptionAlgorithm");
                }
            }
        }

        ///<summary>
        /// Specifies the user name settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsUserName UserName
        {
            get
            {
                return _userName;
            }

            set
            {
                if (_userName != value)
                {
                    _userName = value;
                    CombinedTagHandler.Assign(value, this, "UserName");
                }
            }
        }

        ///<summary>
        /// Specifies the authentication password settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword AuthenticationPassword
        {
            get
            {
                return _authenticationPassword;
            }

            set
            {
                if (_authenticationPassword != value)
                {
                    _authenticationPassword = value;
                    CombinedTagHandler.Assign(value, this, "AuthenticationPassword");
                }
            }
        }

        ///<summary>
        /// Specifies the encryption password settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword EncryptionPassword
        {
            get
            {
                return _encryptionPassword;
            }

            set
            {
                if (_encryptionPassword != value)
                {
                    _encryptionPassword = value;
                    CombinedTagHandler.Assign(value, this, "EncryptionPassword");
                }
            }
        }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        public ConnectionsConnectionSnmpV3UserSettingsBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new ConnectionsConnectionSnmpV3UserSettingsBusAddress();
            return BusAddress;
        }

        public ConnectionsConnectionSnmpV3UserSettingsIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new ConnectionsConnectionSnmpV3UserSettingsIPport();
            return IPport;
        }

        public ConnectionsConnectionSnmpV3UserSettingsSecurityLevel GetOrCreateSecurityLevel()
        {
            if (SecurityLevel == null)
                SecurityLevel = new ConnectionsConnectionSnmpV3UserSettingsSecurityLevel();
            return SecurityLevel;
        }

        public ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm GetOrCreateAuthenticationAlgorithm()
        {
            if (AuthenticationAlgorithm == null)
                AuthenticationAlgorithm = new ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm();
            return AuthenticationAlgorithm;
        }

        public ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm GetOrCreateEncryptionAlgorithm()
        {
            if (EncryptionAlgorithm == null)
                EncryptionAlgorithm = new ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm();
            return EncryptionAlgorithm;
        }

        public ConnectionsConnectionSnmpV3UserSettingsUserName GetOrCreateUserName()
        {
            if (UserName == null)
                UserName = new ConnectionsConnectionSnmpV3UserSettingsUserName();
            return UserName;
        }

        public ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword GetOrCreateAuthenticationPassword()
        {
            if (AuthenticationPassword == null)
                AuthenticationPassword = new ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword();
            return AuthenticationPassword;
        }

        public ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword GetOrCreateEncryptionPassword()
        {
            if (EncryptionPassword == null)
                EncryptionPassword = new ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword();
            return EncryptionPassword;
        }

        public ConnectionsConnectionSnmpV3UserSettingsTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new ConnectionsConnectionSnmpV3UserSettingsTimeoutTime();
            return TimeoutTime;
        }

        public ConnectionsConnectionSnmpV3UserSettingsRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new ConnectionsConnectionSnmpV3UserSettingsRetries();
            return Retries;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _busAddress = read.BusAddress != null ? new ConnectionsConnectionSnmpV3UserSettingsBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _iPport = read.IPport != null ? new ConnectionsConnectionSnmpV3UserSettingsIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _securityLevel = read.SecurityLevel != null ? new ConnectionsConnectionSnmpV3UserSettingsSecurityLevel(read.SecurityLevel, this, editNode.Element["SecurityLevel"]) : null;
            _authenticationAlgorithm = read.AuthenticationAlgorithm != null ? new ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm(read.AuthenticationAlgorithm, this, editNode.Element["AuthenticationAlgorithm"]) : null;
            _encryptionAlgorithm = read.EncryptionAlgorithm != null ? new ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm(read.EncryptionAlgorithm, this, editNode.Element["EncryptionAlgorithm"]) : null;
            _userName = read.UserName != null ? new ConnectionsConnectionSnmpV3UserSettingsUserName(read.UserName, this, editNode.Element["UserName"]) : null;
            _authenticationPassword = read.AuthenticationPassword != null ? new ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword(read.AuthenticationPassword, this, editNode.Element["AuthenticationPassword"]) : null;
            _encryptionPassword = read.EncryptionPassword != null ? new ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword(read.EncryptionPassword, this, editNode.Element["EncryptionPassword"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new ConnectionsConnectionSnmpV3UserSettingsTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _retries = read.Retries != null ? new ConnectionsConnectionSnmpV3UserSettingsRetries(read.Retries, this, editNode.Element["Retries"]) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettings FromRead(Read.IConnectionsConnectionSnmpV3UserSettings read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettings();
            item.BusAddress = ConnectionsConnectionSnmpV3UserSettingsBusAddress.FromRead(read.BusAddress);
            item.IPport = ConnectionsConnectionSnmpV3UserSettingsIPport.FromRead(read.IPport);
            item.SecurityLevel = ConnectionsConnectionSnmpV3UserSettingsSecurityLevel.FromRead(read.SecurityLevel);
            item.AuthenticationAlgorithm = ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm.FromRead(read.AuthenticationAlgorithm);
            item.EncryptionAlgorithm = ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm.FromRead(read.EncryptionAlgorithm);
            item.UserName = ConnectionsConnectionSnmpV3UserSettingsUserName.FromRead(read.UserName);
            item.AuthenticationPassword = ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword.FromRead(read.AuthenticationPassword);
            item.EncryptionPassword = ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword.FromRead(read.EncryptionPassword);
            item.TimeoutTime = ConnectionsConnectionSnmpV3UserSettingsTimeoutTime.FromRead(read.TimeoutTime);
            item.Retries = ConnectionsConnectionSnmpV3UserSettingsRetries.FromRead(read.Retries);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsBusAddress : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsBusAddress>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsBusAddress(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSnmpV3UserSettingsBusAddressRange _range;
        private ConnectionsConnectionSnmpV3UserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSnmpV3UserSettingsBusAddressValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSnmpV3UserSettingsBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSnmpV3UserSettingsBusAddressRange();
            return Range;
        }

        public ConnectionsConnectionSnmpV3UserSettingsBusAddressValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSnmpV3UserSettingsBusAddressValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSnmpV3UserSettingsBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSnmpV3UserSettingsBusAddressValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsBusAddress FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddress read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSnmpV3UserSettingsBusAddressRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSnmpV3UserSettingsBusAddressValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsBusAddressRange : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressRange>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsBusAddressRange(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsBusAddressRange FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsBusAddressRange(this);
        }
    }

    public partial class ConnectionsConnectionSnmpV3UserSettingsBusAddressValues : EditableListNode<Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValues, Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue, ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsBusAddressValues(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsBusAddressValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSnmpV3UserSettingsBusAddressValues FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsBusAddressValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue, string>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsIPport : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsIPport>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsIPport(Read.IConnectionsConnectionSnmpV3UserSettingsIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsIPport FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsIPport read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Specifies the security level settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsSecurityLevel : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsSecurityLevel>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsSecurityLevel(Read.IConnectionsConnectionSnmpV3UserSettingsSecurityLevel read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SecurityLevel node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsSecurityLevel() : base("SecurityLevel")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsSecurityLevel read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsSecurityLevel FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsSecurityLevel read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsSecurityLevel();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsSecurityLevel(this);
        }
    }

    ///<summary>
    /// Specifies the authentication algorithm settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm(Read.IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AuthenticationAlgorithm node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm() : base("AuthenticationAlgorithm")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm(this);
        }
    }

    ///<summary>
    /// Specifies the encryption algorithm settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm(Read.IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a EncryptionAlgorithm node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm() : base("EncryptionAlgorithm")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm(this);
        }
    }

    ///<summary>
    /// Specifies the user name settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsUserName : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsUserName>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsUserName(Read.IConnectionsConnectionSnmpV3UserSettingsUserName read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserName node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsUserName() : base("UserName")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsUserName read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsUserName FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsUserName read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsUserName();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsUserName(this);
        }
    }

    ///<summary>
    /// Specifies the authentication password settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword(Read.IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AuthenticationPassword node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword() : base("AuthenticationPassword")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword(this);
        }
    }

    ///<summary>
    /// Specifies the encryption password settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword(Read.IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a EncryptionPassword node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword() : base("EncryptionPassword")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsEncryptionPassword read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsEncryptionPassword(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsTimeoutTime : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsTimeoutTime>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsTimeoutTime(Read.IConnectionsConnectionSnmpV3UserSettingsTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<uint?> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsTimeoutTime FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsTimeoutTime();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial class ConnectionsConnectionSnmpV3UserSettingsRetries : EditableElementNode<Read.IConnectionsConnectionSnmpV3UserSettingsRetries>
    {
        internal ConnectionsConnectionSnmpV3UserSettingsRetries(Read.IConnectionsConnectionSnmpV3UserSettingsRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSnmpV3UserSettingsRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<uint?> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSnmpV3UserSettingsRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSnmpV3UserSettingsRetries FromRead(Read.IConnectionsConnectionSnmpV3UserSettingsRetries read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSnmpV3UserSettingsRetries();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSnmpV3UserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines an HTTP connection.
    ///</summary>
public partial class ConnectionsConnectionHttp : EditableElementNode<Read.IConnectionsConnectionHttp>
    {
        internal ConnectionsConnectionHttp(Read.IConnectionsConnectionHttp read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Http node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttp() : base("Http")
        {
            OnCreated();
        }

        private ConnectionsConnectionHttpCommunicationOptions _communicationOptions;
        private ConnectionsConnectionHttpUserSettings _userSettings;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public ConnectionsConnectionHttpCommunicationOptions CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    CombinedTagHandler.Assign(value, this, "CommunicationOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public ConnectionsConnectionHttpUserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        public ConnectionsConnectionHttpCommunicationOptions GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new ConnectionsConnectionHttpCommunicationOptions();
            return CommunicationOptions;
        }

        public ConnectionsConnectionHttpUserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ConnectionsConnectionHttpUserSettings();
            return UserSettings;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttp read, XmlElement editNode)
        {
            if (read == null)
                return;
            _communicationOptions = read.CommunicationOptions != null ? new ConnectionsConnectionHttpCommunicationOptions(read.CommunicationOptions, this, editNode.Element["CommunicationOptions"]) : null;
            _userSettings = read.UserSettings != null ? new ConnectionsConnectionHttpUserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
        }

        public static ConnectionsConnectionHttp FromRead(Read.IConnectionsConnectionHttp read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttp();
            item.CommunicationOptions = ConnectionsConnectionHttpCommunicationOptions.FromRead(read.CommunicationOptions);
            item.UserSettings = ConnectionsConnectionHttpUserSettings.FromRead(read.UserSettings);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttp(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial class ConnectionsConnectionHttpCommunicationOptions : EditableElementNode<Read.IConnectionsConnectionHttpCommunicationOptions>
    {
        internal ConnectionsConnectionHttpCommunicationOptions(Read.IConnectionsConnectionHttpCommunicationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CommunicationOptions node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpCommunicationOptions() : base("CommunicationOptions")
        {
            OnCreated();
        }

        private ElementValue<bool?> _webSocket;
        private ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs _notifyConnectionPIDs;
        private ElementValue<bool?> _makeCommandByProtocol;
        private ElementValue<uint?> _webSocketHandshake;
        private ElementValue<bool?> _redundantPolling;
        ///<summary>
        /// Specifies whether this connection is an HTTP connection.
        ///</summary>
public ElementValue<bool?> WebSocket
        {
            get
            {
                return _webSocket;
            }

            set
            {
                if (_webSocket != value)
                {
                    _webSocket = value;
                    ElementHandler.Assign(value, this, "WebSocket");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter IDs to use to monitor (dis)connects.
        ///</summary>
public ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs NotifyConnectionPIDs
        {
            get
            {
                return _notifyConnectionPIDs;
            }

            set
            {
                if (_notifyConnectionPIDs != value)
                {
                    _notifyConnectionPIDs = value;
                    CombinedTagHandler.Assign(value, this, "NotifyConnectionPIDs");
                }
            }
        }

        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
public ElementValue<bool?> MakeCommandByProtocol
        {
            get
            {
                return _makeCommandByProtocol;
            }

            set
            {
                if (_makeCommandByProtocol != value)
                {
                    _makeCommandByProtocol = value;
                    ElementHandler.Assign(value, this, "MakeCommandByProtocol");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the Session to use as a custom opening handshake.
        ///</summary>
public ElementValue<uint?> WebSocketHandshake
        {
            get
            {
                return _webSocketHandshake;
            }

            set
            {
                if (_webSocketHandshake != value)
                {
                    _webSocketHandshake = value;
                    ElementHandler.Assign(value, this, "WebSocketHandshake");
                }
            }
        }

        ///<summary>
        /// Specifies whether this connection is used as part of a redundant polling pair.
        ///</summary>
public ElementValue<bool?> RedundantPolling
        {
            get
            {
                return _redundantPolling;
            }

            set
            {
                if (_redundantPolling != value)
                {
                    _redundantPolling = value;
                    ElementHandler.Assign(value, this, "RedundantPolling");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateWebSocket()
        {
            if (WebSocket == null)
                WebSocket = new ElementValue<bool?>();
            return WebSocket;
        }

        public ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs GetOrCreateNotifyConnectionPIDs()
        {
            if (NotifyConnectionPIDs == null)
                NotifyConnectionPIDs = new ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs();
            return NotifyConnectionPIDs;
        }

        public ElementValue<bool?> GetOrCreateMakeCommandByProtocol()
        {
            if (MakeCommandByProtocol == null)
                MakeCommandByProtocol = new ElementValue<bool?>();
            return MakeCommandByProtocol;
        }

        public ElementValue<uint?> GetOrCreateWebSocketHandshake()
        {
            if (WebSocketHandshake == null)
                WebSocketHandshake = new ElementValue<uint?>();
            return WebSocketHandshake;
        }

        public ElementValue<bool?> GetOrCreateRedundantPolling()
        {
            if (RedundantPolling == null)
                RedundantPolling = new ElementValue<bool?>();
            return RedundantPolling;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpCommunicationOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _webSocket = read.WebSocket != null ? new ElementValue<bool?>(read.WebSocket, this) : null;
            _notifyConnectionPIDs = read.NotifyConnectionPIDs != null ? new ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs(read.NotifyConnectionPIDs, this, editNode.Element["NotifyConnectionPIDs"]) : null;
            _makeCommandByProtocol = read.MakeCommandByProtocol != null ? new ElementValue<bool?>(read.MakeCommandByProtocol, this) : null;
            _webSocketHandshake = read.WebSocketHandshake != null ? new ElementValue<uint?>(read.WebSocketHandshake, this) : null;
            _redundantPolling = read.RedundantPolling != null ? new ElementValue<bool?>(read.RedundantPolling, this) : null;
        }

        public static ConnectionsConnectionHttpCommunicationOptions FromRead(Read.IConnectionsConnectionHttpCommunicationOptions read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpCommunicationOptions();
            item.WebSocket = ElementValue<bool?>.FromRead(read.WebSocket);
            item.NotifyConnectionPIDs = ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs.FromRead(read.NotifyConnectionPIDs);
            item.MakeCommandByProtocol = ElementValue<bool?>.FromRead(read.MakeCommandByProtocol);
            item.WebSocketHandshake = ElementValue<uint?>.FromRead(read.WebSocketHandshake);
            item.RedundantPolling = ElementValue<bool?>.FromRead(read.RedundantPolling);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpCommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the parameter IDs to use to monitor (dis)connects.
    ///</summary>
public partial class ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs : EditableElementNode<Read.IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs>
    {
        internal ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs(Read.IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a NotifyConnectionPIDs node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs() : base("NotifyConnectionPIDs")
        {
            OnCreated();
        }

        private ElementValue<uint?> _connections;
        private ElementValue<uint?> _disconnections;
        ///<summary>
        /// Specifies the ID of the parameter in which the connects have to be logged.
        ///</summary>
public ElementValue<uint?> Connections
        {
            get
            {
                return _connections;
            }

            set
            {
                if (_connections != value)
                {
                    _connections = value;
                    ElementHandler.Assign(value, this, "Connections");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter in which the disconnects have to be logged.
        ///</summary>
public ElementValue<uint?> Disconnections
        {
            get
            {
                return _disconnections;
            }

            set
            {
                if (_disconnections != value)
                {
                    _disconnections = value;
                    ElementHandler.Assign(value, this, "Disconnections");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateConnections()
        {
            if (Connections == null)
                Connections = new ElementValue<uint?>();
            return Connections;
        }

        public ElementValue<uint?> GetOrCreateDisconnections()
        {
            if (Disconnections == null)
                Disconnections = new ElementValue<uint?>();
            return Disconnections;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs read, XmlElement editNode)
        {
            if (read == null)
                return;
            _connections = read.Connections != null ? new ElementValue<uint?>(read.Connections, this) : null;
            _disconnections = read.Disconnections != null ? new ElementValue<uint?>(read.Disconnections, this) : null;
        }

        public static ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs FromRead(Read.IConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs();
            item.Connections = ElementValue<uint?>.FromRead(read.Connections);
            item.Disconnections = ElementValue<uint?>.FromRead(read.Disconnections);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial class ConnectionsConnectionHttpUserSettings : EditableElementNode<Read.IConnectionsConnectionHttpUserSettings>
    {
        internal ConnectionsConnectionHttpUserSettings(Read.IConnectionsConnectionHttpUserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpUserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        private ConnectionsConnectionHttpUserSettingsBusAddress _busAddress;
        private ConnectionsConnectionHttpUserSettingsIPport _iPport;
        private ConnectionsConnectionHttpUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionHttpUserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        public ConnectionsConnectionHttpUserSettingsBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new ConnectionsConnectionHttpUserSettingsBusAddress();
            return BusAddress;
        }

        public ConnectionsConnectionHttpUserSettingsIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new ConnectionsConnectionHttpUserSettingsIPport();
            return IPport;
        }

        public ConnectionsConnectionHttpUserSettingsTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new ConnectionsConnectionHttpUserSettingsTimeoutTime();
            return TimeoutTime;
        }

        public ConnectionsConnectionHttpUserSettingsRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new ConnectionsConnectionHttpUserSettingsRetries();
            return Retries;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpUserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _busAddress = read.BusAddress != null ? new ConnectionsConnectionHttpUserSettingsBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _iPport = read.IPport != null ? new ConnectionsConnectionHttpUserSettingsIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new ConnectionsConnectionHttpUserSettingsTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _retries = read.Retries != null ? new ConnectionsConnectionHttpUserSettingsRetries(read.Retries, this, editNode.Element["Retries"]) : null;
        }

        public static ConnectionsConnectionHttpUserSettings FromRead(Read.IConnectionsConnectionHttpUserSettings read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpUserSettings();
            item.BusAddress = ConnectionsConnectionHttpUserSettingsBusAddress.FromRead(read.BusAddress);
            item.IPport = ConnectionsConnectionHttpUserSettingsIPport.FromRead(read.IPport);
            item.TimeoutTime = ConnectionsConnectionHttpUserSettingsTimeoutTime.FromRead(read.TimeoutTime);
            item.Retries = ConnectionsConnectionHttpUserSettingsRetries.FromRead(read.Retries);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial class ConnectionsConnectionHttpUserSettingsBusAddress : EditableElementNode<Read.IConnectionsConnectionHttpUserSettingsBusAddress>
    {
        internal ConnectionsConnectionHttpUserSettingsBusAddress(Read.IConnectionsConnectionHttpUserSettingsBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionHttpUserSettingsBusAddressRange _range;
        private ConnectionsConnectionHttpUserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionHttpUserSettingsBusAddressValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionHttpUserSettingsBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionHttpUserSettingsBusAddressRange();
            return Range;
        }

        public ConnectionsConnectionHttpUserSettingsBusAddressValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionHttpUserSettingsBusAddressValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpUserSettingsBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionHttpUserSettingsBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionHttpUserSettingsBusAddressValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionHttpUserSettingsBusAddress FromRead(Read.IConnectionsConnectionHttpUserSettingsBusAddress read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpUserSettingsBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionHttpUserSettingsBusAddressRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionHttpUserSettingsBusAddressValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class ConnectionsConnectionHttpUserSettingsBusAddressRange : EditableElementNode<Read.IConnectionsConnectionHttpUserSettingsBusAddressRange>
    {
        internal ConnectionsConnectionHttpUserSettingsBusAddressRange(Read.IConnectionsConnectionHttpUserSettingsBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpUserSettingsBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static ConnectionsConnectionHttpUserSettingsBusAddressRange FromRead(Read.IConnectionsConnectionHttpUserSettingsBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpUserSettingsBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsBusAddressRange(this);
        }
    }

    public partial class ConnectionsConnectionHttpUserSettingsBusAddressValues : EditableListNode<Read.IConnectionsConnectionHttpUserSettingsBusAddressValues, Read.IConnectionsConnectionHttpUserSettingsBusAddressValuesValue, ConnectionsConnectionHttpUserSettingsBusAddressValuesValue>
    {
        internal ConnectionsConnectionHttpUserSettingsBusAddressValues(Read.IConnectionsConnectionHttpUserSettingsBusAddressValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsBusAddressValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpUserSettingsBusAddressValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionHttpUserSettingsBusAddressValues FromRead(Read.IConnectionsConnectionHttpUserSettingsBusAddressValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpUserSettingsBusAddressValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionHttpUserSettingsBusAddressValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionHttpUserSettingsBusAddressValuesValue : EditableElementValueNode<Read.IConnectionsConnectionHttpUserSettingsBusAddressValuesValue, string>
    {
        internal ConnectionsConnectionHttpUserSettingsBusAddressValuesValue(Read.IConnectionsConnectionHttpUserSettingsBusAddressValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsBusAddressValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionHttpUserSettingsBusAddressValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpUserSettingsBusAddressValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionHttpUserSettingsBusAddressValuesValue FromRead(Read.IConnectionsConnectionHttpUserSettingsBusAddressValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpUserSettingsBusAddressValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial class ConnectionsConnectionHttpUserSettingsIPport : EditableElementNode<Read.IConnectionsConnectionHttpUserSettingsIPport>
    {
        internal ConnectionsConnectionHttpUserSettingsIPport(Read.IConnectionsConnectionHttpUserSettingsIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpUserSettingsIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionHttpUserSettingsIPport FromRead(Read.IConnectionsConnectionHttpUserSettingsIPport read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpUserSettingsIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial class ConnectionsConnectionHttpUserSettingsTimeoutTime : EditableElementNode<Read.IConnectionsConnectionHttpUserSettingsTimeoutTime>
    {
        internal ConnectionsConnectionHttpUserSettingsTimeoutTime(Read.IConnectionsConnectionHttpUserSettingsTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<uint?> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpUserSettingsTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionHttpUserSettingsTimeoutTime FromRead(Read.IConnectionsConnectionHttpUserSettingsTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpUserSettingsTimeoutTime();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial class ConnectionsConnectionHttpUserSettingsRetries : EditableElementNode<Read.IConnectionsConnectionHttpUserSettingsRetries>
    {
        internal ConnectionsConnectionHttpUserSettingsRetries(Read.IConnectionsConnectionHttpUserSettingsRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionHttpUserSettingsRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<uint?> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionHttpUserSettingsRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionHttpUserSettingsRetries FromRead(Read.IConnectionsConnectionHttpUserSettingsRetries read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionHttpUserSettingsRetries();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionHttpUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines a serial connection.
    ///</summary>
public partial class ConnectionsConnectionSerial : EditableElementNode<Read.IConnectionsConnectionSerial>
    {
        internal ConnectionsConnectionSerial(Read.IConnectionsConnectionSerial read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Serial node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerial() : base("Serial")
        {
            OnCreated();
        }

        private ConnectionsConnectionSerialCommunicationOptions _communicationOptions;
        private ConnectionsConnectionSerialUserSettings _userSettings;
        private AttributeValue<bool?> _single;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public ConnectionsConnectionSerialCommunicationOptions CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    CombinedTagHandler.Assign(value, this, "CommunicationOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        ///<summary>
        /// Specifies whether this is a dedicated connection.
        ///</summary>
public AttributeValue<bool?> Single
        {
            get
            {
                return _single;
            }

            set
            {
                if (_single != value)
                {
                    _single = value;
                    AttributeHandler.Assign(value, this, "single");
                }
            }
        }

        public ConnectionsConnectionSerialCommunicationOptions GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new ConnectionsConnectionSerialCommunicationOptions();
            return CommunicationOptions;
        }

        public ConnectionsConnectionSerialUserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ConnectionsConnectionSerialUserSettings();
            return UserSettings;
        }

        public AttributeValue<bool?> GetOrCreateSingle()
        {
            if (Single == null)
                Single = new AttributeValue<bool?>();
            return Single;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerial read, XmlElement editNode)
        {
            if (read == null)
                return;
            _communicationOptions = read.CommunicationOptions != null ? new ConnectionsConnectionSerialCommunicationOptions(read.CommunicationOptions, this, editNode.Element["CommunicationOptions"]) : null;
            _userSettings = read.UserSettings != null ? new ConnectionsConnectionSerialUserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
            _single = read.Single != null ? new AttributeValue<bool?>(read.Single, this) : null;
        }

        public static ConnectionsConnectionSerial FromRead(Read.IConnectionsConnectionSerial read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerial();
            item.CommunicationOptions = ConnectionsConnectionSerialCommunicationOptions.FromRead(read.CommunicationOptions);
            item.UserSettings = ConnectionsConnectionSerialUserSettings.FromRead(read.UserSettings);
            item.Single = AttributeValue<bool?>.FromRead(read.Single);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerial(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial class ConnectionsConnectionSerialCommunicationOptions : EditableElementNode<Read.IConnectionsConnectionSerialCommunicationOptions>
    {
        internal ConnectionsConnectionSerialCommunicationOptions(Read.IConnectionsConnectionSerialCommunicationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CommunicationOptions node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialCommunicationOptions() : base("CommunicationOptions")
        {
            OnCreated();
        }

        private ElementValue<bool?> _chunkedHTML;
        private ElementValue<bool?> _closeConnectionOnResponse;
        private ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms _kexAlgorithms;
        private ElementValue<bool?> _makeCommandByProtocol;
        private ElementValue<bool?> _redundantPolling;
        public ElementValue<bool?> ChunkedHTML
        {
            get
            {
                return _chunkedHTML;
            }

            set
            {
                if (_chunkedHTML != value)
                {
                    _chunkedHTML = value;
                    ElementHandler.Assign(value, this, "ChunkedHTML");
                }
            }
        }

        public ElementValue<bool?> CloseConnectionOnResponse
        {
            get
            {
                return _closeConnectionOnResponse;
            }

            set
            {
                if (_closeConnectionOnResponse != value)
                {
                    _closeConnectionOnResponse = value;
                    ElementHandler.Assign(value, this, "CloseConnectionOnResponse");
                }
            }
        }

        public ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms KexAlgorithms
        {
            get
            {
                return _kexAlgorithms;
            }

            set
            {
                if (_kexAlgorithms != value)
                {
                    _kexAlgorithms = value;
                    CombinedTagHandler.Assign(value, this, "KexAlgorithms");
                }
            }
        }

        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
public ElementValue<bool?> MakeCommandByProtocol
        {
            get
            {
                return _makeCommandByProtocol;
            }

            set
            {
                if (_makeCommandByProtocol != value)
                {
                    _makeCommandByProtocol = value;
                    ElementHandler.Assign(value, this, "MakeCommandByProtocol");
                }
            }
        }

        public ElementValue<bool?> RedundantPolling
        {
            get
            {
                return _redundantPolling;
            }

            set
            {
                if (_redundantPolling != value)
                {
                    _redundantPolling = value;
                    ElementHandler.Assign(value, this, "RedundantPolling");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateChunkedHTML()
        {
            if (ChunkedHTML == null)
                ChunkedHTML = new ElementValue<bool?>();
            return ChunkedHTML;
        }

        public ElementValue<bool?> GetOrCreateCloseConnectionOnResponse()
        {
            if (CloseConnectionOnResponse == null)
                CloseConnectionOnResponse = new ElementValue<bool?>();
            return CloseConnectionOnResponse;
        }

        public ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms GetOrCreateKexAlgorithms()
        {
            if (KexAlgorithms == null)
                KexAlgorithms = new ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms();
            return KexAlgorithms;
        }

        public ElementValue<bool?> GetOrCreateMakeCommandByProtocol()
        {
            if (MakeCommandByProtocol == null)
                MakeCommandByProtocol = new ElementValue<bool?>();
            return MakeCommandByProtocol;
        }

        public ElementValue<bool?> GetOrCreateRedundantPolling()
        {
            if (RedundantPolling == null)
                RedundantPolling = new ElementValue<bool?>();
            return RedundantPolling;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialCommunicationOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _chunkedHTML = read.ChunkedHTML != null ? new ElementValue<bool?>(read.ChunkedHTML, this) : null;
            _closeConnectionOnResponse = read.CloseConnectionOnResponse != null ? new ElementValue<bool?>(read.CloseConnectionOnResponse, this) : null;
            _kexAlgorithms = read.KexAlgorithms != null ? new ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms(read.KexAlgorithms, this, editNode.Element["KexAlgorithms"]) : null;
            _makeCommandByProtocol = read.MakeCommandByProtocol != null ? new ElementValue<bool?>(read.MakeCommandByProtocol, this) : null;
            _redundantPolling = read.RedundantPolling != null ? new ElementValue<bool?>(read.RedundantPolling, this) : null;
        }

        public static ConnectionsConnectionSerialCommunicationOptions FromRead(Read.IConnectionsConnectionSerialCommunicationOptions read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialCommunicationOptions();
            item.ChunkedHTML = ElementValue<bool?>.FromRead(read.ChunkedHTML);
            item.CloseConnectionOnResponse = ElementValue<bool?>.FromRead(read.CloseConnectionOnResponse);
            item.KexAlgorithms = ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms.FromRead(read.KexAlgorithms);
            item.MakeCommandByProtocol = ElementValue<bool?>.FromRead(read.MakeCommandByProtocol);
            item.RedundantPolling = ElementValue<bool?>.FromRead(read.RedundantPolling);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialCommunicationOptions(this);
        }
    }

    public partial class ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms : EditableListNode<Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms, Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm, ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm>
    {
        internal ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms(Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a KexAlgorithms node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms() : base("KexAlgorithms")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms FromRead(Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithms read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialCommunicationOptionsKexAlgorithms(this);
        }
    }

    public partial class ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm : EditableElementValueNode<Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm, string>
    {
        internal ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm(Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a KexAlgorithm node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm(bool useCDATA = false) : base("KexAlgorithm", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm(string value, bool useCDATA = false) : base("KexAlgorithm", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm FromRead(Read.IConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettings : EditableElementNode<Read.IConnectionsConnectionSerialUserSettings>
    {
        internal ConnectionsConnectionSerialUserSettings(Read.IConnectionsConnectionSerialUserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        private ConnectionsConnectionSerialUserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSerialUserSettingsIPport _iPport;
        private ConnectionsConnectionSerialUserSettingsBaudrate _baudrate;
        private ConnectionsConnectionSerialUserSettingsParity _parity;
        private ConnectionsConnectionSerialUserSettingsDatabits _databits;
        private ConnectionsConnectionSerialUserSettingsStopbits _stopbits;
        private ConnectionsConnectionSerialUserSettingsFlowcontrol _flowcontrol;
        private ConnectionsConnectionSerialUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSerialUserSettingsRetries _retries;
        private ConnectionsConnectionSerialUserSettingsPortTypeIP _portTypeIP;
        private ConnectionsConnectionSerialUserSettingsPortTypeSerial _portTypeSerial;
        private ConnectionsConnectionSerialUserSettingsPortTypeUDP _portTypeUDP;
        private ConnectionsConnectionSerialUserSettingsType _type;
        private ConnectionsConnectionSerialUserSettingsSslTlsEnabled _sslTlsEnabled;
        private ConnectionsConnectionSerialUserSettingsLocalIPport _localIPport;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsBaudrate Baudrate
        {
            get
            {
                return _baudrate;
            }

            set
            {
                if (_baudrate != value)
                {
                    _baudrate = value;
                    CombinedTagHandler.Assign(value, this, "Baudrate");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsParity Parity
        {
            get
            {
                return _parity;
            }

            set
            {
                if (_parity != value)
                {
                    _parity = value;
                    CombinedTagHandler.Assign(value, this, "Parity");
                }
            }
        }

        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsDatabits Databits
        {
            get
            {
                return _databits;
            }

            set
            {
                if (_databits != value)
                {
                    _databits = value;
                    CombinedTagHandler.Assign(value, this, "Databits");
                }
            }
        }

        ///<summary>
        /// Specifies the stop bits settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsStopbits Stopbits
        {
            get
            {
                return _stopbits;
            }

            set
            {
                if (_stopbits != value)
                {
                    _stopbits = value;
                    CombinedTagHandler.Assign(value, this, "Stopbits");
                }
            }
        }

        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrol Flowcontrol
        {
            get
            {
                return _flowcontrol;
            }

            set
            {
                if (_flowcontrol != value)
                {
                    _flowcontrol = value;
                    CombinedTagHandler.Assign(value, this, "Flowcontrol");
                }
            }
        }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsPortTypeIP PortTypeIP
        {
            get
            {
                return _portTypeIP;
            }

            set
            {
                if (_portTypeIP != value)
                {
                    _portTypeIP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeIP");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsPortTypeSerial PortTypeSerial
        {
            get
            {
                return _portTypeSerial;
            }

            set
            {
                if (_portTypeSerial != value)
                {
                    _portTypeSerial = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeSerial");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsPortTypeUDP PortTypeUDP
        {
            get
            {
                return _portTypeUDP;
            }

            set
            {
                if (_portTypeUDP != value)
                {
                    _portTypeUDP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeUDP");
                }
            }
        }

        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Specifies the SSL/TLS settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsSslTlsEnabled SslTlsEnabled
        {
            get
            {
                return _sslTlsEnabled;
            }

            set
            {
                if (_sslTlsEnabled != value)
                {
                    _sslTlsEnabled = value;
                    CombinedTagHandler.Assign(value, this, "SslTlsEnabled");
                }
            }
        }

        ///<summary>
        /// Specifies the local port settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsLocalIPport LocalIPport
        {
            get
            {
                return _localIPport;
            }

            set
            {
                if (_localIPport != value)
                {
                    _localIPport = value;
                    CombinedTagHandler.Assign(value, this, "LocalIPport");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new ConnectionsConnectionSerialUserSettingsBusAddress();
            return BusAddress;
        }

        public ConnectionsConnectionSerialUserSettingsIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new ConnectionsConnectionSerialUserSettingsIPport();
            return IPport;
        }

        public ConnectionsConnectionSerialUserSettingsBaudrate GetOrCreateBaudrate()
        {
            if (Baudrate == null)
                Baudrate = new ConnectionsConnectionSerialUserSettingsBaudrate();
            return Baudrate;
        }

        public ConnectionsConnectionSerialUserSettingsParity GetOrCreateParity()
        {
            if (Parity == null)
                Parity = new ConnectionsConnectionSerialUserSettingsParity();
            return Parity;
        }

        public ConnectionsConnectionSerialUserSettingsDatabits GetOrCreateDatabits()
        {
            if (Databits == null)
                Databits = new ConnectionsConnectionSerialUserSettingsDatabits();
            return Databits;
        }

        public ConnectionsConnectionSerialUserSettingsStopbits GetOrCreateStopbits()
        {
            if (Stopbits == null)
                Stopbits = new ConnectionsConnectionSerialUserSettingsStopbits();
            return Stopbits;
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrol GetOrCreateFlowcontrol()
        {
            if (Flowcontrol == null)
                Flowcontrol = new ConnectionsConnectionSerialUserSettingsFlowcontrol();
            return Flowcontrol;
        }

        public ConnectionsConnectionSerialUserSettingsTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new ConnectionsConnectionSerialUserSettingsTimeoutTime();
            return TimeoutTime;
        }

        public ConnectionsConnectionSerialUserSettingsRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new ConnectionsConnectionSerialUserSettingsRetries();
            return Retries;
        }

        public ConnectionsConnectionSerialUserSettingsPortTypeIP GetOrCreatePortTypeIP()
        {
            if (PortTypeIP == null)
                PortTypeIP = new ConnectionsConnectionSerialUserSettingsPortTypeIP();
            return PortTypeIP;
        }

        public ConnectionsConnectionSerialUserSettingsPortTypeSerial GetOrCreatePortTypeSerial()
        {
            if (PortTypeSerial == null)
                PortTypeSerial = new ConnectionsConnectionSerialUserSettingsPortTypeSerial();
            return PortTypeSerial;
        }

        public ConnectionsConnectionSerialUserSettingsPortTypeUDP GetOrCreatePortTypeUDP()
        {
            if (PortTypeUDP == null)
                PortTypeUDP = new ConnectionsConnectionSerialUserSettingsPortTypeUDP();
            return PortTypeUDP;
        }

        public ConnectionsConnectionSerialUserSettingsType GetOrCreateType()
        {
            if (Type == null)
                Type = new ConnectionsConnectionSerialUserSettingsType();
            return Type;
        }

        public ConnectionsConnectionSerialUserSettingsSslTlsEnabled GetOrCreateSslTlsEnabled()
        {
            if (SslTlsEnabled == null)
                SslTlsEnabled = new ConnectionsConnectionSerialUserSettingsSslTlsEnabled();
            return SslTlsEnabled;
        }

        public ConnectionsConnectionSerialUserSettingsLocalIPport GetOrCreateLocalIPport()
        {
            if (LocalIPport == null)
                LocalIPport = new ConnectionsConnectionSerialUserSettingsLocalIPport();
            return LocalIPport;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _busAddress = read.BusAddress != null ? new ConnectionsConnectionSerialUserSettingsBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _iPport = read.IPport != null ? new ConnectionsConnectionSerialUserSettingsIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _baudrate = read.Baudrate != null ? new ConnectionsConnectionSerialUserSettingsBaudrate(read.Baudrate, this, editNode.Element["Baudrate"]) : null;
            _parity = read.Parity != null ? new ConnectionsConnectionSerialUserSettingsParity(read.Parity, this, editNode.Element["Parity"]) : null;
            _databits = read.Databits != null ? new ConnectionsConnectionSerialUserSettingsDatabits(read.Databits, this, editNode.Element["Databits"]) : null;
            _stopbits = read.Stopbits != null ? new ConnectionsConnectionSerialUserSettingsStopbits(read.Stopbits, this, editNode.Element["Stopbits"]) : null;
            _flowcontrol = read.Flowcontrol != null ? new ConnectionsConnectionSerialUserSettingsFlowcontrol(read.Flowcontrol, this, editNode.Element["Flowcontrol"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new ConnectionsConnectionSerialUserSettingsTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _retries = read.Retries != null ? new ConnectionsConnectionSerialUserSettingsRetries(read.Retries, this, editNode.Element["Retries"]) : null;
            _portTypeIP = read.PortTypeIP != null ? new ConnectionsConnectionSerialUserSettingsPortTypeIP(read.PortTypeIP, this, editNode.Element["PortTypeIP"]) : null;
            _portTypeSerial = read.PortTypeSerial != null ? new ConnectionsConnectionSerialUserSettingsPortTypeSerial(read.PortTypeSerial, this, editNode.Element["PortTypeSerial"]) : null;
            _portTypeUDP = read.PortTypeUDP != null ? new ConnectionsConnectionSerialUserSettingsPortTypeUDP(read.PortTypeUDP, this, editNode.Element["PortTypeUDP"]) : null;
            _type = read.Type != null ? new ConnectionsConnectionSerialUserSettingsType(read.Type, this, editNode.Element["Type"]) : null;
            _sslTlsEnabled = read.SslTlsEnabled != null ? new ConnectionsConnectionSerialUserSettingsSslTlsEnabled(read.SslTlsEnabled, this, editNode.Element["SslTlsEnabled"]) : null;
            _localIPport = read.LocalIPport != null ? new ConnectionsConnectionSerialUserSettingsLocalIPport(read.LocalIPport, this, editNode.Element["LocalIPport"]) : null;
        }

        public static ConnectionsConnectionSerialUserSettings FromRead(Read.IConnectionsConnectionSerialUserSettings read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettings();
            item.BusAddress = ConnectionsConnectionSerialUserSettingsBusAddress.FromRead(read.BusAddress);
            item.IPport = ConnectionsConnectionSerialUserSettingsIPport.FromRead(read.IPport);
            item.Baudrate = ConnectionsConnectionSerialUserSettingsBaudrate.FromRead(read.Baudrate);
            item.Parity = ConnectionsConnectionSerialUserSettingsParity.FromRead(read.Parity);
            item.Databits = ConnectionsConnectionSerialUserSettingsDatabits.FromRead(read.Databits);
            item.Stopbits = ConnectionsConnectionSerialUserSettingsStopbits.FromRead(read.Stopbits);
            item.Flowcontrol = ConnectionsConnectionSerialUserSettingsFlowcontrol.FromRead(read.Flowcontrol);
            item.TimeoutTime = ConnectionsConnectionSerialUserSettingsTimeoutTime.FromRead(read.TimeoutTime);
            item.Retries = ConnectionsConnectionSerialUserSettingsRetries.FromRead(read.Retries);
            item.PortTypeIP = ConnectionsConnectionSerialUserSettingsPortTypeIP.FromRead(read.PortTypeIP);
            item.PortTypeSerial = ConnectionsConnectionSerialUserSettingsPortTypeSerial.FromRead(read.PortTypeSerial);
            item.PortTypeUDP = ConnectionsConnectionSerialUserSettingsPortTypeUDP.FromRead(read.PortTypeUDP);
            item.Type = ConnectionsConnectionSerialUserSettingsType.FromRead(read.Type);
            item.SslTlsEnabled = ConnectionsConnectionSerialUserSettingsSslTlsEnabled.FromRead(read.SslTlsEnabled);
            item.LocalIPport = ConnectionsConnectionSerialUserSettingsLocalIPport.FromRead(read.LocalIPport);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsBusAddress : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsBusAddress>
    {
        internal ConnectionsConnectionSerialUserSettingsBusAddress(Read.IConnectionsConnectionSerialUserSettingsBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsBusAddressRange _range;
        private ConnectionsConnectionSerialUserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsBusAddressValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSerialUserSettingsBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSerialUserSettingsBusAddressRange();
            return Range;
        }

        public ConnectionsConnectionSerialUserSettingsBusAddressValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSerialUserSettingsBusAddressValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSerialUserSettingsBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSerialUserSettingsBusAddressValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsBusAddress FromRead(Read.IConnectionsConnectionSerialUserSettingsBusAddress read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSerialUserSettingsBusAddressRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSerialUserSettingsBusAddressValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsBusAddressRange : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsBusAddressRange>
    {
        internal ConnectionsConnectionSerialUserSettingsBusAddressRange(Read.IConnectionsConnectionSerialUserSettingsBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsBusAddressRange FromRead(Read.IConnectionsConnectionSerialUserSettingsBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBusAddressRange(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsBusAddressValues : EditableListNode<Read.IConnectionsConnectionSerialUserSettingsBusAddressValues, Read.IConnectionsConnectionSerialUserSettingsBusAddressValuesValue, ConnectionsConnectionSerialUserSettingsBusAddressValuesValue>
    {
        internal ConnectionsConnectionSerialUserSettingsBusAddressValues(Read.IConnectionsConnectionSerialUserSettingsBusAddressValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBusAddressValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsBusAddressValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsBusAddressValues FromRead(Read.IConnectionsConnectionSerialUserSettingsBusAddressValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsBusAddressValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSerialUserSettingsBusAddressValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsBusAddressValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSerialUserSettingsBusAddressValuesValue, string>
    {
        internal ConnectionsConnectionSerialUserSettingsBusAddressValuesValue(Read.IConnectionsConnectionSerialUserSettingsBusAddressValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBusAddressValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsBusAddressValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsBusAddressValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsBusAddressValuesValue FromRead(Read.IConnectionsConnectionSerialUserSettingsBusAddressValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsBusAddressValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsIPport : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsIPport>
    {
        internal ConnectionsConnectionSerialUserSettingsIPport(Read.IConnectionsConnectionSerialUserSettingsIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsIPport FromRead(Read.IConnectionsConnectionSerialUserSettingsIPport read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsIPport(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsBaudrate : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsBaudrate>
    {
        internal ConnectionsConnectionSerialUserSettingsBaudrate(Read.IConnectionsConnectionSerialUserSettingsBaudrate read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Baudrate node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBaudrate() : base("Baudrate")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsBaudrateRange _range;
        private ConnectionsConnectionSerialUserSettingsBaudrateValues _values;
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBaudrateRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsBaudrateValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSerialUserSettingsBaudrateRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSerialUserSettingsBaudrateRange();
            return Range;
        }

        public ConnectionsConnectionSerialUserSettingsBaudrateValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSerialUserSettingsBaudrateValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsBaudrate read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSerialUserSettingsBaudrateRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSerialUserSettingsBaudrateValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsBaudrate FromRead(Read.IConnectionsConnectionSerialUserSettingsBaudrate read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsBaudrate();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSerialUserSettingsBaudrateRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSerialUserSettingsBaudrateValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBaudrate(this);
        }
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsBaudrateRange : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsBaudrateRange>
    {
        internal ConnectionsConnectionSerialUserSettingsBaudrateRange(Read.IConnectionsConnectionSerialUserSettingsBaudrateRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBaudrateRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<uint?> _from;
        private ElementValue<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
public ElementValue<uint?> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
public ElementValue<uint?> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<uint?>();
            return From;
        }

        public ElementValue<uint?> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<uint?>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsBaudrateRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<uint?>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<uint?>(read.To, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsBaudrateRange FromRead(Read.IConnectionsConnectionSerialUserSettingsBaudrateRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsBaudrateRange();
            item.From = ElementValue<uint?>.FromRead(read.From);
            item.To = ElementValue<uint?>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBaudrateRange(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsBaudrateValues : EditableListNode<Read.IConnectionsConnectionSerialUserSettingsBaudrateValues, Read.IConnectionsConnectionSerialUserSettingsBaudrateValuesValue, ConnectionsConnectionSerialUserSettingsBaudrateValuesValue>
    {
        internal ConnectionsConnectionSerialUserSettingsBaudrateValues(Read.IConnectionsConnectionSerialUserSettingsBaudrateValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBaudrateValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsBaudrateValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsBaudrateValues FromRead(Read.IConnectionsConnectionSerialUserSettingsBaudrateValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsBaudrateValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSerialUserSettingsBaudrateValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBaudrateValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsBaudrateValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSerialUserSettingsBaudrateValuesValue, string>
    {
        internal ConnectionsConnectionSerialUserSettingsBaudrateValuesValue(Read.IConnectionsConnectionSerialUserSettingsBaudrateValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsBaudrateValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsBaudrateValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsBaudrateValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsBaudrateValuesValue FromRead(Read.IConnectionsConnectionSerialUserSettingsBaudrateValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsBaudrateValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsBaudrateValuesValue(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsParity : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsParity>
    {
        internal ConnectionsConnectionSerialUserSettingsParity(Read.IConnectionsConnectionSerialUserSettingsParity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Parity node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParity() : base("Parity")
        {
            OnCreated();
        }

        private ConnectionsConnectionSerialUserSettingsParityDefaultValue _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsParityRange _range;
        private ConnectionsConnectionSerialUserSettingsParityValues _values;
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsParityValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsParityDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ConnectionsConnectionSerialUserSettingsParityDefaultValue();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSerialUserSettingsParityRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSerialUserSettingsParityRange();
            return Range;
        }

        public ConnectionsConnectionSerialUserSettingsParityValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSerialUserSettingsParityValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsParity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ConnectionsConnectionSerialUserSettingsParityDefaultValue(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSerialUserSettingsParityRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSerialUserSettingsParityValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsParity FromRead(Read.IConnectionsConnectionSerialUserSettingsParity read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsParity();
            item.DefaultValue = ConnectionsConnectionSerialUserSettingsParityDefaultValue.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSerialUserSettingsParityRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSerialUserSettingsParityValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsParity(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsParityDefaultValue : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal ConnectionsConnectionSerialUserSettingsParityDefaultValue(Read.IValueTag<Enums.EnumPortSettingsParity?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityDefaultValue() : base()
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsParityDefaultValue(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public new static ConnectionsConnectionSerialUserSettingsParityDefaultValue FromRead(Read.IValueTag<Enums.EnumPortSettingsParity?> read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsParityDefaultValue();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsParityRange : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsParityRange>
    {
        internal ConnectionsConnectionSerialUserSettingsParityRange(Read.IConnectionsConnectionSerialUserSettingsParityRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityRange() : base("Range")
        {
            OnCreated();
        }

        private ConnectionsConnectionSerialUserSettingsParityRangeFrom _from;
        private ConnectionsConnectionSerialUserSettingsParityRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityRangeFrom From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityRangeTo To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsParityRangeFrom GetOrCreateFrom()
        {
            if (From == null)
                From = new ConnectionsConnectionSerialUserSettingsParityRangeFrom();
            return From;
        }

        public ConnectionsConnectionSerialUserSettingsParityRangeTo GetOrCreateTo()
        {
            if (To == null)
                To = new ConnectionsConnectionSerialUserSettingsParityRangeTo();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsParityRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ConnectionsConnectionSerialUserSettingsParityRangeFrom(read.From, this) : null;
            _to = read.To != null ? new ConnectionsConnectionSerialUserSettingsParityRangeTo(read.To, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsParityRange FromRead(Read.IConnectionsConnectionSerialUserSettingsParityRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsParityRange();
            item.From = ConnectionsConnectionSerialUserSettingsParityRangeFrom.FromRead(read.From);
            item.To = ConnectionsConnectionSerialUserSettingsParityRangeTo.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsParityRange(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsParityRangeFrom : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal ConnectionsConnectionSerialUserSettingsParityRangeFrom(Read.IValueTag<Enums.EnumPortSettingsParity?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a From node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityRangeFrom() : base()
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsParityRangeFrom(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public new static ConnectionsConnectionSerialUserSettingsParityRangeFrom FromRead(Read.IValueTag<Enums.EnumPortSettingsParity?> read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsParityRangeFrom();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsParityRangeTo : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal ConnectionsConnectionSerialUserSettingsParityRangeTo(Read.IValueTag<Enums.EnumPortSettingsParity?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a To node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityRangeTo() : base()
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsParityRangeTo(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public new static ConnectionsConnectionSerialUserSettingsParityRangeTo FromRead(Read.IValueTag<Enums.EnumPortSettingsParity?> read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsParityRangeTo();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsParityValues : EditableListNode<Read.IConnectionsConnectionSerialUserSettingsParityValues, Read.IConnectionsConnectionSerialUserSettingsParityValuesValue, ConnectionsConnectionSerialUserSettingsParityValuesValue>
    {
        internal ConnectionsConnectionSerialUserSettingsParityValues(Read.IConnectionsConnectionSerialUserSettingsParityValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsParityValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsParityValues FromRead(Read.IConnectionsConnectionSerialUserSettingsParityValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsParityValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSerialUserSettingsParityValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsParityValues(this);
        }
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsParityValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSerialUserSettingsParityValuesValue, Enums.EnumPortSettingsParity?>
    {
        internal ConnectionsConnectionSerialUserSettingsParityValuesValue(Read.IConnectionsConnectionSerialUserSettingsParityValuesValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsParityValuesValue() : base("Value")
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsParityValuesValue(Enums.EnumPortSettingsParity? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsParityValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsParityValuesValue FromRead(Read.IConnectionsConnectionSerialUserSettingsParityValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsParityValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsParityValuesValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsDatabits : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsDatabits>
    {
        internal ConnectionsConnectionSerialUserSettingsDatabits(Read.IConnectionsConnectionSerialUserSettingsDatabits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Databits node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsDatabits() : base("Databits")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsDatabitsRange _range;
        private ConnectionsConnectionSerialUserSettingsDatabitsValues _values;
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsDatabitsRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsDatabitsValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSerialUserSettingsDatabitsRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSerialUserSettingsDatabitsRange();
            return Range;
        }

        public ConnectionsConnectionSerialUserSettingsDatabitsValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSerialUserSettingsDatabitsValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsDatabits read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSerialUserSettingsDatabitsRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSerialUserSettingsDatabitsValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsDatabits FromRead(Read.IConnectionsConnectionSerialUserSettingsDatabits read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsDatabits();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSerialUserSettingsDatabitsRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSerialUserSettingsDatabitsValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsDatabits(this);
        }
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsDatabitsRange : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsDatabitsRange>
    {
        internal ConnectionsConnectionSerialUserSettingsDatabitsRange(Read.IConnectionsConnectionSerialUserSettingsDatabitsRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsDatabitsRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<uint?> _from;
        private ElementValue<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
public ElementValue<uint?> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
public ElementValue<uint?> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<uint?>();
            return From;
        }

        public ElementValue<uint?> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<uint?>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsDatabitsRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<uint?>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<uint?>(read.To, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsDatabitsRange FromRead(Read.IConnectionsConnectionSerialUserSettingsDatabitsRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsDatabitsRange();
            item.From = ElementValue<uint?>.FromRead(read.From);
            item.To = ElementValue<uint?>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsDatabitsRange(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsDatabitsValues : EditableListNode<Read.IConnectionsConnectionSerialUserSettingsDatabitsValues, Read.IConnectionsConnectionSerialUserSettingsDatabitsValuesValue, ConnectionsConnectionSerialUserSettingsDatabitsValuesValue>
    {
        internal ConnectionsConnectionSerialUserSettingsDatabitsValues(Read.IConnectionsConnectionSerialUserSettingsDatabitsValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsDatabitsValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsDatabitsValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsDatabitsValues FromRead(Read.IConnectionsConnectionSerialUserSettingsDatabitsValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsDatabitsValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSerialUserSettingsDatabitsValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsDatabitsValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsDatabitsValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSerialUserSettingsDatabitsValuesValue, uint?>
    {
        internal ConnectionsConnectionSerialUserSettingsDatabitsValuesValue(Read.IConnectionsConnectionSerialUserSettingsDatabitsValuesValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsDatabitsValuesValue() : base("Value")
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsDatabitsValuesValue(uint? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsDatabitsValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsDatabitsValuesValue FromRead(Read.IConnectionsConnectionSerialUserSettingsDatabitsValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsDatabitsValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsDatabitsValuesValue(this);
        }
    }

    ///<summary>
    /// Specifies the stop bits settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsStopbits : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsStopbits>
    {
        internal ConnectionsConnectionSerialUserSettingsStopbits(Read.IConnectionsConnectionSerialUserSettingsStopbits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Stopbits node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsStopbits() : base("Stopbits")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsStopbitsValues _values;
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsStopbitsValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSerialUserSettingsStopbitsValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSerialUserSettingsStopbitsValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsStopbits read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _values = read.Values != null ? new ConnectionsConnectionSerialUserSettingsStopbitsValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsStopbits FromRead(Read.IConnectionsConnectionSerialUserSettingsStopbits read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsStopbits();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Values = ConnectionsConnectionSerialUserSettingsStopbitsValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsStopbits(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsStopbitsValues : EditableListNode<Read.IConnectionsConnectionSerialUserSettingsStopbitsValues, Read.IConnectionsConnectionSerialUserSettingsStopbitsValuesValue, ConnectionsConnectionSerialUserSettingsStopbitsValuesValue>
    {
        internal ConnectionsConnectionSerialUserSettingsStopbitsValues(Read.IConnectionsConnectionSerialUserSettingsStopbitsValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsStopbitsValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsStopbitsValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsStopbitsValues FromRead(Read.IConnectionsConnectionSerialUserSettingsStopbitsValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsStopbitsValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSerialUserSettingsStopbitsValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsStopbitsValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsStopbitsValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSerialUserSettingsStopbitsValuesValue, Enums.EnumPortSettingsStopBits?>
    {
        internal ConnectionsConnectionSerialUserSettingsStopbitsValuesValue(Read.IConnectionsConnectionSerialUserSettingsStopbitsValuesValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsStopbitsValuesValue() : base("Value")
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsStopbitsValuesValue(Enums.EnumPortSettingsStopBits? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsStopbitsValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsStopbitsValuesValue FromRead(Read.IConnectionsConnectionSerialUserSettingsStopbitsValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsStopbitsValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsStopbitsValuesValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsStopBitsConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsStopBits? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsStopBitsConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsFlowcontrol : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsFlowcontrol>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrol(Read.IConnectionsConnectionSerialUserSettingsFlowcontrol read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Flowcontrol node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrol() : base("Flowcontrol")
        {
            OnCreated();
        }

        private ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSerialUserSettingsFlowcontrolRange _range;
        private ConnectionsConnectionSerialUserSettingsFlowcontrolValues _values;
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSerialUserSettingsFlowcontrolRange();
            return Range;
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSerialUserSettingsFlowcontrolValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsFlowcontrol read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSerialUserSettingsFlowcontrolRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSerialUserSettingsFlowcontrolValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsFlowcontrol FromRead(Read.IConnectionsConnectionSerialUserSettingsFlowcontrol read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsFlowcontrol();
            item.DefaultValue = ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSerialUserSettingsFlowcontrolRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSerialUserSettingsFlowcontrolValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsFlowcontrol(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue() : base()
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public new static ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue FromRead(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsFlowcontrolDefaultValue();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsFlowcontrolRange : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsFlowcontrolRange>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolRange(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolRange() : base("Range")
        {
            OnCreated();
        }

        private ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom _from;
        private ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom GetOrCreateFrom()
        {
            if (From == null)
                From = new ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom();
            return From;
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo GetOrCreateTo()
        {
            if (To == null)
                To = new ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom(read.From, this) : null;
            _to = read.To != null ? new ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo(read.To, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsFlowcontrolRange FromRead(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsFlowcontrolRange();
            item.From = ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom.FromRead(read.From);
            item.To = ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsFlowcontrolRange(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a From node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom() : base()
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public new static ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom FromRead(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsFlowcontrolRangeFrom();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a To node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo() : base()
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public new static ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo FromRead(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsFlowcontrolRangeTo();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsFlowcontrolValues : EditableListNode<Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValues, Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue, ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolValues(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsFlowcontrolValues FromRead(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsFlowcontrolValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsFlowcontrolValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue, Enums.EnumPortSettingsFlowControl?>
    {
        internal ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue() : base("Value")
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue(Enums.EnumPortSettingsFlowControl? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue FromRead(Read.IConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsTimeoutTime : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsTimeoutTime>
    {
        internal ConnectionsConnectionSerialUserSettingsTimeoutTime(Read.IConnectionsConnectionSerialUserSettingsTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<uint?> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsTimeoutTime FromRead(Read.IConnectionsConnectionSerialUserSettingsTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsTimeoutTime();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsRetries : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsRetries>
    {
        internal ConnectionsConnectionSerialUserSettingsRetries(Read.IConnectionsConnectionSerialUserSettingsRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<uint?> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsRetries FromRead(Read.IConnectionsConnectionSerialUserSettingsRetries read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsRetries();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsPortTypeIP : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsPortTypeIP>
    {
        internal ConnectionsConnectionSerialUserSettingsPortTypeIP(Read.IConnectionsConnectionSerialUserSettingsPortTypeIP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeIP node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsPortTypeIP() : base("PortTypeIP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsPortTypeIP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsPortTypeIP FromRead(Read.IConnectionsConnectionSerialUserSettingsPortTypeIP read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsPortTypeIP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsPortTypeIP(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsPortTypeSerial : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsPortTypeSerial>
    {
        internal ConnectionsConnectionSerialUserSettingsPortTypeSerial(Read.IConnectionsConnectionSerialUserSettingsPortTypeSerial read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeSerial node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsPortTypeSerial() : base("PortTypeSerial")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsPortTypeSerial read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsPortTypeSerial FromRead(Read.IConnectionsConnectionSerialUserSettingsPortTypeSerial read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsPortTypeSerial();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsPortTypeSerial(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsPortTypeUDP : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsPortTypeUDP>
    {
        internal ConnectionsConnectionSerialUserSettingsPortTypeUDP(Read.IConnectionsConnectionSerialUserSettingsPortTypeUDP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeUDP node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsPortTypeUDP() : base("PortTypeUDP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsPortTypeUDP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsPortTypeUDP FromRead(Read.IConnectionsConnectionSerialUserSettingsPortTypeUDP read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsPortTypeUDP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsPortTypeUDP(this);
        }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsType : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsType>
    {
        internal ConnectionsConnectionSerialUserSettingsType(Read.IConnectionsConnectionSerialUserSettingsType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsType() : base("Type")
        {
            OnCreated();
        }

        private ConnectionsConnectionSerialUserSettingsTypeDefaultValue _defaultValue;
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsTypeDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ConnectionsConnectionSerialUserSettingsTypeDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ConnectionsConnectionSerialUserSettingsTypeDefaultValue();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ConnectionsConnectionSerialUserSettingsTypeDefaultValue(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsType FromRead(Read.IConnectionsConnectionSerialUserSettingsType read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsType();
            item.DefaultValue = ConnectionsConnectionSerialUserSettingsTypeDefaultValue.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsType(this);
        }
    }

    public partial class ConnectionsConnectionSerialUserSettingsTypeDefaultValue : ElementValue<Enums.EnumPortTypes?>
    {
        internal ConnectionsConnectionSerialUserSettingsTypeDefaultValue(Read.IValueTag<Enums.EnumPortTypes?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsTypeDefaultValue() : base()
        {
            OnCreated();
        }

        public ConnectionsConnectionSerialUserSettingsTypeDefaultValue(Enums.EnumPortTypes? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortTypesConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }

        public new static ConnectionsConnectionSerialUserSettingsTypeDefaultValue FromRead(Read.IValueTag<Enums.EnumPortTypes?> read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsTypeDefaultValue();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies the SSL/TLS settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsSslTlsEnabled : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsSslTlsEnabled>
    {
        internal ConnectionsConnectionSerialUserSettingsSslTlsEnabled(Read.IConnectionsConnectionSerialUserSettingsSslTlsEnabled read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SslTlsEnabled node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsSslTlsEnabled() : base("SslTlsEnabled")
        {
            OnCreated();
        }

        private ElementValue<bool?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public ElementValue<bool?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<bool?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsSslTlsEnabled read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<bool?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsSslTlsEnabled FromRead(Read.IConnectionsConnectionSerialUserSettingsSslTlsEnabled read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsSslTlsEnabled();
            item.DefaultValue = ElementValue<bool?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsSslTlsEnabled(this);
        }
    }

    ///<summary>
    /// Specifies the local port settings.
    ///</summary>
public partial class ConnectionsConnectionSerialUserSettingsLocalIPport : EditableElementNode<Read.IConnectionsConnectionSerialUserSettingsLocalIPport>
    {
        internal ConnectionsConnectionSerialUserSettingsLocalIPport(Read.IConnectionsConnectionSerialUserSettingsLocalIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LocalIPport node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSerialUserSettingsLocalIPport() : base("LocalIPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSerialUserSettingsLocalIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSerialUserSettingsLocalIPport FromRead(Read.IConnectionsConnectionSerialUserSettingsLocalIPport read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSerialUserSettingsLocalIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSerialUserSettingsLocalIPport(this);
        }
    }

    ///<summary>
    /// Defines a smart-serial connection.
    ///</summary>
public partial class ConnectionsConnectionSmartSerial : EditableElementNode<Read.IConnectionsConnectionSmartSerial>
    {
        internal ConnectionsConnectionSmartSerial(Read.IConnectionsConnectionSmartSerial read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SmartSerial node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerial() : base("SmartSerial")
        {
            OnCreated();
        }

        private ConnectionsConnectionSmartSerialCommunicationOptions _communicationOptions;
        private ConnectionsConnectionSmartSerialUserSettings _userSettings;
        private AttributeValue<bool?> _single;
        ///<summary>
        /// Specifies the communication settings.
        ///</summary>
public ConnectionsConnectionSmartSerialCommunicationOptions CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    CombinedTagHandler.Assign(value, this, "CommunicationOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        ///<summary>
        /// Specifies whether this is a dedicated connection.
        ///</summary>
public AttributeValue<bool?> Single
        {
            get
            {
                return _single;
            }

            set
            {
                if (_single != value)
                {
                    _single = value;
                    AttributeHandler.Assign(value, this, "single");
                }
            }
        }

        public ConnectionsConnectionSmartSerialCommunicationOptions GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new ConnectionsConnectionSmartSerialCommunicationOptions();
            return CommunicationOptions;
        }

        public ConnectionsConnectionSmartSerialUserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ConnectionsConnectionSmartSerialUserSettings();
            return UserSettings;
        }

        public AttributeValue<bool?> GetOrCreateSingle()
        {
            if (Single == null)
                Single = new AttributeValue<bool?>();
            return Single;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerial read, XmlElement editNode)
        {
            if (read == null)
                return;
            _communicationOptions = read.CommunicationOptions != null ? new ConnectionsConnectionSmartSerialCommunicationOptions(read.CommunicationOptions, this, editNode.Element["CommunicationOptions"]) : null;
            _userSettings = read.UserSettings != null ? new ConnectionsConnectionSmartSerialUserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
            _single = read.Single != null ? new AttributeValue<bool?>(read.Single, this) : null;
        }

        public static ConnectionsConnectionSmartSerial FromRead(Read.IConnectionsConnectionSmartSerial read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerial();
            item.CommunicationOptions = ConnectionsConnectionSmartSerialCommunicationOptions.FromRead(read.CommunicationOptions);
            item.UserSettings = ConnectionsConnectionSmartSerialUserSettings.FromRead(read.UserSettings);
            item.Single = AttributeValue<bool?>.FromRead(read.Single);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerial(this);
        }
    }

    ///<summary>
    /// Specifies the communication settings.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialCommunicationOptions : EditableElementNode<Read.IConnectionsConnectionSmartSerialCommunicationOptions>
    {
        internal ConnectionsConnectionSmartSerialCommunicationOptions(Read.IConnectionsConnectionSmartSerialCommunicationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CommunicationOptions node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialCommunicationOptions() : base("CommunicationOptions")
        {
            OnCreated();
        }

        private ElementValue<bool?> _makeCommandByProtocol;
        private ElementValue<uint?> _maxConcurrentConnections;
        private ElementValue<uint?> _maxReceiveBuffer;
        private ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs _notifyConnectionPIDs;
        private ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo _packetInfo;
        private ElementValue<bool?> _redundantPolling;
        private ElementValue<bool?> _smartIPHeader;
        ///<summary>
        /// Specifies whether the commands will be composed the moment the corresponding group is added to the group execution queue.
        ///</summary>
public ElementValue<bool?> MakeCommandByProtocol
        {
            get
            {
                return _makeCommandByProtocol;
            }

            set
            {
                if (_makeCommandByProtocol != value)
                {
                    _makeCommandByProtocol = value;
                    ElementHandler.Assign(value, this, "MakeCommandByProtocol");
                }
            }
        }

        public ElementValue<uint?> MaxConcurrentConnections
        {
            get
            {
                return _maxConcurrentConnections;
            }

            set
            {
                if (_maxConcurrentConnections != value)
                {
                    _maxConcurrentConnections = value;
                    ElementHandler.Assign(value, this, "MaxConcurrentConnections");
                }
            }
        }

        public ElementValue<uint?> MaxReceiveBuffer
        {
            get
            {
                return _maxReceiveBuffer;
            }

            set
            {
                if (_maxReceiveBuffer != value)
                {
                    _maxReceiveBuffer = value;
                    ElementHandler.Assign(value, this, "MaxReceiveBuffer");
                }
            }
        }

        public ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs NotifyConnectionPIDs
        {
            get
            {
                return _notifyConnectionPIDs;
            }

            set
            {
                if (_notifyConnectionPIDs != value)
                {
                    _notifyConnectionPIDs = value;
                    CombinedTagHandler.Assign(value, this, "NotifyConnectionPIDs");
                }
            }
        }

        public ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo PacketInfo
        {
            get
            {
                return _packetInfo;
            }

            set
            {
                if (_packetInfo != value)
                {
                    _packetInfo = value;
                    CombinedTagHandler.Assign(value, this, "PacketInfo");
                }
            }
        }

        public ElementValue<bool?> RedundantPolling
        {
            get
            {
                return _redundantPolling;
            }

            set
            {
                if (_redundantPolling != value)
                {
                    _redundantPolling = value;
                    ElementHandler.Assign(value, this, "RedundantPolling");
                }
            }
        }

        public ElementValue<bool?> SmartIPHeader
        {
            get
            {
                return _smartIPHeader;
            }

            set
            {
                if (_smartIPHeader != value)
                {
                    _smartIPHeader = value;
                    ElementHandler.Assign(value, this, "SmartIPHeader");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateMakeCommandByProtocol()
        {
            if (MakeCommandByProtocol == null)
                MakeCommandByProtocol = new ElementValue<bool?>();
            return MakeCommandByProtocol;
        }

        public ElementValue<uint?> GetOrCreateMaxConcurrentConnections()
        {
            if (MaxConcurrentConnections == null)
                MaxConcurrentConnections = new ElementValue<uint?>();
            return MaxConcurrentConnections;
        }

        public ElementValue<uint?> GetOrCreateMaxReceiveBuffer()
        {
            if (MaxReceiveBuffer == null)
                MaxReceiveBuffer = new ElementValue<uint?>();
            return MaxReceiveBuffer;
        }

        public ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs GetOrCreateNotifyConnectionPIDs()
        {
            if (NotifyConnectionPIDs == null)
                NotifyConnectionPIDs = new ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs();
            return NotifyConnectionPIDs;
        }

        public ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo GetOrCreatePacketInfo()
        {
            if (PacketInfo == null)
                PacketInfo = new ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo();
            return PacketInfo;
        }

        public ElementValue<bool?> GetOrCreateRedundantPolling()
        {
            if (RedundantPolling == null)
                RedundantPolling = new ElementValue<bool?>();
            return RedundantPolling;
        }

        public ElementValue<bool?> GetOrCreateSmartIPHeader()
        {
            if (SmartIPHeader == null)
                SmartIPHeader = new ElementValue<bool?>();
            return SmartIPHeader;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialCommunicationOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _makeCommandByProtocol = read.MakeCommandByProtocol != null ? new ElementValue<bool?>(read.MakeCommandByProtocol, this) : null;
            _maxConcurrentConnections = read.MaxConcurrentConnections != null ? new ElementValue<uint?>(read.MaxConcurrentConnections, this) : null;
            _maxReceiveBuffer = read.MaxReceiveBuffer != null ? new ElementValue<uint?>(read.MaxReceiveBuffer, this) : null;
            _notifyConnectionPIDs = read.NotifyConnectionPIDs != null ? new ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs(read.NotifyConnectionPIDs, this, editNode.Element["NotifyConnectionPIDs"]) : null;
            _packetInfo = read.PacketInfo != null ? new ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo(read.PacketInfo, this, editNode.Element["PacketInfo"]) : null;
            _redundantPolling = read.RedundantPolling != null ? new ElementValue<bool?>(read.RedundantPolling, this) : null;
            _smartIPHeader = read.SmartIPHeader != null ? new ElementValue<bool?>(read.SmartIPHeader, this) : null;
        }

        public static ConnectionsConnectionSmartSerialCommunicationOptions FromRead(Read.IConnectionsConnectionSmartSerialCommunicationOptions read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialCommunicationOptions();
            item.MakeCommandByProtocol = ElementValue<bool?>.FromRead(read.MakeCommandByProtocol);
            item.MaxConcurrentConnections = ElementValue<uint?>.FromRead(read.MaxConcurrentConnections);
            item.MaxReceiveBuffer = ElementValue<uint?>.FromRead(read.MaxReceiveBuffer);
            item.NotifyConnectionPIDs = ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs.FromRead(read.NotifyConnectionPIDs);
            item.PacketInfo = ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo.FromRead(read.PacketInfo);
            item.RedundantPolling = ElementValue<bool?>.FromRead(read.RedundantPolling);
            item.SmartIPHeader = ElementValue<bool?>.FromRead(read.SmartIPHeader);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialCommunicationOptions(this);
        }
    }

    public partial class ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs : EditableElementNode<Read.IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs>
    {
        internal ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs(Read.IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a NotifyConnectionPIDs node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs() : base("NotifyConnectionPIDs")
        {
            OnCreated();
        }

        private ElementValue<uint?> _connections;
        private ElementValue<uint?> _disconnections;
        public ElementValue<uint?> Connections
        {
            get
            {
                return _connections;
            }

            set
            {
                if (_connections != value)
                {
                    _connections = value;
                    ElementHandler.Assign(value, this, "Connections");
                }
            }
        }

        public ElementValue<uint?> Disconnections
        {
            get
            {
                return _disconnections;
            }

            set
            {
                if (_disconnections != value)
                {
                    _disconnections = value;
                    ElementHandler.Assign(value, this, "Disconnections");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateConnections()
        {
            if (Connections == null)
                Connections = new ElementValue<uint?>();
            return Connections;
        }

        public ElementValue<uint?> GetOrCreateDisconnections()
        {
            if (Disconnections == null)
                Disconnections = new ElementValue<uint?>();
            return Disconnections;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs read, XmlElement editNode)
        {
            if (read == null)
                return;
            _connections = read.Connections != null ? new ElementValue<uint?>(read.Connections, this) : null;
            _disconnections = read.Disconnections != null ? new ElementValue<uint?>(read.Disconnections, this) : null;
        }

        public static ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs FromRead(Read.IConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs();
            item.Connections = ElementValue<uint?>.FromRead(read.Connections);
            item.Disconnections = ElementValue<uint?>.FromRead(read.Disconnections);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs(this);
        }
    }

    public partial class ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo : EditableElementNode<Read.IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo>
    {
        internal ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo(Read.IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PacketInfo node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo() : base("PacketInfo")
        {
            OnCreated();
        }

        private ElementValue<uint?> _lengthIdentifierOffset;
        private ElementValue<uint?> _lengthIdentifierLength;
        private ElementValue<bool?> _includeLengthIdentifier;
        private ElementValue<bool?> _littleEndian;
        public ElementValue<uint?> LengthIdentifierOffset
        {
            get
            {
                return _lengthIdentifierOffset;
            }

            set
            {
                if (_lengthIdentifierOffset != value)
                {
                    _lengthIdentifierOffset = value;
                    ElementHandler.Assign(value, this, "LengthIdentifierOffset");
                }
            }
        }

        public ElementValue<uint?> LengthIdentifierLength
        {
            get
            {
                return _lengthIdentifierLength;
            }

            set
            {
                if (_lengthIdentifierLength != value)
                {
                    _lengthIdentifierLength = value;
                    ElementHandler.Assign(value, this, "LengthIdentifierLength");
                }
            }
        }

        public ElementValue<bool?> IncludeLengthIdentifier
        {
            get
            {
                return _includeLengthIdentifier;
            }

            set
            {
                if (_includeLengthIdentifier != value)
                {
                    _includeLengthIdentifier = value;
                    ElementHandler.Assign(value, this, "IncludeLengthIdentifier");
                }
            }
        }

        public ElementValue<bool?> LittleEndian
        {
            get
            {
                return _littleEndian;
            }

            set
            {
                if (_littleEndian != value)
                {
                    _littleEndian = value;
                    ElementHandler.Assign(value, this, "LittleEndian");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateLengthIdentifierOffset()
        {
            if (LengthIdentifierOffset == null)
                LengthIdentifierOffset = new ElementValue<uint?>();
            return LengthIdentifierOffset;
        }

        public ElementValue<uint?> GetOrCreateLengthIdentifierLength()
        {
            if (LengthIdentifierLength == null)
                LengthIdentifierLength = new ElementValue<uint?>();
            return LengthIdentifierLength;
        }

        public ElementValue<bool?> GetOrCreateIncludeLengthIdentifier()
        {
            if (IncludeLengthIdentifier == null)
                IncludeLengthIdentifier = new ElementValue<bool?>();
            return IncludeLengthIdentifier;
        }

        public ElementValue<bool?> GetOrCreateLittleEndian()
        {
            if (LittleEndian == null)
                LittleEndian = new ElementValue<bool?>();
            return LittleEndian;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo read, XmlElement editNode)
        {
            if (read == null)
                return;
            _lengthIdentifierOffset = read.LengthIdentifierOffset != null ? new ElementValue<uint?>(read.LengthIdentifierOffset, this) : null;
            _lengthIdentifierLength = read.LengthIdentifierLength != null ? new ElementValue<uint?>(read.LengthIdentifierLength, this) : null;
            _includeLengthIdentifier = read.IncludeLengthIdentifier != null ? new ElementValue<bool?>(read.IncludeLengthIdentifier, this) : null;
            _littleEndian = read.LittleEndian != null ? new ElementValue<bool?>(read.LittleEndian, this) : null;
        }

        public static ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo FromRead(Read.IConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo();
            item.LengthIdentifierOffset = ElementValue<uint?>.FromRead(read.LengthIdentifierOffset);
            item.LengthIdentifierLength = ElementValue<uint?>.FromRead(read.LengthIdentifierLength);
            item.IncludeLengthIdentifier = ElementValue<bool?>.FromRead(read.IncludeLengthIdentifier);
            item.LittleEndian = ElementValue<bool?>.FromRead(read.LittleEndian);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettings : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettings>
    {
        internal ConnectionsConnectionSmartSerialUserSettings(Read.IConnectionsConnectionSmartSerialUserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        private ConnectionsConnectionSmartSerialUserSettingsBusAddress _busAddress;
        private ConnectionsConnectionSmartSerialUserSettingsIPport _iPport;
        private ConnectionsConnectionSmartSerialUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionSmartSerialUserSettingsRetries _retries;
        private ConnectionsConnectionSmartSerialUserSettingsPortTypeIP _portTypeIP;
        private ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP _portTypeUDP;
        private ConnectionsConnectionSmartSerialUserSettingsType _type;
        private ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled _sslTlsEnabled;
        private ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses _allowedIPAddresses;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// Configures the port settings.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsPortTypeIP PortTypeIP
        {
            get
            {
                return _portTypeIP;
            }

            set
            {
                if (_portTypeIP != value)
                {
                    _portTypeIP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeIP");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP PortTypeUDP
        {
            get
            {
                return _portTypeUDP;
            }

            set
            {
                if (_portTypeUDP != value)
                {
                    _portTypeUDP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeUDP");
                }
            }
        }

        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Specifies the SSL/TLS settings.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled SslTlsEnabled
        {
            get
            {
                return _sslTlsEnabled;
            }

            set
            {
                if (_sslTlsEnabled != value)
                {
                    _sslTlsEnabled = value;
                    CombinedTagHandler.Assign(value, this, "SslTlsEnabled");
                }
            }
        }

        ///<summary>
        /// Specifies the local port settings.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses AllowedIPAddresses
        {
            get
            {
                return _allowedIPAddresses;
            }

            set
            {
                if (_allowedIPAddresses != value)
                {
                    _allowedIPAddresses = value;
                    CombinedTagHandler.Assign(value, this, "AllowedIPAddresses");
                }
            }
        }

        public ConnectionsConnectionSmartSerialUserSettingsBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new ConnectionsConnectionSmartSerialUserSettingsBusAddress();
            return BusAddress;
        }

        public ConnectionsConnectionSmartSerialUserSettingsIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new ConnectionsConnectionSmartSerialUserSettingsIPport();
            return IPport;
        }

        public ConnectionsConnectionSmartSerialUserSettingsTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new ConnectionsConnectionSmartSerialUserSettingsTimeoutTime();
            return TimeoutTime;
        }

        public ConnectionsConnectionSmartSerialUserSettingsRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new ConnectionsConnectionSmartSerialUserSettingsRetries();
            return Retries;
        }

        public ConnectionsConnectionSmartSerialUserSettingsPortTypeIP GetOrCreatePortTypeIP()
        {
            if (PortTypeIP == null)
                PortTypeIP = new ConnectionsConnectionSmartSerialUserSettingsPortTypeIP();
            return PortTypeIP;
        }

        public ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP GetOrCreatePortTypeUDP()
        {
            if (PortTypeUDP == null)
                PortTypeUDP = new ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP();
            return PortTypeUDP;
        }

        public ConnectionsConnectionSmartSerialUserSettingsType GetOrCreateType()
        {
            if (Type == null)
                Type = new ConnectionsConnectionSmartSerialUserSettingsType();
            return Type;
        }

        public ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled GetOrCreateSslTlsEnabled()
        {
            if (SslTlsEnabled == null)
                SslTlsEnabled = new ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled();
            return SslTlsEnabled;
        }

        public ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses GetOrCreateAllowedIPAddresses()
        {
            if (AllowedIPAddresses == null)
                AllowedIPAddresses = new ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses();
            return AllowedIPAddresses;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _busAddress = read.BusAddress != null ? new ConnectionsConnectionSmartSerialUserSettingsBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _iPport = read.IPport != null ? new ConnectionsConnectionSmartSerialUserSettingsIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new ConnectionsConnectionSmartSerialUserSettingsTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _retries = read.Retries != null ? new ConnectionsConnectionSmartSerialUserSettingsRetries(read.Retries, this, editNode.Element["Retries"]) : null;
            _portTypeIP = read.PortTypeIP != null ? new ConnectionsConnectionSmartSerialUserSettingsPortTypeIP(read.PortTypeIP, this, editNode.Element["PortTypeIP"]) : null;
            _portTypeUDP = read.PortTypeUDP != null ? new ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP(read.PortTypeUDP, this, editNode.Element["PortTypeUDP"]) : null;
            _type = read.Type != null ? new ConnectionsConnectionSmartSerialUserSettingsType(read.Type, this, editNode.Element["Type"]) : null;
            _sslTlsEnabled = read.SslTlsEnabled != null ? new ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled(read.SslTlsEnabled, this, editNode.Element["SslTlsEnabled"]) : null;
            _allowedIPAddresses = read.AllowedIPAddresses != null ? new ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses(read.AllowedIPAddresses, this, editNode.Element["AllowedIPAddresses"]) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettings FromRead(Read.IConnectionsConnectionSmartSerialUserSettings read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettings();
            item.BusAddress = ConnectionsConnectionSmartSerialUserSettingsBusAddress.FromRead(read.BusAddress);
            item.IPport = ConnectionsConnectionSmartSerialUserSettingsIPport.FromRead(read.IPport);
            item.TimeoutTime = ConnectionsConnectionSmartSerialUserSettingsTimeoutTime.FromRead(read.TimeoutTime);
            item.Retries = ConnectionsConnectionSmartSerialUserSettingsRetries.FromRead(read.Retries);
            item.PortTypeIP = ConnectionsConnectionSmartSerialUserSettingsPortTypeIP.FromRead(read.PortTypeIP);
            item.PortTypeUDP = ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP.FromRead(read.PortTypeUDP);
            item.Type = ConnectionsConnectionSmartSerialUserSettingsType.FromRead(read.Type);
            item.SslTlsEnabled = ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled.FromRead(read.SslTlsEnabled);
            item.AllowedIPAddresses = ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses.FromRead(read.AllowedIPAddresses);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsBusAddress : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsBusAddress>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsBusAddress(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionSmartSerialUserSettingsBusAddressRange _range;
        private ConnectionsConnectionSmartSerialUserSettingsBusAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionSmartSerialUserSettingsBusAddressValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionSmartSerialUserSettingsBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionSmartSerialUserSettingsBusAddressRange();
            return Range;
        }

        public ConnectionsConnectionSmartSerialUserSettingsBusAddressValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionSmartSerialUserSettingsBusAddressValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionSmartSerialUserSettingsBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionSmartSerialUserSettingsBusAddressValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsBusAddress FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddress read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionSmartSerialUserSettingsBusAddressRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionSmartSerialUserSettingsBusAddressValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsBusAddressRange : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressRange>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsBusAddressRange(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsBusAddressRange FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsBusAddressRange(this);
        }
    }

    public partial class ConnectionsConnectionSmartSerialUserSettingsBusAddressValues : EditableListNode<Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValues, Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue, ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsBusAddressValues(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsBusAddressValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSmartSerialUserSettingsBusAddressValues FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsBusAddressValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsBusAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue : EditableElementValueNode<Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue, string>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the port settings.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsIPport : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsIPport>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsIPport(Read.IConnectionsConnectionSmartSerialUserSettingsIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether this setting can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsIPport FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsIPport read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsIPport(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsTimeoutTime : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsTimeoutTime>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsTimeoutTime(Read.IConnectionsConnectionSmartSerialUserSettingsTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<uint?> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsTimeoutTime FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsTimeoutTime();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsRetries : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsRetries>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsRetries(Read.IConnectionsConnectionSmartSerialUserSettingsRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<uint?> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsRetries FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsRetries read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsRetries();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsPortTypeIP : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsPortTypeIP>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsPortTypeIP(Read.IConnectionsConnectionSmartSerialUserSettingsPortTypeIP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeIP node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsPortTypeIP() : base("PortTypeIP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsPortTypeIP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsPortTypeIP FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsPortTypeIP read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsPortTypeIP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsPortTypeIP(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP(Read.IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeUDP node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP() : base("PortTypeUDP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsPortTypeUDP read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsPortTypeUDP(this);
        }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsType : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsType>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsType(Read.IConnectionsConnectionSmartSerialUserSettingsType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsType() : base("Type")
        {
            OnCreated();
        }

        private ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue _defaultValue;
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsType FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsType read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsType();
            item.DefaultValue = ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsType(this);
        }
    }

    public partial class ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue : ElementValue<Enums.EnumPortTypes?>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue(Read.IValueTag<Enums.EnumPortTypes?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue() : base()
        {
            OnCreated();
        }

        public ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue(Enums.EnumPortTypes? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortTypesConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }

        public new static ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue FromRead(Read.IValueTag<Enums.EnumPortTypes?> read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsTypeDefaultValue();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies the SSL/TLS settings.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled(Read.IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SslTlsEnabled node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled() : base("SslTlsEnabled")
        {
            OnCreated();
        }

        private ElementValue<bool?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public ElementValue<bool?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies the default setting.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<bool?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<bool?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled();
            item.DefaultValue = ElementValue<bool?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled(this);
        }
    }

    ///<summary>
    /// Specifies the local port settings.
    ///</summary>
public partial class ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses : EditableElementNode<Read.IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses>
    {
        internal ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses(Read.IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AllowedIPAddresses node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses() : base("AllowedIPAddresses")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether allowed IP addresses can be provided.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses FromRead(Read.IConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses(this);
        }
    }

    ///<summary>
    /// Defines a GPIB connection.
    ///</summary>
public partial class ConnectionsConnectionGpib : EditableElementNode<Read.IConnectionsConnectionGpib>
    {
        internal ConnectionsConnectionGpib(Read.IConnectionsConnectionGpib read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Gpib node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpib() : base("Gpib")
        {
            OnCreated();
        }

        private ConnectionsConnectionGpibCommunicationOptions _communicationOptions;
        private ConnectionsConnectionGpibUserSettings _userSettings;
        public ConnectionsConnectionGpibCommunicationOptions CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    CombinedTagHandler.Assign(value, this, "CommunicationOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the user settings.
        ///</summary>
public ConnectionsConnectionGpibUserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        public ConnectionsConnectionGpibCommunicationOptions GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new ConnectionsConnectionGpibCommunicationOptions();
            return CommunicationOptions;
        }

        public ConnectionsConnectionGpibUserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ConnectionsConnectionGpibUserSettings();
            return UserSettings;
        }

        protected override void Initialize(Read.IConnectionsConnectionGpib read, XmlElement editNode)
        {
            if (read == null)
                return;
            _communicationOptions = read.CommunicationOptions != null ? new ConnectionsConnectionGpibCommunicationOptions(read.CommunicationOptions, this, editNode.Element["CommunicationOptions"]) : null;
            _userSettings = read.UserSettings != null ? new ConnectionsConnectionGpibUserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
        }

        public static ConnectionsConnectionGpib FromRead(Read.IConnectionsConnectionGpib read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpib();
            item.CommunicationOptions = ConnectionsConnectionGpibCommunicationOptions.FromRead(read.CommunicationOptions);
            item.UserSettings = ConnectionsConnectionGpibUserSettings.FromRead(read.UserSettings);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpib(this);
        }
    }

    public partial class ConnectionsConnectionGpibCommunicationOptions : EditableElementNode<Read.IConnectionsConnectionGpibCommunicationOptions>
    {
        internal ConnectionsConnectionGpibCommunicationOptions(Read.IConnectionsConnectionGpibCommunicationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CommunicationOptions node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpibCommunicationOptions() : base("CommunicationOptions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionGpibCommunicationOptions read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionGpibCommunicationOptions FromRead(Read.IConnectionsConnectionGpibCommunicationOptions read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpibCommunicationOptions();
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibCommunicationOptions(this);
        }
    }

    ///<summary>
    /// Specifies the user settings.
    ///</summary>
public partial class ConnectionsConnectionGpibUserSettings : EditableElementNode<Read.IConnectionsConnectionGpibUserSettings>
    {
        internal ConnectionsConnectionGpibUserSettings(Read.IConnectionsConnectionGpibUserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpibUserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        private ConnectionsConnectionGpibUserSettingsDeviceAddress _deviceAddress;
        private ConnectionsConnectionGpibUserSettingsTimeoutTime _timeoutTime;
        private ConnectionsConnectionGpibUserSettingsRetries _retries;
        ///<summary>
        /// Configures the bus address.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsDeviceAddress DeviceAddress
        {
            get
            {
                return _deviceAddress;
            }

            set
            {
                if (_deviceAddress != value)
                {
                    _deviceAddress = value;
                    CombinedTagHandler.Assign(value, this, "DeviceAddress");
                }
            }
        }

        ///<summary>
        /// Configures the timeout settings.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Configures the retry settings.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        public ConnectionsConnectionGpibUserSettingsDeviceAddress GetOrCreateDeviceAddress()
        {
            if (DeviceAddress == null)
                DeviceAddress = new ConnectionsConnectionGpibUserSettingsDeviceAddress();
            return DeviceAddress;
        }

        public ConnectionsConnectionGpibUserSettingsTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new ConnectionsConnectionGpibUserSettingsTimeoutTime();
            return TimeoutTime;
        }

        public ConnectionsConnectionGpibUserSettingsRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new ConnectionsConnectionGpibUserSettingsRetries();
            return Retries;
        }

        protected override void Initialize(Read.IConnectionsConnectionGpibUserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _deviceAddress = read.DeviceAddress != null ? new ConnectionsConnectionGpibUserSettingsDeviceAddress(read.DeviceAddress, this, editNode.Element["DeviceAddress"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new ConnectionsConnectionGpibUserSettingsTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _retries = read.Retries != null ? new ConnectionsConnectionGpibUserSettingsRetries(read.Retries, this, editNode.Element["Retries"]) : null;
        }

        public static ConnectionsConnectionGpibUserSettings FromRead(Read.IConnectionsConnectionGpibUserSettings read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpibUserSettings();
            item.DeviceAddress = ConnectionsConnectionGpibUserSettingsDeviceAddress.FromRead(read.DeviceAddress);
            item.TimeoutTime = ConnectionsConnectionGpibUserSettingsTimeoutTime.FromRead(read.TimeoutTime);
            item.Retries = ConnectionsConnectionGpibUserSettingsRetries.FromRead(read.Retries);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettings(this);
        }
    }

    ///<summary>
    /// Configures the bus address.
    ///</summary>
public partial class ConnectionsConnectionGpibUserSettingsDeviceAddress : EditableElementNode<Read.IConnectionsConnectionGpibUserSettingsDeviceAddress>
    {
        internal ConnectionsConnectionGpibUserSettingsDeviceAddress(Read.IConnectionsConnectionGpibUserSettingsDeviceAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DeviceAddress node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsDeviceAddress() : base("DeviceAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private ConnectionsConnectionGpibUserSettingsDeviceAddressRange _range;
        private ConnectionsConnectionGpibUserSettingsDeviceAddressValues _values;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsDeviceAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ConnectionsConnectionGpibUserSettingsDeviceAddressValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ConnectionsConnectionGpibUserSettingsDeviceAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ConnectionsConnectionGpibUserSettingsDeviceAddressRange();
            return Range;
        }

        public ConnectionsConnectionGpibUserSettingsDeviceAddressValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new ConnectionsConnectionGpibUserSettingsDeviceAddressValues();
            return Values;
        }

        protected override void Initialize(Read.IConnectionsConnectionGpibUserSettingsDeviceAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new ConnectionsConnectionGpibUserSettingsDeviceAddressRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new ConnectionsConnectionGpibUserSettingsDeviceAddressValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static ConnectionsConnectionGpibUserSettingsDeviceAddress FromRead(Read.IConnectionsConnectionGpibUserSettingsDeviceAddress read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpibUserSettingsDeviceAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = ConnectionsConnectionGpibUserSettingsDeviceAddressRange.FromRead(read.Range);
            item.Values = ConnectionsConnectionGpibUserSettingsDeviceAddressValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsDeviceAddress(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class ConnectionsConnectionGpibUserSettingsDeviceAddressRange : EditableElementNode<Read.IConnectionsConnectionGpibUserSettingsDeviceAddressRange>
    {
        internal ConnectionsConnectionGpibUserSettingsDeviceAddressRange(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsDeviceAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static ConnectionsConnectionGpibUserSettingsDeviceAddressRange FromRead(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressRange read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpibUserSettingsDeviceAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsDeviceAddressRange(this);
        }
    }

    public partial class ConnectionsConnectionGpibUserSettingsDeviceAddressValues : EditableListNode<Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValues, Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue, ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue>
    {
        internal ConnectionsConnectionGpibUserSettingsDeviceAddressValues(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsDeviceAddressValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValues read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionGpibUserSettingsDeviceAddressValues FromRead(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValues read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpibUserSettingsDeviceAddressValues();
            foreach (var x in read)
            {
                item.Add(ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsDeviceAddressValues(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue : EditableElementValueNode<Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue, string>
    {
        internal ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue FromRead(Read.IConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue(this);
        }
    }

    ///<summary>
    /// Configures the timeout settings.
    ///</summary>
public partial class ConnectionsConnectionGpibUserSettingsTimeoutTime : EditableElementNode<Read.IConnectionsConnectionGpibUserSettingsTimeoutTime>
    {
        internal ConnectionsConnectionGpibUserSettingsTimeoutTime(Read.IConnectionsConnectionGpibUserSettingsTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<string> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionGpibUserSettingsTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionGpibUserSettingsTimeoutTime FromRead(Read.IConnectionsConnectionGpibUserSettingsTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpibUserSettingsTimeoutTime();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Configures the retry settings.
    ///</summary>
public partial class ConnectionsConnectionGpibUserSettingsRetries : EditableElementNode<Read.IConnectionsConnectionGpibUserSettingsRetries>
    {
        internal ConnectionsConnectionGpibUserSettingsRetries(Read.IConnectionsConnectionGpibUserSettingsRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionGpibUserSettingsRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        private ElementValue<string> _defaultValue;
        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        protected override void Initialize(Read.IConnectionsConnectionGpibUserSettingsRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
        }

        public static ConnectionsConnectionGpibUserSettingsRetries FromRead(Read.IConnectionsConnectionGpibUserSettingsRetries read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionGpibUserSettingsRetries();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionGpibUserSettingsRetries(this);
        }
    }

    ///<summary>
    /// Defines a OPC connection.
    ///</summary>
public partial class ConnectionsConnectionOpc : EditableElementNode<Read.IConnectionsConnectionOpc>
    {
        internal ConnectionsConnectionOpc(Read.IConnectionsConnectionOpc read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Opc node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionOpc() : base("Opc")
        {
            OnCreated();
        }

        private ConnectionsConnectionOpcCommunicationOptions _communicationOptions;
        private ConnectionsConnectionOpcUserSettings _userSettings;
        public ConnectionsConnectionOpcCommunicationOptions CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    CombinedTagHandler.Assign(value, this, "CommunicationOptions");
                }
            }
        }

        public ConnectionsConnectionOpcUserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        public ConnectionsConnectionOpcCommunicationOptions GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new ConnectionsConnectionOpcCommunicationOptions();
            return CommunicationOptions;
        }

        public ConnectionsConnectionOpcUserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ConnectionsConnectionOpcUserSettings();
            return UserSettings;
        }

        protected override void Initialize(Read.IConnectionsConnectionOpc read, XmlElement editNode)
        {
            if (read == null)
                return;
            _communicationOptions = read.CommunicationOptions != null ? new ConnectionsConnectionOpcCommunicationOptions(read.CommunicationOptions, this, editNode.Element["CommunicationOptions"]) : null;
            _userSettings = read.UserSettings != null ? new ConnectionsConnectionOpcUserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
        }

        public static ConnectionsConnectionOpc FromRead(Read.IConnectionsConnectionOpc read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionOpc();
            item.CommunicationOptions = ConnectionsConnectionOpcCommunicationOptions.FromRead(read.CommunicationOptions);
            item.UserSettings = ConnectionsConnectionOpcUserSettings.FromRead(read.UserSettings);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionOpc(this);
        }
    }

    public partial class ConnectionsConnectionOpcCommunicationOptions : EditableElementNode<Read.IConnectionsConnectionOpcCommunicationOptions>
    {
        internal ConnectionsConnectionOpcCommunicationOptions(Read.IConnectionsConnectionOpcCommunicationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CommunicationOptions node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionOpcCommunicationOptions() : base("CommunicationOptions")
        {
            OnCreated();
        }

        private ElementValue<string> _progID;
        public ElementValue<string> ProgID
        {
            get
            {
                return _progID;
            }

            set
            {
                if (_progID != value)
                {
                    _progID = value;
                    ElementHandler.Assign(value, this, "ProgID");
                }
            }
        }

        public ElementValue<string> GetOrCreateProgID()
        {
            if (ProgID == null)
                ProgID = new ElementValue<string>();
            return ProgID;
        }

        protected override void Initialize(Read.IConnectionsConnectionOpcCommunicationOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _progID = read.ProgID != null ? new ElementValue<string>(read.ProgID, this) : null;
        }

        public static ConnectionsConnectionOpcCommunicationOptions FromRead(Read.IConnectionsConnectionOpcCommunicationOptions read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionOpcCommunicationOptions();
            item.ProgID = ElementValue<string>.FromRead(read.ProgID);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionOpcCommunicationOptions(this);
        }
    }

    public partial class ConnectionsConnectionOpcUserSettings : EditableElementNode<Read.IConnectionsConnectionOpcUserSettings>
    {
        internal ConnectionsConnectionOpcUserSettings(Read.IConnectionsConnectionOpcUserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ConnectionsConnectionOpcUserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IConnectionsConnectionOpcUserSettings read, XmlElement editNode)
        {
        }

        public static ConnectionsConnectionOpcUserSettings FromRead(Read.IConnectionsConnectionOpcUserSettings read)
        {
            if (read == null)
                return null;
            var item = new ConnectionsConnectionOpcUserSettings();
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitConnectionsConnectionOpcUserSettings(this);
        }
    }

    ///<summary>
    /// Defines the layout and the order of the Data Display pages.
    ///</summary>
public partial class Display : EditableElementNode<Read.IDisplay>
    {
        internal Display(Read.IDisplay read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Display node. None of it's properties will be set.
        ///</summary>
public Display() : base("Display")
        {
            OnCreated();
        }

        private DisplayPages _pages;
        private AttributeValue<string> _defaultPage;
        private AttributeValue<string> _pageOptions;
        private AttributeValue<string> _pageOrder;
        private DisplayType _type;
        private AttributeValue<string> _wideColumnPages;
        ///<summary>
        /// Allows to define pages and specify their configuration (e.g. configure the visibility).
        ///</summary>
public DisplayPages Pages
        {
            get
            {
                return _pages;
            }

            set
            {
                if (_pages != value)
                {
                    _pages = value;
                    CombinedTagHandler.Assign(value, this, "Pages");
                }
            }
        }

        ///<summary>
        /// Defines the page that will be shown by default. Only one page name is allowed.
        /// If you do not specify a default page, the first page will be shown.
        ///</summary>
public AttributeValue<string> DefaultPage
        {
            get
            {
                return _defaultPage;
            }

            set
            {
                if (_defaultPage != value)
                {
                    _defaultPage = value;
                    AttributeHandler.Assign(value, this, "defaultPage");
                }
            }
        }

        ///<summary>
        /// Used for CPE elements in order to disable the possibility to open the Data Display page of the element.
        ///</summary>
public AttributeValue<string> PageOptions
        {
            get
            {
                return _pageOptions;
            }

            set
            {
                if (_pageOptions != value)
                {
                    _pageOptions = value;
                    AttributeHandler.Assign(value, this, "pageOptions");
                }
            }
        }

        ///<summary>
        /// Defines the order of the pages in DataMiner Cube or in the Element Display drop-down box.
        /// By default, the pages will be ordered alphabetically.
        /// In addition to the pages, you can add a reference to a web interface by specifying
        /// -	Webinterface#http://[Polling Ip], or
        /// -	WebInterface#http://[id:parameterID]
        ///</summary>
public AttributeValue<string> PageOrder
        {
            get
            {
                return _pageOrder;
            }

            set
            {
                if (_pageOrder != value)
                {
                    _pageOrder = value;
                    AttributeHandler.Assign(value, this, "pageOrder");
                }
            }
        }

        ///<summary>
        /// See the tooltips of the different options.
        ///</summary>
public DisplayType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        ///<summary>
        /// Defines the pages that have only one column. Page names are separated by a semi-colon (";").
        /// By default, a page will have multiple columns. Use this attribute for pages that will contain e.g. a wide table.
        ///</summary>
public AttributeValue<string> WideColumnPages
        {
            get
            {
                return _wideColumnPages;
            }

            set
            {
                if (_wideColumnPages != value)
                {
                    _wideColumnPages = value;
                    AttributeHandler.Assign(value, this, "wideColumnPages");
                }
            }
        }

        public DisplayPages GetOrCreatePages()
        {
            if (Pages == null)
                Pages = new DisplayPages();
            return Pages;
        }

        public AttributeValue<string> GetOrCreateDefaultPage()
        {
            if (DefaultPage == null)
                DefaultPage = new AttributeValue<string>();
            return DefaultPage;
        }

        public AttributeValue<string> GetOrCreatePageOptions()
        {
            if (PageOptions == null)
                PageOptions = new AttributeValue<string>();
            return PageOptions;
        }

        public AttributeValue<string> GetOrCreatePageOrder()
        {
            if (PageOrder == null)
                PageOrder = new AttributeValue<string>();
            return PageOrder;
        }

        public DisplayType GetOrCreateType()
        {
            if (Type == null)
                Type = new DisplayType();
            return Type;
        }

        public AttributeValue<string> GetOrCreateWideColumnPages()
        {
            if (WideColumnPages == null)
                WideColumnPages = new AttributeValue<string>();
            return WideColumnPages;
        }

        protected override void Initialize(Read.IDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pages = read.Pages != null ? new DisplayPages(read.Pages, this, editNode.Element["Pages"]) : null;
            _defaultPage = read.DefaultPage != null ? new AttributeValue<string>(read.DefaultPage, this) : null;
            _pageOptions = read.PageOptions != null ? new AttributeValue<string>(read.PageOptions, this) : null;
            _pageOrder = read.PageOrder != null ? new AttributeValue<string>(read.PageOrder, this) : null;
            _type = read.Type != null ? new DisplayType(read.Type, this) : null;
            _wideColumnPages = read.WideColumnPages != null ? new AttributeValue<string>(read.WideColumnPages, this) : null;
        }

        public static Display FromRead(Read.IDisplay read)
        {
            if (read == null)
                return null;
            var item = new Display();
            item.Pages = DisplayPages.FromRead(read.Pages);
            item.DefaultPage = AttributeValue<string>.FromRead(read.DefaultPage);
            item.PageOptions = AttributeValue<string>.FromRead(read.PageOptions);
            item.PageOrder = AttributeValue<string>.FromRead(read.PageOrder);
            item.Type = DisplayType.FromRead(read.Type);
            item.WideColumnPages = AttributeValue<string>.FromRead(read.WideColumnPages);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDisplay(this);
        }
    }

    ///<summary>
    /// Allows to define pages and specify their configuration (e.g. configure the visibility).
    ///</summary>
public partial class DisplayPages : EditableListNode<Read.IDisplayPages, Read.IDisplayPagesPage, DisplayPagesPage>
    {
        internal DisplayPages(Read.IDisplayPages read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Pages node. None of it's properties will be set.
        ///</summary>
public DisplayPages() : base("Pages")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IDisplayPages read, XmlElement editNode)
        {
        }

        public static DisplayPages FromRead(Read.IDisplayPages read)
        {
            if (read == null)
                return null;
            var item = new DisplayPages();
            foreach (var x in read)
            {
                item.Add(DisplayPagesPage.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDisplayPages(this);
        }
    }

    ///<summary>
    /// Defines a page.
    ///</summary>
public partial class DisplayPagesPage : EditableElementNode<Read.IDisplayPagesPage>
    {
        internal DisplayPagesPage(Read.IDisplayPagesPage read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Page node. None of it's properties will be set.
        ///</summary>
public DisplayPagesPage() : base("Page")
        {
            OnCreated();
        }

        private ElementValue<string> _name;
        private DisplayPagesPageVisibility _visibility;
        ///<summary>
        /// Specifies the name of the page.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Specifies the page visibility configuration.
        ///</summary>
public DisplayPagesPageVisibility Visibility
        {
            get
            {
                return _visibility;
            }

            set
            {
                if (_visibility != value)
                {
                    _visibility = value;
                    CombinedTagHandler.Assign(value, this, "Visibility");
                }
            }
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public DisplayPagesPageVisibility GetOrCreateVisibility()
        {
            if (Visibility == null)
                Visibility = new DisplayPagesPageVisibility();
            return Visibility;
        }

        protected override void Initialize(Read.IDisplayPagesPage read, XmlElement editNode)
        {
            if (read == null)
                return;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _visibility = read.Visibility != null ? new DisplayPagesPageVisibility(read.Visibility, this, editNode.Element["Visibility"]) : null;
        }

        public static DisplayPagesPage FromRead(Read.IDisplayPagesPage read)
        {
            if (read == null)
                return null;
            var item = new DisplayPagesPage();
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.Visibility = DisplayPagesPageVisibility.FromRead(read.Visibility);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDisplayPagesPage(this);
        }
    }

    ///<summary>
    /// Specifies the page visibility configuration.
    ///</summary>
public partial class DisplayPagesPageVisibility : EditableElementNode<Read.IDisplayPagesPageVisibility>
    {
        internal DisplayPagesPageVisibility(Read.IDisplayPagesPageVisibility read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Visibility node. None of it's properties will be set.
        ///</summary>
public DisplayPagesPageVisibility() : base("Visibility")
        {
            OnCreated();
        }

        private AttributeValue<bool?> _default;
        private AttributeValue<uint?> _overridePID;
        private AttributeValue<string> _valueAttribute;
        ///<summary>
        /// Specifies the default visibility of the page.
        ///</summary>
public AttributeValue<bool?> Default
        {
            get
            {
                return _default;
            }

            set
            {
                if (_default != value)
                {
                    _default = value;
                    AttributeHandler.Assign(value, this, "default");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter to use to compare its value with the value specified in the "value" attribute.
        ///</summary>
public AttributeValue<uint?> OverridePID
        {
            get
            {
                return _overridePID;
            }

            set
            {
                if (_overridePID != value)
                {
                    _overridePID = value;
                    AttributeHandler.Assign(value, this, "overridePID");
                }
            }
        }

        ///<summary>
        /// Specifies the value the parameter referred to by the overridePID attribute should have in order to swap the visibility.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateDefault()
        {
            if (Default == null)
                Default = new AttributeValue<bool?>();
            return Default;
        }

        public AttributeValue<uint?> GetOrCreateOverridePID()
        {
            if (OverridePID == null)
                OverridePID = new AttributeValue<uint?>();
            return OverridePID;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        protected override void Initialize(Read.IDisplayPagesPageVisibility read, XmlElement editNode)
        {
            if (read == null)
                return;
            _default = read.Default != null ? new AttributeValue<bool?>(read.Default, this) : null;
            _overridePID = read.OverridePID != null ? new AttributeValue<uint?>(read.OverridePID, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
        }

        public static DisplayPagesPageVisibility FromRead(Read.IDisplayPagesPageVisibility read)
        {
            if (read == null)
                return null;
            var item = new DisplayPagesPageVisibility();
            item.Default = AttributeValue<bool?>.FromRead(read.Default);
            item.OverridePID = AttributeValue<uint?>.FromRead(read.OverridePID);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDisplayPagesPageVisibility(this);
        }
    }

    public partial class DisplayType : AttributeValue<Enums.EnumDisplayType?>
    {
        internal DisplayType(Read.IValueTag<Enums.EnumDisplayType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public DisplayType() : base()
        {
            OnCreated();
        }

        public DisplayType(Enums.EnumDisplayType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumDisplayTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumDisplayType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDisplayTypeConverter.Convert(rawValue?.Trim());
        }

        public new static DisplayType FromRead(Read.IValueTag<Enums.EnumDisplayType?> read)
        {
            if (read == null)
                return null;
            var item = new DisplayType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// This tag allows you to describe the behavior of Dynamic Virtual Elements.
    ///</summary>
public partial class DVEs : EditableElementNode<Read.IDVEs>
    {
        internal DVEs(Read.IDVEs read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DVEs node. None of it's properties will be set.
        ///</summary>
public DVEs() : base("DVEs")
        {
            OnCreated();
        }

        private DVEsDVEProtocols _dVEProtocols;
        private ExportRules _exportRules;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public DVEsDVEProtocols DVEProtocols
        {
            get
            {
                return _dVEProtocols;
            }

            set
            {
                if (_dVEProtocols != value)
                {
                    _dVEProtocols = value;
                    CombinedTagHandler.Assign(value, this, "DVEProtocols");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ExportRules ExportRules
        {
            get
            {
                return _exportRules;
            }

            set
            {
                if (_exportRules != value)
                {
                    _exportRules = value;
                    CombinedTagHandler.Assign(value, this, "ExportRules");
                }
            }
        }

        public DVEsDVEProtocols GetOrCreateDVEProtocols()
        {
            if (DVEProtocols == null)
                DVEProtocols = new DVEsDVEProtocols();
            return DVEProtocols;
        }

        public ExportRules GetOrCreateExportRules()
        {
            if (ExportRules == null)
                ExportRules = new ExportRules("ExportRules");
            return ExportRules;
        }

        protected override void Initialize(Read.IDVEs read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dVEProtocols = read.DVEProtocols != null ? new DVEsDVEProtocols(read.DVEProtocols, this, editNode.Element["DVEProtocols"]) : null;
            _exportRules = read.ExportRules != null ? new ExportRules(read.ExportRules, this, editNode.Element["ExportRules"]) : null;
        }

        public static DVEs FromRead(Read.IDVEs read)
        {
            if (read == null)
                return null;
            var item = new DVEs();
            item.DVEProtocols = DVEsDVEProtocols.FromRead(read.DVEProtocols);
            item.ExportRules = ExportRules.FromRead(read.ExportRules);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDVEs(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class DVEsDVEProtocols : EditableListNode<Read.IDVEsDVEProtocols, Read.IDVEsDVEProtocolsDVEProtocol, DVEsDVEProtocolsDVEProtocol>
    {
        internal DVEsDVEProtocols(Read.IDVEsDVEProtocols read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DVEProtocols node. None of it's properties will be set.
        ///</summary>
public DVEsDVEProtocols() : base("DVEProtocols")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IDVEsDVEProtocols read, XmlElement editNode)
        {
        }

        public static DVEsDVEProtocols FromRead(Read.IDVEsDVEProtocols read)
        {
            if (read == null)
                return null;
            var item = new DVEsDVEProtocols();
            foreach (var x in read)
            {
                item.Add(DVEsDVEProtocolsDVEProtocol.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDVEsDVEProtocols(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class DVEsDVEProtocolsDVEProtocol : EditableElementNode<Read.IDVEsDVEProtocolsDVEProtocol>
    {
        internal DVEsDVEProtocolsDVEProtocol(Read.IDVEsDVEProtocolsDVEProtocol read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DVEProtocol node. None of it's properties will be set.
        ///</summary>
public DVEsDVEProtocolsDVEProtocol() : base("DVEProtocol")
        {
            OnCreated();
        }

        private ElementValue<bool?> _elementPrefix;
        private AttributeValue<string> _name;
        private AttributeValue<uint?> _tablePID;
        ///<summary>
        /// Set to false to leave out the parent element name in the virtual element name.
        ///</summary>
public ElementValue<bool?> ElementPrefix
        {
            get
            {
                return _elementPrefix;
            }

            set
            {
                if (_elementPrefix != value)
                {
                    _elementPrefix = value;
                    ElementHandler.Assign(value, this, "ElementPrefix");
                }
            }
        }

        ///<summary>
        /// The name of the exported protocol.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Parameter ID of the table to be exported.
        ///</summary>
public AttributeValue<uint?> TablePID
        {
            get
            {
                return _tablePID;
            }

            set
            {
                if (_tablePID != value)
                {
                    _tablePID = value;
                    AttributeHandler.Assign(value, this, "tablePID");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateElementPrefix()
        {
            if (ElementPrefix == null)
                ElementPrefix = new ElementValue<bool?>();
            return ElementPrefix;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<uint?> GetOrCreateTablePID()
        {
            if (TablePID == null)
                TablePID = new AttributeValue<uint?>();
            return TablePID;
        }

        protected override void Initialize(Read.IDVEsDVEProtocolsDVEProtocol read, XmlElement editNode)
        {
            if (read == null)
                return;
            _elementPrefix = read.ElementPrefix != null ? new ElementValue<bool?>(read.ElementPrefix, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _tablePID = read.TablePID != null ? new AttributeValue<uint?>(read.TablePID, this) : null;
        }

        public static DVEsDVEProtocolsDVEProtocol FromRead(Read.IDVEsDVEProtocolsDVEProtocol read)
        {
            if (read == null)
                return null;
            var item = new DVEsDVEProtocolsDVEProtocol();
            item.ElementPrefix = ElementValue<bool?>.FromRead(read.ElementPrefix);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.TablePID = AttributeValue<uint?>.FromRead(read.TablePID);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitDVEsDVEProtocolsDVEProtocol(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class ElementOptions : EditableElementNode<Read.IElementOptions>
    {
        internal ElementOptions(Read.IElementOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ElementOptions node. None of it's properties will be set.
        ///</summary>
public ElementOptions() : base("ElementOptions")
        {
            OnCreated();
        }

        private ElementOptionsUserSettings _userSettings;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementOptionsUserSettings UserSettings
        {
            get
            {
                return _userSettings;
            }

            set
            {
                if (_userSettings != value)
                {
                    _userSettings = value;
                    CombinedTagHandler.Assign(value, this, "UserSettings");
                }
            }
        }

        public ElementOptionsUserSettings GetOrCreateUserSettings()
        {
            if (UserSettings == null)
                UserSettings = new ElementOptionsUserSettings();
            return UserSettings;
        }

        protected override void Initialize(Read.IElementOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _userSettings = read.UserSettings != null ? new ElementOptionsUserSettings(read.UserSettings, this, editNode.Element["UserSettings"]) : null;
        }

        public static ElementOptions FromRead(Read.IElementOptions read)
        {
            if (read == null)
                return null;
            var item = new ElementOptions();
            item.UserSettings = ElementOptionsUserSettings.FromRead(read.UserSettings);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitElementOptions(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class ElementOptionsUserSettings : EditableElementNode<Read.IElementOptionsUserSettings>
    {
        internal ElementOptionsUserSettings(Read.IElementOptionsUserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a UserSettings node. None of it's properties will be set.
        ///</summary>
public ElementOptionsUserSettings() : base("UserSettings")
        {
            OnCreated();
        }

        private PingInterval _pingInterval;
        private SlowPoll _slowPoll;
        private SlowPollBase _slowPollBase;
        private SlowPoll _timeoutTimeElement;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public PingInterval PingInterval
        {
            get
            {
                return _pingInterval;
            }

            set
            {
                if (_pingInterval != value)
                {
                    _pingInterval = value;
                    CombinedTagHandler.Assign(value, this, "PingInterval");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public SlowPoll SlowPoll
        {
            get
            {
                return _slowPoll;
            }

            set
            {
                if (_slowPoll != value)
                {
                    _slowPoll = value;
                    CombinedTagHandler.Assign(value, this, "SlowPoll");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public SlowPollBase SlowPollBase
        {
            get
            {
                return _slowPollBase;
            }

            set
            {
                if (_slowPollBase != value)
                {
                    _slowPollBase = value;
                    CombinedTagHandler.Assign(value, this, "SlowPollBase");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public SlowPoll TimeoutTimeElement
        {
            get
            {
                return _timeoutTimeElement;
            }

            set
            {
                if (_timeoutTimeElement != value)
                {
                    _timeoutTimeElement = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTimeElement");
                }
            }
        }

        public PingInterval GetOrCreatePingInterval()
        {
            if (PingInterval == null)
                PingInterval = new PingInterval("PingInterval");
            return PingInterval;
        }

        public SlowPoll GetOrCreateSlowPoll()
        {
            if (SlowPoll == null)
                SlowPoll = new SlowPoll("SlowPoll");
            return SlowPoll;
        }

        public SlowPollBase GetOrCreateSlowPollBase()
        {
            if (SlowPollBase == null)
                SlowPollBase = new SlowPollBase("SlowPollBase");
            return SlowPollBase;
        }

        public SlowPoll GetOrCreateTimeoutTimeElement()
        {
            if (TimeoutTimeElement == null)
                TimeoutTimeElement = new SlowPoll("TimeoutTimeElement");
            return TimeoutTimeElement;
        }

        protected override void Initialize(Read.IElementOptionsUserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pingInterval = read.PingInterval != null ? new PingInterval(read.PingInterval, this, editNode.Element["PingInterval"]) : null;
            _slowPoll = read.SlowPoll != null ? new SlowPoll(read.SlowPoll, this, editNode.Element["SlowPoll"]) : null;
            _slowPollBase = read.SlowPollBase != null ? new SlowPollBase(read.SlowPollBase, this, editNode.Element["SlowPollBase"]) : null;
            _timeoutTimeElement = read.TimeoutTimeElement != null ? new SlowPoll(read.TimeoutTimeElement, this, editNode.Element["TimeoutTimeElement"]) : null;
        }

        public static ElementOptionsUserSettings FromRead(Read.IElementOptionsUserSettings read)
        {
            if (read == null)
                return null;
            var item = new ElementOptionsUserSettings();
            item.PingInterval = PingInterval.FromRead(read.PingInterval);
            item.SlowPoll = SlowPoll.FromRead(read.SlowPoll);
            item.SlowPollBase = SlowPollBase.FromRead(read.SlowPollBase);
            item.TimeoutTimeElement = SlowPoll.FromRead(read.TimeoutTimeElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitElementOptionsUserSettings(this);
        }
    }

    ///<summary>
    /// Contains options that can be enabled or configured that change how the system will manage or interact with the element.
    ///</summary>
public partial class SystemOptions : EditableElementNode<Read.ISystemOptions>
    {
        internal SystemOptions(Read.ISystemOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SystemOptions node. None of it's properties will be set.
        ///</summary>
public SystemOptions() : base("SystemOptions")
        {
            OnCreated();
        }

        private ElementValue<bool?> _runInSeparateInstance;
        ///<summary>
        /// Set to true if any element running this protocol should be hosted in a separate SLProtocol and SLScripting process. Feature introduced in DataMiner 10.2.7 (RN 33358).
        ///</summary>
public ElementValue<bool?> RunInSeparateInstance
        {
            get
            {
                return _runInSeparateInstance;
            }

            set
            {
                if (_runInSeparateInstance != value)
                {
                    _runInSeparateInstance = value;
                    ElementHandler.Assign(value, this, "RunInSeparateInstance");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateRunInSeparateInstance()
        {
            if (RunInSeparateInstance == null)
                RunInSeparateInstance = new ElementValue<bool?>();
            return RunInSeparateInstance;
        }

        protected override void Initialize(Read.ISystemOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _runInSeparateInstance = read.RunInSeparateInstance != null ? new ElementValue<bool?>(read.RunInSeparateInstance, this) : null;
        }

        public static SystemOptions FromRead(Read.ISystemOptions read)
        {
            if (read == null)
                return null;
            var item = new SystemOptions();
            item.RunInSeparateInstance = ElementValue<bool?>.FromRead(read.RunInSeparateInstance);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSystemOptions(this);
        }
    }

    ///<summary>
    /// Specifies which general parameter groups should be loaded or not. Feature introduced in DataMiner 9.0.1 (RN 12263).
    ///</summary>
public partial class GeneralParameters : EditableListNode<Read.IGeneralParameters, Read.IGeneralParametersGeneralParameter, GeneralParametersGeneralParameter>
    {
        internal GeneralParameters(Read.IGeneralParameters read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a GeneralParameters node. None of it's properties will be set.
        ///</summary>
public GeneralParameters() : base("GeneralParameters")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IGeneralParameters read, XmlElement editNode)
        {
        }

        public static GeneralParameters FromRead(Read.IGeneralParameters read)
        {
            if (read == null)
                return null;
            var item = new GeneralParameters();
            foreach (var x in read)
            {
                item.Add(GeneralParametersGeneralParameter.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGeneralParameters(this);
        }
    }

    ///<summary>
    /// Configures a general parameter group.
    ///</summary>
public partial class GeneralParametersGeneralParameter : EditableElementNode<Read.IGeneralParametersGeneralParameter>
    {
        internal GeneralParametersGeneralParameter(Read.IGeneralParametersGeneralParameter read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a GeneralParameter node. None of it's properties will be set.
        ///</summary>
public GeneralParametersGeneralParameter() : base("GeneralParameter")
        {
            OnCreated();
        }

        private GeneralParametersGeneralParameterGroup _group;
        private AttributeValue<bool?> _enabled;
        ///<summary>
        /// Specifies the general parameter group.
        ///</summary>
public GeneralParametersGeneralParameterGroup Group
        {
            get
            {
                return _group;
            }

            set
            {
                if (_group != value)
                {
                    _group = value;
                    AttributeHandler.Assign(value, this, "group");
                }
            }
        }

        ///<summary>
        /// When set to false, the specified general parameter group will not be loaded.
        ///</summary>
public AttributeValue<bool?> Enabled
        {
            get
            {
                return _enabled;
            }

            set
            {
                if (_enabled != value)
                {
                    _enabled = value;
                    AttributeHandler.Assign(value, this, "enabled");
                }
            }
        }

        public GeneralParametersGeneralParameterGroup GetOrCreateGroup()
        {
            if (Group == null)
                Group = new GeneralParametersGeneralParameterGroup();
            return Group;
        }

        public AttributeValue<bool?> GetOrCreateEnabled()
        {
            if (Enabled == null)
                Enabled = new AttributeValue<bool?>();
            return Enabled;
        }

        protected override void Initialize(Read.IGeneralParametersGeneralParameter read, XmlElement editNode)
        {
            if (read == null)
                return;
            _group = read.Group != null ? new GeneralParametersGeneralParameterGroup(read.Group, this) : null;
            _enabled = read.Enabled != null ? new AttributeValue<bool?>(read.Enabled, this) : null;
        }

        public static GeneralParametersGeneralParameter FromRead(Read.IGeneralParametersGeneralParameter read)
        {
            if (read == null)
                return null;
            var item = new GeneralParametersGeneralParameter();
            item.Group = GeneralParametersGeneralParameterGroup.FromRead(read.Group);
            item.Enabled = AttributeValue<bool?>.FromRead(read.Enabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGeneralParametersGeneralParameter(this);
        }
    }

    public partial class GeneralParametersGeneralParameterGroup : AttributeValue<Enums.EnumGeneralParameterGroupType?>
    {
        internal GeneralParametersGeneralParameterGroup(Read.IValueTag<Enums.EnumGeneralParameterGroupType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a group node. None of it's properties will be set.
        ///</summary>
public GeneralParametersGeneralParameterGroup() : base()
        {
            OnCreated();
        }

        public GeneralParametersGeneralParameterGroup(Enums.EnumGeneralParameterGroupType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumGeneralParameterGroupTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumGeneralParameterGroupType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumGeneralParameterGroupTypeConverter.Convert(rawValue?.Trim());
        }

        public new static GeneralParametersGeneralParameterGroup FromRead(Read.IValueTag<Enums.EnumGeneralParameterGroupType?> read)
        {
            if (read == null)
                return null;
            var item = new GeneralParametersGeneralParameterGroup();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Contains the groups defined in the protocol.
    ///</summary>
public partial class Groups : EditableListNode<Read.IGroups, Read.IGroupsGroup, GroupsGroup>
    {
        internal Groups(Read.IGroups read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Groups node. None of it's properties will be set.
        ///</summary>
public Groups() : base("Groups")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IGroups read, XmlElement editNode)
        {
        }

        public static Groups FromRead(Read.IGroups read)
        {
            if (read == null)
                return null;
            var item = new Groups();
            foreach (var x in read)
            {
                item.Add(GroupsGroup.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroups(this);
        }
    }

    ///<summary>
    /// Groups are used to do the actual device polling.
    /// In a group, you can assemble different parameters, command/response pairs or actions. When a group is executed, all parameters, pairs or actions included in the group will be executed one after the other.
    /// Make sure that the "id" attribute contains a unique group ID.
    ///</summary>
public partial class GroupsGroup : EditableElementNode<Read.IGroupsGroup>
    {
        internal GroupsGroup(Read.IGroupsGroup read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Group node. None of it's properties will be set.
        ///</summary>
public GroupsGroup() : base("Group")
        {
            OnCreated();
        }

        private ElementValue<string> _condition;
        private GroupsGroupContent _content;
        private ElementValue<string> _description;
        private ElementValue<string> _name;
        private GroupsGroupType _type;
        private AttributeValue<uint?> _connection;
        private AttributeValue<uint?> _connectionPID;
        private AttributeValue<uint?> _id;
        private AttributeValue<bool?> _ping;
        ///<summary>
        /// Specifies a condition that must be met in order for the group to execute.
        ///</summary>
public ElementValue<string> Condition
        {
            get
            {
                return _condition;
            }

            set
            {
                if (_condition != value)
                {
                    _condition = value;
                    ElementHandler.Assign(value, this, "Condition");
                }
            }
        }

        ///<summary>
        /// Contains all actions, pairs, parameters, sessions, or triggers that have to be executed consecutively when the group is executed.
        /// In a /Protocol/Groups/Group/Content element, you are only allowed to specify items of the same type:
        /// - action items only,
        /// - pair items only,
        /// - parameter items only,
        /// - session items only,
        /// 
        /// - trigger items only.
        /// Recommendation: The content of a group should not exceed 10 items.
        ///</summary>
public GroupsGroupContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        ///<summary>
        /// Specifies the group description.
        ///</summary>
public ElementValue<string> Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    ElementHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the group. This name could, for example, refer to the information that will be requested from the device.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// By default, a group includes parameters or pairs. However, if you want to include actions or triggers in a group, specify this here.
        /// If you specify "action" or "trigger", the group will be executed at once.
        /// If, however, you specify "poll", "poll action" or "poll trigger", the group will be added to the group execution queue, awaiting execution.
        ///</summary>
public GroupsGroupType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    ElementHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// In case of multiple ports, use this attribute to specify the connection to be used.
        /// Default connection: 0
        ///</summary>
public AttributeValue<uint?> Connection
        {
            get
            {
                return _connection;
            }

            set
            {
                if (_connection != value)
                {
                    _connection = value;
                    AttributeHandler.Assign(value, this, "connection");
                }
            }
        }

        ///<summary>
        /// Via this attribute it is possible to dynamically select an HTTP connection by referring to the connection by means of a parameter ID.
        /// This way, it is possible to switch connection at run-time.
        ///</summary>
public AttributeValue<uint?> ConnectionPID
        {
            get
            {
                return _connectionPID;
            }

            set
            {
                if (_connectionPID != value)
                {
                    _connectionPID = value;
                    AttributeHandler.Assign(value, this, "connectionPID");
                }
            }
        }

        ///<summary>
        /// The unique group ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies whether this is the group to be used when testing the connection in the element wizard.
        ///</summary>
public AttributeValue<bool?> Ping
        {
            get
            {
                return _ping;
            }

            set
            {
                if (_ping != value)
                {
                    _ping = value;
                    AttributeHandler.Assign(value, this, "ping");
                }
            }
        }

        public ElementValue<string> GetOrCreateCondition()
        {
            if (Condition == null)
                Condition = new ElementValue<string>();
            return Condition;
        }

        public GroupsGroupContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new GroupsGroupContent();
            return Content;
        }

        public ElementValue<string> GetOrCreateDescription()
        {
            if (Description == null)
                Description = new ElementValue<string>();
            return Description;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public GroupsGroupType GetOrCreateType()
        {
            if (Type == null)
                Type = new GroupsGroupType();
            return Type;
        }

        public AttributeValue<uint?> GetOrCreateConnection()
        {
            if (Connection == null)
                Connection = new AttributeValue<uint?>();
            return Connection;
        }

        public AttributeValue<uint?> GetOrCreateConnectionPID()
        {
            if (ConnectionPID == null)
                ConnectionPID = new AttributeValue<uint?>();
            return ConnectionPID;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<bool?> GetOrCreatePing()
        {
            if (Ping == null)
                Ping = new AttributeValue<bool?>();
            return Ping;
        }

        protected override void Initialize(Read.IGroupsGroup read, XmlElement editNode)
        {
            if (read == null)
                return;
            _condition = read.Condition != null ? new ElementValue<string>(read.Condition, this) : null;
            _content = read.Content != null ? new GroupsGroupContent(read.Content, this, editNode.Element["Content"]) : null;
            _description = read.Description != null ? new ElementValue<string>(read.Description, this) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _type = read.Type != null ? new GroupsGroupType(read.Type, this) : null;
            _connection = read.Connection != null ? new AttributeValue<uint?>(read.Connection, this) : null;
            _connectionPID = read.ConnectionPID != null ? new AttributeValue<uint?>(read.ConnectionPID, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _ping = read.Ping != null ? new AttributeValue<bool?>(read.Ping, this) : null;
        }

        public static GroupsGroup FromRead(Read.IGroupsGroup read)
        {
            if (read == null)
                return null;
            var item = new GroupsGroup();
            item.Condition = ElementValue<string>.FromRead(read.Condition);
            item.Content = GroupsGroupContent.FromRead(read.Content);
            item.Description = ElementValue<string>.FromRead(read.Description);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.Type = GroupsGroupType.FromRead(read.Type);
            item.Connection = AttributeValue<uint?>.FromRead(read.Connection);
            item.ConnectionPID = AttributeValue<uint?>.FromRead(read.ConnectionPID);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Ping = AttributeValue<bool?>.FromRead(read.Ping);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroup(this);
        }
    }

    ///<summary>
    /// Contains all actions, pairs, parameters, sessions, or triggers that have to be executed consecutively when the group is executed.
    /// In a /Protocol/Groups/Group/Content element, you are only allowed to specify items of the same type:
    /// - action items only,
    /// - pair items only,
    /// - parameter items only,
    /// - session items only,
    /// 
    /// - trigger items only.
    /// Recommendation: The content of a group should not exceed 10 items.
    ///</summary>
public partial class GroupsGroupContent : ComplexEditableListNode<Read.IGroupsGroupContent, Read.IGroupsGroupContentItem, IGroupsGroupContentItem>
    {
        internal GroupsGroupContent(Read.IGroupsGroupContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode, new Dictionary<string, Type>() { { "Action", typeof(GroupsGroupContentAction) }, { "Pair", typeof(GroupsGroupContentPair) }, { "Param", typeof(GroupsGroupContentParam) }, { "Session", typeof(GroupsGroupContentSession) }, { "Trigger", typeof(GroupsGroupContentTrigger) }, { "", typeof(GroupsGroupContentItem) } })
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public GroupsGroupContent() : base("Content", new Dictionary<string, Type>() { { "Action", typeof(GroupsGroupContentAction) }, { "Pair", typeof(GroupsGroupContentPair) }, { "Param", typeof(GroupsGroupContentParam) }, { "Session", typeof(GroupsGroupContentSession) }, { "Trigger", typeof(GroupsGroupContentTrigger) }, { "", typeof(GroupsGroupContentItem) } })
        {
            OnCreated();
        }

        private AttributeValue<bool?> _multipleGet;
        ///<summary>
        /// If "true", all parameters will be read in one SNMP Get operation.
        /// This "multipleGet" option cannot be used with parameters of Type "Array".
        ///</summary>
public AttributeValue<bool?> MultipleGet
        {
            get
            {
                return _multipleGet;
            }

            set
            {
                if (_multipleGet != value)
                {
                    _multipleGet = value;
                    AttributeHandler.Assign(value, this, "multipleGet");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateMultipleGet()
        {
            if (MultipleGet == null)
                MultipleGet = new AttributeValue<bool?>();
            return MultipleGet;
        }

        protected override void Initialize(Read.IGroupsGroupContent read, XmlElement editNode)
        {
            if (read == null)
                return;
            _multipleGet = read.MultipleGet != null ? new AttributeValue<bool?>(read.MultipleGet, this) : null;
        }

        public static GroupsGroupContent FromRead(Read.IGroupsGroupContent read)
        {
            if (read == null)
                return null;
            var item = new GroupsGroupContent();
            item.MultipleGet = AttributeValue<bool?>.FromRead(read.MultipleGet);
            foreach (var x in read)
            {
                item.Add(GroupsGroupContentItem.ItemFromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContent(this);
        }
    }

    public interface IGroupsGroupContentItem : IEditableNode
    {
    }

    public partial class GroupsGroupContentItem : EditableElementNode<Read.IGroupsGroupContentItem>, IGroupsGroupContentItem
    {
        protected GroupsGroupContentItem(string tagName) : base(tagName)
        {
        }

        internal GroupsGroupContentItem(Read.IGroupsGroupContentItem read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        protected override void Initialize(Read.IGroupsGroupContentItem read, XmlElement editNode)
        {
        }

        public static IGroupsGroupContentItem ItemFromRead(Read.IGroupsGroupContentItem read)
        {
            if (read == null)
                return null;
            switch (read.TagName)
            {
                case "Action":
                    return GroupsGroupContentAction.FromRead(read as Read.IGroupsGroupContentAction);
                case "Pair":
                    return GroupsGroupContentPair.FromRead(read as Read.IGroupsGroupContentPair);
                case "Param":
                    return GroupsGroupContentParam.FromRead(read as Read.IGroupsGroupContentParam);
                case "Session":
                    return GroupsGroupContentSession.FromRead(read as Read.IGroupsGroupContentSession);
                case "Trigger":
                    return GroupsGroupContentTrigger.FromRead(read as Read.IGroupsGroupContentTrigger);
                default:
                    return new GroupsGroupContentItem(read.TagName);
            }
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentItem(this);
        }
    }

    ///<summary>
    /// Specifies the ID of an action to include in the group.
    /// If you include actions in a group, do not forget to set the attribute /Protocol/Groups/Group@type to "action".
    ///</summary>
public partial class GroupsGroupContentAction : EditableElementValueNode<Read.IGroupsGroupContentAction, string>, IGroupsGroupContentItem
    {
        internal GroupsGroupContentAction(Read.IGroupsGroupContentAction read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Action node. None of it's properties will be set.
        ///</summary>
public GroupsGroupContentAction(bool useCDATA = false) : base("Action", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public GroupsGroupContentAction(string value, bool useCDATA = false) : base("Action", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _next;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed action before executing the next action.
        ///</summary>
public AttributeValue<uint?> Next
        {
            get
            {
                return _next;
            }

            set
            {
                if (_next != value)
                {
                    _next = value;
                    AttributeHandler.Assign(value, this, "next");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateNext()
        {
            if (Next == null)
                Next = new AttributeValue<uint?>();
            return Next;
        }

        protected override void Initialize(Read.IGroupsGroupContentAction read, XmlElement editNode)
        {
            if (read == null)
                return;
            _next = read.Next != null ? new AttributeValue<uint?>(read.Next, this) : null;
        }

        public static GroupsGroupContentAction FromRead(Read.IGroupsGroupContentAction read)
        {
            if (read == null)
                return null;
            var item = new GroupsGroupContentAction();
            item.Value = read.Value;
            item.Next = AttributeValue<uint?>.FromRead(read.Next);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentAction(this);
        }
    }

    ///<summary>
    /// Specifies the ID of a command/response pair to be included in a group.
    /// When a setting has to be changed, it is common practice to include in a group
    /// - a "SET" pair, directly followed by
    /// - a "GET" pair.
    /// That way, the DataMiner interface will immediately show the changed values.
    ///</summary>
public partial class GroupsGroupContentPair : EditableElementValueNode<Read.IGroupsGroupContentPair, uint?>, IGroupsGroupContentItem
    {
        internal GroupsGroupContentPair(Read.IGroupsGroupContentPair read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Pair node. None of it's properties will be set.
        ///</summary>
public GroupsGroupContentPair() : base("Pair")
        {
            OnCreated();
        }

        public GroupsGroupContentPair(uint? value) : base("Pair", value)
        {
        }

        private AttributeValue<uint?> _next;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed pair before executing the next pair.
        ///</summary>
public AttributeValue<uint?> Next
        {
            get
            {
                return _next;
            }

            set
            {
                if (_next != value)
                {
                    _next = value;
                    AttributeHandler.Assign(value, this, "next");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateNext()
        {
            if (Next == null)
                Next = new AttributeValue<uint?>();
            return Next;
        }

        protected override void Initialize(Read.IGroupsGroupContentPair read, XmlElement editNode)
        {
            if (read == null)
                return;
            _next = read.Next != null ? new AttributeValue<uint?>(read.Next, this) : null;
        }

        public static GroupsGroupContentPair FromRead(Read.IGroupsGroupContentPair read)
        {
            if (read == null)
                return null;
            var item = new GroupsGroupContentPair();
            item.Value = read.Value;
            item.Next = AttributeValue<uint?>.FromRead(read.Next);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentPair(this);
        }
    }

    ///<summary>
    /// Specifies the ID of a parameter to be included in the group.
    ///</summary>
public partial class GroupsGroupContentParam : EditableElementValueNode<Read.IGroupsGroupContentParam, string>, IGroupsGroupContentItem
    {
        internal GroupsGroupContentParam(Read.IGroupsGroupContentParam read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Param node. None of it's properties will be set.
        ///</summary>
public GroupsGroupContentParam(bool useCDATA = false) : base("Param", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public GroupsGroupContentParam(string value, bool useCDATA = false) : base("Param", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _next;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait before reading the next parameter.
        ///</summary>
public AttributeValue<uint?> Next
        {
            get
            {
                return _next;
            }

            set
            {
                if (_next != value)
                {
                    _next = value;
                    AttributeHandler.Assign(value, this, "next");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateNext()
        {
            if (Next == null)
                Next = new AttributeValue<uint?>();
            return Next;
        }

        protected override void Initialize(Read.IGroupsGroupContentParam read, XmlElement editNode)
        {
            if (read == null)
                return;
            _next = read.Next != null ? new AttributeValue<uint?>(read.Next, this) : null;
        }

        public static GroupsGroupContentParam FromRead(Read.IGroupsGroupContentParam read)
        {
            if (read == null)
                return null;
            var item = new GroupsGroupContentParam();
            item.Value = read.Value;
            item.Next = AttributeValue<uint?>.FromRead(read.Next);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentParam(this);
        }
    }

    ///<summary>
    /// Specifies the ID of an HTTP session to be included in the group.
    ///</summary>
public partial class GroupsGroupContentSession : EditableElementValueNode<Read.IGroupsGroupContentSession, uint?>, IGroupsGroupContentItem
    {
        internal GroupsGroupContentSession(Read.IGroupsGroupContentSession read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Session node. None of it's properties will be set.
        ///</summary>
public GroupsGroupContentSession() : base("Session")
        {
            OnCreated();
        }

        public GroupsGroupContentSession(uint? value) : base("Session", value)
        {
        }

        private AttributeValue<uint?> _connection;
        private AttributeValue<uint?> _next;
        ///<summary>
        /// If you want to execute only a specific connection within a certain session, then use the connection attribute to specify the connection.
        /// Feature introduced in DataMiner 8.5.7 (RN 9928).
        ///</summary>
public AttributeValue<uint?> Connection
        {
            get
            {
                return _connection;
            }

            set
            {
                if (_connection != value)
                {
                    _connection = value;
                    AttributeHandler.Assign(value, this, "connection");
                }
            }
        }

        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait after having received the response of the last executed session before executing the next session.
        /// If the last item in the group contains this attribute, it will also cause a delay before the next group is executed.
        ///</summary>
public AttributeValue<uint?> Next
        {
            get
            {
                return _next;
            }

            set
            {
                if (_next != value)
                {
                    _next = value;
                    AttributeHandler.Assign(value, this, "next");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateConnection()
        {
            if (Connection == null)
                Connection = new AttributeValue<uint?>();
            return Connection;
        }

        public AttributeValue<uint?> GetOrCreateNext()
        {
            if (Next == null)
                Next = new AttributeValue<uint?>();
            return Next;
        }

        protected override void Initialize(Read.IGroupsGroupContentSession read, XmlElement editNode)
        {
            if (read == null)
                return;
            _connection = read.Connection != null ? new AttributeValue<uint?>(read.Connection, this) : null;
            _next = read.Next != null ? new AttributeValue<uint?>(read.Next, this) : null;
        }

        public static GroupsGroupContentSession FromRead(Read.IGroupsGroupContentSession read)
        {
            if (read == null)
                return null;
            var item = new GroupsGroupContentSession();
            item.Value = read.Value;
            item.Connection = AttributeValue<uint?>.FromRead(read.Connection);
            item.Next = AttributeValue<uint?>.FromRead(read.Next);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentSession(this);
        }
    }

    ///<summary>
    /// Specifies the ID of a trigger to be included in a group.
    /// If you include triggers in a group, do not forget to set the value of the "type" attribute of this group to “trigger”.
    ///</summary>
public partial class GroupsGroupContentTrigger : EditableElementValueNode<Read.IGroupsGroupContentTrigger, string>, IGroupsGroupContentItem
    {
        internal GroupsGroupContentTrigger(Read.IGroupsGroupContentTrigger read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Trigger node. None of it's properties will be set.
        ///</summary>
public GroupsGroupContentTrigger(bool useCDATA = false) : base("Trigger", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public GroupsGroupContentTrigger(string value, bool useCDATA = false) : base("Trigger", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _next;
        ///<summary>
        /// Specifies the number of milliseconds DataMiner has to wait before executing the next trigger.
        ///</summary>
public AttributeValue<uint?> Next
        {
            get
            {
                return _next;
            }

            set
            {
                if (_next != value)
                {
                    _next = value;
                    AttributeHandler.Assign(value, this, "next");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateNext()
        {
            if (Next == null)
                Next = new AttributeValue<uint?>();
            return Next;
        }

        protected override void Initialize(Read.IGroupsGroupContentTrigger read, XmlElement editNode)
        {
            if (read == null)
                return;
            _next = read.Next != null ? new AttributeValue<uint?>(read.Next, this) : null;
        }

        public static GroupsGroupContentTrigger FromRead(Read.IGroupsGroupContentTrigger read)
        {
            if (read == null)
                return null;
            var item = new GroupsGroupContentTrigger();
            item.Value = read.Value;
            item.Next = AttributeValue<uint?>.FromRead(read.Next);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitGroupsGroupContentTrigger(this);
        }
    }

    public partial class GroupsGroupType : ElementValue<Enums.EnumGroupType?>
    {
        internal GroupsGroupType(Read.IValueTag<Enums.EnumGroupType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public GroupsGroupType() : base()
        {
            OnCreated();
        }

        public GroupsGroupType(Enums.EnumGroupType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumGroupTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumGroupType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumGroupTypeConverter.Convert(rawValue?.Trim());
        }

        public new static GroupsGroupType FromRead(Read.IValueTag<Enums.EnumGroupType?> read)
        {
            if (read == null)
                return null;
            var item = new GroupsGroupType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// The root of the HTTP-specific features in a protocol.
    ///</summary>
public partial class HTTP : EditableListNode<Read.IHTTP, Read.IHTTPSession, HTTPSession>
    {
        internal HTTP(Read.IHTTP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a HTTP node. None of it's properties will be set.
        ///</summary>
public HTTP() : base("HTTP")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IHTTP read, XmlElement editNode)
        {
        }

        public static HTTP FromRead(Read.IHTTP read)
        {
            if (read == null)
                return null;
            var item = new HTTP();
            foreach (var x in read)
            {
                item.Add(HTTPSession.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTP(this);
        }
    }

    ///<summary>
    /// Represents a particular HTTP session.
    ///</summary>
public partial class HTTPSession : EditableListNode<Read.IHTTPSession, Read.IHTTPSessionConnection, HTTPSessionConnection>
    {
        internal HTTPSession(Read.IHTTPSession read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Session node. None of it's properties will be set.
        ///</summary>
public HTTPSession() : base("Session")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _id;
        private AttributeValue<bool?> _ignoreTimeout;
        private AttributeValue<bool?> _keepAlive;
        private HTTPSessionLoginMethod _loginMethod;
        private AttributeValue<string> _name;
        private AttributeValue<string> _password;
        private AttributeValue<string> _proxyPassword;
        private AttributeValue<string> _proxyServer;
        private AttributeValue<string> _proxyUser;
        private AttributeValue<uint?> _timeout;
        private AttributeValue<string> _userName;
        ///<summary>
        /// The unique session ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// If the HTTP connection should ignore timeout for this session, set this attribute to true.
        /// This works in a similar way as the serial pair ignoreTimeout option.
        /// Default value: false.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        /// 
        ///</summary>
public AttributeValue<bool?> IgnoreTimeout
        {
            get
            {
                return _ignoreTimeout;
            }

            set
            {
                if (_ignoreTimeout != value)
                {
                    _ignoreTimeout = value;
                    AttributeHandler.Assign(value, this, "ignoreTimeout");
                }
            }
        }

        ///<summary>
        /// Specifies whether the session should be kept alive.
        /// Feature introduced in DataMiner 8.5.7 (RN 9929).
        ///</summary>
public AttributeValue<bool?> KeepAlive
        {
            get
            {
                return _keepAlive;
            }

            set
            {
                if (_keepAlive != value)
                {
                    _keepAlive = value;
                    AttributeHandler.Assign(value, this, "keepAlive");
                }
            }
        }

        ///<summary>
        /// Specifies the authentication method to use.
        ///</summary>
public HTTPSessionLoginMethod LoginMethod
        {
            get
            {
                return _loginMethod;
            }

            set
            {
                if (_loginMethod != value)
                {
                    _loginMethod = value;
                    AttributeHandler.Assign(value, this, "loginMethod");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the session.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// If you set loginMethod to "credentials", then use this attribute to specify the password.
        ///</summary>
public AttributeValue<string> Password
        {
            get
            {
                return _password;
            }

            set
            {
                if (_password != value)
                {
                    _password = value;
                    AttributeHandler.Assign(value, this, "password");
                }
            }
        }

        ///<summary>
        /// If, in the proxyServer attribute, you specified a proxy server that requires authentication, then use this attribute to specify the password.
        ///</summary>
public AttributeValue<string> ProxyPassword
        {
            get
            {
                return _proxyPassword;
            }

            set
            {
                if (_proxyPassword != value)
                {
                    _proxyPassword = value;
                    AttributeHandler.Assign(value, this, "proxyPassword");
                }
            }
        }

        ///<summary>
        /// Use this attribute to specify the proxy server through which the connection has to be set up.
        /// Note: If you do not specify a proxy server, then an attempt will be made to fetch the default proxy configuration using the Web Proxy Auto-Discovery Protocol (WPAD).
        ///</summary>
public AttributeValue<string> ProxyServer
        {
            get
            {
                return _proxyServer;
            }

            set
            {
                if (_proxyServer != value)
                {
                    _proxyServer = value;
                    AttributeHandler.Assign(value, this, "proxyServer");
                }
            }
        }

        ///<summary>
        /// If, in the proxyServer attribute, you specified a proxy server that requires authentication, then use this attribute to specify the user name.
        ///</summary>
public AttributeValue<string> ProxyUser
        {
            get
            {
                return _proxyUser;
            }

            set
            {
                if (_proxyUser != value)
                {
                    _proxyUser = value;
                    AttributeHandler.Assign(value, this, "proxyUser");
                }
            }
        }

        ///<summary>
        /// Specifies that DataMiner must use this timeout value (ms) instead of the default one when executing this session.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        ///</summary>
public AttributeValue<uint?> Timeout
        {
            get
            {
                return _timeout;
            }

            set
            {
                if (_timeout != value)
                {
                    _timeout = value;
                    AttributeHandler.Assign(value, this, "timeout");
                }
            }
        }

        ///<summary>
        /// If you set loginMethod to "credentials", then use this attribute to specify the user name.
        ///</summary>
public AttributeValue<string> UserName
        {
            get
            {
                return _userName;
            }

            set
            {
                if (_userName != value)
                {
                    _userName = value;
                    AttributeHandler.Assign(value, this, "userName");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<bool?> GetOrCreateIgnoreTimeout()
        {
            if (IgnoreTimeout == null)
                IgnoreTimeout = new AttributeValue<bool?>();
            return IgnoreTimeout;
        }

        public AttributeValue<bool?> GetOrCreateKeepAlive()
        {
            if (KeepAlive == null)
                KeepAlive = new AttributeValue<bool?>();
            return KeepAlive;
        }

        public HTTPSessionLoginMethod GetOrCreateLoginMethod()
        {
            if (LoginMethod == null)
                LoginMethod = new HTTPSessionLoginMethod();
            return LoginMethod;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<string> GetOrCreatePassword()
        {
            if (Password == null)
                Password = new AttributeValue<string>();
            return Password;
        }

        public AttributeValue<string> GetOrCreateProxyPassword()
        {
            if (ProxyPassword == null)
                ProxyPassword = new AttributeValue<string>();
            return ProxyPassword;
        }

        public AttributeValue<string> GetOrCreateProxyServer()
        {
            if (ProxyServer == null)
                ProxyServer = new AttributeValue<string>();
            return ProxyServer;
        }

        public AttributeValue<string> GetOrCreateProxyUser()
        {
            if (ProxyUser == null)
                ProxyUser = new AttributeValue<string>();
            return ProxyUser;
        }

        public AttributeValue<uint?> GetOrCreateTimeout()
        {
            if (Timeout == null)
                Timeout = new AttributeValue<uint?>();
            return Timeout;
        }

        public AttributeValue<string> GetOrCreateUserName()
        {
            if (UserName == null)
                UserName = new AttributeValue<string>();
            return UserName;
        }

        protected override void Initialize(Read.IHTTPSession read, XmlElement editNode)
        {
            if (read == null)
                return;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _ignoreTimeout = read.IgnoreTimeout != null ? new AttributeValue<bool?>(read.IgnoreTimeout, this) : null;
            _keepAlive = read.KeepAlive != null ? new AttributeValue<bool?>(read.KeepAlive, this) : null;
            _loginMethod = read.LoginMethod != null ? new HTTPSessionLoginMethod(read.LoginMethod, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _password = read.Password != null ? new AttributeValue<string>(read.Password, this) : null;
            _proxyPassword = read.ProxyPassword != null ? new AttributeValue<string>(read.ProxyPassword, this) : null;
            _proxyServer = read.ProxyServer != null ? new AttributeValue<string>(read.ProxyServer, this) : null;
            _proxyUser = read.ProxyUser != null ? new AttributeValue<string>(read.ProxyUser, this) : null;
            _timeout = read.Timeout != null ? new AttributeValue<uint?>(read.Timeout, this) : null;
            _userName = read.UserName != null ? new AttributeValue<string>(read.UserName, this) : null;
        }

        public static HTTPSession FromRead(Read.IHTTPSession read)
        {
            if (read == null)
                return null;
            var item = new HTTPSession();
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.IgnoreTimeout = AttributeValue<bool?>.FromRead(read.IgnoreTimeout);
            item.KeepAlive = AttributeValue<bool?>.FromRead(read.KeepAlive);
            item.LoginMethod = HTTPSessionLoginMethod.FromRead(read.LoginMethod);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Password = AttributeValue<string>.FromRead(read.Password);
            item.ProxyPassword = AttributeValue<string>.FromRead(read.ProxyPassword);
            item.ProxyServer = AttributeValue<string>.FromRead(read.ProxyServer);
            item.ProxyUser = AttributeValue<string>.FromRead(read.ProxyUser);
            item.Timeout = AttributeValue<uint?>.FromRead(read.Timeout);
            item.UserName = AttributeValue<string>.FromRead(read.UserName);
            foreach (var x in read)
            {
                item.Add(HTTPSessionConnection.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSession(this);
        }
    }

    ///<summary>
    /// Specifies a connection. This typically contains a request and a response.
    ///</summary>
public partial class HTTPSessionConnection : EditableElementNode<Read.IHTTPSessionConnection>
    {
        internal HTTPSessionConnection(Read.IHTTPSessionConnection read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Connection node. None of it's properties will be set.
        ///</summary>
public HTTPSessionConnection() : base("Connection")
        {
            OnCreated();
        }

        private HTTPSessionConnectionRequest _request;
        private HTTPSessionConnectionResponse _response;
        private AttributeValue<uint?> _id;
        private AttributeValue<bool?> _ignoreTimeout;
        private AttributeValue<string> _name;
        private AttributeValue<uint?> _timeout;
        ///<summary>
        /// Defines the HTTP request to be sent.
        ///</summary>
public HTTPSessionConnectionRequest Request
        {
            get
            {
                return _request;
            }

            set
            {
                if (_request != value)
                {
                    _request = value;
                    CombinedTagHandler.Assign(value, this, "Request");
                }
            }
        }

        ///<summary>
        /// Defines the response to the HTTP request you defined in ../Connection/Request.
        ///</summary>
public HTTPSessionConnectionResponse Response
        {
            get
            {
                return _response;
            }

            set
            {
                if (_response != value)
                {
                    _response = value;
                    CombinedTagHandler.Assign(value, this, "Response");
                }
            }
        }

        ///<summary>
        /// The unique connection ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// If the HTTP connection should ignore timeout, set this attribute to true.
        /// This works in a similar way as the serial pair ignoreTimeout option.
        /// Default value: false.
        /// Feature introduced in DataMiner 9.0.2 (RN 10543).
        /// 
        ///</summary>
public AttributeValue<bool?> IgnoreTimeout
        {
            get
            {
                return _ignoreTimeout;
            }

            set
            {
                if (_ignoreTimeout != value)
                {
                    _ignoreTimeout = value;
                    AttributeHandler.Assign(value, this, "ignoreTimeout");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the connection.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Specifies that DataMiner must use this timeout value (ms) )instead of the default one (or the one specified in the Session tag) when executing this connection of this session.
        /// Feature introduced in DataMiner 9.0.2 (RN 12542).
        ///</summary>
public AttributeValue<uint?> Timeout
        {
            get
            {
                return _timeout;
            }

            set
            {
                if (_timeout != value)
                {
                    _timeout = value;
                    AttributeHandler.Assign(value, this, "timeout");
                }
            }
        }

        public HTTPSessionConnectionRequest GetOrCreateRequest()
        {
            if (Request == null)
                Request = new HTTPSessionConnectionRequest();
            return Request;
        }

        public HTTPSessionConnectionResponse GetOrCreateResponse()
        {
            if (Response == null)
                Response = new HTTPSessionConnectionResponse();
            return Response;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<bool?> GetOrCreateIgnoreTimeout()
        {
            if (IgnoreTimeout == null)
                IgnoreTimeout = new AttributeValue<bool?>();
            return IgnoreTimeout;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<uint?> GetOrCreateTimeout()
        {
            if (Timeout == null)
                Timeout = new AttributeValue<uint?>();
            return Timeout;
        }

        protected override void Initialize(Read.IHTTPSessionConnection read, XmlElement editNode)
        {
            if (read == null)
                return;
            _request = read.Request != null ? new HTTPSessionConnectionRequest(read.Request, this, editNode.Element["Request"]) : null;
            _response = read.Response != null ? new HTTPSessionConnectionResponse(read.Response, this, editNode.Element["Response"]) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _ignoreTimeout = read.IgnoreTimeout != null ? new AttributeValue<bool?>(read.IgnoreTimeout, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _timeout = read.Timeout != null ? new AttributeValue<uint?>(read.Timeout, this) : null;
        }

        public static HTTPSessionConnection FromRead(Read.IHTTPSessionConnection read)
        {
            if (read == null)
                return null;
            var item = new HTTPSessionConnection();
            item.Request = HTTPSessionConnectionRequest.FromRead(read.Request);
            item.Response = HTTPSessionConnectionResponse.FromRead(read.Response);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.IgnoreTimeout = AttributeValue<bool?>.FromRead(read.IgnoreTimeout);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Timeout = AttributeValue<uint?>.FromRead(read.Timeout);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnection(this);
        }
    }

    ///<summary>
    /// Defines the HTTP request to be sent.
    ///</summary>
public partial class HTTPSessionConnectionRequest : EditableElementNode<Read.IHTTPSessionConnectionRequest>
    {
        internal HTTPSessionConnectionRequest(Read.IHTTPSessionConnectionRequest read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Request node. None of it's properties will be set.
        ///</summary>
public HTTPSessionConnectionRequest() : base("Request")
        {
            OnCreated();
        }

        private HttpRequestHeaders _headers;
        private HttpRequestData _data;
        private HttpRequestParameters _parameters;
        private AttributeValue<uint?> _pid;
        private HTTPSessionConnectionRequestVerb _verb;
        private AttributeValue<string> _url;
        public HttpRequestHeaders Headers
        {
            get
            {
                return _headers;
            }

            set
            {
                if (_headers != value)
                {
                    _headers = value;
                    CombinedTagHandler.Assign(value, this, "Headers");
                }
            }
        }

        public HttpRequestData Data
        {
            get
            {
                return _data;
            }

            set
            {
                if (_data != value)
                {
                    _data = value;
                    CombinedTagHandler.Assign(value, this, "Data");
                }
            }
        }

        public HttpRequestParameters Parameters
        {
            get
            {
                return _parameters;
            }

            set
            {
                if (_parameters != value)
                {
                    _parameters = value;
                    CombinedTagHandler.Assign(value, this, "Parameters");
                }
            }
        }

        ///<summary>
        /// Replaces the url attribute. The parameter value will be used as URL.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        ///<summary>
        /// Specifies the verb to be used in the HTTP request.
        /// If you do not specify this attribute, "GET" will be used by default.
        ///</summary>
public HTTPSessionConnectionRequestVerb Verb
        {
            get
            {
                return _verb;
            }

            set
            {
                if (_verb != value)
                {
                    _verb = value;
                    AttributeHandler.Assign(value, this, "verb");
                }
            }
        }

        ///<summary>
        /// Specifies the URL of the request.
        /// If you do not specify this attribute, the root directory of the server specified in the element wizard will be used.
        ///</summary>
public AttributeValue<string> Url
        {
            get
            {
                return _url;
            }

            set
            {
                if (_url != value)
                {
                    _url = value;
                    AttributeHandler.Assign(value, this, "url");
                }
            }
        }

        public HttpRequestHeaders GetOrCreateHeaders()
        {
            if (Headers == null)
                Headers = new HttpRequestHeaders("Headers");
            return Headers;
        }

        public HttpRequestData GetOrCreateData()
        {
            if (Data == null)
                Data = new HttpRequestData("Data");
            return Data;
        }

        public HttpRequestParameters GetOrCreateParameters()
        {
            if (Parameters == null)
                Parameters = new HttpRequestParameters("Parameters");
            return Parameters;
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        public HTTPSessionConnectionRequestVerb GetOrCreateVerb()
        {
            if (Verb == null)
                Verb = new HTTPSessionConnectionRequestVerb();
            return Verb;
        }

        public AttributeValue<string> GetOrCreateUrl()
        {
            if (Url == null)
                Url = new AttributeValue<string>();
            return Url;
        }

        protected override void Initialize(Read.IHTTPSessionConnectionRequest read, XmlElement editNode)
        {
            if (read == null)
                return;
            _headers = read.Headers != null ? new HttpRequestHeaders(read.Headers, this, editNode.Element["Headers"]) : null;
            _data = read.Data != null ? new HttpRequestData(read.Data, this, editNode.Element["Data"]) : null;
            _parameters = read.Parameters != null ? new HttpRequestParameters(read.Parameters, this, editNode.Element["Parameters"]) : null;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
            _verb = read.Verb != null ? new HTTPSessionConnectionRequestVerb(read.Verb, this) : null;
            _url = read.Url != null ? new AttributeValue<string>(read.Url, this) : null;
        }

        public static HTTPSessionConnectionRequest FromRead(Read.IHTTPSessionConnectionRequest read)
        {
            if (read == null)
                return null;
            var item = new HTTPSessionConnectionRequest();
            item.Headers = HttpRequestHeaders.FromRead(read.Headers);
            item.Data = HttpRequestData.FromRead(read.Data);
            item.Parameters = HttpRequestParameters.FromRead(read.Parameters);
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            item.Verb = HTTPSessionConnectionRequestVerb.FromRead(read.Verb);
            item.Url = AttributeValue<string>.FromRead(read.Url);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionRequest(this);
        }
    }

    public partial class HTTPSessionConnectionRequestVerb : AttributeValue<Enums.EnumHttpRequestVerb?>
    {
        internal HTTPSessionConnectionRequestVerb(Read.IValueTag<Enums.EnumHttpRequestVerb?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a verb node. None of it's properties will be set.
        ///</summary>
public HTTPSessionConnectionRequestVerb() : base()
        {
            OnCreated();
        }

        public HTTPSessionConnectionRequestVerb(Enums.EnumHttpRequestVerb? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumHttpRequestVerbConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumHttpRequestVerb? ConvertRawValue(string rawValue)
        {
            return Enums.EnumHttpRequestVerbConverter.Convert(rawValue?.Trim());
        }

        public new static HTTPSessionConnectionRequestVerb FromRead(Read.IValueTag<Enums.EnumHttpRequestVerb?> read)
        {
            if (read == null)
                return null;
            var item = new HTTPSessionConnectionRequestVerb();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines the response to the HTTP request you defined in ../Connection/Request.
    ///</summary>
public partial class HTTPSessionConnectionResponse : EditableElementNode<Read.IHTTPSessionConnectionResponse>
    {
        internal HTTPSessionConnectionResponse(Read.IHTTPSessionConnectionResponse read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Response node. None of it's properties will be set.
        ///</summary>
public HTTPSessionConnectionResponse() : base("Response")
        {
            OnCreated();
        }

        private HTTPSessionConnectionResponseHeaders _headers;
        private HTTPSessionConnectionResponseContent _content;
        private AttributeValue<uint?> _statusCode;
        ///<summary>
        /// Specifies the response headers of which you want to store the contents in a parameter.
        ///</summary>
public HTTPSessionConnectionResponseHeaders Headers
        {
            get
            {
                return _headers;
            }

            set
            {
                if (_headers != value)
                {
                    _headers = value;
                    CombinedTagHandler.Assign(value, this, "Headers");
                }
            }
        }

        ///<summary>
        /// The pid attribute of this element specifies the ID of the parameter in which you want the contents of the response to be stored.
        ///</summary>
public HTTPSessionConnectionResponseContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter in which the HTTP status-line has to be stored ("e.g. HTTP/1.1 200 OK".
        ///</summary>
public AttributeValue<uint?> StatusCode
        {
            get
            {
                return _statusCode;
            }

            set
            {
                if (_statusCode != value)
                {
                    _statusCode = value;
                    AttributeHandler.Assign(value, this, "statusCode");
                }
            }
        }

        public HTTPSessionConnectionResponseHeaders GetOrCreateHeaders()
        {
            if (Headers == null)
                Headers = new HTTPSessionConnectionResponseHeaders();
            return Headers;
        }

        public HTTPSessionConnectionResponseContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new HTTPSessionConnectionResponseContent();
            return Content;
        }

        public AttributeValue<uint?> GetOrCreateStatusCode()
        {
            if (StatusCode == null)
                StatusCode = new AttributeValue<uint?>();
            return StatusCode;
        }

        protected override void Initialize(Read.IHTTPSessionConnectionResponse read, XmlElement editNode)
        {
            if (read == null)
                return;
            _headers = read.Headers != null ? new HTTPSessionConnectionResponseHeaders(read.Headers, this, editNode.Element["Headers"]) : null;
            _content = read.Content != null ? new HTTPSessionConnectionResponseContent(read.Content, this, editNode.Element["Content"]) : null;
            _statusCode = read.StatusCode != null ? new AttributeValue<uint?>(read.StatusCode, this) : null;
        }

        public static HTTPSessionConnectionResponse FromRead(Read.IHTTPSessionConnectionResponse read)
        {
            if (read == null)
                return null;
            var item = new HTTPSessionConnectionResponse();
            item.Headers = HTTPSessionConnectionResponseHeaders.FromRead(read.Headers);
            item.Content = HTTPSessionConnectionResponseContent.FromRead(read.Content);
            item.StatusCode = AttributeValue<uint?>.FromRead(read.StatusCode);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionResponse(this);
        }
    }

    ///<summary>
    /// Specifies the response headers of which you want to store the contents in a parameter.
    ///</summary>
public partial class HTTPSessionConnectionResponseHeaders : EditableListNode<Read.IHTTPSessionConnectionResponseHeaders, Read.IHTTPSessionConnectionResponseHeadersHeader, HTTPSessionConnectionResponseHeadersHeader>
    {
        internal HTTPSessionConnectionResponseHeaders(Read.IHTTPSessionConnectionResponseHeaders read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Headers node. None of it's properties will be set.
        ///</summary>
public HTTPSessionConnectionResponseHeaders() : base("Headers")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IHTTPSessionConnectionResponseHeaders read, XmlElement editNode)
        {
        }

        public static HTTPSessionConnectionResponseHeaders FromRead(Read.IHTTPSessionConnectionResponseHeaders read)
        {
            if (read == null)
                return null;
            var item = new HTTPSessionConnectionResponseHeaders();
            foreach (var x in read)
            {
                item.Add(HTTPSessionConnectionResponseHeadersHeader.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionResponseHeaders(this);
        }
    }

    ///<summary>
    /// Specifies that the contents of a particular response header has to be stored in a parameter.&lt;BR /&gt;
    /// In this context, this has to be done by means of a key/value pair.
    ///</summary>
public partial class HTTPSessionConnectionResponseHeadersHeader : EditableElementNode<Read.IHTTPSessionConnectionResponseHeadersHeader>
    {
        internal HTTPSessionConnectionResponseHeadersHeader(Read.IHTTPSessionConnectionResponseHeadersHeader read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Header node. None of it's properties will be set.
        ///</summary>
public HTTPSessionConnectionResponseHeadersHeader() : base("Header")
        {
            OnCreated();
        }

        private AttributeValue<string> _key;
        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the name of the header of which you want the contents to be stored in the parameter having the ID defined in the pid attribute.
        ///</summary>
public AttributeValue<string> Key
        {
            get
            {
                return _key;
            }

            set
            {
                if (_key != value)
                {
                    _key = value;
                    AttributeHandler.Assign(value, this, "key");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter in which you want to store the contents of the header defined in the key attribute.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<string> GetOrCreateKey()
        {
            if (Key == null)
                Key = new AttributeValue<string>();
            return Key;
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IHTTPSessionConnectionResponseHeadersHeader read, XmlElement editNode)
        {
            if (read == null)
                return;
            _key = read.Key != null ? new AttributeValue<string>(read.Key, this) : null;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static HTTPSessionConnectionResponseHeadersHeader FromRead(Read.IHTTPSessionConnectionResponseHeadersHeader read)
        {
            if (read == null)
                return null;
            var item = new HTTPSessionConnectionResponseHeadersHeader();
            item.Key = AttributeValue<string>.FromRead(read.Key);
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionResponseHeadersHeader(this);
        }
    }

    ///<summary>
    /// The pid attribute of this element specifies the ID of the parameter in which you want the contents of the response to be stored.
    ///</summary>
public partial class HTTPSessionConnectionResponseContent : EditableElementNode<Read.IHTTPSessionConnectionResponseContent>
    {
        internal HTTPSessionConnectionResponseContent(Read.IHTTPSessionConnectionResponseContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public HTTPSessionConnectionResponseContent() : base("Content")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter in which you want the contents of the response to be stored.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IHTTPSessionConnectionResponseContent read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static HTTPSessionConnectionResponseContent FromRead(Read.IHTTPSessionConnectionResponseContent read)
        {
            if (read == null)
                return null;
            var item = new HTTPSessionConnectionResponseContent();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHTTPSessionConnectionResponseContent(this);
        }
    }

    public partial class HTTPSessionLoginMethod : AttributeValue<Enums.EnumHttpLoginMethod?>
    {
        internal HTTPSessionLoginMethod(Read.IValueTag<Enums.EnumHttpLoginMethod?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a loginMethod node. None of it's properties will be set.
        ///</summary>
public HTTPSessionLoginMethod() : base()
        {
            OnCreated();
        }

        public HTTPSessionLoginMethod(Enums.EnumHttpLoginMethod? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumHttpLoginMethodConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumHttpLoginMethod? ConvertRawValue(string rawValue)
        {
            return Enums.EnumHttpLoginMethodConverter.Convert(rawValue?.Trim());
        }

        public new static HTTPSessionLoginMethod FromRead(Read.IValueTag<Enums.EnumHttpLoginMethod?> read)
        {
            if (read == null)
                return null;
            var item = new HTTPSessionLoginMethod();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Configures internal licensing.
    ///</summary>
public partial class InternalLicenses : EditableListNode<Read.IInternalLicenses, Read.IInternalLicensesInternalLicense, InternalLicensesInternalLicense>
    {
        internal InternalLicenses(Read.IInternalLicenses read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a InternalLicenses node. None of it's properties will be set.
        ///</summary>
public InternalLicenses() : base("InternalLicenses")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IInternalLicenses read, XmlElement editNode)
        {
        }

        public static InternalLicenses FromRead(Read.IInternalLicenses read)
        {
            if (read == null)
                return null;
            var item = new InternalLicenses();
            foreach (var x in read)
            {
                item.Add(InternalLicensesInternalLicense.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitInternalLicenses(this);
        }
    }

    ///<summary>
    /// Configures internal licensing of the specified type.
    ///</summary>
public partial class InternalLicensesInternalLicense : EditableElementNode<Read.IInternalLicensesInternalLicense>
    {
        internal InternalLicensesInternalLicense(Read.IInternalLicensesInternalLicense read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a InternalLicense node. None of it's properties will be set.
        ///</summary>
public InternalLicensesInternalLicense() : base("InternalLicense")
        {
            OnCreated();
        }

        private AttributeValue<string> _type;
        public AttributeValue<string> Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public AttributeValue<string> GetOrCreateType()
        {
            if (Type == null)
                Type = new AttributeValue<string>();
            return Type;
        }

        protected override void Initialize(Read.IInternalLicensesInternalLicense read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new AttributeValue<string>(read.Type, this) : null;
        }

        public static InternalLicensesInternalLicense FromRead(Read.IInternalLicensesInternalLicense read)
        {
            if (read == null)
                return null;
            var item = new InternalLicensesInternalLicense();
            item.Type = AttributeValue<string>.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitInternalLicensesInternalLicense(this);
        }
    }

    ///<summary>
    /// Groups NoTimeout elements.
    ///</summary>
public partial class NoTimeouts : EditableListNode<Read.INoTimeouts, Read.INoTimeoutsNoTimeout, NoTimeoutsNoTimeout>
    {
        internal NoTimeouts(Read.INoTimeouts read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a NoTimeouts node. None of it's properties will be set.
        ///</summary>
public NoTimeouts() : base("NoTimeouts")
        {
            OnCreated();
        }

        protected override void Initialize(Read.INoTimeouts read, XmlElement editNode)
        {
        }

        public static NoTimeouts FromRead(Read.INoTimeouts read)
        {
            if (read == null)
                return null;
            var item = new NoTimeouts();
            foreach (var x in read)
            {
                item.Add(NoTimeoutsNoTimeout.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitNoTimeouts(this);
        }
    }

    ///<summary>
    /// Indicates that the specified error (response value) should not cause a timeout.
    ///</summary>
public partial class NoTimeoutsNoTimeout : EditableElementValueNode<Read.INoTimeoutsNoTimeout, string>
    {
        internal NoTimeoutsNoTimeout(Read.INoTimeoutsNoTimeout read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a NoTimeout node. None of it's properties will be set.
        ///</summary>
public NoTimeoutsNoTimeout(bool useCDATA = false) : base("NoTimeout", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public NoTimeoutsNoTimeout(string value, bool useCDATA = false) : base("NoTimeout", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.INoTimeoutsNoTimeout read, XmlElement editNode)
        {
        }

        public static NoTimeoutsNoTimeout FromRead(Read.INoTimeoutsNoTimeout read)
        {
            if (read == null)
                return null;
            var item = new NoTimeoutsNoTimeout();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitNoTimeoutsNoTimeout(this);
        }
    }

    ///<summary>
    /// Defines options for the protocol.
    ///</summary>
public partial class Options : EditableElementNode<Read.IOptions>
    {
        internal Options(Read.IOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Options node. None of it's properties will be set.
        ///</summary>
public Options() : base("Options")
        {
            OnCreated();
        }

        private OptionsDataBaseOptions _dataBaseOptions;
        private ElementValue<bool?> _disableViewRefresh;
        private OptionsEncoding _encoding;
        private ElementValue<bool?> _forceDefaultAlarming;
        private OptionsGenerateMIB _generateMIB;
        private Icon _icon;
        private OptionsNoTimeouts _noTimeouts;
        private ElementValue<string> _overrideTimeoutDVE;
        private ElementValue<bool?> _postPonePortInitialisation;
        private ElementValue<bool?> _useAgentBinding;
        public OptionsDataBaseOptions DataBaseOptions
        {
            get
            {
                return _dataBaseOptions;
            }

            set
            {
                if (_dataBaseOptions != value)
                {
                    _dataBaseOptions = value;
                    CombinedTagHandler.Assign(value, this, "DataBaseOptions");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<bool?> DisableViewRefresh
        {
            get
            {
                return _disableViewRefresh;
            }

            set
            {
                if (_disableViewRefresh != value)
                {
                    _disableViewRefresh = value;
                    ElementHandler.Assign(value, this, "DisableViewRefresh");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public OptionsEncoding Encoding
        {
            get
            {
                return _encoding;
            }

            set
            {
                if (_encoding != value)
                {
                    _encoding = value;
                    ElementHandler.Assign(value, this, "Encoding");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<bool?> ForceDefaultAlarming
        {
            get
            {
                return _forceDefaultAlarming;
            }

            set
            {
                if (_forceDefaultAlarming != value)
                {
                    _forceDefaultAlarming = value;
                    ElementHandler.Assign(value, this, "ForceDefaultAlarming");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public OptionsGenerateMIB GenerateMIB
        {
            get
            {
                return _generateMIB;
            }

            set
            {
                if (_generateMIB != value)
                {
                    _generateMIB = value;
                    CombinedTagHandler.Assign(value, this, "GenerateMIB");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public Icon Icon
        {
            get
            {
                return _icon;
            }

            set
            {
                if (_icon != value)
                {
                    _icon = value;
                    CombinedTagHandler.Assign(value, this, "Icon");
                }
            }
        }

        ///<summary>
        /// Groups NoTimeout elements of the protocol. Feature introduced in DataMiner 8.5.3 (RN 8775).
        ///</summary>
public OptionsNoTimeouts NoTimeouts
        {
            get
            {
                return _noTimeouts;
            }

            set
            {
                if (_noTimeouts != value)
                {
                    _noTimeouts = value;
                    CombinedTagHandler.Assign(value, this, "NoTimeouts");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<string> OverrideTimeoutDVE
        {
            get
            {
                return _overrideTimeoutDVE;
            }

            set
            {
                if (_overrideTimeoutDVE != value)
                {
                    _overrideTimeoutDVE = value;
                    ElementHandler.Assign(value, this, "OverrideTimeoutDVE");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<bool?> PostPonePortInitialisation
        {
            get
            {
                return _postPonePortInitialisation;
            }

            set
            {
                if (_postPonePortInitialisation != value)
                {
                    _postPonePortInitialisation = value;
                    ElementHandler.Assign(value, this, "PostPonePortInitialisation");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<bool?> UseAgentBinding
        {
            get
            {
                return _useAgentBinding;
            }

            set
            {
                if (_useAgentBinding != value)
                {
                    _useAgentBinding = value;
                    ElementHandler.Assign(value, this, "UseAgentBinding");
                }
            }
        }

        public OptionsDataBaseOptions GetOrCreateDataBaseOptions()
        {
            if (DataBaseOptions == null)
                DataBaseOptions = new OptionsDataBaseOptions();
            return DataBaseOptions;
        }

        public ElementValue<bool?> GetOrCreateDisableViewRefresh()
        {
            if (DisableViewRefresh == null)
                DisableViewRefresh = new ElementValue<bool?>();
            return DisableViewRefresh;
        }

        public OptionsEncoding GetOrCreateEncoding()
        {
            if (Encoding == null)
                Encoding = new OptionsEncoding();
            return Encoding;
        }

        public ElementValue<bool?> GetOrCreateForceDefaultAlarming()
        {
            if (ForceDefaultAlarming == null)
                ForceDefaultAlarming = new ElementValue<bool?>();
            return ForceDefaultAlarming;
        }

        public OptionsGenerateMIB GetOrCreateGenerateMIB()
        {
            if (GenerateMIB == null)
                GenerateMIB = new OptionsGenerateMIB();
            return GenerateMIB;
        }

        public Icon GetOrCreateIcon()
        {
            if (Icon == null)
                Icon = new Icon("Icon");
            return Icon;
        }

        public OptionsNoTimeouts GetOrCreateNoTimeouts()
        {
            if (NoTimeouts == null)
                NoTimeouts = new OptionsNoTimeouts();
            return NoTimeouts;
        }

        public ElementValue<string> GetOrCreateOverrideTimeoutDVE()
        {
            if (OverrideTimeoutDVE == null)
                OverrideTimeoutDVE = new ElementValue<string>();
            return OverrideTimeoutDVE;
        }

        public ElementValue<bool?> GetOrCreatePostPonePortInitialisation()
        {
            if (PostPonePortInitialisation == null)
                PostPonePortInitialisation = new ElementValue<bool?>();
            return PostPonePortInitialisation;
        }

        public ElementValue<bool?> GetOrCreateUseAgentBinding()
        {
            if (UseAgentBinding == null)
                UseAgentBinding = new ElementValue<bool?>();
            return UseAgentBinding;
        }

        protected override void Initialize(Read.IOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dataBaseOptions = read.DataBaseOptions != null ? new OptionsDataBaseOptions(read.DataBaseOptions, this, editNode.Element["DataBaseOptions"]) : null;
            _disableViewRefresh = read.DisableViewRefresh != null ? new ElementValue<bool?>(read.DisableViewRefresh, this) : null;
            _encoding = read.Encoding != null ? new OptionsEncoding(read.Encoding, this) : null;
            _forceDefaultAlarming = read.ForceDefaultAlarming != null ? new ElementValue<bool?>(read.ForceDefaultAlarming, this) : null;
            _generateMIB = read.GenerateMIB != null ? new OptionsGenerateMIB(read.GenerateMIB, this, editNode.Element["GenerateMIB"]) : null;
            _icon = read.Icon != null ? new Icon(read.Icon, this, editNode.Element["Icon"]) : null;
            _noTimeouts = read.NoTimeouts != null ? new OptionsNoTimeouts(read.NoTimeouts, this, editNode.Element["NoTimeouts"]) : null;
            _overrideTimeoutDVE = read.OverrideTimeoutDVE != null ? new ElementValue<string>(read.OverrideTimeoutDVE, this) : null;
            _postPonePortInitialisation = read.PostPonePortInitialisation != null ? new ElementValue<bool?>(read.PostPonePortInitialisation, this) : null;
            _useAgentBinding = read.UseAgentBinding != null ? new ElementValue<bool?>(read.UseAgentBinding, this) : null;
        }

        public static Options FromRead(Read.IOptions read)
        {
            if (read == null)
                return null;
            var item = new Options();
            item.DataBaseOptions = OptionsDataBaseOptions.FromRead(read.DataBaseOptions);
            item.DisableViewRefresh = ElementValue<bool?>.FromRead(read.DisableViewRefresh);
            item.Encoding = OptionsEncoding.FromRead(read.Encoding);
            item.ForceDefaultAlarming = ElementValue<bool?>.FromRead(read.ForceDefaultAlarming);
            item.GenerateMIB = OptionsGenerateMIB.FromRead(read.GenerateMIB);
            item.Icon = Icon.FromRead(read.Icon);
            item.NoTimeouts = OptionsNoTimeouts.FromRead(read.NoTimeouts);
            item.OverrideTimeoutDVE = ElementValue<string>.FromRead(read.OverrideTimeoutDVE);
            item.PostPonePortInitialisation = ElementValue<bool?>.FromRead(read.PostPonePortInitialisation);
            item.UseAgentBinding = ElementValue<bool?>.FromRead(read.UseAgentBinding);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptions(this);
        }
    }

    public partial class OptionsDataBaseOptions : EditableElementNode<Read.IOptionsDataBaseOptions>
    {
        internal OptionsDataBaseOptions(Read.IOptionsDataBaseOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DataBaseOptions node. None of it's properties will be set.
        ///</summary>
public OptionsDataBaseOptions() : base("DataBaseOptions")
        {
            OnCreated();
        }

        private ElementValue<bool?> _customDataIDs;
        private ElementValue<bool?> _partitionedTrending;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<bool?> CustomDataIDs
        {
            get
            {
                return _customDataIDs;
            }

            set
            {
                if (_customDataIDs != value)
                {
                    _customDataIDs = value;
                    ElementHandler.Assign(value, this, "CustomDataIDs");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<bool?> PartitionedTrending
        {
            get
            {
                return _partitionedTrending;
            }

            set
            {
                if (_partitionedTrending != value)
                {
                    _partitionedTrending = value;
                    ElementHandler.Assign(value, this, "PartitionedTrending");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateCustomDataIDs()
        {
            if (CustomDataIDs == null)
                CustomDataIDs = new ElementValue<bool?>();
            return CustomDataIDs;
        }

        public ElementValue<bool?> GetOrCreatePartitionedTrending()
        {
            if (PartitionedTrending == null)
                PartitionedTrending = new ElementValue<bool?>();
            return PartitionedTrending;
        }

        protected override void Initialize(Read.IOptionsDataBaseOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _customDataIDs = read.CustomDataIDs != null ? new ElementValue<bool?>(read.CustomDataIDs, this) : null;
            _partitionedTrending = read.PartitionedTrending != null ? new ElementValue<bool?>(read.PartitionedTrending, this) : null;
        }

        public static OptionsDataBaseOptions FromRead(Read.IOptionsDataBaseOptions read)
        {
            if (read == null)
                return null;
            var item = new OptionsDataBaseOptions();
            item.CustomDataIDs = ElementValue<bool?>.FromRead(read.CustomDataIDs);
            item.PartitionedTrending = ElementValue<bool?>.FromRead(read.PartitionedTrending);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptionsDataBaseOptions(this);
        }
    }

    public partial class OptionsEncoding : ElementValue<Enums.EnumEncoding?>
    {
        internal OptionsEncoding(Read.IValueTag<Enums.EnumEncoding?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Encoding node. None of it's properties will be set.
        ///</summary>
public OptionsEncoding() : base()
        {
            OnCreated();
        }

        public OptionsEncoding(Enums.EnumEncoding? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumEncodingConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumEncoding? ConvertRawValue(string rawValue)
        {
            return Enums.EnumEncodingConverter.Convert(rawValue?.Trim());
        }

        public new static OptionsEncoding FromRead(Read.IValueTag<Enums.EnumEncoding?> read)
        {
            if (read == null)
                return null;
            var item = new OptionsEncoding();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class OptionsGenerateMIB : EditableElementValueNode<Read.IOptionsGenerateMIB, Enums.EnumSNMP?>
    {
        internal OptionsGenerateMIB(Read.IOptionsGenerateMIB read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a GenerateMIB node. None of it's properties will be set.
        ///</summary>
public OptionsGenerateMIB() : base("GenerateMIB")
        {
            OnCreated();
        }

        public OptionsGenerateMIB(Enums.EnumSNMP? value) : base("GenerateMIB", value)
        {
        }

        private AttributeValue<bool?> _includePages;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<bool?> IncludePages
        {
            get
            {
                return _includePages;
            }

            set
            {
                if (_includePages != value)
                {
                    _includePages = value;
                    AttributeHandler.Assign(value, this, "includePages");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateIncludePages()
        {
            if (IncludePages == null)
                IncludePages = new AttributeValue<bool?>();
            return IncludePages;
        }

        protected override void Initialize(Read.IOptionsGenerateMIB read, XmlElement editNode)
        {
            if (read == null)
                return;
            _includePages = read.IncludePages != null ? new AttributeValue<bool?>(read.IncludePages, this) : null;
        }

        public static OptionsGenerateMIB FromRead(Read.IOptionsGenerateMIB read)
        {
            if (read == null)
                return null;
            var item = new OptionsGenerateMIB();
            item.Value = read.Value;
            item.IncludePages = AttributeValue<bool?>.FromRead(read.IncludePages);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptionsGenerateMIB(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumSNMPConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumSNMP? ConvertRawValue(string rawValue)
        {
            return Enums.EnumSNMPConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Groups NoTimeout elements of the protocol. Feature introduced in DataMiner 8.5.3 (RN 8775).
    ///</summary>
public partial class OptionsNoTimeouts : EditableListNode<Read.IOptionsNoTimeouts, Read.IOptionsNoTimeoutsNoTimeout, OptionsNoTimeoutsNoTimeout>
    {
        internal OptionsNoTimeouts(Read.IOptionsNoTimeouts read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a NoTimeouts node. None of it's properties will be set.
        ///</summary>
public OptionsNoTimeouts() : base("NoTimeouts")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IOptionsNoTimeouts read, XmlElement editNode)
        {
        }

        public static OptionsNoTimeouts FromRead(Read.IOptionsNoTimeouts read)
        {
            if (read == null)
                return null;
            var item = new OptionsNoTimeouts();
            foreach (var x in read)
            {
                item.Add(OptionsNoTimeoutsNoTimeout.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptionsNoTimeouts(this);
        }
    }

    ///<summary>
    /// Suppresses a timeout in case the specified error (response value) occurs.
    ///</summary>
public partial class OptionsNoTimeoutsNoTimeout : EditableElementValueNode<Read.IOptionsNoTimeoutsNoTimeout, string>
    {
        internal OptionsNoTimeoutsNoTimeout(Read.IOptionsNoTimeoutsNoTimeout read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a NoTimeout node. None of it's properties will be set.
        ///</summary>
public OptionsNoTimeoutsNoTimeout(bool useCDATA = false) : base("NoTimeout", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public OptionsNoTimeoutsNoTimeout(string value, bool useCDATA = false) : base("NoTimeout", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IOptionsNoTimeoutsNoTimeout read, XmlElement editNode)
        {
        }

        public static OptionsNoTimeoutsNoTimeout FromRead(Read.IOptionsNoTimeoutsNoTimeout read)
        {
            if (read == null)
                return null;
            var item = new OptionsNoTimeoutsNoTimeout();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOptionsNoTimeoutsNoTimeout(this);
        }
    }

    ///<summary>
    /// Specifies the level of access users will have to elements, views, services and redundancy groups created by elements based on this protocol.
    /// Feature introduced in DataMiner 9.0.3 (RN 13010).
    ///</summary>
public partial class Ownership : EditableElementNode<Read.IOwnership>
    {
        internal Ownership(Read.IOwnership read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Ownership node. None of it's properties will be set.
        ///</summary>
public Ownership() : base("Ownership")
        {
            OnCreated();
        }

        private OwnershipElements _elements;
        private OwnershipViews _views;
        private OwnershipServices _services;
        private OwnershipRedundancyGroups _redundancyGroups;
        ///<summary>
        /// Groups ownership declarations of DataMiner elements.
        ///</summary>
public OwnershipElements Elements
        {
            get
            {
                return _elements;
            }

            set
            {
                if (_elements != value)
                {
                    _elements = value;
                    CombinedTagHandler.Assign(value, this, "Elements");
                }
            }
        }

        ///<summary>
        /// Groups ownership declarations of view properties.
        ///</summary>
public OwnershipViews Views
        {
            get
            {
                return _views;
            }

            set
            {
                if (_views != value)
                {
                    _views = value;
                    CombinedTagHandler.Assign(value, this, "Views");
                }
            }
        }

        ///<summary>
        /// Groups service ownership declarations.
        ///</summary>
public OwnershipServices Services
        {
            get
            {
                return _services;
            }

            set
            {
                if (_services != value)
                {
                    _services = value;
                    CombinedTagHandler.Assign(value, this, "Services");
                }
            }
        }

        ///<summary>
        /// Groups redundancy group ownership declarations.
        ///</summary>
public OwnershipRedundancyGroups RedundancyGroups
        {
            get
            {
                return _redundancyGroups;
            }

            set
            {
                if (_redundancyGroups != value)
                {
                    _redundancyGroups = value;
                    CombinedTagHandler.Assign(value, this, "RedundancyGroups");
                }
            }
        }

        public OwnershipElements GetOrCreateElements()
        {
            if (Elements == null)
                Elements = new OwnershipElements();
            return Elements;
        }

        public OwnershipViews GetOrCreateViews()
        {
            if (Views == null)
                Views = new OwnershipViews();
            return Views;
        }

        public OwnershipServices GetOrCreateServices()
        {
            if (Services == null)
                Services = new OwnershipServices();
            return Services;
        }

        public OwnershipRedundancyGroups GetOrCreateRedundancyGroups()
        {
            if (RedundancyGroups == null)
                RedundancyGroups = new OwnershipRedundancyGroups();
            return RedundancyGroups;
        }

        protected override void Initialize(Read.IOwnership read, XmlElement editNode)
        {
            if (read == null)
                return;
            _elements = read.Elements != null ? new OwnershipElements(read.Elements, this, editNode.Element["Elements"]) : null;
            _views = read.Views != null ? new OwnershipViews(read.Views, this, editNode.Element["Views"]) : null;
            _services = read.Services != null ? new OwnershipServices(read.Services, this, editNode.Element["Services"]) : null;
            _redundancyGroups = read.RedundancyGroups != null ? new OwnershipRedundancyGroups(read.RedundancyGroups, this, editNode.Element["RedundancyGroups"]) : null;
        }

        public static Ownership FromRead(Read.IOwnership read)
        {
            if (read == null)
                return null;
            var item = new Ownership();
            item.Elements = OwnershipElements.FromRead(read.Elements);
            item.Views = OwnershipViews.FromRead(read.Views);
            item.Services = OwnershipServices.FromRead(read.Services);
            item.RedundancyGroups = OwnershipRedundancyGroups.FromRead(read.RedundancyGroups);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnership(this);
        }
    }

    ///<summary>
    /// Groups ownership declarations of DataMiner elements.
    ///</summary>
public partial class OwnershipElements : EditableListNode<Read.IOwnershipElements, Read.IOwnershipElementsElement, OwnershipElementsElement>
    {
        internal OwnershipElements(Read.IOwnershipElements read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Elements node. None of it's properties will be set.
        ///</summary>
public OwnershipElements() : base("Elements")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IOwnershipElements read, XmlElement editNode)
        {
        }

        public static OwnershipElements FromRead(Read.IOwnershipElements read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElements();
            foreach (var x in read)
            {
                item.Add(OwnershipElementsElement.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElements(this);
        }
    }

    ///<summary>
    /// Declares ownership of specific DataMiner elements.
    ///</summary>
public partial class OwnershipElementsElement : EditableElementNode<Read.IOwnershipElementsElement>
    {
        internal OwnershipElementsElement(Read.IOwnershipElementsElement read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Element node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElement() : base("Element")
        {
            OnCreated();
        }

        private ElementValue<string> _protocol;
        private OwnershipElementsElementDescription _description;
        private OwnershipElementsElementProperties _properties;
        private OwnershipElementsElementAlarmTemplate _alarmTemplate;
        private OwnershipElementsElementTrendTemplate _trendTemplate;
        ///<summary>
        /// Declares ownership of DataMiner elements running the specified protocol. Supported wildcard characters: '*' and '?'.
        ///</summary>
public ElementValue<string> Protocol
        {
            get
            {
                return _protocol;
            }

            set
            {
                if (_protocol != value)
                {
                    _protocol = value;
                    ElementHandler.Assign(value, this, "Protocol");
                }
            }
        }

        ///<summary>
        /// Declares ownership of the element description.
        ///</summary>
public OwnershipElementsElementDescription Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    CombinedTagHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Groups ownership declarations of element properties.
        ///</summary>
public OwnershipElementsElementProperties Properties
        {
            get
            {
                return _properties;
            }

            set
            {
                if (_properties != value)
                {
                    _properties = value;
                    CombinedTagHandler.Assign(value, this, "Properties");
                }
            }
        }

        ///<summary>
        /// Declares ownership of the alarm template.
        ///</summary>
public OwnershipElementsElementAlarmTemplate AlarmTemplate
        {
            get
            {
                return _alarmTemplate;
            }

            set
            {
                if (_alarmTemplate != value)
                {
                    _alarmTemplate = value;
                    CombinedTagHandler.Assign(value, this, "AlarmTemplate");
                }
            }
        }

        ///<summary>
        /// Declares ownership of the trend template.
        ///</summary>
public OwnershipElementsElementTrendTemplate TrendTemplate
        {
            get
            {
                return _trendTemplate;
            }

            set
            {
                if (_trendTemplate != value)
                {
                    _trendTemplate = value;
                    CombinedTagHandler.Assign(value, this, "TrendTemplate");
                }
            }
        }

        public ElementValue<string> GetOrCreateProtocol()
        {
            if (Protocol == null)
                Protocol = new ElementValue<string>();
            return Protocol;
        }

        public OwnershipElementsElementDescription GetOrCreateDescription()
        {
            if (Description == null)
                Description = new OwnershipElementsElementDescription();
            return Description;
        }

        public OwnershipElementsElementProperties GetOrCreateProperties()
        {
            if (Properties == null)
                Properties = new OwnershipElementsElementProperties();
            return Properties;
        }

        public OwnershipElementsElementAlarmTemplate GetOrCreateAlarmTemplate()
        {
            if (AlarmTemplate == null)
                AlarmTemplate = new OwnershipElementsElementAlarmTemplate();
            return AlarmTemplate;
        }

        public OwnershipElementsElementTrendTemplate GetOrCreateTrendTemplate()
        {
            if (TrendTemplate == null)
                TrendTemplate = new OwnershipElementsElementTrendTemplate();
            return TrendTemplate;
        }

        protected override void Initialize(Read.IOwnershipElementsElement read, XmlElement editNode)
        {
            if (read == null)
                return;
            _protocol = read.Protocol != null ? new ElementValue<string>(read.Protocol, this) : null;
            _description = read.Description != null ? new OwnershipElementsElementDescription(read.Description, this, editNode.Element["Description"]) : null;
            _properties = read.Properties != null ? new OwnershipElementsElementProperties(read.Properties, this, editNode.Element["Properties"]) : null;
            _alarmTemplate = read.AlarmTemplate != null ? new OwnershipElementsElementAlarmTemplate(read.AlarmTemplate, this, editNode.Element["AlarmTemplate"]) : null;
            _trendTemplate = read.TrendTemplate != null ? new OwnershipElementsElementTrendTemplate(read.TrendTemplate, this, editNode.Element["TrendTemplate"]) : null;
        }

        public static OwnershipElementsElement FromRead(Read.IOwnershipElementsElement read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElement();
            item.Protocol = ElementValue<string>.FromRead(read.Protocol);
            item.Description = OwnershipElementsElementDescription.FromRead(read.Description);
            item.Properties = OwnershipElementsElementProperties.FromRead(read.Properties);
            item.AlarmTemplate = OwnershipElementsElementAlarmTemplate.FromRead(read.AlarmTemplate);
            item.TrendTemplate = OwnershipElementsElementTrendTemplate.FromRead(read.TrendTemplate);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElement(this);
        }
    }

    ///<summary>
    /// Declares ownership of the element description.
    ///</summary>
public partial class OwnershipElementsElementDescription : EditableElementNode<Read.IOwnershipElementsElementDescription>
    {
        internal OwnershipElementsElementDescription(Read.IOwnershipElementsElementDescription read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Description node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementDescription() : base("Description")
        {
            OnCreated();
        }

        private OwnershipElementsElementDescriptionAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipElementsElementDescriptionAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public OwnershipElementsElementDescriptionAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipElementsElementDescriptionAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipElementsElementDescription read, XmlElement editNode)
        {
            if (read == null)
                return;
            _accessType = read.AccessType != null ? new OwnershipElementsElementDescriptionAccessType(read.AccessType, this) : null;
        }

        public static OwnershipElementsElementDescription FromRead(Read.IOwnershipElementsElementDescription read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementDescription();
            item.AccessType = OwnershipElementsElementDescriptionAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementDescription(this);
        }
    }

    public partial class OwnershipElementsElementDescriptionAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipElementsElementDescriptionAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementDescriptionAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipElementsElementDescriptionAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipElementsElementDescriptionAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementDescriptionAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Groups ownership declarations of element properties.
    ///</summary>
public partial class OwnershipElementsElementProperties : EditableListNode<Read.IOwnershipElementsElementProperties, Read.IOwnershipElementsElementPropertiesProperty, OwnershipElementsElementPropertiesProperty>
    {
        internal OwnershipElementsElementProperties(Read.IOwnershipElementsElementProperties read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Properties node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementProperties() : base("Properties")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IOwnershipElementsElementProperties read, XmlElement editNode)
        {
        }

        public static OwnershipElementsElementProperties FromRead(Read.IOwnershipElementsElementProperties read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementProperties();
            foreach (var x in read)
            {
                item.Add(OwnershipElementsElementPropertiesProperty.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementProperties(this);
        }
    }

    ///<summary>
    /// Declares ownership of the specified element property.
    ///</summary>
public partial class OwnershipElementsElementPropertiesProperty : EditableElementNode<Read.IOwnershipElementsElementPropertiesProperty>
    {
        internal OwnershipElementsElementPropertiesProperty(Read.IOwnershipElementsElementPropertiesProperty read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Property node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementPropertiesProperty() : base("Property")
        {
            OnCreated();
        }

        private ElementValue<string> _name;
        private OwnershipElementsElementPropertiesPropertyAccessType _accessType;
        ///<summary>
        /// Specifies the name of the element property. Supported wildcard characters: '*' and '?'.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipElementsElementPropertiesPropertyAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public OwnershipElementsElementPropertiesPropertyAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipElementsElementPropertiesPropertyAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipElementsElementPropertiesProperty read, XmlElement editNode)
        {
            if (read == null)
                return;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _accessType = read.AccessType != null ? new OwnershipElementsElementPropertiesPropertyAccessType(read.AccessType, this) : null;
        }

        public static OwnershipElementsElementPropertiesProperty FromRead(Read.IOwnershipElementsElementPropertiesProperty read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementPropertiesProperty();
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.AccessType = OwnershipElementsElementPropertiesPropertyAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementPropertiesProperty(this);
        }
    }

    public partial class OwnershipElementsElementPropertiesPropertyAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipElementsElementPropertiesPropertyAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementPropertiesPropertyAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipElementsElementPropertiesPropertyAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipElementsElementPropertiesPropertyAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementPropertiesPropertyAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Declares ownership of the alarm template.
    ///</summary>
public partial class OwnershipElementsElementAlarmTemplate : EditableElementNode<Read.IOwnershipElementsElementAlarmTemplate>
    {
        internal OwnershipElementsElementAlarmTemplate(Read.IOwnershipElementsElementAlarmTemplate read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AlarmTemplate node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementAlarmTemplate() : base("AlarmTemplate")
        {
            OnCreated();
        }

        private OwnershipElementsElementAlarmTemplateAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipElementsElementAlarmTemplateAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public OwnershipElementsElementAlarmTemplateAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipElementsElementAlarmTemplateAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipElementsElementAlarmTemplate read, XmlElement editNode)
        {
            if (read == null)
                return;
            _accessType = read.AccessType != null ? new OwnershipElementsElementAlarmTemplateAccessType(read.AccessType, this) : null;
        }

        public static OwnershipElementsElementAlarmTemplate FromRead(Read.IOwnershipElementsElementAlarmTemplate read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementAlarmTemplate();
            item.AccessType = OwnershipElementsElementAlarmTemplateAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementAlarmTemplate(this);
        }
    }

    public partial class OwnershipElementsElementAlarmTemplateAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipElementsElementAlarmTemplateAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementAlarmTemplateAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipElementsElementAlarmTemplateAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipElementsElementAlarmTemplateAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementAlarmTemplateAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Declares ownership of the trend template.
    ///</summary>
public partial class OwnershipElementsElementTrendTemplate : EditableElementNode<Read.IOwnershipElementsElementTrendTemplate>
    {
        internal OwnershipElementsElementTrendTemplate(Read.IOwnershipElementsElementTrendTemplate read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TrendTemplate node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementTrendTemplate() : base("TrendTemplate")
        {
            OnCreated();
        }

        private OwnershipElementsElementTrendTemplateAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipElementsElementTrendTemplateAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public OwnershipElementsElementTrendTemplateAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipElementsElementTrendTemplateAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipElementsElementTrendTemplate read, XmlElement editNode)
        {
            if (read == null)
                return;
            _accessType = read.AccessType != null ? new OwnershipElementsElementTrendTemplateAccessType(read.AccessType, this) : null;
        }

        public static OwnershipElementsElementTrendTemplate FromRead(Read.IOwnershipElementsElementTrendTemplate read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementTrendTemplate();
            item.AccessType = OwnershipElementsElementTrendTemplateAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipElementsElementTrendTemplate(this);
        }
    }

    public partial class OwnershipElementsElementTrendTemplateAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipElementsElementTrendTemplateAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipElementsElementTrendTemplateAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipElementsElementTrendTemplateAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipElementsElementTrendTemplateAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipElementsElementTrendTemplateAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Groups ownership declarations of view properties.
    ///</summary>
public partial class OwnershipViews : EditableElementNode<Read.IOwnershipViews>
    {
        internal OwnershipViews(Read.IOwnershipViews read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Views node. None of it's properties will be set.
        ///</summary>
public OwnershipViews() : base("Views")
        {
            OnCreated();
        }

        private OwnershipViewsView _view;
        ///<summary>
        /// Declares ownership of view properties.
        ///</summary>
public OwnershipViewsView View
        {
            get
            {
                return _view;
            }

            set
            {
                if (_view != value)
                {
                    _view = value;
                    CombinedTagHandler.Assign(value, this, "View");
                }
            }
        }

        public OwnershipViewsView GetOrCreateView()
        {
            if (View == null)
                View = new OwnershipViewsView();
            return View;
        }

        protected override void Initialize(Read.IOwnershipViews read, XmlElement editNode)
        {
            if (read == null)
                return;
            _view = read.View != null ? new OwnershipViewsView(read.View, this, editNode.Element["View"]) : null;
        }

        public static OwnershipViews FromRead(Read.IOwnershipViews read)
        {
            if (read == null)
                return null;
            var item = new OwnershipViews();
            item.View = OwnershipViewsView.FromRead(read.View);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipViews(this);
        }
    }

    ///<summary>
    /// Declares ownership of view properties.
    ///</summary>
public partial class OwnershipViewsView : EditableElementNode<Read.IOwnershipViewsView>
    {
        internal OwnershipViewsView(Read.IOwnershipViewsView read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a View node. None of it's properties will be set.
        ///</summary>
public OwnershipViewsView() : base("View")
        {
            OnCreated();
        }

        private OwnershipViewsViewProperties _properties;
        ///<summary>
        /// Groups ownership declarations of view properties.
        ///</summary>
public OwnershipViewsViewProperties Properties
        {
            get
            {
                return _properties;
            }

            set
            {
                if (_properties != value)
                {
                    _properties = value;
                    CombinedTagHandler.Assign(value, this, "Properties");
                }
            }
        }

        public OwnershipViewsViewProperties GetOrCreateProperties()
        {
            if (Properties == null)
                Properties = new OwnershipViewsViewProperties();
            return Properties;
        }

        protected override void Initialize(Read.IOwnershipViewsView read, XmlElement editNode)
        {
            if (read == null)
                return;
            _properties = read.Properties != null ? new OwnershipViewsViewProperties(read.Properties, this, editNode.Element["Properties"]) : null;
        }

        public static OwnershipViewsView FromRead(Read.IOwnershipViewsView read)
        {
            if (read == null)
                return null;
            var item = new OwnershipViewsView();
            item.Properties = OwnershipViewsViewProperties.FromRead(read.Properties);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipViewsView(this);
        }
    }

    ///<summary>
    /// Groups ownership declarations of view properties.
    ///</summary>
public partial class OwnershipViewsViewProperties : EditableListNode<Read.IOwnershipViewsViewProperties, Read.IOwnershipViewsViewPropertiesProperty, OwnershipViewsViewPropertiesProperty>
    {
        internal OwnershipViewsViewProperties(Read.IOwnershipViewsViewProperties read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Properties node. None of it's properties will be set.
        ///</summary>
public OwnershipViewsViewProperties() : base("Properties")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IOwnershipViewsViewProperties read, XmlElement editNode)
        {
        }

        public static OwnershipViewsViewProperties FromRead(Read.IOwnershipViewsViewProperties read)
        {
            if (read == null)
                return null;
            var item = new OwnershipViewsViewProperties();
            foreach (var x in read)
            {
                item.Add(OwnershipViewsViewPropertiesProperty.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipViewsViewProperties(this);
        }
    }

    ///<summary>
    /// Declares ownership of the specified view property.
    ///</summary>
public partial class OwnershipViewsViewPropertiesProperty : EditableElementNode<Read.IOwnershipViewsViewPropertiesProperty>
    {
        internal OwnershipViewsViewPropertiesProperty(Read.IOwnershipViewsViewPropertiesProperty read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Property node. None of it's properties will be set.
        ///</summary>
public OwnershipViewsViewPropertiesProperty() : base("Property")
        {
            OnCreated();
        }

        private ElementValue<string> _name;
        private OwnershipViewsViewPropertiesPropertyAccessType _accessType;
        ///<summary>
        /// Specifies the name of the view property. Supported wildcard characters: '*' and '?'.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipViewsViewPropertiesPropertyAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public OwnershipViewsViewPropertiesPropertyAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipViewsViewPropertiesPropertyAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipViewsViewPropertiesProperty read, XmlElement editNode)
        {
            if (read == null)
                return;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _accessType = read.AccessType != null ? new OwnershipViewsViewPropertiesPropertyAccessType(read.AccessType, this) : null;
        }

        public static OwnershipViewsViewPropertiesProperty FromRead(Read.IOwnershipViewsViewPropertiesProperty read)
        {
            if (read == null)
                return null;
            var item = new OwnershipViewsViewPropertiesProperty();
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.AccessType = OwnershipViewsViewPropertiesPropertyAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipViewsViewPropertiesProperty(this);
        }
    }

    public partial class OwnershipViewsViewPropertiesPropertyAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipViewsViewPropertiesPropertyAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipViewsViewPropertiesPropertyAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipViewsViewPropertiesPropertyAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipViewsViewPropertiesPropertyAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipViewsViewPropertiesPropertyAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Groups service ownership declarations.
    ///</summary>
public partial class OwnershipServices : EditableElementNode<Read.IOwnershipServices>
    {
        internal OwnershipServices(Read.IOwnershipServices read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Services node. None of it's properties will be set.
        ///</summary>
public OwnershipServices() : base("Services")
        {
            OnCreated();
        }

        private OwnershipServicesService _service;
        ///<summary>
        /// Declares ownership of a service.
        ///</summary>
public OwnershipServicesService Service
        {
            get
            {
                return _service;
            }

            set
            {
                if (_service != value)
                {
                    _service = value;
                    CombinedTagHandler.Assign(value, this, "Service");
                }
            }
        }

        public OwnershipServicesService GetOrCreateService()
        {
            if (Service == null)
                Service = new OwnershipServicesService();
            return Service;
        }

        protected override void Initialize(Read.IOwnershipServices read, XmlElement editNode)
        {
            if (read == null)
                return;
            _service = read.Service != null ? new OwnershipServicesService(read.Service, this, editNode.Element["Service"]) : null;
        }

        public static OwnershipServices FromRead(Read.IOwnershipServices read)
        {
            if (read == null)
                return null;
            var item = new OwnershipServices();
            item.Service = OwnershipServicesService.FromRead(read.Service);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServices(this);
        }
    }

    ///<summary>
    /// Declares ownership of a service.
    ///</summary>
public partial class OwnershipServicesService : EditableElementNode<Read.IOwnershipServicesService>
    {
        internal OwnershipServicesService(Read.IOwnershipServicesService read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Service node. None of it's properties will be set.
        ///</summary>
public OwnershipServicesService() : base("Service")
        {
            OnCreated();
        }

        private OwnershipServicesServiceDescription _description;
        private OwnershipServicesServiceProperties _properties;
        ///<summary>
        /// Declares ownership of the service description.
        ///</summary>
public OwnershipServicesServiceDescription Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    CombinedTagHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Groups ownership declarations of service properties.
        ///</summary>
public OwnershipServicesServiceProperties Properties
        {
            get
            {
                return _properties;
            }

            set
            {
                if (_properties != value)
                {
                    _properties = value;
                    CombinedTagHandler.Assign(value, this, "Properties");
                }
            }
        }

        public OwnershipServicesServiceDescription GetOrCreateDescription()
        {
            if (Description == null)
                Description = new OwnershipServicesServiceDescription();
            return Description;
        }

        public OwnershipServicesServiceProperties GetOrCreateProperties()
        {
            if (Properties == null)
                Properties = new OwnershipServicesServiceProperties();
            return Properties;
        }

        protected override void Initialize(Read.IOwnershipServicesService read, XmlElement editNode)
        {
            if (read == null)
                return;
            _description = read.Description != null ? new OwnershipServicesServiceDescription(read.Description, this, editNode.Element["Description"]) : null;
            _properties = read.Properties != null ? new OwnershipServicesServiceProperties(read.Properties, this, editNode.Element["Properties"]) : null;
        }

        public static OwnershipServicesService FromRead(Read.IOwnershipServicesService read)
        {
            if (read == null)
                return null;
            var item = new OwnershipServicesService();
            item.Description = OwnershipServicesServiceDescription.FromRead(read.Description);
            item.Properties = OwnershipServicesServiceProperties.FromRead(read.Properties);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServicesService(this);
        }
    }

    ///<summary>
    /// Declares ownership of the service description.
    ///</summary>
public partial class OwnershipServicesServiceDescription : EditableElementNode<Read.IOwnershipServicesServiceDescription>
    {
        internal OwnershipServicesServiceDescription(Read.IOwnershipServicesServiceDescription read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Description node. None of it's properties will be set.
        ///</summary>
public OwnershipServicesServiceDescription() : base("Description")
        {
            OnCreated();
        }

        private OwnershipServicesServiceDescriptionAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipServicesServiceDescriptionAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public OwnershipServicesServiceDescriptionAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipServicesServiceDescriptionAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipServicesServiceDescription read, XmlElement editNode)
        {
            if (read == null)
                return;
            _accessType = read.AccessType != null ? new OwnershipServicesServiceDescriptionAccessType(read.AccessType, this) : null;
        }

        public static OwnershipServicesServiceDescription FromRead(Read.IOwnershipServicesServiceDescription read)
        {
            if (read == null)
                return null;
            var item = new OwnershipServicesServiceDescription();
            item.AccessType = OwnershipServicesServiceDescriptionAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServicesServiceDescription(this);
        }
    }

    public partial class OwnershipServicesServiceDescriptionAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipServicesServiceDescriptionAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipServicesServiceDescriptionAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipServicesServiceDescriptionAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipServicesServiceDescriptionAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipServicesServiceDescriptionAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Groups ownership declarations of service properties.
    ///</summary>
public partial class OwnershipServicesServiceProperties : EditableListNode<Read.IOwnershipServicesServiceProperties, Read.IOwnershipServicesServicePropertiesProperty, OwnershipServicesServicePropertiesProperty>
    {
        internal OwnershipServicesServiceProperties(Read.IOwnershipServicesServiceProperties read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Properties node. None of it's properties will be set.
        ///</summary>
public OwnershipServicesServiceProperties() : base("Properties")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IOwnershipServicesServiceProperties read, XmlElement editNode)
        {
        }

        public static OwnershipServicesServiceProperties FromRead(Read.IOwnershipServicesServiceProperties read)
        {
            if (read == null)
                return null;
            var item = new OwnershipServicesServiceProperties();
            foreach (var x in read)
            {
                item.Add(OwnershipServicesServicePropertiesProperty.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServicesServiceProperties(this);
        }
    }

    ///<summary>
    /// Declares ownership of the specified service property.
    ///</summary>
public partial class OwnershipServicesServicePropertiesProperty : EditableElementNode<Read.IOwnershipServicesServicePropertiesProperty>
    {
        internal OwnershipServicesServicePropertiesProperty(Read.IOwnershipServicesServicePropertiesProperty read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Property node. None of it's properties will be set.
        ///</summary>
public OwnershipServicesServicePropertiesProperty() : base("Property")
        {
            OnCreated();
        }

        private ElementValue<string> _name;
        private OwnershipServicesServicePropertiesPropertyAccessType _accessType;
        ///<summary>
        /// Specifies the name of the service property. Supported wildcard characters: '*' and '?'.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipServicesServicePropertiesPropertyAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public OwnershipServicesServicePropertiesPropertyAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipServicesServicePropertiesPropertyAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipServicesServicePropertiesProperty read, XmlElement editNode)
        {
            if (read == null)
                return;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _accessType = read.AccessType != null ? new OwnershipServicesServicePropertiesPropertyAccessType(read.AccessType, this) : null;
        }

        public static OwnershipServicesServicePropertiesProperty FromRead(Read.IOwnershipServicesServicePropertiesProperty read)
        {
            if (read == null)
                return null;
            var item = new OwnershipServicesServicePropertiesProperty();
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.AccessType = OwnershipServicesServicePropertiesPropertyAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipServicesServicePropertiesProperty(this);
        }
    }

    public partial class OwnershipServicesServicePropertiesPropertyAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipServicesServicePropertiesPropertyAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipServicesServicePropertiesPropertyAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipServicesServicePropertiesPropertyAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipServicesServicePropertiesPropertyAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipServicesServicePropertiesPropertyAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Groups redundancy group ownership declarations.
    ///</summary>
public partial class OwnershipRedundancyGroups : EditableElementNode<Read.IOwnershipRedundancyGroups>
    {
        internal OwnershipRedundancyGroups(Read.IOwnershipRedundancyGroups read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a RedundancyGroups node. None of it's properties will be set.
        ///</summary>
public OwnershipRedundancyGroups() : base("RedundancyGroups")
        {
            OnCreated();
        }

        private OwnershipRedundancyGroupsRedundancyGroup _redundancyGroup;
        ///<summary>
        /// Declares ownership of a redundancy group.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroup RedundancyGroup
        {
            get
            {
                return _redundancyGroup;
            }

            set
            {
                if (_redundancyGroup != value)
                {
                    _redundancyGroup = value;
                    CombinedTagHandler.Assign(value, this, "RedundancyGroup");
                }
            }
        }

        public OwnershipRedundancyGroupsRedundancyGroup GetOrCreateRedundancyGroup()
        {
            if (RedundancyGroup == null)
                RedundancyGroup = new OwnershipRedundancyGroupsRedundancyGroup();
            return RedundancyGroup;
        }

        protected override void Initialize(Read.IOwnershipRedundancyGroups read, XmlElement editNode)
        {
            if (read == null)
                return;
            _redundancyGroup = read.RedundancyGroup != null ? new OwnershipRedundancyGroupsRedundancyGroup(read.RedundancyGroup, this, editNode.Element["RedundancyGroup"]) : null;
        }

        public static OwnershipRedundancyGroups FromRead(Read.IOwnershipRedundancyGroups read)
        {
            if (read == null)
                return null;
            var item = new OwnershipRedundancyGroups();
            item.RedundancyGroup = OwnershipRedundancyGroupsRedundancyGroup.FromRead(read.RedundancyGroup);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroups(this);
        }
    }

    ///<summary>
    /// Declares ownership of a redundancy group.
    ///</summary>
public partial class OwnershipRedundancyGroupsRedundancyGroup : EditableElementNode<Read.IOwnershipRedundancyGroupsRedundancyGroup>
    {
        internal OwnershipRedundancyGroupsRedundancyGroup(Read.IOwnershipRedundancyGroupsRedundancyGroup read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a RedundancyGroup node. None of it's properties will be set.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroup() : base("RedundancyGroup")
        {
            OnCreated();
        }

        private OwnershipRedundancyGroupsRedundancyGroupDescription _description;
        private OwnershipRedundancyGroupsRedundancyGroupMaintenance _maintenance;
        private OwnershipRedundancyGroupsRedundancyGroupSwitching _switching;
        ///<summary>
        /// Declares ownership of the redundancy group description.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupDescription Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    CombinedTagHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Declares ownership of the redundancy group maintenance.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupMaintenance Maintenance
        {
            get
            {
                return _maintenance;
            }

            set
            {
                if (_maintenance != value)
                {
                    _maintenance = value;
                    CombinedTagHandler.Assign(value, this, "Maintenance");
                }
            }
        }

        ///<summary>
        /// Declares ownership of the redundancy group switching.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupSwitching Switching
        {
            get
            {
                return _switching;
            }

            set
            {
                if (_switching != value)
                {
                    _switching = value;
                    CombinedTagHandler.Assign(value, this, "Switching");
                }
            }
        }

        public OwnershipRedundancyGroupsRedundancyGroupDescription GetOrCreateDescription()
        {
            if (Description == null)
                Description = new OwnershipRedundancyGroupsRedundancyGroupDescription();
            return Description;
        }

        public OwnershipRedundancyGroupsRedundancyGroupMaintenance GetOrCreateMaintenance()
        {
            if (Maintenance == null)
                Maintenance = new OwnershipRedundancyGroupsRedundancyGroupMaintenance();
            return Maintenance;
        }

        public OwnershipRedundancyGroupsRedundancyGroupSwitching GetOrCreateSwitching()
        {
            if (Switching == null)
                Switching = new OwnershipRedundancyGroupsRedundancyGroupSwitching();
            return Switching;
        }

        protected override void Initialize(Read.IOwnershipRedundancyGroupsRedundancyGroup read, XmlElement editNode)
        {
            if (read == null)
                return;
            _description = read.Description != null ? new OwnershipRedundancyGroupsRedundancyGroupDescription(read.Description, this, editNode.Element["Description"]) : null;
            _maintenance = read.Maintenance != null ? new OwnershipRedundancyGroupsRedundancyGroupMaintenance(read.Maintenance, this, editNode.Element["Maintenance"]) : null;
            _switching = read.Switching != null ? new OwnershipRedundancyGroupsRedundancyGroupSwitching(read.Switching, this, editNode.Element["Switching"]) : null;
        }

        public static OwnershipRedundancyGroupsRedundancyGroup FromRead(Read.IOwnershipRedundancyGroupsRedundancyGroup read)
        {
            if (read == null)
                return null;
            var item = new OwnershipRedundancyGroupsRedundancyGroup();
            item.Description = OwnershipRedundancyGroupsRedundancyGroupDescription.FromRead(read.Description);
            item.Maintenance = OwnershipRedundancyGroupsRedundancyGroupMaintenance.FromRead(read.Maintenance);
            item.Switching = OwnershipRedundancyGroupsRedundancyGroupSwitching.FromRead(read.Switching);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroupsRedundancyGroup(this);
        }
    }

    ///<summary>
    /// Declares ownership of the redundancy group description.
    ///</summary>
public partial class OwnershipRedundancyGroupsRedundancyGroupDescription : EditableElementNode<Read.IOwnershipRedundancyGroupsRedundancyGroupDescription>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupDescription(Read.IOwnershipRedundancyGroupsRedundancyGroupDescription read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Description node. None of it's properties will be set.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupDescription() : base("Description")
        {
            OnCreated();
        }

        private OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipRedundancyGroupsRedundancyGroupDescription read, XmlElement editNode)
        {
            if (read == null)
                return;
            _accessType = read.AccessType != null ? new OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType(read.AccessType, this) : null;
        }

        public static OwnershipRedundancyGroupsRedundancyGroupDescription FromRead(Read.IOwnershipRedundancyGroupsRedundancyGroupDescription read)
        {
            if (read == null)
                return null;
            var item = new OwnershipRedundancyGroupsRedundancyGroupDescription();
            item.AccessType = OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroupsRedundancyGroupDescription(this);
        }
    }

    public partial class OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipRedundancyGroupsRedundancyGroupDescriptionAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Declares ownership of the redundancy group maintenance.
    ///</summary>
public partial class OwnershipRedundancyGroupsRedundancyGroupMaintenance : EditableElementNode<Read.IOwnershipRedundancyGroupsRedundancyGroupMaintenance>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupMaintenance(Read.IOwnershipRedundancyGroupsRedundancyGroupMaintenance read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Maintenance node. None of it's properties will be set.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupMaintenance() : base("Maintenance")
        {
            OnCreated();
        }

        private OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipRedundancyGroupsRedundancyGroupMaintenance read, XmlElement editNode)
        {
            if (read == null)
                return;
            _accessType = read.AccessType != null ? new OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType(read.AccessType, this) : null;
        }

        public static OwnershipRedundancyGroupsRedundancyGroupMaintenance FromRead(Read.IOwnershipRedundancyGroupsRedundancyGroupMaintenance read)
        {
            if (read == null)
                return null;
            var item = new OwnershipRedundancyGroupsRedundancyGroupMaintenance();
            item.AccessType = OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroupsRedundancyGroupMaintenance(this);
        }
    }

    public partial class OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipRedundancyGroupsRedundancyGroupMaintenanceAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Declares ownership of the redundancy group switching.
    ///</summary>
public partial class OwnershipRedundancyGroupsRedundancyGroupSwitching : EditableElementNode<Read.IOwnershipRedundancyGroupsRedundancyGroupSwitching>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupSwitching(Read.IOwnershipRedundancyGroupsRedundancyGroupSwitching read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Switching node. None of it's properties will be set.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupSwitching() : base("Switching")
        {
            OnCreated();
        }

        private OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType _accessType;
        ///<summary>
        /// Specifies the access type.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType AccessType
        {
            get
            {
                return _accessType;
            }

            set
            {
                if (_accessType != value)
                {
                    _accessType = value;
                    ElementHandler.Assign(value, this, "AccessType");
                }
            }
        }

        public OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType GetOrCreateAccessType()
        {
            if (AccessType == null)
                AccessType = new OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType();
            return AccessType;
        }

        protected override void Initialize(Read.IOwnershipRedundancyGroupsRedundancyGroupSwitching read, XmlElement editNode)
        {
            if (read == null)
                return;
            _accessType = read.AccessType != null ? new OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType(read.AccessType, this) : null;
        }

        public static OwnershipRedundancyGroupsRedundancyGroupSwitching FromRead(Read.IOwnershipRedundancyGroupsRedundancyGroupSwitching read)
        {
            if (read == null)
                return null;
            var item = new OwnershipRedundancyGroupsRedundancyGroupSwitching();
            item.AccessType = OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType.FromRead(read.AccessType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitOwnershipRedundancyGroupsRedundancyGroupSwitching(this);
        }
    }

    public partial class OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType : ElementValue<Enums.EnumOwnershipAccessType?>
    {
        internal OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType(Read.IValueTag<Enums.EnumOwnershipAccessType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a AccessType node. None of it's properties will be set.
        ///</summary>
public OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType() : base()
        {
            OnCreated();
        }

        public OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType(Enums.EnumOwnershipAccessType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOwnershipAccessTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOwnershipAccessType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOwnershipAccessTypeConverter.Convert(rawValue?.Trim());
        }

        public new static OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType FromRead(Read.IValueTag<Enums.EnumOwnershipAccessType?> read)
        {
            if (read == null)
                return null;
            var item = new OwnershipRedundancyGroupsRedundancyGroupSwitchingAccessType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Contains all the pairs defined in the protocol.
    ///</summary>
public partial class Pairs : EditableListNode<Read.IPairs, Read.IPairsPair, PairsPair>
    {
        internal Pairs(Read.IPairs read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Pairs node. None of it's properties will be set.
        ///</summary>
public Pairs() : base("Pairs")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IPairs read, XmlElement editNode)
        {
        }

        public static Pairs FromRead(Read.IPairs read)
        {
            if (read == null)
                return null;
            var item = new Pairs();
            foreach (var x in read)
            {
                item.Add(PairsPair.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairs(this);
        }
    }

    ///<summary>
    /// Defines a pair consisting of a command and optionally a response.
    ///</summary>
public partial class PairsPair : EditableElementNode<Read.IPairsPair>
    {
        internal PairsPair(Read.IPairsPair read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Pair node. None of it's properties will be set.
        ///</summary>
public PairsPair() : base("Pair")
        {
            OnCreated();
        }

        private ElementValue<string> _condition;
        private PairsPairContent _content;
        private ElementValue<string> _description;
        private ElementValue<string> _name;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _options;
        private AttributeValue<bool?> _ping;
        private AttributeValue<uint?> _timeout;
        ///<summary>
        /// Specifies a condition that must be met in order for the pair to execute.
        ///</summary>
public ElementValue<string> Condition
        {
            get
            {
                return _condition;
            }

            set
            {
                if (_condition != value)
                {
                    _condition = value;
                    ElementHandler.Assign(value, this, "Condition");
                }
            }
        }

        ///<summary>
        /// Specifies the command to be sent and the expected response(s) (if any) after the command has been sent.
        /// You can specify only one command. The number of responses, however, can vary from none to several, depending on the device.
        /// - If no response is expected, then specify the command, but no response.
        /// - If only one single response is expected, then specify the command and the expected response.
        /// - If multiple responses are expected, then specify the command and all expected responses.
        /// 
        /// When DataMiner receives a response from the device after having sent a command, it will try to match the response to one of the responses
        /// defined in this tag. If several responses have been defined, it will check them top down.
        /// If a match is found, DataMiner will move on to the next command/response pair.
        /// If no match is found, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has
        /// occurred. The log files of the device will contain more detailed information. If the new response still does not match one of the defined
        /// responses, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
        /// will skip the command, and move to the next command/response pair.
        /// By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device
        /// in System Display.
        ///</summary>
public PairsPairContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        ///<summary>
        /// Contains a textual description of the pair.
        ///</summary>
public ElementValue<string> Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    ElementHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the pair. This name is displayed in the stream viewer when the pair is executed.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Specifies the unique ID of the pair.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";").
        /// For an overview of all options that can be specified in this tag, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// If set to "true", the pair will be executed when the device is in timeout and slow polling is activated.
        /// Note: This option cannot be used in protocols of type SNMP or OPC.
        ///</summary>
public AttributeValue<bool?> Ping
        {
            get
            {
                return _ping;
            }

            set
            {
                if (_ping != value)
                {
                    _ping = value;
                    AttributeHandler.Assign(value, this, "ping");
                }
            }
        }

        ///<summary>
        /// Specifies the timeout value to use for this pair instead of the default value when executing the pair.
        /// Using this option, you can extend the period of time DataMiner will wait for a response after having sent a command.
        ///</summary>
public AttributeValue<uint?> Timeout
        {
            get
            {
                return _timeout;
            }

            set
            {
                if (_timeout != value)
                {
                    _timeout = value;
                    AttributeHandler.Assign(value, this, "timeout");
                }
            }
        }

        public ElementValue<string> GetOrCreateCondition()
        {
            if (Condition == null)
                Condition = new ElementValue<string>();
            return Condition;
        }

        public PairsPairContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new PairsPairContent();
            return Content;
        }

        public ElementValue<string> GetOrCreateDescription()
        {
            if (Description == null)
                Description = new ElementValue<string>();
            return Description;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<bool?> GetOrCreatePing()
        {
            if (Ping == null)
                Ping = new AttributeValue<bool?>();
            return Ping;
        }

        public AttributeValue<uint?> GetOrCreateTimeout()
        {
            if (Timeout == null)
                Timeout = new AttributeValue<uint?>();
            return Timeout;
        }

        protected override void Initialize(Read.IPairsPair read, XmlElement editNode)
        {
            if (read == null)
                return;
            _condition = read.Condition != null ? new ElementValue<string>(read.Condition, this) : null;
            _content = read.Content != null ? new PairsPairContent(read.Content, this, editNode.Element["Content"]) : null;
            _description = read.Description != null ? new ElementValue<string>(read.Description, this) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _ping = read.Ping != null ? new AttributeValue<bool?>(read.Ping, this) : null;
            _timeout = read.Timeout != null ? new AttributeValue<uint?>(read.Timeout, this) : null;
        }

        public static PairsPair FromRead(Read.IPairsPair read)
        {
            if (read == null)
                return null;
            var item = new PairsPair();
            item.Condition = ElementValue<string>.FromRead(read.Condition);
            item.Content = PairsPairContent.FromRead(read.Content);
            item.Description = ElementValue<string>.FromRead(read.Description);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Ping = AttributeValue<bool?>.FromRead(read.Ping);
            item.Timeout = AttributeValue<uint?>.FromRead(read.Timeout);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPair(this);
        }
    }

    ///<summary>
    /// Specifies the command to be sent and the expected response(s) (if any) after the command has been sent.
    /// You can specify only one command. The number of responses, however, can vary from none to several, depending on the device.
    /// - If no response is expected, then specify the command, but no response.
    /// - If only one single response is expected, then specify the command and the expected response.
    /// - If multiple responses are expected, then specify the command and all expected responses.
    /// 
    /// When DataMiner receives a response from the device after having sent a command, it will try to match the response to one of the responses
    /// defined in this tag. If several responses have been defined, it will check them top down.
    /// If a match is found, DataMiner will move on to the next command/response pair.
    /// If no match is found, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has
    /// occurred. The log files of the device will contain more detailed information. If the new response still does not match one of the defined
    /// responses, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
    /// will skip the command, and move to the next command/response pair.
    /// By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device
    /// in System Display.
    ///</summary>
public partial class PairsPairContent : ComplexEditableListNode<Read.IPairsPairContent, Read.IPairsPairContentItem, IPairsPairContentItem>
    {
        internal PairsPairContent(Read.IPairsPairContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode, new Dictionary<string, Type>() { { "Command", typeof(PairsPairContentCommand) }, { "Response", typeof(PairsPairContentResponse) }, { "ResponseOnBadCommand", typeof(PairsPairContentResponseOnBadCommand) }, { "", typeof(PairsPairContentItem) } })
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public PairsPairContent() : base("Content", new Dictionary<string, Type>() { { "Command", typeof(PairsPairContentCommand) }, { "Response", typeof(PairsPairContentResponse) }, { "ResponseOnBadCommand", typeof(PairsPairContentResponseOnBadCommand) }, { "", typeof(PairsPairContentItem) } })
        {
            OnCreated();
        }

        private PairsPairContentCommand _command;
        ///<summary>
        /// Specifies the ID of the command that will be sent when the pair is executed.
        ///</summary>
public PairsPairContentCommand Command
        {
            get
            {
                return _command;
            }

            set
            {
                if (_command != value)
                {
                    _command = value;
                    CombinedTagHandler.Assign(value, this, "Command");
                }
            }
        }

        protected override void Initialize(Read.IPairsPairContent read, XmlElement editNode)
        {
            if (read == null)
                return;
            _command = read.Command != null ? new PairsPairContentCommand(read.Command, this, editNode.Element["Command"]) : null;
        }

        public static PairsPairContent FromRead(Read.IPairsPairContent read)
        {
            if (read == null)
                return null;
            var item = new PairsPairContent();
            item.Command = PairsPairContentCommand.FromRead(read.Command);
            foreach (var x in read)
            {
                item.Add(PairsPairContentItem.ItemFromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContent(this);
        }
    }

    public interface IPairsPairContentItem : IEditableNode
    {
    }

    public partial class PairsPairContentItem : EditableElementNode<Read.IPairsPairContentItem>, IPairsPairContentItem
    {
        protected PairsPairContentItem(string tagName) : base(tagName)
        {
        }

        internal PairsPairContentItem(Read.IPairsPairContentItem read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        protected override void Initialize(Read.IPairsPairContentItem read, XmlElement editNode)
        {
        }

        public static IPairsPairContentItem ItemFromRead(Read.IPairsPairContentItem read)
        {
            if (read == null)
                return null;
            switch (read.TagName)
            {
                case "Command":
                    return PairsPairContentCommand.FromRead(read as Read.IPairsPairContentCommand);
                case "Response":
                    return PairsPairContentResponse.FromRead(read as Read.IPairsPairContentResponse);
                case "ResponseOnBadCommand":
                    return PairsPairContentResponseOnBadCommand.FromRead(read as Read.IPairsPairContentResponseOnBadCommand);
                default:
                    return new PairsPairContentItem(read.TagName);
            }
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContentItem(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the command that will be sent when the pair is executed.
    ///</summary>
public partial class PairsPairContentCommand : EditableElementValueNode<Read.IPairsPairContentCommand, uint?>, IPairsPairContentItem
    {
        internal PairsPairContentCommand(Read.IPairsPairContentCommand read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Command node. None of it's properties will be set.
        ///</summary>
public PairsPairContentCommand() : base("Command")
        {
            OnCreated();
        }

        public PairsPairContentCommand(uint? value) : base("Command", value)
        {
        }

        protected override void Initialize(Read.IPairsPairContentCommand read, XmlElement editNode)
        {
        }

        public static PairsPairContentCommand FromRead(Read.IPairsPairContentCommand read)
        {
            if (read == null)
                return null;
            var item = new PairsPairContentCommand();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContentCommand(this);
        }
    }

    ///<summary>
    /// Specifies the ID of an expected response.
    ///</summary>
public partial class PairsPairContentResponse : EditableElementValueNode<Read.IPairsPairContentResponse, uint?>, IPairsPairContentItem
    {
        internal PairsPairContentResponse(Read.IPairsPairContentResponse read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Response node. None of it's properties will be set.
        ///</summary>
public PairsPairContentResponse() : base("Response")
        {
            OnCreated();
        }

        public PairsPairContentResponse(uint? value) : base("Response", value)
        {
        }

        protected override void Initialize(Read.IPairsPairContentResponse read, XmlElement editNode)
        {
        }

        public static PairsPairContentResponse FromRead(Read.IPairsPairContentResponse read)
        {
            if (read == null)
                return null;
            var item = new PairsPairContentResponse();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContentResponse(this);
        }
    }

    ///<summary>
    /// Defines an error message coming from the device.
    /// If the device is able to return an error message, and if the structure of that error message is known, then you can create a response that
    /// matches that error message, and included that response in the command/response pair as a "ResponseOnBadCommand".
    /// When the device sends a response that matches the ResponseOnBadCommand, then this will be indicated in the communication indicator of the DataMiner user interface.
    /// The command, however, will not be executed again as the received response matched one of the defined responses.
    /// Also, the information received from the device in the error message can be used to inform users about the error that occurred.
    ///</summary>
public partial class PairsPairContentResponseOnBadCommand : EditableElementValueNode<Read.IPairsPairContentResponseOnBadCommand, uint?>, IPairsPairContentItem
    {
        internal PairsPairContentResponseOnBadCommand(Read.IPairsPairContentResponseOnBadCommand read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ResponseOnBadCommand node. None of it's properties will be set.
        ///</summary>
public PairsPairContentResponseOnBadCommand() : base("ResponseOnBadCommand")
        {
            OnCreated();
        }

        public PairsPairContentResponseOnBadCommand(uint? value) : base("ResponseOnBadCommand", value)
        {
        }

        protected override void Initialize(Read.IPairsPairContentResponseOnBadCommand read, XmlElement editNode)
        {
        }

        public static PairsPairContentResponseOnBadCommand FromRead(Read.IPairsPairContentResponseOnBadCommand read)
        {
            if (read == null)
                return null;
            var item = new PairsPairContentResponseOnBadCommand();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPairsPairContentResponseOnBadCommand(this);
        }
    }

    ///<summary>
    /// Defines the DataMiner Connectivity Framework (DCF) interfaces.
    /// Feature introduced in DataMiner 8.0.0 (RN 5663).
    ///</summary>
public partial class ParameterGroups : EditableListNode<Read.IParameterGroups, Read.IParameterGroupsGroup, ParameterGroupsGroup>
    {
        internal ParameterGroups(Read.IParameterGroups read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ParameterGroups node. None of it's properties will be set.
        ///</summary>
public ParameterGroups() : base("ParameterGroups")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParameterGroups read, XmlElement editNode)
        {
        }

        public static ParameterGroups FromRead(Read.IParameterGroups read)
        {
            if (read == null)
                return null;
            var item = new ParameterGroups();
            foreach (var x in read)
            {
                item.Add(ParameterGroupsGroup.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParameterGroups(this);
        }
    }

    ///<summary>
    /// Defines a parameter group.
    ///</summary>
public partial class ParameterGroupsGroup : EditableElementNode<Read.IParameterGroupsGroup>
    {
        internal ParameterGroupsGroup(Read.IParameterGroupsGroup read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Group node. None of it's properties will be set.
        ///</summary>
public ParameterGroupsGroup() : base("Group")
        {
            OnCreated();
        }

        private ParameterGroupsGroupParams _params;
        private AttributeValue<bool?> _calculateAlarmState;
        private AttributeValue<uint?> _dynamicId;
        private AttributeValue<string> _dynamicIndex;
        private AttributeValue<bool?> _dynamicUsePK;
        private AttributeValue<uint?> _id;
        private AttributeValue<bool?> _isInternal;
        private AttributeValue<string> _name;
        private ParameterGroupsGroupType _type;
        ///<summary>
        /// Specifies the parameters that are included in the group.
        ///</summary>
public ParameterGroupsGroupParams Params
        {
            get
            {
                return _params;
            }

            set
            {
                if (_params != value)
                {
                    _params = value;
                    CombinedTagHandler.Assign(value, this, "Params");
                }
            }
        }

        ///<summary>
        /// Specifies whether to disable the interface state calculation.
        ///</summary>
public AttributeValue<bool?> CalculateAlarmState
        {
            get
            {
                return _calculateAlarmState;
            }

            set
            {
                if (_calculateAlarmState != value)
                {
                    _calculateAlarmState = value;
                    AttributeHandler.Assign(value, this, "calculateAlarmState");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the table parameter.
        ///</summary>
public AttributeValue<uint?> DynamicId
        {
            get
            {
                return _dynamicId;
            }

            set
            {
                if (_dynamicId != value)
                {
                    _dynamicId = value;
                    AttributeHandler.Assign(value, this, "dynamicId");
                }
            }
        }

        ///<summary>
        /// Specifies the display key, which can be used as a filter.
        ///</summary>
public AttributeValue<string> DynamicIndex
        {
            get
            {
                return _dynamicIndex;
            }

            set
            {
                if (_dynamicIndex != value)
                {
                    _dynamicIndex = value;
                    AttributeHandler.Assign(value, this, "dynamicIndex");
                }
            }
        }

        ///<summary>
        /// Specifies whether the display key or the primary key should be used in the interface name (Default: false).
        ///</summary>
public AttributeValue<bool?> DynamicUsePK
        {
            get
            {
                return _dynamicUsePK;
            }

            set
            {
                if (_dynamicUsePK != value)
                {
                    _dynamicUsePK = value;
                    AttributeHandler.Assign(value, this, "dynamicUsePK");
                }
            }
        }

        ///<summary>
        /// Specifies the unique ID of the parameter group.
        /// A parameter group cannot have an ID equal to 10000 or higher. The IDs starting from 10000 are reserved for DCF dynamic interfaces. Feature introduced in DataMiner 8.5.3 (RN 8863). Since DataMiner 9.0.4 (RN 13161), DataMiner creates new dynamic interfaces in the range 100 000 - 199 999 (instead of starting from 10 000).
        /// 
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies whether this an internal interface (Default: false).
        ///</summary>
public AttributeValue<bool?> IsInternal
        {
            get
            {
                return _isInternal;
            }

            set
            {
                if (_isInternal != value)
                {
                    _isInternal = value;
                    AttributeHandler.Assign(value, this, "isInternal");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the parameter group.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Specifies the type of the interface.
        ///</summary>
public ParameterGroupsGroupType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public ParameterGroupsGroupParams GetOrCreateParams()
        {
            if (Params == null)
                Params = new ParameterGroupsGroupParams();
            return Params;
        }

        public AttributeValue<bool?> GetOrCreateCalculateAlarmState()
        {
            if (CalculateAlarmState == null)
                CalculateAlarmState = new AttributeValue<bool?>();
            return CalculateAlarmState;
        }

        public AttributeValue<uint?> GetOrCreateDynamicId()
        {
            if (DynamicId == null)
                DynamicId = new AttributeValue<uint?>();
            return DynamicId;
        }

        public AttributeValue<string> GetOrCreateDynamicIndex()
        {
            if (DynamicIndex == null)
                DynamicIndex = new AttributeValue<string>();
            return DynamicIndex;
        }

        public AttributeValue<bool?> GetOrCreateDynamicUsePK()
        {
            if (DynamicUsePK == null)
                DynamicUsePK = new AttributeValue<bool?>();
            return DynamicUsePK;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<bool?> GetOrCreateIsInternal()
        {
            if (IsInternal == null)
                IsInternal = new AttributeValue<bool?>();
            return IsInternal;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public ParameterGroupsGroupType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParameterGroupsGroupType();
            return Type;
        }

        protected override void Initialize(Read.IParameterGroupsGroup read, XmlElement editNode)
        {
            if (read == null)
                return;
            _params = read.Params != null ? new ParameterGroupsGroupParams(read.Params, this, editNode.Element["Params"]) : null;
            _calculateAlarmState = read.CalculateAlarmState != null ? new AttributeValue<bool?>(read.CalculateAlarmState, this) : null;
            _dynamicId = read.DynamicId != null ? new AttributeValue<uint?>(read.DynamicId, this) : null;
            _dynamicIndex = read.DynamicIndex != null ? new AttributeValue<string>(read.DynamicIndex, this) : null;
            _dynamicUsePK = read.DynamicUsePK != null ? new AttributeValue<bool?>(read.DynamicUsePK, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _isInternal = read.IsInternal != null ? new AttributeValue<bool?>(read.IsInternal, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _type = read.Type != null ? new ParameterGroupsGroupType(read.Type, this) : null;
        }

        public static ParameterGroupsGroup FromRead(Read.IParameterGroupsGroup read)
        {
            if (read == null)
                return null;
            var item = new ParameterGroupsGroup();
            item.Params = ParameterGroupsGroupParams.FromRead(read.Params);
            item.CalculateAlarmState = AttributeValue<bool?>.FromRead(read.CalculateAlarmState);
            item.DynamicId = AttributeValue<uint?>.FromRead(read.DynamicId);
            item.DynamicIndex = AttributeValue<string>.FromRead(read.DynamicIndex);
            item.DynamicUsePK = AttributeValue<bool?>.FromRead(read.DynamicUsePK);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.IsInternal = AttributeValue<bool?>.FromRead(read.IsInternal);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Type = ParameterGroupsGroupType.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParameterGroupsGroup(this);
        }
    }

    ///<summary>
    /// Specifies the parameters that are included in the group.
    ///</summary>
public partial class ParameterGroupsGroupParams : EditableListNode<Read.IParameterGroupsGroupParams, Read.IParameterGroupsGroupParamsParam, ParameterGroupsGroupParamsParam>
    {
        internal ParameterGroupsGroupParams(Read.IParameterGroupsGroupParams read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Params node. None of it's properties will be set.
        ///</summary>
public ParameterGroupsGroupParams() : base("Params")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParameterGroupsGroupParams read, XmlElement editNode)
        {
        }

        public static ParameterGroupsGroupParams FromRead(Read.IParameterGroupsGroupParams read)
        {
            if (read == null)
                return null;
            var item = new ParameterGroupsGroupParams();
            foreach (var x in read)
            {
                item.Add(ParameterGroupsGroupParamsParam.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParameterGroupsGroupParams(this);
        }
    }

    ///<summary>
    /// Specifies a parameter that is included in the group.
    ///</summary>
public partial class ParameterGroupsGroupParamsParam : EditableElementNode<Read.IParameterGroupsGroupParamsParam>
    {
        internal ParameterGroupsGroupParamsParam(Read.IParameterGroupsGroupParamsParam read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Param node. None of it's properties will be set.
        ///</summary>
public ParameterGroupsGroupParamsParam() : base("Param")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _id;
        private AttributeValue<string> _index;
        ///<summary>
        /// Specifies the ID of the included parameter.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter ID of the index column (primary key).
        ///</summary>
public AttributeValue<string> Index
        {
            get
            {
                return _index;
            }

            set
            {
                if (_index != value)
                {
                    _index = value;
                    AttributeHandler.Assign(value, this, "index");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateIndex()
        {
            if (Index == null)
                Index = new AttributeValue<string>();
            return Index;
        }

        protected override void Initialize(Read.IParameterGroupsGroupParamsParam read, XmlElement editNode)
        {
            if (read == null)
                return;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _index = read.Index != null ? new AttributeValue<string>(read.Index, this) : null;
        }

        public static ParameterGroupsGroupParamsParam FromRead(Read.IParameterGroupsGroupParamsParam read)
        {
            if (read == null)
                return null;
            var item = new ParameterGroupsGroupParamsParam();
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Index = AttributeValue<string>.FromRead(read.Index);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParameterGroupsGroupParamsParam(this);
        }
    }

    public partial class ParameterGroupsGroupType : AttributeValue<Enums.EnumParamGroupType?>
    {
        internal ParameterGroupsGroupType(Read.IValueTag<Enums.EnumParamGroupType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public ParameterGroupsGroupType() : base()
        {
            OnCreated();
        }

        public ParameterGroupsGroupType(Enums.EnumParamGroupType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamGroupTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamGroupType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamGroupTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParameterGroupsGroupType FromRead(Read.IValueTag<Enums.EnumParamGroupType?> read)
        {
            if (read == null)
                return null;
            var item = new ParameterGroupsGroupType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Contains all the parameters defined in the protocol.
    ///</summary>
public partial class Params : EditableListNode<Read.IParams, Read.IParamsParam, ParamsParam>
    {
        internal Params(Read.IParams read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Params node. None of it's properties will be set.
        ///</summary>
public Params() : base("Params")
        {
            OnCreated();
        }

        private AttributeValue<string> _loadSequence;
        ///<summary>
        /// Changes the order in which saved parameter data is retrieved when the element starts up.
        ///</summary>
public AttributeValue<string> LoadSequence
        {
            get
            {
                return _loadSequence;
            }

            set
            {
                if (_loadSequence != value)
                {
                    _loadSequence = value;
                    AttributeHandler.Assign(value, this, "loadSequence");
                }
            }
        }

        public AttributeValue<string> GetOrCreateLoadSequence()
        {
            if (LoadSequence == null)
                LoadSequence = new AttributeValue<string>();
            return LoadSequence;
        }

        protected override void Initialize(Read.IParams read, XmlElement editNode)
        {
            if (read == null)
                return;
            _loadSequence = read.LoadSequence != null ? new AttributeValue<string>(read.LoadSequence, this) : null;
        }

        public static Params FromRead(Read.IParams read)
        {
            if (read == null)
                return null;
            var item = new Params();
            item.LoadSequence = AttributeValue<string>.FromRead(read.LoadSequence);
            foreach (var x in read)
            {
                item.Add(ParamsParam.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParams(this);
        }
    }

    ///<summary>
    /// Defines a parameter.
    ///</summary>
public partial class ParamsParam : EditableElementNode<Read.IParamsParam>
    {
        internal ParamsParam(Read.IParamsParam read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Param node. None of it's properties will be set.
        ///</summary>
public ParamsParam() : base("Param")
        {
            OnCreated();
        }

        private ParamsParamAlarm _alarm;
        private ParamsParamArrayOptions _arrayOptions;
        private ParamsParamCRC _cRC;
        private ParamsParamCrossDriverOptions _crossDriverOptions;
        private ParamsParamDashboard _dashboard;
        private ParamsParamDatabase _database;
        private ParamsParamDependencies _dependencies;
        private ElementValue<string> _description;
        private ParamsParamDisplay _display;
        private ParamsParamHyperLinks _hyperLinks;
        private Icon _icon;
        private ParamsParamInformation _information;
        private ParamsParamInterprete _interprete;
        private ParamsParamLength _length;
        private ParamsParamMatrix _matrix;
        private ParamsParamMeasurement _measurement;
        private ParamsParamMediation _mediation;
        private ElementValue<string> _message;
        private ElementValue<string> _name;
        private ParamsParamReplication _replication;
        private ParamsParamSNMP _sNMP;
        private ParamsParamType _type;
        private ParamsParamConfirmPopup _confirmPopup;
        private AttributeValue<string> _duplicateAs;
        private AttributeValue<string> _export;
        private AttributeValue<bool?> _historySet;
        private AttributeValue<uint?> _id;
        private AttributeValue<uint?> _level;
        private AttributeValue<string> _options;
        private AttributeValue<uint?> _pollingInterval;
        private AttributeValue<bool?> _save;
        private AttributeValue<System.TimeSpan?> _saveInterval;
        private AttributeValue<bool?> _setter;
        private AttributeValue<bool?> _snapshot;
        private AttributeValue<string> _snmpSetAndGet;
        private AttributeValue<bool?> _trending;
        private AttributeValue<uint?> _verificationTimeout;
        ///<summary>
        /// Specifies the default parameter alarming configuration. Each alarm consists of two components:
        /// -	Severity: Critical, Major, Minor, Warning or Normal
        /// -	Severity Range: Low, Medium or High
        /// These are combined into the following alarm levels:
        /// -	Critical Low (CL)
        /// -	Major Low (MaL)
        /// -	Minor Low (MiL)
        /// -	Warning Low (WaL)
        /// -	Normal (Normal)
        /// -	Warning High (WaH)
        /// -	Minor High (MiH)
        /// -	Major High (MaH)
        /// -	Critical High (CH)
        /// Each alarm level is included in a /Protocol/Params/Param/Alarm element, so a value can be assigned to it. If the value of the monitored parameter is equal to or exceeds
        /// a value included in the /Protocol/Params/Param/Alarm element, DataMiner will process an alarm depending on the alarm level that corresponds to the
        /// value.
        /// These assigned values are not only accessible via the protocol, but also via DataMiner Cuber or System Display. The alarm values of a parameter can be altered by
        /// means of alarm templates, on condition that a /Protocol/Params/Param/Alarm element has been defined for the parameter in the protocol. The alarm
        /// levels of a parameter can be adapted at any moment, regardless of the values specified in the protocol.
        ///</summary>
public ParamsParamAlarm Alarm
        {
            get
            {
                return _alarm;
            }

            set
            {
                if (_alarm != value)
                {
                    _alarm = value;
                    CombinedTagHandler.Assign(value, this, "Alarm");
                }
            }
        }

        ///<summary>
        /// Defines all table columns.
        /// Each table column is defined by one or two Parameters:
        /// -	one for read, and/or
        /// -	one for write.
        ///</summary>
public ParamsParamArrayOptions ArrayOptions
        {
            get
            {
                return _arrayOptions;
            }

            set
            {
                if (_arrayOptions != value)
                {
                    _arrayOptions = value;
                    CombinedTagHandler.Assign(value, this, "ArrayOptions");
                }
            }
        }

        ///<summary>
        /// If /Protocol/Params/Param/Type is set to "CRC", then this CRC element allows you to define the CRC used in the communication with the device.
        /// The information you specify here will be used to calculate the CRC of the command/response.
        ///</summary>
public ParamsParamCRC CRC
        {
            get
            {
                return _cRC;
            }

            set
            {
                if (_cRC != value)
                {
                    _cRC = value;
                    CombinedTagHandler.Assign(value, this, "CRC");
                }
            }
        }

        ///<summary>
        /// Allows building a direct view table using multiple columns from multiple different protocols. Feature introduced in DataMiner 10.2.9 (RN 33253).
        ///</summary>
public ParamsParamCrossDriverOptions CrossDriverOptions
        {
            get
            {
                return _crossDriverOptions;
            }

            set
            {
                if (_crossDriverOptions != value)
                {
                    _crossDriverOptions = value;
                    CombinedTagHandler.Assign(value, this, "CrossDriverOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the configuration for use in dashboards.
        ///</summary>
public ParamsParamDashboard Dashboard
        {
            get
            {
                return _dashboard;
            }

            set
            {
                if (_dashboard != value)
                {
                    _dashboard = value;
                    CombinedTagHandler.Assign(value, this, "Dashboard");
                }
            }
        }

        ///<summary>
        /// Specifies database-related configuration options.
        /// Feature introduced in DataMiner 9.0.0 (RN 11853).
        ///</summary>
public ParamsParamDatabase Database
        {
            get
            {
                return _database;
            }

            set
            {
                if (_database != value)
                {
                    _database = value;
                    CombinedTagHandler.Assign(value, this, "Database");
                }
            }
        }

        ///<summary>
        /// Allows you to link one or more parameters. This is mostly used for situations in which clicking a button executes a command that includes several parameters.
        /// Execution of such a command will only proceed if all dependent parameters have a valid value.
        ///</summary>
public ParamsParamDependencies Dependencies
        {
            get
            {
                return _dependencies;
            }

            set
            {
                if (_dependencies != value)
                {
                    _dependencies = value;
                    CombinedTagHandler.Assign(value, this, "Dependencies");
                }
            }
        }

        ///<summary>
        /// Specifies the description of the parameter.
        /// Typically, the parameter name refers to the technical name of the parameter, while the parameter description provides a more common name or description.
        /// Preferably, the description should be unique throughout the protocol.
        ///</summary>
public ElementValue<string> Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    ElementHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Defines if and how a parameter will be displayed on the user interface.
        ///</summary>
public ParamsParamDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// Contains the custom commands (i.e. “hyperlinks”) that have to appear on the shortcut menu when users right-click an alarm of this parameter.
        /// These custom commands are often hyperlinks pointing to a web page or an automation script.
        ///</summary>
public ParamsParamHyperLinks HyperLinks
        {
            get
            {
                return _hyperLinks;
            }

            set
            {
                if (_hyperLinks != value)
                {
                    _hyperLinks = value;
                    CombinedTagHandler.Assign(value, this, "HyperLinks");
                }
            }
        }

        ///<summary>
        /// Specifies the icon to be shown in a tree control.
        ///</summary>
public Icon Icon
        {
            get
            {
                return _icon;
            }

            set
            {
                if (_icon != value)
                {
                    _icon = value;
                    CombinedTagHandler.Assign(value, this, "Icon");
                }
            }
        }

        ///<summary>
        /// Specifies additional information about the parameter.
        /// DataMiner will show this additional information in tooltips.
        /// Note: Only parameters of type "read" or "read bit" will use /Protocol/Params/Param/Information. In some cases, however, also parameters of type "write" or "write bit" will have one.
        ///</summary>
public ParamsParamInformation Information
        {
            get
            {
                return _information;
            }

            set
            {
                if (_information != value)
                {
                    _information = value;
                    CombinedTagHandler.Assign(value, this, "Information");
                }
            }
        }

        ///<summary>
        /// Specifies how a parameter value is processed.
        ///</summary>
public ParamsParamInterprete Interprete
        {
            get
            {
                return _interprete;
            }

            set
            {
                if (_interprete != value)
                {
                    _interprete = value;
                    CombinedTagHandler.Assign(value, this, "Interprete");
                }
            }
        }

        ///<summary>
        /// Specifies the length of the command/response.
        ///</summary>
public ParamsParamLength Length
        {
            get
            {
                return _length;
            }

            set
            {
                if (_length != value)
                {
                    _length = value;
                    CombinedTagHandler.Assign(value, this, "Length");
                }
            }
        }

        ///<summary>
        /// If /Protocol/Params/Param/Type is set to "matrix", then this will allow you to define the matrix control. Feature introduced in DataMiner 10.3.1/10.4.0 (RN 34661).
        ///</summary>
public ParamsParamMatrix Matrix
        {
            get
            {
                return _matrix;
            }

            set
            {
                if (_matrix != value)
                {
                    _matrix = value;
                    CombinedTagHandler.Assign(value, this, "Matrix");
                }
            }
        }

        ///<summary>
        /// Specifies how the parameter has to be displayed on the user interface (depending on the parameter type).
        ///</summary>
public ParamsParamMeasurement Measurement
        {
            get
            {
                return _measurement;
            }

            set
            {
                if (_measurement != value)
                {
                    _measurement = value;
                    CombinedTagHandler.Assign(value, this, "Measurement");
                }
            }
        }

        ///<summary>
        /// Contains the links between parameters of a base protocol and parameters of this protocol.
        ///</summary>
public ParamsParamMediation Mediation
        {
            get
            {
                return _mediation;
            }

            set
            {
                if (_mediation != value)
                {
                    _mediation = value;
                    CombinedTagHandler.Assign(value, this, "Mediation");
                }
            }
        }

        ///<summary>
        /// Specifies a message to be displayed when users change the parameter on the user interface.
        /// Usually, this text will appear as a pop-up warning when a potentially dangerous setting has to be changed.
        ///</summary>
public ElementValue<string> Message
        {
            get
            {
                return _message;
            }

            set
            {
                if (_message != value)
                {
                    _message = value;
                    ElementHandler.Assign(value, this, "Message");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the parameter. Typically, the parameter name refers to the technical name of the parameter, while the parameter description provides a more common name or description.
        /// Although it is possible that the name is used in alarm notifications, typically the parameter description will be used. See /Protocol/Params/Param/Description.
        /// Important:
        /// -	The name must be unique throughout the protocol.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Used to replicate specific parameters from another element.
        ///</summary>
public ParamsParamReplication Replication
        {
            get
            {
                return _replication;
            }

            set
            {
                if (_replication != value)
                {
                    _replication = value;
                    CombinedTagHandler.Assign(value, this, "Replication");
                }
            }
        }

        ///<summary>
        /// Specifies SNMP related functionality for this parameter.
        /// Only used in protocols for elements that are SNMP-compliant. In case of such an element, DataMiner will interrogate the SNMP agent specified in /Proto­col/Params/Param/SNMP/OID or capture traps defined in /Protocol/Params/Param/SNMP/TrapOID.
        ///</summary>
public ParamsParamSNMP SNMP
        {
            get
            {
                return _sNMP;
            }

            set
            {
                if (_sNMP != value)
                {
                    _sNMP = value;
                    CombinedTagHandler.Assign(value, this, "SNMP");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter type.
        /// For more information about the different types, refer to the DataMiner Protocol Markup Language documentation.
        /// Parameters of type "elementid", "elementname", "elementdmaid" and "dataminer info" are the first parameters that are loaded by a protocol. Although they hold information, they cannot, as such,
        /// be displayed in Element Display. Therefore, for these types of parameters, always set /Protocol/Params/Param/Display/RTDisplay "false".
        /// If you do want to display the information in one of these parameters in Element Display, there is a workaround: create another parameter of type "read", and copy the value from its invisible parameter to this new parameter after protocol start-up. You can then display the "read" parameter in Element Display.
        ///</summary>
public ParamsParamType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Overrides the "Never ask for confirmation after setting parameter value" setting in DataMiner Cube.
        /// Feature introduced in DataMiner 9.0.0 (RN 11133).
        ///</summary>
public ParamsParamConfirmPopup ConfirmPopup
        {
            get
            {
                return _confirmPopup;
            }

            set
            {
                if (_confirmPopup != value)
                {
                    _confirmPopup = value;
                    AttributeHandler.Assign(value, this, "confirmPopup");
                }
            }
        }

        ///<summary>
        /// Specifies that the value of the parameter on which this attribute is specified should be shown in the specified view table column(s).
        ///</summary>
public AttributeValue<string> DuplicateAs
        {
            get
            {
                return _duplicateAs;
            }

            set
            {
                if (_duplicateAs != value)
                {
                    _duplicateAs = value;
                    AttributeHandler.Assign(value, this, "duplicateAs");
                }
            }
        }

        ///<summary>
        /// Allows exporting a parameter to an exported protocol used by a dynamic virtual element (DVE).
        ///</summary>
public AttributeValue<string> Export
        {
            get
            {
                return _export;
            }

            set
            {
                if (_export != value)
                {
                    _export = value;
                    AttributeHandler.Assign(value, this, "export");
                }
            }
        }

        ///<summary>
        /// Specifies that this parameter is a history set parameter.
        /// If you mark a parameter as a history set parameter, its last set value will not be stored in the trending database when the element is restarted.
        ///</summary>
public AttributeValue<bool?> HistorySet
        {
            get
            {
                return _historySet;
            }

            set
            {
                if (_historySet != value)
                {
                    _historySet = value;
                    AttributeHandler.Assign(value, this, "historySet");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter.
        /// -	Normal protocols: range 1-64000
        /// -	Spectrum analyzers: range 50000-59999
        /// Warning: Never change parameter IDs in existing protocols. This would severely affect alarms, trend displays, MS Visio files, etc.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies the security level of this parameter.
        /// All users of whom the security level is above the one specified in this attribute are able to change (i.e. set) the value of the parameter.
        ///</summary>
public AttributeValue<uint?> Level
        {
            get
            {
                return _level;
            }

            set
            {
                if (_level != value)
                {
                    _level = value;
                    AttributeHandler.Assign(value, this, "level");
                }
            }
        }

        ///<summary>
        /// Specifies the options applied to this parameter.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the polling interval (ms) as a hint for the real-time trend graph.
        ///</summary>
public AttributeValue<uint?> PollingInterval
        {
            get
            {
                return _pollingInterval;
            }

            set
            {
                if (_pollingInterval != value)
                {
                    _pollingInterval = value;
                    AttributeHandler.Assign(value, this, "pollingInterval");
                }
            }
        }

        ///<summary>
        /// Specifies whether the parameter has to be saved each time its value changes.
        /// Default: false
        /// Note: Only applicable for standalone parameters. For column parameters, refer to the "save" option in the Protocol/Params/Param/ArrayOptions/ColumnOptions/ColumnOption@options attribute.
        ///</summary>
public AttributeValue<bool?> Save
        {
            get
            {
                return _save;
            }

            set
            {
                if (_save != value)
                {
                    _save = value;
                    AttributeHandler.Assign(value, this, "save");
                }
            }
        }

        ///<summary>
        /// Specifies the interval at which the parameter values should be saved.
        /// Feature introduced in DataMiner 9.5.7 (RN 16708).
        ///</summary>
public AttributeValue<System.TimeSpan?> SaveInterval
        {
            get
            {
                return _saveInterval;
            }

            set
            {
                if (_saveInterval != value)
                {
                    _saveInterval = value;
                    AttributeHandler.Assign(value, this, "saveInterval");
                }
            }
        }

        ///<summary>
        /// Specifies whether the value of the write parameter will be copied to the corresponding read parameter (with­out the need to add a trigger or an action).
        /// Default: false
        ///</summary>
public AttributeValue<bool?> Setter
        {
            get
            {
                return _setter;
            }

            set
            {
                if (_setter != value)
                {
                    _setter = value;
                    AttributeHandler.Assign(value, this, "setter");
                }
            }
        }

        ///<summary>
        /// Specifies the offload of snapshots of a parameter to the central database.
        /// This option is never set on a table, but on the columns that a snapshot should be taken from.
        /// The behavior is the same as the trending attribute, but does not require a trend template. Also, the data will not be stored in the local database, but in the specified central database. This is done via settings in the Db.xml file.
        /// When this attribute is not present, the snapshot is set to false.
        /// 
        ///</summary>
public AttributeValue<bool?> Snapshot
        {
            get
            {
                return _snapshot;
            }

            set
            {
                if (_snapshot != value)
                {
                    _snapshot = value;
                    AttributeHandler.Assign(value, this, "snapshot");
                }
            }
        }

        ///<summary>
        /// Performs a set and get on a "write" parameter.
        /// When defined on columns with the default value true, cells are retrieved via an Execute Next. The get will not be executed when the set failed.
        /// For a list of possible values, see dynamicSnmpGet.
        /// 
        ///</summary>
public AttributeValue<string> SnmpSetAndGet
        {
            get
            {
                return _snmpSetAndGet;
            }

            set
            {
                if (_snmpSetAndGet != value)
                {
                    _snmpSetAndGet = value;
                    AttributeHandler.Assign(value, this, "snmpSetAndGet");
                }
            }
        }

        ///<summary>
        /// Specifies whether the parameter supports trending.
        /// Default: true
        ///</summary>
public AttributeValue<bool?> Trending
        {
            get
            {
                return _trending;
            }

            set
            {
                if (_trending != value)
                {
                    _trending = value;
                    AttributeHandler.Assign(value, this, "trending");
                }
            }
        }

        ///<summary>
        /// Overrides the default verification timeout (or the verification timeout value set in MaintenanceSettings.xml) for this parameter with the specified value (in milliseconds).
        ///</summary>
public AttributeValue<uint?> VerificationTimeout
        {
            get
            {
                return _verificationTimeout;
            }

            set
            {
                if (_verificationTimeout != value)
                {
                    _verificationTimeout = value;
                    AttributeHandler.Assign(value, this, "verificationTimeout");
                }
            }
        }

        public ParamsParamAlarm GetOrCreateAlarm()
        {
            if (Alarm == null)
                Alarm = new ParamsParamAlarm();
            return Alarm;
        }

        public ParamsParamArrayOptions GetOrCreateArrayOptions()
        {
            if (ArrayOptions == null)
                ArrayOptions = new ParamsParamArrayOptions();
            return ArrayOptions;
        }

        public ParamsParamCRC GetOrCreateCRC()
        {
            if (CRC == null)
                CRC = new ParamsParamCRC();
            return CRC;
        }

        public ParamsParamCrossDriverOptions GetOrCreateCrossDriverOptions()
        {
            if (CrossDriverOptions == null)
                CrossDriverOptions = new ParamsParamCrossDriverOptions();
            return CrossDriverOptions;
        }

        public ParamsParamDashboard GetOrCreateDashboard()
        {
            if (Dashboard == null)
                Dashboard = new ParamsParamDashboard();
            return Dashboard;
        }

        public ParamsParamDatabase GetOrCreateDatabase()
        {
            if (Database == null)
                Database = new ParamsParamDatabase();
            return Database;
        }

        public ParamsParamDependencies GetOrCreateDependencies()
        {
            if (Dependencies == null)
                Dependencies = new ParamsParamDependencies();
            return Dependencies;
        }

        public ElementValue<string> GetOrCreateDescription()
        {
            if (Description == null)
                Description = new ElementValue<string>();
            return Description;
        }

        public ParamsParamDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new ParamsParamDisplay();
            return Display;
        }

        public ParamsParamHyperLinks GetOrCreateHyperLinks()
        {
            if (HyperLinks == null)
                HyperLinks = new ParamsParamHyperLinks();
            return HyperLinks;
        }

        public Icon GetOrCreateIcon()
        {
            if (Icon == null)
                Icon = new Icon("Icon");
            return Icon;
        }

        public ParamsParamInformation GetOrCreateInformation()
        {
            if (Information == null)
                Information = new ParamsParamInformation();
            return Information;
        }

        public ParamsParamInterprete GetOrCreateInterprete()
        {
            if (Interprete == null)
                Interprete = new ParamsParamInterprete();
            return Interprete;
        }

        public ParamsParamLength GetOrCreateLength()
        {
            if (Length == null)
                Length = new ParamsParamLength();
            return Length;
        }

        public ParamsParamMatrix GetOrCreateMatrix()
        {
            if (Matrix == null)
                Matrix = new ParamsParamMatrix();
            return Matrix;
        }

        public ParamsParamMeasurement GetOrCreateMeasurement()
        {
            if (Measurement == null)
                Measurement = new ParamsParamMeasurement();
            return Measurement;
        }

        public ParamsParamMediation GetOrCreateMediation()
        {
            if (Mediation == null)
                Mediation = new ParamsParamMediation();
            return Mediation;
        }

        public ElementValue<string> GetOrCreateMessage()
        {
            if (Message == null)
                Message = new ElementValue<string>();
            return Message;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public ParamsParamReplication GetOrCreateReplication()
        {
            if (Replication == null)
                Replication = new ParamsParamReplication();
            return Replication;
        }

        public ParamsParamSNMP GetOrCreateSNMP()
        {
            if (SNMP == null)
                SNMP = new ParamsParamSNMP();
            return SNMP;
        }

        public ParamsParamType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamType();
            return Type;
        }

        public ParamsParamConfirmPopup GetOrCreateConfirmPopup()
        {
            if (ConfirmPopup == null)
                ConfirmPopup = new ParamsParamConfirmPopup();
            return ConfirmPopup;
        }

        public AttributeValue<string> GetOrCreateDuplicateAs()
        {
            if (DuplicateAs == null)
                DuplicateAs = new AttributeValue<string>();
            return DuplicateAs;
        }

        public AttributeValue<string> GetOrCreateExport()
        {
            if (Export == null)
                Export = new AttributeValue<string>();
            return Export;
        }

        public AttributeValue<bool?> GetOrCreateHistorySet()
        {
            if (HistorySet == null)
                HistorySet = new AttributeValue<bool?>();
            return HistorySet;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<uint?> GetOrCreateLevel()
        {
            if (Level == null)
                Level = new AttributeValue<uint?>();
            return Level;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<uint?> GetOrCreatePollingInterval()
        {
            if (PollingInterval == null)
                PollingInterval = new AttributeValue<uint?>();
            return PollingInterval;
        }

        public AttributeValue<bool?> GetOrCreateSave()
        {
            if (Save == null)
                Save = new AttributeValue<bool?>();
            return Save;
        }

        public AttributeValue<System.TimeSpan?> GetOrCreateSaveInterval()
        {
            if (SaveInterval == null)
                SaveInterval = new AttributeValue<System.TimeSpan?>();
            return SaveInterval;
        }

        public AttributeValue<bool?> GetOrCreateSetter()
        {
            if (Setter == null)
                Setter = new AttributeValue<bool?>();
            return Setter;
        }

        public AttributeValue<bool?> GetOrCreateSnapshot()
        {
            if (Snapshot == null)
                Snapshot = new AttributeValue<bool?>();
            return Snapshot;
        }

        public AttributeValue<string> GetOrCreateSnmpSetAndGet()
        {
            if (SnmpSetAndGet == null)
                SnmpSetAndGet = new AttributeValue<string>();
            return SnmpSetAndGet;
        }

        public AttributeValue<bool?> GetOrCreateTrending()
        {
            if (Trending == null)
                Trending = new AttributeValue<bool?>();
            return Trending;
        }

        public AttributeValue<uint?> GetOrCreateVerificationTimeout()
        {
            if (VerificationTimeout == null)
                VerificationTimeout = new AttributeValue<uint?>();
            return VerificationTimeout;
        }

        protected override void Initialize(Read.IParamsParam read, XmlElement editNode)
        {
            if (read == null)
                return;
            _alarm = read.Alarm != null ? new ParamsParamAlarm(read.Alarm, this, editNode.Element["Alarm"]) : null;
            _arrayOptions = read.ArrayOptions != null ? new ParamsParamArrayOptions(read.ArrayOptions, this, editNode.Element["ArrayOptions"]) : null;
            _cRC = read.CRC != null ? new ParamsParamCRC(read.CRC, this, editNode.Element["CRC"]) : null;
            _crossDriverOptions = read.CrossDriverOptions != null ? new ParamsParamCrossDriverOptions(read.CrossDriverOptions, this, editNode.Element["CrossDriverOptions"]) : null;
            _dashboard = read.Dashboard != null ? new ParamsParamDashboard(read.Dashboard, this, editNode.Element["Dashboard"]) : null;
            _database = read.Database != null ? new ParamsParamDatabase(read.Database, this, editNode.Element["Database"]) : null;
            _dependencies = read.Dependencies != null ? new ParamsParamDependencies(read.Dependencies, this, editNode.Element["Dependencies"]) : null;
            _description = read.Description != null ? new ElementValue<string>(read.Description, this) : null;
            _display = read.Display != null ? new ParamsParamDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _hyperLinks = read.HyperLinks != null ? new ParamsParamHyperLinks(read.HyperLinks, this, editNode.Element["HyperLinks"]) : null;
            _icon = read.Icon != null ? new Icon(read.Icon, this, editNode.Element["Icon"]) : null;
            _information = read.Information != null ? new ParamsParamInformation(read.Information, this, editNode.Element["Information"]) : null;
            _interprete = read.Interprete != null ? new ParamsParamInterprete(read.Interprete, this, editNode.Element["Interprete"]) : null;
            _length = read.Length != null ? new ParamsParamLength(read.Length, this, editNode.Element["Length"]) : null;
            _matrix = read.Matrix != null ? new ParamsParamMatrix(read.Matrix, this, editNode.Element["Matrix"]) : null;
            _measurement = read.Measurement != null ? new ParamsParamMeasurement(read.Measurement, this, editNode.Element["Measurement"]) : null;
            _mediation = read.Mediation != null ? new ParamsParamMediation(read.Mediation, this, editNode.Element["Mediation"]) : null;
            _message = read.Message != null ? new ElementValue<string>(read.Message, this) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _replication = read.Replication != null ? new ParamsParamReplication(read.Replication, this, editNode.Element["Replication"]) : null;
            _sNMP = read.SNMP != null ? new ParamsParamSNMP(read.SNMP, this, editNode.Element["SNMP"]) : null;
            _type = read.Type != null ? new ParamsParamType(read.Type, this, editNode.Element["Type"]) : null;
            _confirmPopup = read.ConfirmPopup != null ? new ParamsParamConfirmPopup(read.ConfirmPopup, this) : null;
            _duplicateAs = read.DuplicateAs != null ? new AttributeValue<string>(read.DuplicateAs, this) : null;
            _export = read.Export != null ? new AttributeValue<string>(read.Export, this) : null;
            _historySet = read.HistorySet != null ? new AttributeValue<bool?>(read.HistorySet, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _level = read.Level != null ? new AttributeValue<uint?>(read.Level, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _pollingInterval = read.PollingInterval != null ? new AttributeValue<uint?>(read.PollingInterval, this) : null;
            _save = read.Save != null ? new AttributeValue<bool?>(read.Save, this) : null;
            _saveInterval = read.SaveInterval != null ? new AttributeValue<System.TimeSpan?>(read.SaveInterval, this) : null;
            _setter = read.Setter != null ? new AttributeValue<bool?>(read.Setter, this) : null;
            _snapshot = read.Snapshot != null ? new AttributeValue<bool?>(read.Snapshot, this) : null;
            _snmpSetAndGet = read.SnmpSetAndGet != null ? new AttributeValue<string>(read.SnmpSetAndGet, this) : null;
            _trending = read.Trending != null ? new AttributeValue<bool?>(read.Trending, this) : null;
            _verificationTimeout = read.VerificationTimeout != null ? new AttributeValue<uint?>(read.VerificationTimeout, this) : null;
        }

        public static ParamsParam FromRead(Read.IParamsParam read)
        {
            if (read == null)
                return null;
            var item = new ParamsParam();
            item.Alarm = ParamsParamAlarm.FromRead(read.Alarm);
            item.ArrayOptions = ParamsParamArrayOptions.FromRead(read.ArrayOptions);
            item.CRC = ParamsParamCRC.FromRead(read.CRC);
            item.CrossDriverOptions = ParamsParamCrossDriverOptions.FromRead(read.CrossDriverOptions);
            item.Dashboard = ParamsParamDashboard.FromRead(read.Dashboard);
            item.Database = ParamsParamDatabase.FromRead(read.Database);
            item.Dependencies = ParamsParamDependencies.FromRead(read.Dependencies);
            item.Description = ElementValue<string>.FromRead(read.Description);
            item.Display = ParamsParamDisplay.FromRead(read.Display);
            item.HyperLinks = ParamsParamHyperLinks.FromRead(read.HyperLinks);
            item.Icon = Icon.FromRead(read.Icon);
            item.Information = ParamsParamInformation.FromRead(read.Information);
            item.Interprete = ParamsParamInterprete.FromRead(read.Interprete);
            item.Length = ParamsParamLength.FromRead(read.Length);
            item.Matrix = ParamsParamMatrix.FromRead(read.Matrix);
            item.Measurement = ParamsParamMeasurement.FromRead(read.Measurement);
            item.Mediation = ParamsParamMediation.FromRead(read.Mediation);
            item.Message = ElementValue<string>.FromRead(read.Message);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.Replication = ParamsParamReplication.FromRead(read.Replication);
            item.SNMP = ParamsParamSNMP.FromRead(read.SNMP);
            item.Type = ParamsParamType.FromRead(read.Type);
            item.ConfirmPopup = ParamsParamConfirmPopup.FromRead(read.ConfirmPopup);
            item.DuplicateAs = AttributeValue<string>.FromRead(read.DuplicateAs);
            item.Export = AttributeValue<string>.FromRead(read.Export);
            item.HistorySet = AttributeValue<bool?>.FromRead(read.HistorySet);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Level = AttributeValue<uint?>.FromRead(read.Level);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.PollingInterval = AttributeValue<uint?>.FromRead(read.PollingInterval);
            item.Save = AttributeValue<bool?>.FromRead(read.Save);
            item.SaveInterval = AttributeValue<System.TimeSpan?>.FromRead(read.SaveInterval);
            item.Setter = AttributeValue<bool?>.FromRead(read.Setter);
            item.Snapshot = AttributeValue<bool?>.FromRead(read.Snapshot);
            item.SnmpSetAndGet = AttributeValue<string>.FromRead(read.SnmpSetAndGet);
            item.Trending = AttributeValue<bool?>.FromRead(read.Trending);
            item.VerificationTimeout = AttributeValue<uint?>.FromRead(read.VerificationTimeout);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParam(this);
        }
    }

    ///<summary>
    /// Specifies the default parameter alarming configuration. Each alarm consists of two components:
    /// -	Severity: Critical, Major, Minor, Warning or Normal
    /// -	Severity Range: Low, Medium or High
    /// These are combined into the following alarm levels:
    /// -	Critical Low (CL)
    /// -	Major Low (MaL)
    /// -	Minor Low (MiL)
    /// -	Warning Low (WaL)
    /// -	Normal (Normal)
    /// -	Warning High (WaH)
    /// -	Minor High (MiH)
    /// -	Major High (MaH)
    /// -	Critical High (CH)
    /// Each alarm level is included in a /Protocol/Params/Param/Alarm element, so a value can be assigned to it. If the value of the monitored parameter is equal to or exceeds
    /// a value included in the /Protocol/Params/Param/Alarm element, DataMiner will process an alarm depending on the alarm level that corresponds to the
    /// value.
    /// These assigned values are not only accessible via the protocol, but also via DataMiner Cuber or System Display. The alarm values of a parameter can be altered by
    /// means of alarm templates, on condition that a /Protocol/Params/Param/Alarm element has been defined for the parameter in the protocol. The alarm
    /// levels of a parameter can be adapted at any moment, regardless of the values specified in the protocol.
    ///</summary>
public partial class ParamsParamAlarm : EditableElementNode<Read.IParamsParamAlarm>
    {
        internal ParamsParamAlarm(Read.IParamsParamAlarm read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Alarm node. None of it's properties will be set.
        ///</summary>
public ParamsParamAlarm() : base("Alarm")
        {
            OnCreated();
        }

        private ElementValue<string> _cH;
        private ElementValue<string> _cL;
        private ElementValue<string> _info;
        private ElementValue<string> _maH;
        private ElementValue<string> _maL;
        private ElementValue<string> _miH;
        private ElementValue<string> _miL;
        private ParamsParamAlarmMonitored _monitored;
        private ElementValue<string> _normal;
        private ElementValue<string> _waH;
        private ElementValue<string> _waL;
        private AttributeValue<uint?> _activeTime;
        private AttributeValue<string> _options;
        private AttributeValue<string> _type;
        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "critical high" alarm.
        ///</summary>
public ElementValue<string> CH
        {
            get
            {
                return _cH;
            }

            set
            {
                if (_cH != value)
                {
                    _cH = value;
                    ElementHandler.Assign(value, this, "CH");
                }
            }
        }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "critical low" alarm.
        ///</summary>
public ElementValue<string> CL
        {
            get
            {
                return _cL;
            }

            set
            {
                if (_cL != value)
                {
                    _cL = value;
                    ElementHandler.Assign(value, this, "CL");
                }
            }
        }

        ///<summary>
        /// When the value of the alarm is equal to the value specified in this element, an information event is generated.
        ///</summary>
public ElementValue<string> Info
        {
            get
            {
                return _info;
            }

            set
            {
                if (_info != value)
                {
                    _info = value;
                    ElementHandler.Assign(value, this, "Info");
                }
            }
        }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "major high" alarm.
        ///</summary>
public ElementValue<string> MaH
        {
            get
            {
                return _maH;
            }

            set
            {
                if (_maH != value)
                {
                    _maH = value;
                    ElementHandler.Assign(value, this, "MaH");
                }
            }
        }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "major low" alarm.
        ///</summary>
public ElementValue<string> MaL
        {
            get
            {
                return _maL;
            }

            set
            {
                if (_maL != value)
                {
                    _maL = value;
                    ElementHandler.Assign(value, this, "MaL");
                }
            }
        }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "minor high" alarm.
        ///</summary>
public ElementValue<string> MiH
        {
            get
            {
                return _miH;
            }

            set
            {
                if (_miH != value)
                {
                    _miH = value;
                    ElementHandler.Assign(value, this, "MiH");
                }
            }
        }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "minor low" alarm.
        ///</summary>
public ElementValue<string> MiL
        {
            get
            {
                return _miL;
            }

            set
            {
                if (_miL != value)
                {
                    _miL = value;
                    ElementHandler.Assign(value, this, "MiL");
                }
            }
        }

        ///<summary>
        /// Allows enabling or disabling the /Protocol/Params/Param/Alarm element assigned to the parameter.
        ///</summary>
public ParamsParamAlarmMonitored Monitored
        {
            get
            {
                return _monitored;
            }

            set
            {
                if (_monitored != value)
                {
                    _monitored = value;
                    CombinedTagHandler.Assign(value, this, "Monitored");
                }
            }
        }

        ///<summary>
        /// When the parameter value equals this value (Integer or String, depending on the type of the parameter) or does not exceed the
        /// specified warning limits, DataMiner will not generate an alarm. If an alarm was generated earlier, its type will be set to "dropped".
        ///</summary>
public ElementValue<string> Normal
        {
            get
            {
                return _normal;
            }

            set
            {
                if (_normal != value)
                {
                    _normal = value;
                    ElementHandler.Assign(value, this, "Normal");
                }
            }
        }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "warning high" alarm.
        ///</summary>
public ElementValue<string> WaH
        {
            get
            {
                return _waH;
            }

            set
            {
                if (_waH != value)
                {
                    _waH = value;
                    ElementHandler.Assign(value, this, "WaH");
                }
            }
        }

        ///<summary>
        /// Defines the default value in the alarm template that this parameter must equal or exceed in order for DataMiner to create a new "warning low" alarm.
        ///</summary>
public ElementValue<string> WaL
        {
            get
            {
                return _waL;
            }

            set
            {
                if (_waL != value)
                {
                    _waL = value;
                    ElementHandler.Assign(value, this, "WaL");
                }
            }
        }

        ///<summary>
        /// In case of a constant alarm: the time (in milliseconds) before the alarm is cleared.
        ///</summary>
public AttributeValue<uint?> ActiveTime
        {
            get
            {
                return _activeTime;
            }

            set
            {
                if (_activeTime != value)
                {
                    _activeTime = value;
                    AttributeHandler.Assign(value, this, "activeTime");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";"). These options can only be used if the table is linked to another table.
        /// -	threshold: When using this option, specify two parameter IDs, separated by a comma. If the value of the second parameter is smaller than the value of the first parameter,
        /// no Alarm will be generated.
        /// -	propertyNames: In this option, specify the property labels to be added to the alarm tab. Multiple names are separated by a comma.
        /// -	properties: In this option, specify the format of the properties to be added to the alarm tab. Always start the properties string with the character used to separate the different formats.
        /// Each property in the string is either a parameter ID or a combination of text and parameter IDs separated by an asterisk ("*"). If the characters between * are numbers only, then they are considered a parameter ID.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// When the polled device is able to send a nominal value for the parameter, this attribute can be added to the /Protocol/Params/Param/Alarm.
        /// - If set to "absolute", the alarm values defined in /Protocol/Params/Param/Alarm will be calculated in accordance with the nominal value sent by the device.
        /// When the "Critical Low" tag contains the value 5, this value will be subtracted from the nominal value to calculate the actual alarm limit.
        /// -	If set to "relative", percentages will be taken instead of absolute values in order to calculate the actual alarm limits. Example: When the "Minor High" element contains 50,
        /// the alarm limit will contain the nominal value increased with 50% of its value.
        /// You can normalize an alarm by (optionally) adding two parameters, separated by a comma.
        /// -	First parameter: The ID of the parameter that holds the nominal value. This can be a dynamic table parameter or a normal parameter. In case of a table parameter,
        /// each row will be compared with the nominal value found in the same row of the specified column.
        /// -	Second parameter: The ID of the parameter that holds the value by which to multiply the nominal value.
        ///</summary>
public AttributeValue<string> Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public ElementValue<string> GetOrCreateCH()
        {
            if (CH == null)
                CH = new ElementValue<string>();
            return CH;
        }

        public ElementValue<string> GetOrCreateCL()
        {
            if (CL == null)
                CL = new ElementValue<string>();
            return CL;
        }

        public ElementValue<string> GetOrCreateInfo()
        {
            if (Info == null)
                Info = new ElementValue<string>();
            return Info;
        }

        public ElementValue<string> GetOrCreateMaH()
        {
            if (MaH == null)
                MaH = new ElementValue<string>();
            return MaH;
        }

        public ElementValue<string> GetOrCreateMaL()
        {
            if (MaL == null)
                MaL = new ElementValue<string>();
            return MaL;
        }

        public ElementValue<string> GetOrCreateMiH()
        {
            if (MiH == null)
                MiH = new ElementValue<string>();
            return MiH;
        }

        public ElementValue<string> GetOrCreateMiL()
        {
            if (MiL == null)
                MiL = new ElementValue<string>();
            return MiL;
        }

        public ParamsParamAlarmMonitored GetOrCreateMonitored()
        {
            if (Monitored == null)
                Monitored = new ParamsParamAlarmMonitored();
            return Monitored;
        }

        public ElementValue<string> GetOrCreateNormal()
        {
            if (Normal == null)
                Normal = new ElementValue<string>();
            return Normal;
        }

        public ElementValue<string> GetOrCreateWaH()
        {
            if (WaH == null)
                WaH = new ElementValue<string>();
            return WaH;
        }

        public ElementValue<string> GetOrCreateWaL()
        {
            if (WaL == null)
                WaL = new ElementValue<string>();
            return WaL;
        }

        public AttributeValue<uint?> GetOrCreateActiveTime()
        {
            if (ActiveTime == null)
                ActiveTime = new AttributeValue<uint?>();
            return ActiveTime;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<string> GetOrCreateType()
        {
            if (Type == null)
                Type = new AttributeValue<string>();
            return Type;
        }

        protected override void Initialize(Read.IParamsParamAlarm read, XmlElement editNode)
        {
            if (read == null)
                return;
            _cH = read.CH != null ? new ElementValue<string>(read.CH, this) : null;
            _cL = read.CL != null ? new ElementValue<string>(read.CL, this) : null;
            _info = read.Info != null ? new ElementValue<string>(read.Info, this) : null;
            _maH = read.MaH != null ? new ElementValue<string>(read.MaH, this) : null;
            _maL = read.MaL != null ? new ElementValue<string>(read.MaL, this) : null;
            _miH = read.MiH != null ? new ElementValue<string>(read.MiH, this) : null;
            _miL = read.MiL != null ? new ElementValue<string>(read.MiL, this) : null;
            _monitored = read.Monitored != null ? new ParamsParamAlarmMonitored(read.Monitored, this, editNode.Element["Monitored"]) : null;
            _normal = read.Normal != null ? new ElementValue<string>(read.Normal, this) : null;
            _waH = read.WaH != null ? new ElementValue<string>(read.WaH, this) : null;
            _waL = read.WaL != null ? new ElementValue<string>(read.WaL, this) : null;
            _activeTime = read.ActiveTime != null ? new AttributeValue<uint?>(read.ActiveTime, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _type = read.Type != null ? new AttributeValue<string>(read.Type, this) : null;
        }

        public static ParamsParamAlarm FromRead(Read.IParamsParamAlarm read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamAlarm();
            item.CH = ElementValue<string>.FromRead(read.CH);
            item.CL = ElementValue<string>.FromRead(read.CL);
            item.Info = ElementValue<string>.FromRead(read.Info);
            item.MaH = ElementValue<string>.FromRead(read.MaH);
            item.MaL = ElementValue<string>.FromRead(read.MaL);
            item.MiH = ElementValue<string>.FromRead(read.MiH);
            item.MiL = ElementValue<string>.FromRead(read.MiL);
            item.Monitored = ParamsParamAlarmMonitored.FromRead(read.Monitored);
            item.Normal = ElementValue<string>.FromRead(read.Normal);
            item.WaH = ElementValue<string>.FromRead(read.WaH);
            item.WaL = ElementValue<string>.FromRead(read.WaL);
            item.ActiveTime = AttributeValue<uint?>.FromRead(read.ActiveTime);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Type = AttributeValue<string>.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamAlarm(this);
        }
    }

    ///<summary>
    /// Allows enabling or disabling the /Protocol/Params/Param/Alarm element assigned to the parameter.
    ///</summary>
public partial class ParamsParamAlarmMonitored : EditableElementValueNode<Read.IParamsParamAlarmMonitored, bool?>
    {
        internal ParamsParamAlarmMonitored(Read.IParamsParamAlarmMonitored read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Monitored node. None of it's properties will be set.
        ///</summary>
public ParamsParamAlarmMonitored() : base("Monitored")
        {
            OnCreated();
        }

        public ParamsParamAlarmMonitored(bool? value) : base("Monitored", value)
        {
        }

        private AttributeValue<string> _disabledIf;
        ///<summary>
        /// Allows monitoring to be disabled when a parameter contains a particular value. Format: "pid,value".
        ///</summary>
public AttributeValue<string> DisabledIf
        {
            get
            {
                return _disabledIf;
            }

            set
            {
                if (_disabledIf != value)
                {
                    _disabledIf = value;
                    AttributeHandler.Assign(value, this, "disabledIf");
                }
            }
        }

        public AttributeValue<string> GetOrCreateDisabledIf()
        {
            if (DisabledIf == null)
                DisabledIf = new AttributeValue<string>();
            return DisabledIf;
        }

        protected override void Initialize(Read.IParamsParamAlarmMonitored read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabledIf = read.DisabledIf != null ? new AttributeValue<string>(read.DisabledIf, this) : null;
        }

        public static ParamsParamAlarmMonitored FromRead(Read.IParamsParamAlarmMonitored read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamAlarmMonitored();
            item.Value = read.Value;
            item.DisabledIf = AttributeValue<string>.FromRead(read.DisabledIf);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamAlarmMonitored(this);
        }
    }

    ///<summary>
    /// Defines all table columns.
    /// Each table column is defined by one or two Parameters:
    /// -	one for read, and/or
    /// -	one for write.
    ///</summary>
public partial class ParamsParamArrayOptions : EditableListNode<Read.IParamsParamArrayOptions, Read.ITypeColumnOption, TypeColumnOption>
    {
        internal ParamsParamArrayOptions(Read.IParamsParamArrayOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ArrayOptions node. None of it's properties will be set.
        ///</summary>
public ParamsParamArrayOptions() : base("ArrayOptions")
        {
            OnCreated();
        }

        private ElementValue<string> _namingFormat;
        private AttributeValue<bool?> _deleteRow;
        private AttributeValue<uint?> _displayColumn;
        private AttributeValue<uint?> _index;
        private AttributeValue<string> _options;
        private AttributeValue<string> _partial;
        private AttributeValue<string> _snmpIndex;
        ///<summary>
        /// Defines the structure of the display key.
        /// The first character denotes the separator used.
        /// Integers between two separators will be used as column pids.
        /// Using any other alphanumeric string between separators will display this string in the row index.
        ///</summary>
public ElementValue<string> NamingFormat
        {
            get
            {
                return _namingFormat;
            }

            set
            {
                if (_namingFormat != value)
                {
                    _namingFormat = value;
                    ElementHandler.Assign(value, this, "NamingFormat");
                }
            }
        }

        ///<summary>
        /// Specifies how non-existing rows should be handled.
        /// This attribute is used in combination with snmpSetAndGet or dynamicSnmpGet functionality on tables.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        /// Feature introduced in DataMiner 8.5.7 (RN 10007).
        /// 
        ///</summary>
public AttributeValue<bool?> DeleteRow
        {
            get
            {
                return _deleteRow;
            }

            set
            {
                if (_deleteRow != value)
                {
                    _deleteRow = value;
                    AttributeHandler.Assign(value, this, "deleteRow");
                }
            }
        }

        ///<summary>
        /// Defines which column is used as an identifier for the user.
        /// This column can be updated, and normally contains a readable key which identifies the row for the user.
        ///</summary>
public AttributeValue<uint?> DisplayColumn
        {
            get
            {
                return _displayColumn;
            }

            set
            {
                if (_displayColumn != value)
                {
                    _displayColumn = value;
                    AttributeHandler.Assign(value, this, "displayColumn");
                }
            }
        }

        ///<summary>
        /// Defines which column contains the primary keys.
        /// The column containing the primary keys has to be of type "string". Once a row is created, the value of the primary key cannot be changed.
        ///</summary>
public AttributeValue<uint?> Index
        {
            get
            {
                return _index;
            }

            set
            {
                if (_index != value)
                {
                    _index = value;
                    AttributeHandler.Assign(value, this, "index");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        /// Note: In this attribute, you can specify multiple values separated by a character of choice (a semi-colon is recommended).
        /// This character has to be the first character in the value of the options attribute. If, for example, you want to separate the different options by a semi-colon, the first character of the options value has to be a semi-colon.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// If set to "true", the table will be subdivided into multiple pages (default: 1000 rows per page).
        /// A page navigator will be displayed at the bottom of the table.
        /// To manually set the number of rows per page, type a colon (":") after "true", followed by the number of rows per page. This value has to be a value between 10 and 5000.
        ///</summary>
public AttributeValue<string> Partial
        {
            get
            {
                return _partial;
            }

            set
            {
                if (_partial != value)
                {
                    _partial = value;
                    AttributeHandler.Assign(value, this, "partial");
                }
            }
        }

        ///<summary>
        /// Defines the columns that are used when you retrieve the table using SNMP.
        /// If you want a concatenation of multiple columns, you can separate them with semicolons (";").
        ///</summary>
public AttributeValue<string> SnmpIndex
        {
            get
            {
                return _snmpIndex;
            }

            set
            {
                if (_snmpIndex != value)
                {
                    _snmpIndex = value;
                    AttributeHandler.Assign(value, this, "snmpIndex");
                }
            }
        }

        public ElementValue<string> GetOrCreateNamingFormat()
        {
            if (NamingFormat == null)
                NamingFormat = new ElementValue<string>();
            return NamingFormat;
        }

        public AttributeValue<bool?> GetOrCreateDeleteRow()
        {
            if (DeleteRow == null)
                DeleteRow = new AttributeValue<bool?>();
            return DeleteRow;
        }

        public AttributeValue<uint?> GetOrCreateDisplayColumn()
        {
            if (DisplayColumn == null)
                DisplayColumn = new AttributeValue<uint?>();
            return DisplayColumn;
        }

        public AttributeValue<uint?> GetOrCreateIndex()
        {
            if (Index == null)
                Index = new AttributeValue<uint?>();
            return Index;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<string> GetOrCreatePartial()
        {
            if (Partial == null)
                Partial = new AttributeValue<string>();
            return Partial;
        }

        public AttributeValue<string> GetOrCreateSnmpIndex()
        {
            if (SnmpIndex == null)
                SnmpIndex = new AttributeValue<string>();
            return SnmpIndex;
        }

        protected override void Initialize(Read.IParamsParamArrayOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _namingFormat = read.NamingFormat != null ? new ElementValue<string>(read.NamingFormat, this) : null;
            _deleteRow = read.DeleteRow != null ? new AttributeValue<bool?>(read.DeleteRow, this) : null;
            _displayColumn = read.DisplayColumn != null ? new AttributeValue<uint?>(read.DisplayColumn, this) : null;
            _index = read.Index != null ? new AttributeValue<uint?>(read.Index, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _partial = read.Partial != null ? new AttributeValue<string>(read.Partial, this) : null;
            _snmpIndex = read.SnmpIndex != null ? new AttributeValue<string>(read.SnmpIndex, this) : null;
        }

        public static ParamsParamArrayOptions FromRead(Read.IParamsParamArrayOptions read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamArrayOptions();
            item.NamingFormat = ElementValue<string>.FromRead(read.NamingFormat);
            item.DeleteRow = AttributeValue<bool?>.FromRead(read.DeleteRow);
            item.DisplayColumn = AttributeValue<uint?>.FromRead(read.DisplayColumn);
            item.Index = AttributeValue<uint?>.FromRead(read.Index);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Partial = AttributeValue<string>.FromRead(read.Partial);
            item.SnmpIndex = AttributeValue<string>.FromRead(read.SnmpIndex);
            foreach (var x in read)
            {
                item.Add(TypeColumnOption.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamArrayOptions(this);
        }
    }

    ///<summary>
    /// Defines the structure of the display key.
    /// The first character denotes the separator used.
    /// Integers between two separators will be used as column pids.
    /// Using any other alphanumeric string between separators will display this string in the row index.
    ///</summary>
public partial class ParamsParamArrayOptionsNamingFormat : ElementValue<string>
    {
        internal ParamsParamArrayOptionsNamingFormat(Read.IParamsParamArrayOptionsNamingFormat read, IEditableNode parent, bool useCDATA = false) : base(read, parent, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a NamingFormat node. None of it's properties will be set.
        ///</summary>
public ParamsParamArrayOptionsNamingFormat(bool useCDATA = false) : base(useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamArrayOptionsNamingFormat(string value, bool useCDATA = false) : base(value, useCDATA: useCDATA)
        {
        }

        public static ParamsParamArrayOptionsNamingFormat FromRead(Read.IParamsParamArrayOptionsNamingFormat read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamArrayOptionsNamingFormat();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamArrayOptionsNamingFormat(this);
        }
    }

    ///<summary>
    /// If /Protocol/Params/Param/Type is set to "CRC", then this CRC element allows you to define the CRC used in the communication with the device.
    /// The information you specify here will be used to calculate the CRC of the command/response.
    ///</summary>
public partial class ParamsParamCRC : EditableElementNode<Read.IParamsParamCRC>
    {
        internal ParamsParamCRC(Read.IParamsParamCRC read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CRC node. None of it's properties will be set.
        ///</summary>
public ParamsParamCRC() : base("CRC")
        {
            OnCreated();
        }

        private ParamsParamCRCContent _content;
        private ParamsParamCRCType _type;
        ///<summary>
        /// Specifies the parameters of the command/response to be included in the CRC calculation. In other words, the operation specified in
        /// /Protocol/Params/Param/CRC/Type will only be performed on the parameters that make up the content.
        /// Note: The first parameter of the command/response has ID 0.
        ///</summary>
public ParamsParamCRCContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        ///<summary>
        /// Defines the CRC calculation algorithm.
        ///</summary>
public ParamsParamCRCType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        public ParamsParamCRCContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new ParamsParamCRCContent();
            return Content;
        }

        public ParamsParamCRCType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamCRCType();
            return Type;
        }

        protected override void Initialize(Read.IParamsParamCRC read, XmlElement editNode)
        {
            if (read == null)
                return;
            _content = read.Content != null ? new ParamsParamCRCContent(read.Content, this, editNode.Element["Content"]) : null;
            _type = read.Type != null ? new ParamsParamCRCType(read.Type, this, editNode.Element["Type"]) : null;
        }

        public static ParamsParamCRC FromRead(Read.IParamsParamCRC read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamCRC();
            item.Content = ParamsParamCRCContent.FromRead(read.Content);
            item.Type = ParamsParamCRCType.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCRC(this);
        }
    }

    ///<summary>
    /// Specifies the parameters of the command/response to be included in the CRC calculation. In other words, the operation specified in
    /// /Protocol/Params/Param/CRC/Type will only be performed on the parameters that make up the content.
    /// Note: The first parameter of the command/response has ID 0.
    ///</summary>
public partial class ParamsParamCRCContent : EditableListNode<Read.IParamsParamCRCContent, Read.IParamsParamCRCContentParam, ParamsParamCRCContentParam>
    {
        internal ParamsParamCRCContent(Read.IParamsParamCRCContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public ParamsParamCRCContent() : base("Content")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamCRCContent read, XmlElement editNode)
        {
        }

        public static ParamsParamCRCContent FromRead(Read.IParamsParamCRCContent read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamCRCContent();
            foreach (var x in read)
            {
                item.Add(ParamsParamCRCContentParam.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCRCContent(this);
        }
    }

    ///<summary>
    /// Specifies a parameter of the command/response to be included in the CRC calculation.
    ///</summary>
public partial class ParamsParamCRCContentParam : EditableElementValueNode<Read.IParamsParamCRCContentParam, uint?>
    {
        internal ParamsParamCRCContentParam(Read.IParamsParamCRCContentParam read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Param node. None of it's properties will be set.
        ///</summary>
public ParamsParamCRCContentParam() : base("Param")
        {
            OnCreated();
        }

        public ParamsParamCRCContentParam(uint? value) : base("Param", value)
        {
        }

        protected override void Initialize(Read.IParamsParamCRCContentParam read, XmlElement editNode)
        {
        }

        public static ParamsParamCRCContentParam FromRead(Read.IParamsParamCRCContentParam read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamCRCContentParam();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCRCContentParam(this);
        }
    }

    ///<summary>
    /// Defines the CRC calculation algorithm.
    ///</summary>
public partial class ParamsParamCRCType : EditableElementValueNode<Read.IParamsParamCRCType, Enums.EnumParamCRCType?>
    {
        internal ParamsParamCRCType(Read.IParamsParamCRCType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ParamsParamCRCType() : base("Type")
        {
            OnCreated();
        }

        public ParamsParamCRCType(Enums.EnumParamCRCType? value) : base("Type", value)
        {
        }

        private AttributeValue<int?> _byteoffset;
        private AttributeValue<string> _groupbytes;
        private AttributeValue<uint?> _mod;
        private AttributeValue<int?> _off;
        private AttributeValue<string> _options;
        private AttributeValue<uint?> _totaloffset;
        ///<summary>
        /// Allows to add an offset to every single byte of the CRC.
        /// Can be used in combination with all possible CRC types.
        ///</summary>
public AttributeValue<int?> Byteoffset
        {
            get
            {
                return _byteoffset;
            }

            set
            {
                if (_byteoffset != value)
                {
                    _byteoffset = value;
                    AttributeHandler.Assign(value, this, "byteoffset");
                }
            }
        }

        ///<summary>
        /// Specifies the number of bytes on which to perform the operation.
        /// Only valid if the CRC type is set to one of the following values: LSB after subtract, LSB after sum, Exor, Sum
        ///</summary>
public AttributeValue<string> Groupbytes
        {
            get
            {
                return _groupbytes;
            }

            set
            {
                if (_groupbytes != value)
                {
                    _groupbytes = value;
                    AttributeHandler.Assign(value, this, "groupbytes");
                }
            }
        }

        ///<summary>
        /// Specifies that a modulo operation has to be performed on the CRC after it has been calculated.
        ///</summary>
public AttributeValue<uint?> Mod
        {
            get
            {
                return _mod;
            }

            set
            {
                if (_mod != value)
                {
                    _mod = value;
                    AttributeHandler.Assign(value, this, "mod");
                }
            }
        }

        ///<summary>
        /// Specifies an offset value to be added to the calculated CRC.
        /// Only valid if the CRC type is set to one of the following values: LSB after subtract, LSB after sum, Rest, Subtract, Sum.
        ///</summary>
public AttributeValue<int?> Off
        {
            get
            {
                return _off;
            }

            set
            {
                if (_off != value)
                {
                    _off = value;
                    AttributeHandler.Assign(value, this, "off");
                }
            }
        }

        ///<summary>
        /// Specifies additional options, separated by semi-colons (";"). Available options:
        /// -	ones complement: each bit of the calculated CRC will be inverted. (Example: AAAA will become 5555)
        /// -	or totaloffset: the "totaloffset" value will not be added but "OR"-ed.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies an offset value to be added to the CRC after it has been calculated.
        ///</summary>
public AttributeValue<uint?> Totaloffset
        {
            get
            {
                return _totaloffset;
            }

            set
            {
                if (_totaloffset != value)
                {
                    _totaloffset = value;
                    AttributeHandler.Assign(value, this, "totaloffset");
                }
            }
        }

        public AttributeValue<int?> GetOrCreateByteoffset()
        {
            if (Byteoffset == null)
                Byteoffset = new AttributeValue<int?>();
            return Byteoffset;
        }

        public AttributeValue<string> GetOrCreateGroupbytes()
        {
            if (Groupbytes == null)
                Groupbytes = new AttributeValue<string>();
            return Groupbytes;
        }

        public AttributeValue<uint?> GetOrCreateMod()
        {
            if (Mod == null)
                Mod = new AttributeValue<uint?>();
            return Mod;
        }

        public AttributeValue<int?> GetOrCreateOff()
        {
            if (Off == null)
                Off = new AttributeValue<int?>();
            return Off;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<uint?> GetOrCreateTotaloffset()
        {
            if (Totaloffset == null)
                Totaloffset = new AttributeValue<uint?>();
            return Totaloffset;
        }

        protected override void Initialize(Read.IParamsParamCRCType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _byteoffset = read.Byteoffset != null ? new AttributeValue<int?>(read.Byteoffset, this) : null;
            _groupbytes = read.Groupbytes != null ? new AttributeValue<string>(read.Groupbytes, this) : null;
            _mod = read.Mod != null ? new AttributeValue<uint?>(read.Mod, this) : null;
            _off = read.Off != null ? new AttributeValue<int?>(read.Off, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _totaloffset = read.Totaloffset != null ? new AttributeValue<uint?>(read.Totaloffset, this) : null;
        }

        public static ParamsParamCRCType FromRead(Read.IParamsParamCRCType read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamCRCType();
            item.Value = read.Value;
            item.Byteoffset = AttributeValue<int?>.FromRead(read.Byteoffset);
            item.Groupbytes = AttributeValue<string>.FromRead(read.Groupbytes);
            item.Mod = AttributeValue<uint?>.FromRead(read.Mod);
            item.Off = AttributeValue<int?>.FromRead(read.Off);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Totaloffset = AttributeValue<uint?>.FromRead(read.Totaloffset);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCRCType(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamCRCTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamCRCType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamCRCTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Allows building a direct view table using multiple columns from multiple different protocols. Feature introduced in DataMiner 10.2.9 (RN 33253).
    ///</summary>
public partial class ParamsParamCrossDriverOptions : EditableListNode<Read.IParamsParamCrossDriverOptions, Read.IParamsParamCrossDriverOptionsCrossDriverOption, ParamsParamCrossDriverOptionsCrossDriverOption>
    {
        internal ParamsParamCrossDriverOptions(Read.IParamsParamCrossDriverOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CrossDriverOptions node. None of it's properties will be set.
        ///</summary>
public ParamsParamCrossDriverOptions() : base("CrossDriverOptions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamCrossDriverOptions read, XmlElement editNode)
        {
        }

        public static ParamsParamCrossDriverOptions FromRead(Read.IParamsParamCrossDriverOptions read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamCrossDriverOptions();
            foreach (var x in read)
            {
                item.Add(ParamsParamCrossDriverOptionsCrossDriverOption.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCrossDriverOptions(this);
        }
    }

    ///<summary>
    /// Specifies column mappings from a remote protocol to this protocol.
    ///</summary>
public partial class ParamsParamCrossDriverOptionsCrossDriverOption : EditableListNode<Read.IParamsParamCrossDriverOptionsCrossDriverOption, Read.IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation, ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation>
    {
        internal ParamsParamCrossDriverOptionsCrossDriverOption(Read.IParamsParamCrossDriverOptionsCrossDriverOption read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CrossDriverOption node. None of it's properties will be set.
        ///</summary>
public ParamsParamCrossDriverOptionsCrossDriverOption() : base("CrossDriverOption")
        {
            OnCreated();
        }

        private AttributeValue<string> _protocol;
        private AttributeValue<uint?> _remoteTablePID;
        ///<summary>
        /// Specifies the name of the protocol.
        ///</summary>
public AttributeValue<string> Protocol
        {
            get
            {
                return _protocol;
            }

            set
            {
                if (_protocol != value)
                {
                    _protocol = value;
                    AttributeHandler.Assign(value, this, "protocol");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter ID of the remote table.
        ///</summary>
public AttributeValue<uint?> RemoteTablePID
        {
            get
            {
                return _remoteTablePID;
            }

            set
            {
                if (_remoteTablePID != value)
                {
                    _remoteTablePID = value;
                    AttributeHandler.Assign(value, this, "remoteTablePID");
                }
            }
        }

        public AttributeValue<string> GetOrCreateProtocol()
        {
            if (Protocol == null)
                Protocol = new AttributeValue<string>();
            return Protocol;
        }

        public AttributeValue<uint?> GetOrCreateRemoteTablePID()
        {
            if (RemoteTablePID == null)
                RemoteTablePID = new AttributeValue<uint?>();
            return RemoteTablePID;
        }

        protected override void Initialize(Read.IParamsParamCrossDriverOptionsCrossDriverOption read, XmlElement editNode)
        {
            if (read == null)
                return;
            _protocol = read.Protocol != null ? new AttributeValue<string>(read.Protocol, this) : null;
            _remoteTablePID = read.RemoteTablePID != null ? new AttributeValue<uint?>(read.RemoteTablePID, this) : null;
        }

        public static ParamsParamCrossDriverOptionsCrossDriverOption FromRead(Read.IParamsParamCrossDriverOptionsCrossDriverOption read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamCrossDriverOptionsCrossDriverOption();
            item.Protocol = AttributeValue<string>.FromRead(read.Protocol);
            item.RemoteTablePID = AttributeValue<uint?>.FromRead(read.RemoteTablePID);
            foreach (var x in read)
            {
                item.Add(ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCrossDriverOptionsCrossDriverOption(this);
        }
    }

    ///<summary>
    /// Maps a column parameter ID from the remote protocol to this protocol.
    ///</summary>
public partial class ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation : EditableElementNode<Read.IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation>
    {
        internal ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation(Read.IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PIDTranslation node. None of it's properties will be set.
        ///</summary>
public ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation() : base("PIDTranslation")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _local;
        private AttributeValue<uint?> _remote;
        ///<summary>
        /// Specifies the parameter ID of the column in this protocol.
        ///</summary>
public AttributeValue<uint?> Local
        {
            get
            {
                return _local;
            }

            set
            {
                if (_local != value)
                {
                    _local = value;
                    AttributeHandler.Assign(value, this, "local");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter ID of the column in the remote protocol.
        ///</summary>
public AttributeValue<uint?> Remote
        {
            get
            {
                return _remote;
            }

            set
            {
                if (_remote != value)
                {
                    _remote = value;
                    AttributeHandler.Assign(value, this, "remote");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateLocal()
        {
            if (Local == null)
                Local = new AttributeValue<uint?>();
            return Local;
        }

        public AttributeValue<uint?> GetOrCreateRemote()
        {
            if (Remote == null)
                Remote = new AttributeValue<uint?>();
            return Remote;
        }

        protected override void Initialize(Read.IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation read, XmlElement editNode)
        {
            if (read == null)
                return;
            _local = read.Local != null ? new AttributeValue<uint?>(read.Local, this) : null;
            _remote = read.Remote != null ? new AttributeValue<uint?>(read.Remote, this) : null;
        }

        public static ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation FromRead(Read.IParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation();
            item.Local = AttributeValue<uint?>.FromRead(read.Local);
            item.Remote = AttributeValue<uint?>.FromRead(read.Remote);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation(this);
        }
    }

    ///<summary>
    /// Specifies the configuration for use in dashboards.
    ///</summary>
public partial class ParamsParamDashboard : EditableElementNode<Read.IParamsParamDashboard>
    {
        internal ParamsParamDashboard(Read.IParamsParamDashboard read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Dashboard node. None of it's properties will be set.
        ///</summary>
public ParamsParamDashboard() : base("Dashboard")
        {
            OnCreated();
        }

        private ElementValue<string> _type;
        private ParamsParamDashboardDashboardOptions _dashboardOptions;
        ///<summary>
        /// Indicates the type of button panel.
        ///</summary>
public ElementValue<string> Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    ElementHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Groups the options that will determine how the button panel is displayed.
        ///</summary>
public ParamsParamDashboardDashboardOptions DashboardOptions
        {
            get
            {
                return _dashboardOptions;
            }

            set
            {
                if (_dashboardOptions != value)
                {
                    _dashboardOptions = value;
                    CombinedTagHandler.Assign(value, this, "DashboardOptions");
                }
            }
        }

        public ElementValue<string> GetOrCreateType()
        {
            if (Type == null)
                Type = new ElementValue<string>();
            return Type;
        }

        public ParamsParamDashboardDashboardOptions GetOrCreateDashboardOptions()
        {
            if (DashboardOptions == null)
                DashboardOptions = new ParamsParamDashboardDashboardOptions();
            return DashboardOptions;
        }

        protected override void Initialize(Read.IParamsParamDashboard read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new ElementValue<string>(read.Type, this) : null;
            _dashboardOptions = read.DashboardOptions != null ? new ParamsParamDashboardDashboardOptions(read.DashboardOptions, this, editNode.Element["DashboardOptions"]) : null;
        }

        public static ParamsParamDashboard FromRead(Read.IParamsParamDashboard read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDashboard();
            item.Type = ElementValue<string>.FromRead(read.Type);
            item.DashboardOptions = ParamsParamDashboardDashboardOptions.FromRead(read.DashboardOptions);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDashboard(this);
        }
    }

    ///<summary>
    /// Groups the options that will determine how the button panel is displayed.
    ///</summary>
public partial class ParamsParamDashboardDashboardOptions : EditableListNode<Read.IParamsParamDashboardDashboardOptions, Read.IParamsParamDashboardDashboardOptionsDashboardOption, ParamsParamDashboardDashboardOptionsDashboardOption>
    {
        internal ParamsParamDashboardDashboardOptions(Read.IParamsParamDashboardDashboardOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DashboardOptions node. None of it's properties will be set.
        ///</summary>
public ParamsParamDashboardDashboardOptions() : base("DashboardOptions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamDashboardDashboardOptions read, XmlElement editNode)
        {
        }

        public static ParamsParamDashboardDashboardOptions FromRead(Read.IParamsParamDashboardDashboardOptions read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDashboardDashboardOptions();
            foreach (var x in read)
            {
                item.Add(ParamsParamDashboardDashboardOptionsDashboardOption.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDashboardDashboardOptions(this);
        }
    }

    ///<summary>
    /// Specifies how the button panel is displayed.
    ///</summary>
public partial class ParamsParamDashboardDashboardOptionsDashboardOption : EditableElementValueNode<Read.IParamsParamDashboardDashboardOptionsDashboardOption, uint?>
    {
        internal ParamsParamDashboardDashboardOptionsDashboardOption(Read.IParamsParamDashboardDashboardOptionsDashboardOption read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DashboardOption node. None of it's properties will be set.
        ///</summary>
public ParamsParamDashboardDashboardOptionsDashboardOption() : base("DashboardOption")
        {
            OnCreated();
        }

        public ParamsParamDashboardDashboardOptionsDashboardOption(uint? value) : base("DashboardOption", value)
        {
        }

        private AttributeValue<string> _type;
        private AttributeValue<string> _name;
        ///<summary>
        /// Specifies whether the value denotes a column index or a parameter ID.
        ///</summary>
public AttributeValue<string> Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the option.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public AttributeValue<string> GetOrCreateType()
        {
            if (Type == null)
                Type = new AttributeValue<string>();
            return Type;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.IParamsParamDashboardDashboardOptionsDashboardOption read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new AttributeValue<string>(read.Type, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static ParamsParamDashboardDashboardOptionsDashboardOption FromRead(Read.IParamsParamDashboardDashboardOptionsDashboardOption read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDashboardDashboardOptionsDashboardOption();
            item.Value = read.Value;
            item.Type = AttributeValue<string>.FromRead(read.Type);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDashboardDashboardOptionsDashboardOption(this);
        }
    }

    ///<summary>
    /// Specifies database-related configuration options.
    /// Feature introduced in DataMiner 9.0.0 (RN 11853).
    ///</summary>
public partial class ParamsParamDatabase : EditableElementNode<Read.IParamsParamDatabase>
    {
        internal ParamsParamDatabase(Read.IParamsParamDatabase read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Database node. None of it's properties will be set.
        ///</summary>
public ParamsParamDatabase() : base("Database")
        {
            OnCreated();
        }

        private ParamsParamDatabaseColumnDefinition _columnDefinition;
        private ParamsParamDatabaseConnection _connection;
        private ParamsParamDatabaseCQLOptions _cQLOptions;
        private ParamsParamDatabasePartition _partition;
        private ParamsParamDatabaseIndexingOptions _indexingOptions;
        ///<summary>
        /// Specifies the type of the corresponding column in the database table.
        ///</summary>
public ParamsParamDatabaseColumnDefinition ColumnDefinition
        {
            get
            {
                return _columnDefinition;
            }

            set
            {
                if (_columnDefinition != value)
                {
                    _columnDefinition = value;
                    CombinedTagHandler.Assign(value, this, "ColumnDefinition");
                }
            }
        }

        ///<summary>
        /// Specifies connection options.
        ///</summary>
public ParamsParamDatabaseConnection Connection
        {
            get
            {
                return _connection;
            }

            set
            {
                if (_connection != value)
                {
                    _connection = value;
                    CombinedTagHandler.Assign(value, this, "Connection");
                }
            }
        }

        ///<summary>
        /// Specifies Cassandra-related database settings.
        /// Feature introduced in DataMiner 9.0.0 (RN 11853).
        ///</summary>
public ParamsParamDatabaseCQLOptions CQLOptions
        {
            get
            {
                return _cQLOptions;
            }

            set
            {
                if (_cQLOptions != value)
                {
                    _cQLOptions = value;
                    CombinedTagHandler.Assign(value, this, "CQLOptions");
                }
            }
        }

        ///<summary>
        /// Specifies the partitioning configuration.
        ///</summary>
public ParamsParamDatabasePartition Partition
        {
            get
            {
                return _partition;
            }

            set
            {
                if (_partition != value)
                {
                    _partition = value;
                    CombinedTagHandler.Assign(value, this, "Partition");
                }
            }
        }

        ///<summary>
        /// Specifies indexing options (Elastic).
        /// Feature introduced in DataMiner 9.6.4 (RN 13552).
        ///</summary>
public ParamsParamDatabaseIndexingOptions IndexingOptions
        {
            get
            {
                return _indexingOptions;
            }

            set
            {
                if (_indexingOptions != value)
                {
                    _indexingOptions = value;
                    CombinedTagHandler.Assign(value, this, "IndexingOptions");
                }
            }
        }

        public ParamsParamDatabaseColumnDefinition GetOrCreateColumnDefinition()
        {
            if (ColumnDefinition == null)
                ColumnDefinition = new ParamsParamDatabaseColumnDefinition();
            return ColumnDefinition;
        }

        public ParamsParamDatabaseConnection GetOrCreateConnection()
        {
            if (Connection == null)
                Connection = new ParamsParamDatabaseConnection();
            return Connection;
        }

        public ParamsParamDatabaseCQLOptions GetOrCreateCQLOptions()
        {
            if (CQLOptions == null)
                CQLOptions = new ParamsParamDatabaseCQLOptions();
            return CQLOptions;
        }

        public ParamsParamDatabasePartition GetOrCreatePartition()
        {
            if (Partition == null)
                Partition = new ParamsParamDatabasePartition();
            return Partition;
        }

        public ParamsParamDatabaseIndexingOptions GetOrCreateIndexingOptions()
        {
            if (IndexingOptions == null)
                IndexingOptions = new ParamsParamDatabaseIndexingOptions();
            return IndexingOptions;
        }

        protected override void Initialize(Read.IParamsParamDatabase read, XmlElement editNode)
        {
            if (read == null)
                return;
            _columnDefinition = read.ColumnDefinition != null ? new ParamsParamDatabaseColumnDefinition(read.ColumnDefinition, this, editNode.Element["ColumnDefinition"]) : null;
            _connection = read.Connection != null ? new ParamsParamDatabaseConnection(read.Connection, this, editNode.Element["Connection"]) : null;
            _cQLOptions = read.CQLOptions != null ? new ParamsParamDatabaseCQLOptions(read.CQLOptions, this, editNode.Element["CQLOptions"]) : null;
            _partition = read.Partition != null ? new ParamsParamDatabasePartition(read.Partition, this, editNode.Element["Partition"]) : null;
            _indexingOptions = read.IndexingOptions != null ? new ParamsParamDatabaseIndexingOptions(read.IndexingOptions, this, editNode.Element["IndexingOptions"]) : null;
        }

        public static ParamsParamDatabase FromRead(Read.IParamsParamDatabase read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDatabase();
            item.ColumnDefinition = ParamsParamDatabaseColumnDefinition.FromRead(read.ColumnDefinition);
            item.Connection = ParamsParamDatabaseConnection.FromRead(read.Connection);
            item.CQLOptions = ParamsParamDatabaseCQLOptions.FromRead(read.CQLOptions);
            item.Partition = ParamsParamDatabasePartition.FromRead(read.Partition);
            item.IndexingOptions = ParamsParamDatabaseIndexingOptions.FromRead(read.IndexingOptions);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabase(this);
        }
    }

    ///<summary>
    /// Specifies the type of the corresponding column in the database table.
    ///</summary>
public partial class ParamsParamDatabaseColumnDefinition : EditableElementValueNode<Read.IParamsParamDatabaseColumnDefinition, string>
    {
        internal ParamsParamDatabaseColumnDefinition(Read.IParamsParamDatabaseColumnDefinition read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ColumnDefinition node. None of it's properties will be set.
        ///</summary>
public ParamsParamDatabaseColumnDefinition(bool useCDATA = false) : base("ColumnDefinition", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamDatabaseColumnDefinition(string value, bool useCDATA = false) : base("ColumnDefinition", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _default;
        ///<summary>
        /// Specifies the default value.
        ///</summary>
public AttributeValue<string> Default
        {
            get
            {
                return _default;
            }

            set
            {
                if (_default != value)
                {
                    _default = value;
                    AttributeHandler.Assign(value, this, "default");
                }
            }
        }

        public AttributeValue<string> GetOrCreateDefault()
        {
            if (Default == null)
                Default = new AttributeValue<string>();
            return Default;
        }

        protected override void Initialize(Read.IParamsParamDatabaseColumnDefinition read, XmlElement editNode)
        {
            if (read == null)
                return;
            _default = read.Default != null ? new AttributeValue<string>(read.Default, this) : null;
        }

        public static ParamsParamDatabaseColumnDefinition FromRead(Read.IParamsParamDatabaseColumnDefinition read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDatabaseColumnDefinition();
            item.Value = read.Value;
            item.Default = AttributeValue<string>.FromRead(read.Default);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabaseColumnDefinition(this);
        }
    }

    ///<summary>
    /// Specifies connection options.
    ///</summary>
public partial class ParamsParamDatabaseConnection : EditableElementNode<Read.IParamsParamDatabaseConnection>
    {
        internal ParamsParamDatabaseConnection(Read.IParamsParamDatabaseConnection read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Connection node. None of it's properties will be set.
        ///</summary>
public ParamsParamDatabaseConnection() : base("Connection")
        {
            OnCreated();
        }

        private ElementValue<string> _type;
        ///<summary>
        /// Specifies the connection type.
        ///</summary>
public ElementValue<string> Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    ElementHandler.Assign(value, this, "Type");
                }
            }
        }

        public ElementValue<string> GetOrCreateType()
        {
            if (Type == null)
                Type = new ElementValue<string>();
            return Type;
        }

        protected override void Initialize(Read.IParamsParamDatabaseConnection read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new ElementValue<string>(read.Type, this) : null;
        }

        public static ParamsParamDatabaseConnection FromRead(Read.IParamsParamDatabaseConnection read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDatabaseConnection();
            item.Type = ElementValue<string>.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabaseConnection(this);
        }
    }

    ///<summary>
    /// Specifies Cassandra-related database settings.
    /// Feature introduced in DataMiner 9.0.0 (RN 11853).
    ///</summary>
public partial class ParamsParamDatabaseCQLOptions : EditableElementNode<Read.IParamsParamDatabaseCQLOptions>
    {
        internal ParamsParamDatabaseCQLOptions(Read.IParamsParamDatabaseCQLOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a CQLOptions node. None of it's properties will be set.
        ///</summary>
public ParamsParamDatabaseCQLOptions() : base("CQLOptions")
        {
            OnCreated();
        }

        private ElementValue<string> _clustering;
        private ElementValue<string> _finalizer;
        private ElementValue<string> _tableProperty;
        ///<summary>
        /// Specifies how the primary key of the table is defined.
        /// Contains a semicolon separated list of column idx values denoting the columns that form the primary key.
        ///</summary>
public ElementValue<string> Clustering
        {
            get
            {
                return _clustering;
            }

            set
            {
                if (_clustering != value)
                {
                    _clustering = value;
                    ElementHandler.Assign(value, this, "Clustering");
                }
            }
        }

        ///<summary>
        /// Specifies the query that has to be executed after the creation of the table. This can for example be a query that will preload data or create indexes.
        ///</summary>
public ElementValue<string> Finalizer
        {
            get
            {
                return _finalizer;
            }

            set
            {
                if (_finalizer != value)
                {
                    _finalizer = value;
                    ElementHandler.Assign(value, this, "Finalizer");
                }
            }
        }

        ///<summary>
        /// Specifies the WITH clause that is to be used to set the necessary table properties.
        ///</summary>
public ElementValue<string> TableProperty
        {
            get
            {
                return _tableProperty;
            }

            set
            {
                if (_tableProperty != value)
                {
                    _tableProperty = value;
                    ElementHandler.Assign(value, this, "TableProperty");
                }
            }
        }

        public ElementValue<string> GetOrCreateClustering()
        {
            if (Clustering == null)
                Clustering = new ElementValue<string>();
            return Clustering;
        }

        public ElementValue<string> GetOrCreateFinalizer()
        {
            if (Finalizer == null)
                Finalizer = new ElementValue<string>();
            return Finalizer;
        }

        public ElementValue<string> GetOrCreateTableProperty()
        {
            if (TableProperty == null)
                TableProperty = new ElementValue<string>();
            return TableProperty;
        }

        protected override void Initialize(Read.IParamsParamDatabaseCQLOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _clustering = read.Clustering != null ? new ElementValue<string>(read.Clustering, this) : null;
            _finalizer = read.Finalizer != null ? new ElementValue<string>(read.Finalizer, this) : null;
            _tableProperty = read.TableProperty != null ? new ElementValue<string>(read.TableProperty, this) : null;
        }

        public static ParamsParamDatabaseCQLOptions FromRead(Read.IParamsParamDatabaseCQLOptions read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDatabaseCQLOptions();
            item.Clustering = ElementValue<string>.FromRead(read.Clustering);
            item.Finalizer = ElementValue<string>.FromRead(read.Finalizer);
            item.TableProperty = ElementValue<string>.FromRead(read.TableProperty);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabaseCQLOptions(this);
        }
    }

    ///<summary>
    /// Specifies the partitioning configuration.
    ///</summary>
public partial class ParamsParamDatabasePartition : EditableElementValueNode<Read.IParamsParamDatabasePartition, Enums.EnumDatabasePartition?>
    {
        internal ParamsParamDatabasePartition(Read.IParamsParamDatabasePartition read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Partition node. None of it's properties will be set.
        ///</summary>
public ParamsParamDatabasePartition() : base("Partition")
        {
            OnCreated();
        }

        public ParamsParamDatabasePartition(Enums.EnumDatabasePartition? value) : base("Partition", value)
        {
        }

        private AttributeValue<uint?> _partitionsToKeep;
        ///<summary>
        /// Specifies the number of partitions to keep.
        ///</summary>
public AttributeValue<uint?> PartitionsToKeep
        {
            get
            {
                return _partitionsToKeep;
            }

            set
            {
                if (_partitionsToKeep != value)
                {
                    _partitionsToKeep = value;
                    AttributeHandler.Assign(value, this, "partitionsToKeep");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePartitionsToKeep()
        {
            if (PartitionsToKeep == null)
                PartitionsToKeep = new AttributeValue<uint?>();
            return PartitionsToKeep;
        }

        protected override void Initialize(Read.IParamsParamDatabasePartition read, XmlElement editNode)
        {
            if (read == null)
                return;
            _partitionsToKeep = read.PartitionsToKeep != null ? new AttributeValue<uint?>(read.PartitionsToKeep, this) : null;
        }

        public static ParamsParamDatabasePartition FromRead(Read.IParamsParamDatabasePartition read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDatabasePartition();
            item.Value = read.Value;
            item.PartitionsToKeep = AttributeValue<uint?>.FromRead(read.PartitionsToKeep);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabasePartition(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumDatabasePartitionConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumDatabasePartition? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDatabasePartitionConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies indexing options (Elastic).
    /// Feature introduced in DataMiner 9.6.4 (RN 13552).
    ///</summary>
public partial class ParamsParamDatabaseIndexingOptions : EditableElementNode<Read.IParamsParamDatabaseIndexingOptions>
    {
        internal ParamsParamDatabaseIndexingOptions(Read.IParamsParamDatabaseIndexingOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IndexingOptions node. None of it's properties will be set.
        ///</summary>
public ParamsParamDatabaseIndexingOptions() : base("IndexingOptions")
        {
            OnCreated();
        }

        private AttributeValue<bool?> _enabled;
        ///<summary>
        /// Indicates whether the data of the logger table will be stored in the Elastic database instead of Cassandra. When set to true, the data of the logger table will be stored in the Elastic database instead of Cassandra.
        ///</summary>
public AttributeValue<bool?> Enabled
        {
            get
            {
                return _enabled;
            }

            set
            {
                if (_enabled != value)
                {
                    _enabled = value;
                    AttributeHandler.Assign(value, this, "enabled");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateEnabled()
        {
            if (Enabled == null)
                Enabled = new AttributeValue<bool?>();
            return Enabled;
        }

        protected override void Initialize(Read.IParamsParamDatabaseIndexingOptions read, XmlElement editNode)
        {
            if (read == null)
                return;
            _enabled = read.Enabled != null ? new AttributeValue<bool?>(read.Enabled, this) : null;
        }

        public static ParamsParamDatabaseIndexingOptions FromRead(Read.IParamsParamDatabaseIndexingOptions read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDatabaseIndexingOptions();
            item.Enabled = AttributeValue<bool?>.FromRead(read.Enabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDatabaseIndexingOptions(this);
        }
    }

    ///<summary>
    /// Allows you to link one or more parameters. This is mostly used for situations in which clicking a button executes a command that includes several parameters.
    /// Execution of such a command will only proceed if all dependent parameters have a valid value.
    ///</summary>
public partial class ParamsParamDependencies : EditableListNode<Read.IParamsParamDependencies, Read.IParamsParamDependenciesId, ParamsParamDependenciesId>
    {
        internal ParamsParamDependencies(Read.IParamsParamDependencies read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Dependencies node. None of it's properties will be set.
        ///</summary>
public ParamsParamDependencies() : base("Dependencies")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamDependencies read, XmlElement editNode)
        {
        }

        public static ParamsParamDependencies FromRead(Read.IParamsParamDependencies read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDependencies();
            foreach (var x in read)
            {
                item.Add(ParamsParamDependenciesId.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDependencies(this);
        }
    }

    ///<summary>
    /// Specifies the IDs of the parameters that are linked to this parameter.
    ///</summary>
public partial class ParamsParamDependenciesId : EditableElementValueNode<Read.IParamsParamDependenciesId, string>
    {
        internal ParamsParamDependenciesId(Read.IParamsParamDependenciesId read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Id node. None of it's properties will be set.
        ///</summary>
public ParamsParamDependenciesId(bool useCDATA = false) : base("Id", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamDependenciesId(string value, bool useCDATA = false) : base("Id", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<bool?> _postSet;
        ///<summary>
        /// Specifies whether the dependency parameter acts as a preset or a post-set. Refer to the DataMiner Protocol Markup Language Documentation for more information.
        ///</summary>
public AttributeValue<bool?> PostSet
        {
            get
            {
                return _postSet;
            }

            set
            {
                if (_postSet != value)
                {
                    _postSet = value;
                    AttributeHandler.Assign(value, this, "postSet");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreatePostSet()
        {
            if (PostSet == null)
                PostSet = new AttributeValue<bool?>();
            return PostSet;
        }

        protected override void Initialize(Read.IParamsParamDependenciesId read, XmlElement editNode)
        {
            if (read == null)
                return;
            _postSet = read.PostSet != null ? new AttributeValue<bool?>(read.PostSet, this) : null;
        }

        public static ParamsParamDependenciesId FromRead(Read.IParamsParamDependenciesId read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDependenciesId();
            item.Value = read.Value;
            item.PostSet = AttributeValue<bool?>.FromRead(read.PostSet);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDependenciesId(this);
        }
    }

    ///<summary>
    /// Defines if and how a parameter will be displayed on the user interface.
    ///</summary>
public partial class ParamsParamDisplay : EditableElementNode<Read.IParamsParamDisplay>
    {
        internal ParamsParamDisplay(Read.IParamsParamDisplay read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Display node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplay() : base("Display")
        {
            OnCreated();
        }

        private ParamsParamDisplayDynamicUnits _dynamicUnits;
        private ElementValue<uint?> _decimals;
        private ParamsParamDisplayParametersView _parametersView;
        private ParamsParamDisplayPositions _positions;
        private ParamsParamDisplayRange _range;
        private ParamsParamDisplayRTDisplay _rTDisplay;
        private ElementValue<decimal?> _steps;
        private ParamsParamDisplayTrending _trending;
        private ElementValue<string> _units;
        ///<summary>
        /// Specifies the dynamic units that can be used.
        ///</summary>
public ParamsParamDisplayDynamicUnits DynamicUnits
        {
            get
            {
                return _dynamicUnits;
            }

            set
            {
                if (_dynamicUnits != value)
                {
                    _dynamicUnits = value;
                    CombinedTagHandler.Assign(value, this, "DynamicUnits");
                }
            }
        }

        ///<summary>
        /// Defines the number of decimals to be used to display the parameter value on the user inter­face.
        ///</summary>
public ElementValue<uint?> Decimals
        {
            get
            {
                return _decimals;
            }

            set
            {
                if (_decimals != value)
                {
                    _decimals = value;
                    ElementHandler.Assign(value, this, "Decimals");
                }
            }
        }

        ///<summary>
        /// Allows displaying a parameter as a chart.
        /// The parameters holding the actual values to be displayed have to be specified in /Protocol/Params/Param/Display/ParametersView/Parameters.
        /// Note: When this is used, make sure to set /Protocol/Params/Param/Measurement/Type to “Chart”.
        ///</summary>
public ParamsParamDisplayParametersView ParametersView
        {
            get
            {
                return _parametersView;
            }

            set
            {
                if (_parametersView != value)
                {
                    _parametersView = value;
                    CombinedTagHandler.Assign(value, this, "ParametersView");
                }
            }
        }

        ///<summary>
        /// Defines the position of the parameter on the user interface.
        /// Note: As a parameter can be displayed on several locations on the user interface, /Protocol/Params/Param/Display/Positions can contain more than
        /// one position.
        ///</summary>
public ParamsParamDisplayPositions Positions
        {
            get
            {
                return _positions;
            }

            set
            {
                if (_positions != value)
                {
                    _positions = value;
                    CombinedTagHandler.Assign(value, this, "Positions");
                }
            }
        }

        ///<summary>
        /// Defines the parameter value range.
        ///</summary>
public ParamsParamDisplayRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        ///<summary>
        /// Specifies whether the parameter should be pushed to the SLElement process.
        ///</summary>
public ParamsParamDisplayRTDisplay RTDisplay
        {
            get
            {
                return _rTDisplay;
            }

            set
            {
                if (_rTDisplay != value)
                {
                    _rTDisplay = value;
                    CombinedTagHandler.Assign(value, this, "RTDisplay");
                }
            }
        }

        ///<summary>
        /// Defines the step size of a write parameter.
        ///</summary>
public ElementValue<decimal?> Steps
        {
            get
            {
                return _steps;
            }

            set
            {
                if (_steps != value)
                {
                    _steps = value;
                    ElementHandler.Assign(value, this, "Steps");
                }
            }
        }

        ///<summary>
        /// Specifies the formula to be used for the average trending data of this parameter. By default, the average over a 5 minute timespan is stored.
        ///</summary>
public ParamsParamDisplayTrending Trending
        {
            get
            {
                return _trending;
            }

            set
            {
                if (_trending != value)
                {
                    _trending = value;
                    CombinedTagHandler.Assign(value, this, "Trending");
                }
            }
        }

        ///<summary>
        /// Specifies a unit for a parameter value displayed on the user interface. This can be a unit like "Vac", "dBm", etc., but it can also be a string like "batteries"
        /// (for a parameter showing the number of batteries attached to a backup power supply).
        /// The specified unit will be used each time the value of the parameter is displayed: in a report, on the alarm display, etc.
        ///</summary>
public ElementValue<string> Units
        {
            get
            {
                return _units;
            }

            set
            {
                if (_units != value)
                {
                    _units = value;
                    ElementHandler.Assign(value, this, "Units");
                }
            }
        }

        public ParamsParamDisplayDynamicUnits GetOrCreateDynamicUnits()
        {
            if (DynamicUnits == null)
                DynamicUnits = new ParamsParamDisplayDynamicUnits();
            return DynamicUnits;
        }

        public ElementValue<uint?> GetOrCreateDecimals()
        {
            if (Decimals == null)
                Decimals = new ElementValue<uint?>();
            return Decimals;
        }

        public ParamsParamDisplayParametersView GetOrCreateParametersView()
        {
            if (ParametersView == null)
                ParametersView = new ParamsParamDisplayParametersView();
            return ParametersView;
        }

        public ParamsParamDisplayPositions GetOrCreatePositions()
        {
            if (Positions == null)
                Positions = new ParamsParamDisplayPositions();
            return Positions;
        }

        public ParamsParamDisplayRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ParamsParamDisplayRange();
            return Range;
        }

        public ParamsParamDisplayRTDisplay GetOrCreateRTDisplay()
        {
            if (RTDisplay == null)
                RTDisplay = new ParamsParamDisplayRTDisplay();
            return RTDisplay;
        }

        public ElementValue<decimal?> GetOrCreateSteps()
        {
            if (Steps == null)
                Steps = new ElementValue<decimal?>();
            return Steps;
        }

        public ParamsParamDisplayTrending GetOrCreateTrending()
        {
            if (Trending == null)
                Trending = new ParamsParamDisplayTrending();
            return Trending;
        }

        public ElementValue<string> GetOrCreateUnits()
        {
            if (Units == null)
                Units = new ElementValue<string>();
            return Units;
        }

        protected override void Initialize(Read.IParamsParamDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dynamicUnits = read.DynamicUnits != null ? new ParamsParamDisplayDynamicUnits(read.DynamicUnits, this, editNode.Element["DynamicUnits"]) : null;
            _decimals = read.Decimals != null ? new ElementValue<uint?>(read.Decimals, this) : null;
            _parametersView = read.ParametersView != null ? new ParamsParamDisplayParametersView(read.ParametersView, this, editNode.Element["ParametersView"]) : null;
            _positions = read.Positions != null ? new ParamsParamDisplayPositions(read.Positions, this, editNode.Element["Positions"]) : null;
            _range = read.Range != null ? new ParamsParamDisplayRange(read.Range, this, editNode.Element["Range"]) : null;
            _rTDisplay = read.RTDisplay != null ? new ParamsParamDisplayRTDisplay(read.RTDisplay, this, editNode.Element["RTDisplay"]) : null;
            _steps = read.Steps != null ? new ElementValue<decimal?>(read.Steps, this) : null;
            _trending = read.Trending != null ? new ParamsParamDisplayTrending(read.Trending, this, editNode.Element["Trending"]) : null;
            _units = read.Units != null ? new ElementValue<string>(read.Units, this) : null;
        }

        public static ParamsParamDisplay FromRead(Read.IParamsParamDisplay read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplay();
            item.DynamicUnits = ParamsParamDisplayDynamicUnits.FromRead(read.DynamicUnits);
            item.Decimals = ElementValue<uint?>.FromRead(read.Decimals);
            item.ParametersView = ParamsParamDisplayParametersView.FromRead(read.ParametersView);
            item.Positions = ParamsParamDisplayPositions.FromRead(read.Positions);
            item.Range = ParamsParamDisplayRange.FromRead(read.Range);
            item.RTDisplay = ParamsParamDisplayRTDisplay.FromRead(read.RTDisplay);
            item.Steps = ElementValue<decimal?>.FromRead(read.Steps);
            item.Trending = ParamsParamDisplayTrending.FromRead(read.Trending);
            item.Units = ElementValue<string>.FromRead(read.Units);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplay(this);
        }
    }

    ///<summary>
    /// Specifies the dynamic units that can be used.
    ///</summary>
public partial class ParamsParamDisplayDynamicUnits : EditableListNode<Read.IParamsParamDisplayDynamicUnits, Read.IParamsParamDisplayDynamicUnitsUnit, ParamsParamDisplayDynamicUnitsUnit>
    {
        internal ParamsParamDisplayDynamicUnits(Read.IParamsParamDisplayDynamicUnits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DynamicUnits node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayDynamicUnits() : base("DynamicUnits")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamDisplayDynamicUnits read, XmlElement editNode)
        {
        }

        public static ParamsParamDisplayDynamicUnits FromRead(Read.IParamsParamDisplayDynamicUnits read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayDynamicUnits();
            foreach (var x in read)
            {
                item.Add(ParamsParamDisplayDynamicUnitsUnit.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayDynamicUnits(this);
        }
    }

    ///<summary>
    /// Specifies a dynamic unit.
    ///</summary>
public partial class ParamsParamDisplayDynamicUnitsUnit : EditableElementValueNode<Read.IParamsParamDisplayDynamicUnitsUnit, string>
    {
        internal ParamsParamDisplayDynamicUnitsUnit(Read.IParamsParamDisplayDynamicUnitsUnit read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Unit node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayDynamicUnitsUnit(bool useCDATA = false) : base("Unit", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamDisplayDynamicUnitsUnit(string value, bool useCDATA = false) : base("Unit", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _decimals;
        ///<summary>
        /// Specifies the number of decimals to be used to display the parameter value on the user interface with this unit.
        ///</summary>
public AttributeValue<uint?> Decimals
        {
            get
            {
                return _decimals;
            }

            set
            {
                if (_decimals != value)
                {
                    _decimals = value;
                    AttributeHandler.Assign(value, this, "decimals");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateDecimals()
        {
            if (Decimals == null)
                Decimals = new AttributeValue<uint?>();
            return Decimals;
        }

        protected override void Initialize(Read.IParamsParamDisplayDynamicUnitsUnit read, XmlElement editNode)
        {
            if (read == null)
                return;
            _decimals = read.Decimals != null ? new AttributeValue<uint?>(read.Decimals, this) : null;
        }

        public static ParamsParamDisplayDynamicUnitsUnit FromRead(Read.IParamsParamDisplayDynamicUnitsUnit read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayDynamicUnitsUnit();
            item.Value = read.Value;
            item.Decimals = AttributeValue<uint?>.FromRead(read.Decimals);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayDynamicUnitsUnit(this);
        }
    }

    ///<summary>
    /// Allows displaying a parameter as a chart.
    /// The parameters holding the actual values to be displayed have to be specified in /Protocol/Params/Param/Display/ParametersView/Parameters.
    /// Note: When this is used, make sure to set /Protocol/Params/Param/Measurement/Type to “Chart”.
    ///</summary>
public partial class ParamsParamDisplayParametersView : EditableElementNode<Read.IParamsParamDisplayParametersView>
    {
        internal ParamsParamDisplayParametersView(Read.IParamsParamDisplayParametersView read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ParametersView node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayParametersView() : base("ParametersView")
        {
            OnCreated();
        }

        private ParamsParamDisplayParametersViewParameters _parameters;
        private AttributeValue<string> _options;
        private ParamsParamDisplayParametersViewType _type;
        ///<summary>
        /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then here you have to define the parameters holding the actual values to be displayed.
        ///</summary>
public ParamsParamDisplayParametersViewParameters Parameters
        {
            get
            {
                return _parameters;
            }

            set
            {
                if (_parameters != value)
                {
                    _parameters = value;
                    CombinedTagHandler.Assign(value, this, "Parameters");
                }
            }
        }

        ///<summary>
        /// A pipe-separated list of options:
        /// -	Height: Height of the chart (in pixels). If you do not specify a height, the chart will take up the rest of the page.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the chart type: Column, Pie, Row, StackedArea
        /// Note:
        /// -	Pie charts only work if the referenced values are either all positive or all negative.
        /// -	StackedArea charts should not be used to display values that are constantly changing.
        ///</summary>
public ParamsParamDisplayParametersViewType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public ParamsParamDisplayParametersViewParameters GetOrCreateParameters()
        {
            if (Parameters == null)
                Parameters = new ParamsParamDisplayParametersViewParameters();
            return Parameters;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public ParamsParamDisplayParametersViewType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamDisplayParametersViewType();
            return Type;
        }

        protected override void Initialize(Read.IParamsParamDisplayParametersView read, XmlElement editNode)
        {
            if (read == null)
                return;
            _parameters = read.Parameters != null ? new ParamsParamDisplayParametersViewParameters(read.Parameters, this, editNode.Element["Parameters"]) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _type = read.Type != null ? new ParamsParamDisplayParametersViewType(read.Type, this) : null;
        }

        public static ParamsParamDisplayParametersView FromRead(Read.IParamsParamDisplayParametersView read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayParametersView();
            item.Parameters = ParamsParamDisplayParametersViewParameters.FromRead(read.Parameters);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Type = ParamsParamDisplayParametersViewType.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayParametersView(this);
        }
    }

    ///<summary>
    /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then here you have to define the parameters holding the actual values to be displayed.
    ///</summary>
public partial class ParamsParamDisplayParametersViewParameters : EditableListNode<Read.IParamsParamDisplayParametersViewParameters, Read.IParamsParamDisplayParametersViewParametersParameter, ParamsParamDisplayParametersViewParametersParameter>
    {
        internal ParamsParamDisplayParametersViewParameters(Read.IParamsParamDisplayParametersViewParameters read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Parameters node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayParametersViewParameters() : base("Parameters")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamDisplayParametersViewParameters read, XmlElement editNode)
        {
        }

        public static ParamsParamDisplayParametersViewParameters FromRead(Read.IParamsParamDisplayParametersViewParameters read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayParametersViewParameters();
            foreach (var x in read)
            {
                item.Add(ParamsParamDisplayParametersViewParametersParameter.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayParametersViewParameters(this);
        }
    }

    ///<summary>
    /// If you use /Protocol/Params/Param/Display/ParametersView to display a parameter as a chart, then add a Parameter element to
    /// /Protocol/Params/Param/Display/ParametersView/Parameters for every parameter holding a value to be displayed.
    /// Note: Only specify parameters of type "double".
    ///</summary>
public partial class ParamsParamDisplayParametersViewParametersParameter : EditableElementNode<Read.IParamsParamDisplayParametersViewParametersParameter>
    {
        internal ParamsParamDisplayParametersViewParametersParameter(Read.IParamsParamDisplayParametersViewParametersParameter read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Parameter node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayParametersViewParametersParameter() : base("Parameter")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _id;
        private AttributeValue<string> _options;
        private AttributeValue<string> _tableIndex;
        ///<summary>
        /// Specifies the ID of the parameter.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// *** Not yet implemented. ***
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the row index (in case the “id” attribute refers to a table parameter).
        ///</summary>
public AttributeValue<string> TableIndex
        {
            get
            {
                return _tableIndex;
            }

            set
            {
                if (_tableIndex != value)
                {
                    _tableIndex = value;
                    AttributeHandler.Assign(value, this, "tableIndex");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<string> GetOrCreateTableIndex()
        {
            if (TableIndex == null)
                TableIndex = new AttributeValue<string>();
            return TableIndex;
        }

        protected override void Initialize(Read.IParamsParamDisplayParametersViewParametersParameter read, XmlElement editNode)
        {
            if (read == null)
                return;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _tableIndex = read.TableIndex != null ? new AttributeValue<string>(read.TableIndex, this) : null;
        }

        public static ParamsParamDisplayParametersViewParametersParameter FromRead(Read.IParamsParamDisplayParametersViewParametersParameter read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayParametersViewParametersParameter();
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.TableIndex = AttributeValue<string>.FromRead(read.TableIndex);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayParametersViewParametersParameter(this);
        }
    }

    public partial class ParamsParamDisplayParametersViewType : AttributeValue<Enums.EnumParametersViewType?>
    {
        internal ParamsParamDisplayParametersViewType(Read.IValueTag<Enums.EnumParametersViewType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayParametersViewType() : base()
        {
            OnCreated();
        }

        public ParamsParamDisplayParametersViewType(Enums.EnumParametersViewType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParametersViewTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParametersViewType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParametersViewTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamDisplayParametersViewType FromRead(Read.IValueTag<Enums.EnumParametersViewType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayParametersViewType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines the position of the parameter on the user interface.
    /// Note: As a parameter can be displayed on several locations on the user interface, /Protocol/Params/Param/Display/Positions can contain more than
    /// one position.
    ///</summary>
public partial class ParamsParamDisplayPositions : EditableListNode<Read.IParamsParamDisplayPositions, Read.IParamsParamDisplayPositionsPosition, ParamsParamDisplayPositionsPosition>
    {
        internal ParamsParamDisplayPositions(Read.IParamsParamDisplayPositions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Positions node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayPositions() : base("Positions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamDisplayPositions read, XmlElement editNode)
        {
        }

        public static ParamsParamDisplayPositions FromRead(Read.IParamsParamDisplayPositions read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayPositions();
            foreach (var x in read)
            {
                item.Add(ParamsParamDisplayPositionsPosition.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayPositions(this);
        }
    }

    ///<summary>
    /// Defines the location of the parameter on the user interface.
    ///</summary>
public partial class ParamsParamDisplayPositionsPosition : EditableElementNode<Read.IParamsParamDisplayPositionsPosition>
    {
        internal ParamsParamDisplayPositionsPosition(Read.IParamsParamDisplayPositionsPosition read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Position node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayPositionsPosition() : base("Position")
        {
            OnCreated();
        }

        private ParamsParamDisplayPositionsPositionPage _page;
        private ElementValue<uint?> _column;
        private ElementValue<uint?> _row;
        ///<summary>
        /// Specifies on which page you want to display the parameter.
        /// All Data display pages specified in the protocol will appear in the page selection box at the top of the Data Display.
        ///</summary>
public ParamsParamDisplayPositionsPositionPage Page
        {
            get
            {
                return _page;
            }

            set
            {
                if (_page != value)
                {
                    _page = value;
                    CombinedTagHandler.Assign(value, this, "Page");
                }
            }
        }

        ///<summary>
        /// Specifies the horizontal position of the parameter on the page specified in
        /// /Protocol/Params/Param/Display/Positions/Position/Page.
        /// Data display pages are divided into rows and columns. In /Protocol/Params/Param/Display/Positions/Position/Column, you can specify the column on which you want the parameter to be displayed.
        /// Enter an integer value between 0 and 5.
        /// Note: It is recommended to divide the user interface into two columns: a left-hand column with column value 0, and a right-hand column with column value 1.
        ///</summary>
public ElementValue<uint?> Column
        {
            get
            {
                return _column;
            }

            set
            {
                if (_column != value)
                {
                    _column = value;
                    ElementHandler.Assign(value, this, "Column");
                }
            }
        }

        ///<summary>
        /// Specifies the vertical position of the parameter on thepage specified in /Protocol/Params/Param/Display/Positions/Position/Page.
        /// Data display pages are divided into rows and columns. In /Protocol/Params/Param/Display/Positions/Position/Row, you can specify the row on which you want
        /// the parameter to be displayed.
        /// Note: 0 = first row
        ///</summary>
public ElementValue<uint?> Row
        {
            get
            {
                return _row;
            }

            set
            {
                if (_row != value)
                {
                    _row = value;
                    ElementHandler.Assign(value, this, "Row");
                }
            }
        }

        public ParamsParamDisplayPositionsPositionPage GetOrCreatePage()
        {
            if (Page == null)
                Page = new ParamsParamDisplayPositionsPositionPage();
            return Page;
        }

        public ElementValue<uint?> GetOrCreateColumn()
        {
            if (Column == null)
                Column = new ElementValue<uint?>();
            return Column;
        }

        public ElementValue<uint?> GetOrCreateRow()
        {
            if (Row == null)
                Row = new ElementValue<uint?>();
            return Row;
        }

        protected override void Initialize(Read.IParamsParamDisplayPositionsPosition read, XmlElement editNode)
        {
            if (read == null)
                return;
            _page = read.Page != null ? new ParamsParamDisplayPositionsPositionPage(read.Page, this, editNode.Element["Page"]) : null;
            _column = read.Column != null ? new ElementValue<uint?>(read.Column, this) : null;
            _row = read.Row != null ? new ElementValue<uint?>(read.Row, this) : null;
        }

        public static ParamsParamDisplayPositionsPosition FromRead(Read.IParamsParamDisplayPositionsPosition read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayPositionsPosition();
            item.Page = ParamsParamDisplayPositionsPositionPage.FromRead(read.Page);
            item.Column = ElementValue<uint?>.FromRead(read.Column);
            item.Row = ElementValue<uint?>.FromRead(read.Row);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayPositionsPosition(this);
        }
    }

    ///<summary>
    /// Specifies on which page you want to display the parameter.
    /// All Data display pages specified in the protocol will appear in the page selection box at the top of the Data Display.
    ///</summary>
public partial class ParamsParamDisplayPositionsPositionPage : EditableElementValueNode<Read.IParamsParamDisplayPositionsPositionPage, string>
    {
        internal ParamsParamDisplayPositionsPositionPage(Read.IParamsParamDisplayPositionsPositionPage read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Page node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayPositionsPositionPage(bool useCDATA = false) : base("Page", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamDisplayPositionsPositionPage(string value, bool useCDATA = false) : base("Page", value, useCDATA: useCDATA)
        {
        }

        private ParamsParamDisplayPositionsPositionPageMeasType _measType;
        ///<summary>
        /// This attribute allows you to display a parameter as a specific type of parameter on a particular page.
        ///</summary>
public ParamsParamDisplayPositionsPositionPageMeasType MeasType
        {
            get
            {
                return _measType;
            }

            set
            {
                if (_measType != value)
                {
                    _measType = value;
                    AttributeHandler.Assign(value, this, "measType");
                }
            }
        }

        public ParamsParamDisplayPositionsPositionPageMeasType GetOrCreateMeasType()
        {
            if (MeasType == null)
                MeasType = new ParamsParamDisplayPositionsPositionPageMeasType();
            return MeasType;
        }

        protected override void Initialize(Read.IParamsParamDisplayPositionsPositionPage read, XmlElement editNode)
        {
            if (read == null)
                return;
            _measType = read.MeasType != null ? new ParamsParamDisplayPositionsPositionPageMeasType(read.MeasType, this) : null;
        }

        public static ParamsParamDisplayPositionsPositionPage FromRead(Read.IParamsParamDisplayPositionsPositionPage read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayPositionsPositionPage();
            item.Value = read.Value;
            item.MeasType = ParamsParamDisplayPositionsPositionPageMeasType.FromRead(read.MeasType);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayPositionsPositionPage(this);
        }
    }

    public partial class ParamsParamDisplayPositionsPositionPageMeasType : AttributeValue<Enums.EnumParamMeasurementType?>
    {
        internal ParamsParamDisplayPositionsPositionPageMeasType(Read.IValueTag<Enums.EnumParamMeasurementType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a measType node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayPositionsPositionPageMeasType() : base()
        {
            OnCreated();
        }

        public ParamsParamDisplayPositionsPositionPageMeasType(Enums.EnumParamMeasurementType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamMeasurementTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamMeasurementType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamMeasurementTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamDisplayPositionsPositionPageMeasType FromRead(Read.IValueTag<Enums.EnumParamMeasurementType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayPositionsPositionPageMeasType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines the parameter value range.
    ///</summary>
public partial class ParamsParamDisplayRange : EditableElementNode<Read.IParamsParamDisplayRange>
    {
        internal ParamsParamDisplayRange(Read.IParamsParamDisplayRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<decimal?> _low;
        private ElementValue<decimal?> _high;
        ///<summary>
        /// Specifies the lower limit of the range, i.e. the minimum value of the parameter.
        ///</summary>
public ElementValue<decimal?> Low
        {
            get
            {
                return _low;
            }

            set
            {
                if (_low != value)
                {
                    _low = value;
                    ElementHandler.Assign(value, this, "Low");
                }
            }
        }

        ///<summary>
        /// Specifies the upper limit of the value range, i.e. the maximum value of the parameter.
        ///</summary>
public ElementValue<decimal?> High
        {
            get
            {
                return _high;
            }

            set
            {
                if (_high != value)
                {
                    _high = value;
                    ElementHandler.Assign(value, this, "High");
                }
            }
        }

        public ElementValue<decimal?> GetOrCreateLow()
        {
            if (Low == null)
                Low = new ElementValue<decimal?>();
            return Low;
        }

        public ElementValue<decimal?> GetOrCreateHigh()
        {
            if (High == null)
                High = new ElementValue<decimal?>();
            return High;
        }

        protected override void Initialize(Read.IParamsParamDisplayRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _low = read.Low != null ? new ElementValue<decimal?>(read.Low, this) : null;
            _high = read.High != null ? new ElementValue<decimal?>(read.High, this) : null;
        }

        public static ParamsParamDisplayRange FromRead(Read.IParamsParamDisplayRange read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayRange();
            item.Low = ElementValue<decimal?>.FromRead(read.Low);
            item.High = ElementValue<decimal?>.FromRead(read.High);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayRange(this);
        }
    }

    ///<summary>
    /// Specifies whether the parameter should be pushed to the SLElement process.
    ///</summary>
public partial class ParamsParamDisplayRTDisplay : EditableElementValueNode<Read.IParamsParamDisplayRTDisplay, bool?>
    {
        internal ParamsParamDisplayRTDisplay(Read.IParamsParamDisplayRTDisplay read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a RTDisplay node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayRTDisplay() : base("RTDisplay")
        {
            OnCreated();
        }

        public ParamsParamDisplayRTDisplay(bool? value) : base("RTDisplay", value)
        {
        }

        private AttributeValue<bool?> _onAppLevel;
        ///<summary>
        /// Set this attribute to "true" if the parameter has no position but needs RTDisplay true for application purposes. For validation only.
        ///</summary>
public AttributeValue<bool?> OnAppLevel
        {
            get
            {
                return _onAppLevel;
            }

            set
            {
                if (_onAppLevel != value)
                {
                    _onAppLevel = value;
                    AttributeHandler.Assign(value, this, "onAppLevel");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateOnAppLevel()
        {
            if (OnAppLevel == null)
                OnAppLevel = new AttributeValue<bool?>();
            return OnAppLevel;
        }

        protected override void Initialize(Read.IParamsParamDisplayRTDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _onAppLevel = read.OnAppLevel != null ? new AttributeValue<bool?>(read.OnAppLevel, this) : null;
        }

        public static ParamsParamDisplayRTDisplay FromRead(Read.IParamsParamDisplayRTDisplay read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayRTDisplay();
            item.Value = read.Value;
            item.OnAppLevel = AttributeValue<bool?>.FromRead(read.OnAppLevel);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayRTDisplay(this);
        }
    }

    ///<summary>
    /// Specifies the formula to be used for the average trending data of this parameter. By default, the average over a 5 minute timespan is stored.
    ///</summary>
public partial class ParamsParamDisplayTrending : EditableElementNode<Read.IParamsParamDisplayTrending>
    {
        internal ParamsParamDisplayTrending(Read.IParamsParamDisplayTrending read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Trending node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayTrending() : base("Trending")
        {
            OnCreated();
        }

        private ParamsParamDisplayTrendingType _type;
        private AttributeValue<bool?> _logarithmic;
        ///<summary>
        /// Specifies the formula used to determine the average trending data.
        ///</summary>
public ParamsParamDisplayTrendingType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Set this attribute to "true" if you want to set the trend graph of the parameter to a logarithmic scale.
        ///</summary>
public AttributeValue<bool?> Logarithmic
        {
            get
            {
                return _logarithmic;
            }

            set
            {
                if (_logarithmic != value)
                {
                    _logarithmic = value;
                    AttributeHandler.Assign(value, this, "logarithmic");
                }
            }
        }

        public ParamsParamDisplayTrendingType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamDisplayTrendingType();
            return Type;
        }

        public AttributeValue<bool?> GetOrCreateLogarithmic()
        {
            if (Logarithmic == null)
                Logarithmic = new AttributeValue<bool?>();
            return Logarithmic;
        }

        protected override void Initialize(Read.IParamsParamDisplayTrending read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new ParamsParamDisplayTrendingType(read.Type, this, editNode.Element["Type"]) : null;
            _logarithmic = read.Logarithmic != null ? new AttributeValue<bool?>(read.Logarithmic, this) : null;
        }

        public static ParamsParamDisplayTrending FromRead(Read.IParamsParamDisplayTrending read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayTrending();
            item.Type = ParamsParamDisplayTrendingType.FromRead(read.Type);
            item.Logarithmic = AttributeValue<bool?>.FromRead(read.Logarithmic);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayTrending(this);
        }
    }

    ///<summary>
    /// Specifies the formula used to determine the average trending data.
    ///</summary>
public partial class ParamsParamDisplayTrendingType : EditableElementValueNode<Read.IParamsParamDisplayTrendingType, Enums.EnumTrendingType?>
    {
        internal ParamsParamDisplayTrendingType(Read.IParamsParamDisplayTrendingType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ParamsParamDisplayTrendingType() : base("Type")
        {
            OnCreated();
        }

        public ParamsParamDisplayTrendingType(Enums.EnumTrendingType? value) : base("Type", value)
        {
        }

        private AttributeValue<string> _operations;
        ///<summary>
        /// Option to choose a logarithmic scale for the vertical axis. The parameter’s real value should always be larger than 0 for log10(value) to be possible.
        ///</summary>
public AttributeValue<string> Operations
        {
            get
            {
                return _operations;
            }

            set
            {
                if (_operations != value)
                {
                    _operations = value;
                    AttributeHandler.Assign(value, this, "operations");
                }
            }
        }

        public AttributeValue<string> GetOrCreateOperations()
        {
            if (Operations == null)
                Operations = new AttributeValue<string>();
            return Operations;
        }

        protected override void Initialize(Read.IParamsParamDisplayTrendingType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _operations = read.Operations != null ? new AttributeValue<string>(read.Operations, this) : null;
        }

        public static ParamsParamDisplayTrendingType FromRead(Read.IParamsParamDisplayTrendingType read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamDisplayTrendingType();
            item.Value = read.Value;
            item.Operations = AttributeValue<string>.FromRead(read.Operations);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamDisplayTrendingType(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumTrendingTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumTrendingType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTrendingTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Contains the custom commands (i.e. “hyperlinks”) that have to appear on the shortcut menu when users right-click an alarm of this parameter.
    /// These custom commands are often hyperlinks pointing to a web page or an automation script.
    ///</summary>
public partial class ParamsParamHyperLinks : EditableListNode<Read.IParamsParamHyperLinks, Read.IParamsParamHyperLinksHyperLink, ParamsParamHyperLinksHyperLink>
    {
        internal ParamsParamHyperLinks(Read.IParamsParamHyperLinks read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a HyperLinks node. None of it's properties will be set.
        ///</summary>
public ParamsParamHyperLinks() : base("HyperLinks")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamHyperLinks read, XmlElement editNode)
        {
        }

        public static ParamsParamHyperLinks FromRead(Read.IParamsParamHyperLinks read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamHyperLinks();
            foreach (var x in read)
            {
                item.Add(ParamsParamHyperLinksHyperLink.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamHyperLinks(this);
        }
    }

    ///<summary>
    /// Defines a custom command (i.e. “hyperlink”) that has to appear on the shortcut menu when users right-click an alarm of this parameter.
    ///</summary>
public partial class ParamsParamHyperLinksHyperLink : EditableElementValueNode<Read.IParamsParamHyperLinksHyperLink, string>
    {
        internal ParamsParamHyperLinksHyperLink(Read.IParamsParamHyperLinksHyperLink read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a HyperLink node. None of it's properties will be set.
        ///</summary>
public ParamsParamHyperLinksHyperLink(bool useCDATA = false) : base("HyperLink", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamHyperLinksHyperLink(string value, bool useCDATA = false) : base("HyperLink", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _valueParsing;
        ///<summary>
        /// Makes the command appear on the shortcut menu of specific alarms and information events.
        /// If you specify a string in this attribute, the command will only appear on the shortcut menu of alarms and information events of which the value matches the string you specified.
        /// If you leave this attribute empty, the command will appear on the shortcut menu of every alarm and information event.
        /// The string you specify in this valueParsing attribute can contain wildcards (question marks and asterisks) as well as placeholders.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> ValueParsing
        {
            get
            {
                return _valueParsing;
            }

            set
            {
                if (_valueParsing != value)
                {
                    _valueParsing = value;
                    AttributeHandler.Assign(value, this, "valueParsing");
                }
            }
        }

        public AttributeValue<string> GetOrCreateValueParsing()
        {
            if (ValueParsing == null)
                ValueParsing = new AttributeValue<string>();
            return ValueParsing;
        }

        protected override void Initialize(Read.IParamsParamHyperLinksHyperLink read, XmlElement editNode)
        {
            if (read == null)
                return;
            _valueParsing = read.ValueParsing != null ? new AttributeValue<string>(read.ValueParsing, this) : null;
        }

        public static ParamsParamHyperLinksHyperLink FromRead(Read.IParamsParamHyperLinksHyperLink read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamHyperLinksHyperLink();
            item.Value = read.Value;
            item.ValueParsing = AttributeValue<string>.FromRead(read.ValueParsing);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamHyperLinksHyperLink(this);
        }
    }

    ///<summary>
    /// Specifies additional information about the parameter.
    /// DataMiner will show this additional information in tooltips.
    /// Note: Only parameters of type "read" or "read bit" will use /Protocol/Params/Param/Information. In some cases, however, also parameters of type "write" or "write bit" will have one.
    ///</summary>
public partial class ParamsParamInformation : EditableElementNode<Read.IParamsParamInformation>
    {
        internal ParamsParamInformation(Read.IParamsParamInformation read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Information node. None of it's properties will be set.
        ///</summary>
public ParamsParamInformation() : base("Information")
        {
            OnCreated();
        }

        private ElementValue<string> _alarmDescription;
        private ElementValue<string> _category;
        private ElementValue<string> _correctiveAction;
        private ParamsParamInformationIncludes _includes;
        private ElementValue<string> _subtext;
        private ElementValue<string> _text;
        ///<summary>
        /// Specifies an alarm description. When an alarm for this parameter is generated, the value specified here will be shown in the Alarm Description field of the alarm.
        ///</summary>
public ElementValue<string> AlarmDescription
        {
            get
            {
                return _alarmDescription;
            }

            set
            {
                if (_alarmDescription != value)
                {
                    _alarmDescription = value;
                    ElementHandler.Assign(value, this, "AlarmDescription");
                }
            }
        }

        ///<summary>
        /// Specifies a category. When an alarm for this parameter is generated, the value specified here will be shown in the Category field of the alarm.
        ///</summary>
public ElementValue<string> Category
        {
            get
            {
                return _category;
            }

            set
            {
                if (_category != value)
                {
                    _category = value;
                    ElementHandler.Assign(value, this, "Category");
                }
            }
        }

        ///<summary>
        /// Specifies a corrective action. When an alarm for this parameter is generated, the value specified here will be shown in the Corrective Action field of the alarm.
        ///</summary>
public ElementValue<string> CorrectiveAction
        {
            get
            {
                return _correctiveAction;
            }

            set
            {
                if (_correctiveAction != value)
                {
                    _correctiveAction = value;
                    ElementHandler.Assign(value, this, "CorrectiveAction");
                }
            }
        }

        ///<summary>
        /// Contains one or more /Protocol/Params/Param/Information/Include elements to indicate that you want additional information to be displayed in the tooltip.
        ///</summary>
public ParamsParamInformationIncludes Includes
        {
            get
            {
                return _includes;
            }

            set
            {
                if (_includes != value)
                {
                    _includes = value;
                    CombinedTagHandler.Assign(value, this, "Includes");
                }
            }
        }

        ///<summary>
        /// Specifies the actual content of the tooltip.
        /// Next to the title of the tooltip, a drop-down arrow will allow users to enlarge the tooltip and display the text contained in /Protocol/Params/Param/Information/Subtext.
        ///</summary>
public ElementValue<string> Subtext
        {
            get
            {
                return _subtext;
            }

            set
            {
                if (_subtext != value)
                {
                    _subtext = value;
                    ElementHandler.Assign(value, this, "Subtext");
                }
            }
        }

        ///<summary>
        /// Specifies the title of the tooltip.
        ///</summary>
public ElementValue<string> Text
        {
            get
            {
                return _text;
            }

            set
            {
                if (_text != value)
                {
                    _text = value;
                    ElementHandler.Assign(value, this, "Text");
                }
            }
        }

        public ElementValue<string> GetOrCreateAlarmDescription()
        {
            if (AlarmDescription == null)
                AlarmDescription = new ElementValue<string>();
            return AlarmDescription;
        }

        public ElementValue<string> GetOrCreateCategory()
        {
            if (Category == null)
                Category = new ElementValue<string>();
            return Category;
        }

        public ElementValue<string> GetOrCreateCorrectiveAction()
        {
            if (CorrectiveAction == null)
                CorrectiveAction = new ElementValue<string>();
            return CorrectiveAction;
        }

        public ParamsParamInformationIncludes GetOrCreateIncludes()
        {
            if (Includes == null)
                Includes = new ParamsParamInformationIncludes();
            return Includes;
        }

        public ElementValue<string> GetOrCreateSubtext()
        {
            if (Subtext == null)
                Subtext = new ElementValue<string>();
            return Subtext;
        }

        public ElementValue<string> GetOrCreateText()
        {
            if (Text == null)
                Text = new ElementValue<string>();
            return Text;
        }

        protected override void Initialize(Read.IParamsParamInformation read, XmlElement editNode)
        {
            if (read == null)
                return;
            _alarmDescription = read.AlarmDescription != null ? new ElementValue<string>(read.AlarmDescription, this) : null;
            _category = read.Category != null ? new ElementValue<string>(read.Category, this) : null;
            _correctiveAction = read.CorrectiveAction != null ? new ElementValue<string>(read.CorrectiveAction, this) : null;
            _includes = read.Includes != null ? new ParamsParamInformationIncludes(read.Includes, this, editNode.Element["Includes"]) : null;
            _subtext = read.Subtext != null ? new ElementValue<string>(read.Subtext, this) : null;
            _text = read.Text != null ? new ElementValue<string>(read.Text, this) : null;
        }

        public static ParamsParamInformation FromRead(Read.IParamsParamInformation read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInformation();
            item.AlarmDescription = ElementValue<string>.FromRead(read.AlarmDescription);
            item.Category = ElementValue<string>.FromRead(read.Category);
            item.CorrectiveAction = ElementValue<string>.FromRead(read.CorrectiveAction);
            item.Includes = ParamsParamInformationIncludes.FromRead(read.Includes);
            item.Subtext = ElementValue<string>.FromRead(read.Subtext);
            item.Text = ElementValue<string>.FromRead(read.Text);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInformation(this);
        }
    }

    ///<summary>
    /// Contains one or more /Protocol/Params/Param/Information/Include elements to indicate that you want additional information to be displayed in the tooltip.
    ///</summary>
public partial class ParamsParamInformationIncludes : EditableListNode<Read.IParamsParamInformationIncludes, Read.IParamsParamInformationIncludesInclude, ParamsParamInformationIncludesInclude>
    {
        internal ParamsParamInformationIncludes(Read.IParamsParamInformationIncludes read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Includes node. None of it's properties will be set.
        ///</summary>
public ParamsParamInformationIncludes() : base("Includes")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamInformationIncludes read, XmlElement editNode)
        {
        }

        public static ParamsParamInformationIncludes FromRead(Read.IParamsParamInformationIncludes read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInformationIncludes();
            foreach (var x in read)
            {
                item.Add(ParamsParamInformationIncludesInclude.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInformationIncludes(this);
        }
    }

    ///<summary>
    /// Indicates that you want additional information to be displayed in the tooltip.
    /// Information specified in /Protocol/Params/Param/Information/Include elements will appear underneath the con­tents of the /Protocol/Params/Param/Information/Subtext element.
    /// Can contain one of the following values:
    /// - Range: The range of the parameter.
    /// - Units: The unit of the parameter.
    /// - Steps: The step size of the parameter.
    /// - Time: A time stamp that refers to either the last known change or the last time the Parameter was changed by its write parameter (if any).
    ///</summary>
public partial class ParamsParamInformationIncludesInclude : EditableElementValueNode<Read.IParamsParamInformationIncludesInclude, Enums.EnumParamInformationInclude?>
    {
        internal ParamsParamInformationIncludesInclude(Read.IParamsParamInformationIncludesInclude read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Include node. None of it's properties will be set.
        ///</summary>
public ParamsParamInformationIncludesInclude() : base("Include")
        {
            OnCreated();
        }

        public ParamsParamInformationIncludesInclude(Enums.EnumParamInformationInclude? value) : base("Include", value)
        {
        }

        protected override void Initialize(Read.IParamsParamInformationIncludesInclude read, XmlElement editNode)
        {
        }

        public static ParamsParamInformationIncludesInclude FromRead(Read.IParamsParamInformationIncludesInclude read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInformationIncludesInclude();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInformationIncludesInclude(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamInformationIncludeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamInformationInclude? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInformationIncludeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies how a parameter value is processed.
    ///</summary>
public partial class ParamsParamInterprete : EditableElementNode<Read.IParamsParamInterprete>
    {
        internal ParamsParamInterprete(Read.IParamsParamInterprete read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Interprete node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterprete() : base("Interprete")
        {
            OnCreated();
        }

        private ParamsParamInterpreteAlignment _alignment;
        private ElementValue<uint?> _base;
        private ElementValue<uint?> _bits;
        private ElementValue<uint?> _byteOffset;
        private ElementValue<uint?> _decimals;
        private ElementValue<string> _defaultValue;
        private ParamsParamInterpreteEndian _endian;
        private ParamsParamInterpreteExceptions _exceptions;
        private ElementValue<decimal?> _factor;
        private ElementValue<uint?> _length;
        private ParamsParamInterpreteLengthType _lengthType;
        private ElementValue<uint?> _nbrOfBits;
        private ParamsParamInterpreteOffSet _offSet;
        private ParamsParamInterpreteOthers _others;
        private ParamsParamInterpreteRange _range;
        private ParamsParamInterpreteRawType _rawType;
        private ParamsParamInterpreteRounding _rounding;
        private ParamsParamInterpreteScale _scale;
        private ParamsParamInterpreteSequence _sequence;
        private ElementValue<uint?> _startPosition;
        private ParamsParamInterpreteType _type;
        private ElementValue<string> _valueElement;
        ///<summary>
        /// Used to retrieve BCD numbers from an incoming stream.
        /// When a /Protocol/Params/Param/Interprete/Bits element is defined in a group, only a couple of bits will be used from each byte.
        /// When a read bit parameter, with its rawtype set to “bcd”, is assigned to that group and exists of multiple bytes, the Alignment element can be needed to specify the exact starting position
        /// of the first BCD.
        ///</summary>
public ParamsParamInterpreteAlignment Alignment
        {
            get
            {
                return _alignment;
            }

            set
            {
                if (_alignment != value)
                {
                    _alignment = value;
                    ElementHandler.Assign(value, this, "Alignment");
                }
            }
        }

        ///<summary>
        /// Specifies the numeral system (decimal, hexadecimal, etc.).
        /// Contains a number between 2 and 36. Default: 10
        /// Note: In case of base 36, the letters "a" through "z" (or "A" through "Z") are assigned the values 10 through 35.
        ///</summary>
public ElementValue<uint?> Base
        {
            get
            {
                return _base;
            }

            set
            {
                if (_base != value)
                {
                    _base = value;
                    ElementHandler.Assign(value, this, "Base");
                }
            }
        }

        ///<summary>
        /// Used when a group of multiple bytes has been defined, but only a couple of bits are used from each byte.
        /// For example, when only the lower 4 bits are used from each byte, a group can be defined with /Protocol/Params/Param/Interprete/Bits set to 4.
        /// When a "read bit" parameter of 8 bits is assigned to that group, 4 lower bits of 2 bytes will be taken instead of 1 complete byte.
        ///</summary>
public ElementValue<uint?> Bits
        {
            get
            {
                return _bits;
            }

            set
            {
                if (_bits != value)
                {
                    _bits = value;
                    ElementHandler.Assign(value, this, "Bits");
                }
            }
        }

        ///<summary>
        /// Specifies the byte offset.
        /// Each incoming byte of a group containing this ByteOffset element will be decremented with the specified byte offset, while each outgoing byte of the group will be incremented with the specified byte offset.
        ///</summary>
public ElementValue<uint?> ByteOffset
        {
            get
            {
                return _byteOffset;
            }

            set
            {
                if (_byteOffset != value)
                {
                    _byteOffset = value;
                    ElementHandler.Assign(value, this, "ByteOffset");
                }
            }
        }

        ///<summary>
        /// Specifies the number of decimals that will be stored in memory.
        ///</summary>
public ElementValue<uint?> Decimals
        {
            get
            {
                return _decimals;
            }

            set
            {
                if (_decimals != value)
                {
                    _decimals = value;
                    ElementHandler.Assign(value, this, "Decimals");
                }
            }
        }

        ///<summary>
        /// Specifies the default value to be assigned to the parameter if it is empty after startup. If this parameter is saved, the saved value will overrule the default value.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether DataMiner must reverse the byte order.
        /// When numbers are composed of multiple bytes, Intel processors reverse the byte order before writing them to memory.
        /// This optional element instructs DataMiner to either reverse the byte order or not (only relevant in case of unsigned numbers).
        /// - Big: The byte order will be reversed.
        /// - Little: The byte order will not be reversed.
        /// Note: By default, Little Endian is used.
        ///</summary>
public ParamsParamInterpreteEndian Endian
        {
            get
            {
                return _endian;
            }

            set
            {
                if (_endian != value)
                {
                    _endian = value;
                    ElementHandler.Assign(value, this, "Endian");
                }
            }
        }

        ///<summary>
        /// In /Protocol/Params/Param/Interprete/Others, you can define symbols that are not accepted by the rawtype.
        /// However, a rare condition of a parameter can also be expressed by a symbol that is allowed by the parameter's rawtype.
        /// In that case, you can use /Protocol/Params/Param/Interprete/Exceptions/Exception.
        /// In /Protocol/Params/Param/Interprete/Exceptions, you can specify several /Protocol/Params/Param/Interprete/Exceptions/Exception elements, each representing a different exceptional state.
        /// Note: Only useful for parameters of type "read".
        ///</summary>
public ParamsParamInterpreteExceptions Exceptions
        {
            get
            {
                return _exceptions;
            }

            set
            {
                if (_exceptions != value)
                {
                    _exceptions = value;
                    CombinedTagHandler.Assign(value, this, "Exceptions");
                }
            }
        }

        ///<summary>
        /// Multiplies the parameter value with the specified factor.
        ///</summary>
public ElementValue<decimal?> Factor
        {
            get
            {
                return _factor;
            }

            set
            {
                if (_factor != value)
                {
                    _factor = value;
                    ElementHandler.Assign(value, this, "Factor");
                }
            }
        }

        ///<summary>
        /// Specifies the exact length of the parameter (in bytes). Used when /Protocol/Params/Param/Interprete/LengthType is set to "fixed".
        ///</summary>
public ElementValue<uint?> Length
        {
            get
            {
                return _length;
            }

            set
            {
                if (_length != value)
                {
                    _length = value;
                    ElementHandler.Assign(value, this, "Length");
                }
            }
        }

        ///<summary>
        /// Specifies whether the parameter has a fixed length.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public ParamsParamInterpreteLengthType LengthType
        {
            get
            {
                return _lengthType;
            }

            set
            {
                if (_lengthType != value)
                {
                    _lengthType = value;
                    CombinedTagHandler.Assign(value, this, "LengthType");
                }
            }
        }

        ///<summary>
        /// Specifies the number of bits needed.
        /// When this number exceeds the number of bits used in a byte, the /Protocol/Params/Param/Interprete/Endian element can be set to "big" to make DataMiner reverse the bit order when processing them.
        ///</summary>
public ElementValue<uint?> NbrOfBits
        {
            get
            {
                return _nbrOfBits;
            }

            set
            {
                if (_nbrOfBits != value)
                {
                    _nbrOfBits = value;
                    ElementHandler.Assign(value, this, "NbrOfBits");
                }
            }
        }

        ///<summary>
        /// In case the Sequence tag contains "OffSet " as an operation, to offset to be added can be specified using this tag.
        ///</summary>
public ParamsParamInterpreteOffSet OffSet
        {
            get
            {
                return _offSet;
            }

            set
            {
                if (_offSet != value)
                {
                    _offSet = value;
                    CombinedTagHandler.Assign(value, this, "OffSet");
                }
            }
        }

        ///<summary>
        /// Each parameter has a certain rawtype, but in some cases other characters are sent instead of the usual ones to indicate a rare condition.
        /// These symbols are often not allowed by the rawtype of the parameter. To catch those characters and display the singular state of the parameter, they can be specified in /Protocol/Params/Param/Interprete/Others.
        ///</summary>
public ParamsParamInterpreteOthers Others
        {
            get
            {
                return _others;
            }

            set
            {
                if (_others != value)
                {
                    _others = value;
                    CombinedTagHandler.Assign(value, this, "Others");
                }
            }
        }

        ///<summary>
        /// Defines a range for the parameter values. By adding a range to /Protocol/Params/Param/Interprete, a value outside this defined range will be ignored.
        /// The limits of the range are defined by /Protocol/Params/Param/Interprete/Range/Low and /Protocol/Params/Param/Interprete/Range/High.
        /// Note: This can also be used to specify a value range in case of a simulated element.
        ///</summary>
public ParamsParamInterpreteRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        ///<summary>
        /// Specifies which type of content is allowed in the parameter.
        /// If an incoming parameter value does not match the expected rawtype, DataMiner will not process it.
        /// The rawtype setting can therefore be considered as a kind of filter.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public ParamsParamInterpreteRawType RawType
        {
            get
            {
                return _rawType;
            }

            set
            {
                if (_rawType != value)
                {
                    _rawType = value;
                    ElementHandler.Assign(value, this, "RawType");
                }
            }
        }

        ///<summary>
        /// Specifies how the parameter value is rounded (Default: down).
        /// Feature introduced in DataMiner 9.0.0 (Main Release) and DataMiner 9.0.4 (Feature Release) (RN 13519).
        ///</summary>
public ParamsParamInterpreteRounding Rounding
        {
            get
            {
                return _rounding;
            }

            set
            {
                if (_rounding != value)
                {
                    _rounding = value;
                    ElementHandler.Assign(value, this, "Rounding");
                }
            }
        }

        ///<summary>
        /// Specifies that you want DataMiner to re-interpret the value range of a particular parameter.
        ///</summary>
public ParamsParamInterpreteScale Scale
        {
            get
            {
                return _scale;
            }

            set
            {
                if (_scale != value)
                {
                    _scale = value;
                    CombinedTagHandler.Assign(value, this, "Scale");
                }
            }
        }

        ///<summary>
        /// Specifies a mathematical operation to be performed on the parameter value.
        /// Specify at least one mathematical operation. If you specify multiple operations, separate them using semi-colons (";").
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public ParamsParamInterpreteSequence Sequence
        {
            get
            {
                return _sequence;
            }

            set
            {
                if (_sequence != value)
                {
                    _sequence = value;
                    CombinedTagHandler.Assign(value, this, "Sequence");
                }
            }
        }

        ///<summary>
        /// Specifies the start bit in the group to which the parameter refers to in case the parameter is of type "read/write bits".
        /// The most significant bit of the group is considered to be bit 0, and the counter is incremented as the significance of the bits decreases.
        ///</summary>
public ElementValue<uint?> StartPosition
        {
            get
            {
                return _startPosition;
            }

            set
            {
                if (_startPosition != value)
                {
                    _startPosition = value;
                    ElementHandler.Assign(value, this, "StartPosition");
                }
            }
        }

        ///<summary>
        /// In this tag, you can specify how the parameter should be processed and saved.
        /// Specify one of the following values:
        /// - string: The parameter will be processed as an ASCII string.
        /// - double: The parameter will be processed as a number.
        /// - high nibble: The parameter will be processed as the high nibble (i.e. first four bits) of a byte.
        ///</summary>
public ParamsParamInterpreteType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// In case of a parameter with a fixed length and a fixed value, set /Protocol/Params/Param/Inter­prete/LengthType to "fixed" and specify the fixed value here.
        ///</summary>
public ElementValue<string> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        public ParamsParamInterpreteAlignment GetOrCreateAlignment()
        {
            if (Alignment == null)
                Alignment = new ParamsParamInterpreteAlignment();
            return Alignment;
        }

        public ElementValue<uint?> GetOrCreateBase()
        {
            if (Base == null)
                Base = new ElementValue<uint?>();
            return Base;
        }

        public ElementValue<uint?> GetOrCreateBits()
        {
            if (Bits == null)
                Bits = new ElementValue<uint?>();
            return Bits;
        }

        public ElementValue<uint?> GetOrCreateByteOffset()
        {
            if (ByteOffset == null)
                ByteOffset = new ElementValue<uint?>();
            return ByteOffset;
        }

        public ElementValue<uint?> GetOrCreateDecimals()
        {
            if (Decimals == null)
                Decimals = new ElementValue<uint?>();
            return Decimals;
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ParamsParamInterpreteEndian GetOrCreateEndian()
        {
            if (Endian == null)
                Endian = new ParamsParamInterpreteEndian();
            return Endian;
        }

        public ParamsParamInterpreteExceptions GetOrCreateExceptions()
        {
            if (Exceptions == null)
                Exceptions = new ParamsParamInterpreteExceptions();
            return Exceptions;
        }

        public ElementValue<decimal?> GetOrCreateFactor()
        {
            if (Factor == null)
                Factor = new ElementValue<decimal?>();
            return Factor;
        }

        public ElementValue<uint?> GetOrCreateLength()
        {
            if (Length == null)
                Length = new ElementValue<uint?>();
            return Length;
        }

        public ParamsParamInterpreteLengthType GetOrCreateLengthType()
        {
            if (LengthType == null)
                LengthType = new ParamsParamInterpreteLengthType();
            return LengthType;
        }

        public ElementValue<uint?> GetOrCreateNbrOfBits()
        {
            if (NbrOfBits == null)
                NbrOfBits = new ElementValue<uint?>();
            return NbrOfBits;
        }

        public ParamsParamInterpreteOffSet GetOrCreateOffSet()
        {
            if (OffSet == null)
                OffSet = new ParamsParamInterpreteOffSet();
            return OffSet;
        }

        public ParamsParamInterpreteOthers GetOrCreateOthers()
        {
            if (Others == null)
                Others = new ParamsParamInterpreteOthers();
            return Others;
        }

        public ParamsParamInterpreteRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new ParamsParamInterpreteRange();
            return Range;
        }

        public ParamsParamInterpreteRawType GetOrCreateRawType()
        {
            if (RawType == null)
                RawType = new ParamsParamInterpreteRawType();
            return RawType;
        }

        public ParamsParamInterpreteRounding GetOrCreateRounding()
        {
            if (Rounding == null)
                Rounding = new ParamsParamInterpreteRounding();
            return Rounding;
        }

        public ParamsParamInterpreteScale GetOrCreateScale()
        {
            if (Scale == null)
                Scale = new ParamsParamInterpreteScale();
            return Scale;
        }

        public ParamsParamInterpreteSequence GetOrCreateSequence()
        {
            if (Sequence == null)
                Sequence = new ParamsParamInterpreteSequence();
            return Sequence;
        }

        public ElementValue<uint?> GetOrCreateStartPosition()
        {
            if (StartPosition == null)
                StartPosition = new ElementValue<uint?>();
            return StartPosition;
        }

        public ParamsParamInterpreteType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamInterpreteType();
            return Type;
        }

        public ElementValue<string> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<string>();
            return ValueElement;
        }

        protected override void Initialize(Read.IParamsParamInterprete read, XmlElement editNode)
        {
            if (read == null)
                return;
            _alignment = read.Alignment != null ? new ParamsParamInterpreteAlignment(read.Alignment, this) : null;
            _base = read.Base != null ? new ElementValue<uint?>(read.Base, this) : null;
            _bits = read.Bits != null ? new ElementValue<uint?>(read.Bits, this) : null;
            _byteOffset = read.ByteOffset != null ? new ElementValue<uint?>(read.ByteOffset, this) : null;
            _decimals = read.Decimals != null ? new ElementValue<uint?>(read.Decimals, this) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _endian = read.Endian != null ? new ParamsParamInterpreteEndian(read.Endian, this) : null;
            _exceptions = read.Exceptions != null ? new ParamsParamInterpreteExceptions(read.Exceptions, this, editNode.Element["Exceptions"]) : null;
            _factor = read.Factor != null ? new ElementValue<decimal?>(read.Factor, this) : null;
            _length = read.Length != null ? new ElementValue<uint?>(read.Length, this) : null;
            _lengthType = read.LengthType != null ? new ParamsParamInterpreteLengthType(read.LengthType, this, editNode.Element["LengthType"]) : null;
            _nbrOfBits = read.NbrOfBits != null ? new ElementValue<uint?>(read.NbrOfBits, this) : null;
            _offSet = read.OffSet != null ? new ParamsParamInterpreteOffSet(read.OffSet, this, editNode.Element["OffSet"]) : null;
            _others = read.Others != null ? new ParamsParamInterpreteOthers(read.Others, this, editNode.Element["Others"]) : null;
            _range = read.Range != null ? new ParamsParamInterpreteRange(read.Range, this, editNode.Element["Range"]) : null;
            _rawType = read.RawType != null ? new ParamsParamInterpreteRawType(read.RawType, this) : null;
            _rounding = read.Rounding != null ? new ParamsParamInterpreteRounding(read.Rounding, this) : null;
            _scale = read.Scale != null ? new ParamsParamInterpreteScale(read.Scale, this, editNode.Element["Scale"]) : null;
            _sequence = read.Sequence != null ? new ParamsParamInterpreteSequence(read.Sequence, this, editNode.Element["Sequence"]) : null;
            _startPosition = read.StartPosition != null ? new ElementValue<uint?>(read.StartPosition, this) : null;
            _type = read.Type != null ? new ParamsParamInterpreteType(read.Type, this, editNode.Element["Type"]) : null;
            _valueElement = read.ValueElement != null ? new ElementValue<string>(read.ValueElement, this) : null;
        }

        public static ParamsParamInterprete FromRead(Read.IParamsParamInterprete read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterprete();
            item.Alignment = ParamsParamInterpreteAlignment.FromRead(read.Alignment);
            item.Base = ElementValue<uint?>.FromRead(read.Base);
            item.Bits = ElementValue<uint?>.FromRead(read.Bits);
            item.ByteOffset = ElementValue<uint?>.FromRead(read.ByteOffset);
            item.Decimals = ElementValue<uint?>.FromRead(read.Decimals);
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Endian = ParamsParamInterpreteEndian.FromRead(read.Endian);
            item.Exceptions = ParamsParamInterpreteExceptions.FromRead(read.Exceptions);
            item.Factor = ElementValue<decimal?>.FromRead(read.Factor);
            item.Length = ElementValue<uint?>.FromRead(read.Length);
            item.LengthType = ParamsParamInterpreteLengthType.FromRead(read.LengthType);
            item.NbrOfBits = ElementValue<uint?>.FromRead(read.NbrOfBits);
            item.OffSet = ParamsParamInterpreteOffSet.FromRead(read.OffSet);
            item.Others = ParamsParamInterpreteOthers.FromRead(read.Others);
            item.Range = ParamsParamInterpreteRange.FromRead(read.Range);
            item.RawType = ParamsParamInterpreteRawType.FromRead(read.RawType);
            item.Rounding = ParamsParamInterpreteRounding.FromRead(read.Rounding);
            item.Scale = ParamsParamInterpreteScale.FromRead(read.Scale);
            item.Sequence = ParamsParamInterpreteSequence.FromRead(read.Sequence);
            item.StartPosition = ElementValue<uint?>.FromRead(read.StartPosition);
            item.Type = ParamsParamInterpreteType.FromRead(read.Type);
            item.ValueElement = ElementValue<string>.FromRead(read.ValueElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterprete(this);
        }
    }

    public partial class ParamsParamInterpreteAlignment : ElementValue<Enums.EnumParamInterpretAlignment?>
    {
        internal ParamsParamInterpreteAlignment(Read.IValueTag<Enums.EnumParamInterpretAlignment?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Alignment node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteAlignment() : base()
        {
            OnCreated();
        }

        public ParamsParamInterpreteAlignment(Enums.EnumParamInterpretAlignment? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamInterpretAlignmentConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamInterpretAlignment? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretAlignmentConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamInterpreteAlignment FromRead(Read.IValueTag<Enums.EnumParamInterpretAlignment?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteAlignment();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamInterpreteEndian : ElementValue<Enums.EnumParamInterpretEndian?>
    {
        internal ParamsParamInterpreteEndian(Read.IValueTag<Enums.EnumParamInterpretEndian?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Endian node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteEndian() : base()
        {
            OnCreated();
        }

        public ParamsParamInterpreteEndian(Enums.EnumParamInterpretEndian? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamInterpretEndianConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamInterpretEndian? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretEndianConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamInterpreteEndian FromRead(Read.IValueTag<Enums.EnumParamInterpretEndian?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteEndian();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// In /Protocol/Params/Param/Interprete/Others, you can define symbols that are not accepted by the rawtype.
    /// However, a rare condition of a parameter can also be expressed by a symbol that is allowed by the parameter's rawtype.
    /// In that case, you can use /Protocol/Params/Param/Interprete/Exceptions/Exception.
    /// In /Protocol/Params/Param/Interprete/Exceptions, you can specify several /Protocol/Params/Param/Interprete/Exceptions/Exception elements, each representing a different exceptional state.
    /// Note: Only useful for parameters of type "read".
    ///</summary>
public partial class ParamsParamInterpreteExceptions : EditableListNode<Read.IParamsParamInterpreteExceptions, Read.IParamsParamInterpreteExceptionsException, ParamsParamInterpreteExceptionsException>
    {
        internal ParamsParamInterpreteExceptions(Read.IParamsParamInterpreteExceptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Exceptions node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteExceptions() : base("Exceptions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamInterpreteExceptions read, XmlElement editNode)
        {
        }

        public static ParamsParamInterpreteExceptions FromRead(Read.IParamsParamInterpreteExceptions read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteExceptions();
            foreach (var x in read)
            {
                item.Add(ParamsParamInterpreteExceptionsException.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteExceptions(this);
        }
    }

    ///<summary>
    /// Each exception is uniquely identified by its ID.
    /// If the parameter receives an incoming symbol that matches the value specified in /Protocol/Params/Param/Interprete/Exceptions/Exception, the contents of /Protocol/Params/Param/Interprete/Exceptions/Exception/Display will be shown.
    ///</summary>
public partial class ParamsParamInterpreteExceptionsException : EditableElementNode<Read.IParamsParamInterpreteExceptionsException>
    {
        internal ParamsParamInterpreteExceptionsException(Read.IParamsParamInterpreteExceptionsException read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Exception node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteExceptionsException() : base("Exception")
        {
            OnCreated();
        }

        private ParamsParamInterpreteExceptionsExceptionDisplay _display;
        private ElementValue<string> _valueElement;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _valueAttribute;
        ///<summary>
        /// Specifies the text that has to be displayed when the incoming value matches the contents of the value attribute of /Protocol/Params/Param/Interprete/Exceptions/Exception.
        ///</summary>
public ParamsParamInterpreteExceptionsExceptionDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// Specifies the new value to which you want to internally map the incoming exception value specified in the value attribute of the /Protocol/Params/Param/Interprete/Exceptions/Exception element.
        ///</summary>
public ElementValue<string> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        ///<summary>
        /// Specifies the unique ID of the exception.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// When the parameter receives an incoming symbol that matches the contents of this tag, the contents of /Protocol/Params/Param/Interprete/Exceptions/Exception/Display will be displayed.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        public ParamsParamInterpreteExceptionsExceptionDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new ParamsParamInterpreteExceptionsExceptionDisplay();
            return Display;
        }

        public ElementValue<string> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<string>();
            return ValueElement;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        protected override void Initialize(Read.IParamsParamInterpreteExceptionsException read, XmlElement editNode)
        {
            if (read == null)
                return;
            _display = read.Display != null ? new ParamsParamInterpreteExceptionsExceptionDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _valueElement = read.ValueElement != null ? new ElementValue<string>(read.ValueElement, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
        }

        public static ParamsParamInterpreteExceptionsException FromRead(Read.IParamsParamInterpreteExceptionsException read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteExceptionsException();
            item.Display = ParamsParamInterpreteExceptionsExceptionDisplay.FromRead(read.Display);
            item.ValueElement = ElementValue<string>.FromRead(read.ValueElement);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteExceptionsException(this);
        }
    }

    ///<summary>
    /// Specifies the text that has to be displayed when the incoming value matches the contents of the value attribute of /Protocol/Params/Param/Interprete/Exceptions/Exception.
    ///</summary>
public partial class ParamsParamInterpreteExceptionsExceptionDisplay : EditableElementValueNode<Read.IParamsParamInterpreteExceptionsExceptionDisplay, string>
    {
        internal ParamsParamInterpreteExceptionsExceptionDisplay(Read.IParamsParamInterpreteExceptionsExceptionDisplay read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Display node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteExceptionsExceptionDisplay(bool useCDATA = false) : base("Display", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamInterpreteExceptionsExceptionDisplay(string value, bool useCDATA = false) : base("Display", value, useCDATA: useCDATA)
        {
        }

        private ParamsParamInterpreteExceptionsExceptionDisplayState _state;
        ///<summary>
        /// To emphasize the rare condition of the parameter, you can set the state attribute to "disabled" to have the parameter displayed in gray.
        ///</summary>
public ParamsParamInterpreteExceptionsExceptionDisplayState State
        {
            get
            {
                return _state;
            }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    AttributeHandler.Assign(value, this, "state");
                }
            }
        }

        public ParamsParamInterpreteExceptionsExceptionDisplayState GetOrCreateState()
        {
            if (State == null)
                State = new ParamsParamInterpreteExceptionsExceptionDisplayState();
            return State;
        }

        protected override void Initialize(Read.IParamsParamInterpreteExceptionsExceptionDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _state = read.State != null ? new ParamsParamInterpreteExceptionsExceptionDisplayState(read.State, this) : null;
        }

        public static ParamsParamInterpreteExceptionsExceptionDisplay FromRead(Read.IParamsParamInterpreteExceptionsExceptionDisplay read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteExceptionsExceptionDisplay();
            item.Value = read.Value;
            item.State = ParamsParamInterpreteExceptionsExceptionDisplayState.FromRead(read.State);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteExceptionsExceptionDisplay(this);
        }
    }

    public partial class ParamsParamInterpreteExceptionsExceptionDisplayState : AttributeValue<Enums.EnumDisplayState?>
    {
        internal ParamsParamInterpreteExceptionsExceptionDisplayState(Read.IValueTag<Enums.EnumDisplayState?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a state node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteExceptionsExceptionDisplayState() : base()
        {
            OnCreated();
        }

        public ParamsParamInterpreteExceptionsExceptionDisplayState(Enums.EnumDisplayState? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumDisplayStateConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumDisplayState? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDisplayStateConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamInterpreteExceptionsExceptionDisplayState FromRead(Read.IValueTag<Enums.EnumDisplayState?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteExceptionsExceptionDisplayState();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies whether the parameter has a fixed length.
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
public partial class ParamsParamInterpreteLengthType : EditableElementValueNode<Read.IParamsParamInterpreteLengthType, Enums.EnumParamInterpretLengthType?>
    {
        internal ParamsParamInterpreteLengthType(Read.IParamsParamInterpreteLengthType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LengthType node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteLengthType() : base("LengthType")
        {
            OnCreated();
        }

        public ParamsParamInterpreteLengthType(Enums.EnumParamInterpretLengthType? value) : base("LengthType", value)
        {
        }

        private AttributeValue<uint?> _id;
        private AttributeValue<uint?> _times;
        ///<summary>
        /// If LengthType is set to "other param", this attribute has to contain the ID of the "other" parameter that contains the parameter length.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// If LengthType is "next param", then this attribute has to contain the number of times the next parameter should occur before it is considered to be the next parameter.
        ///</summary>
public AttributeValue<uint?> Times
        {
            get
            {
                return _times;
            }

            set
            {
                if (_times != value)
                {
                    _times = value;
                    AttributeHandler.Assign(value, this, "times");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<uint?> GetOrCreateTimes()
        {
            if (Times == null)
                Times = new AttributeValue<uint?>();
            return Times;
        }

        protected override void Initialize(Read.IParamsParamInterpreteLengthType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _times = read.Times != null ? new AttributeValue<uint?>(read.Times, this) : null;
        }

        public static ParamsParamInterpreteLengthType FromRead(Read.IParamsParamInterpreteLengthType read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteLengthType();
            item.Value = read.Value;
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Times = AttributeValue<uint?>.FromRead(read.Times);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteLengthType(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamInterpretLengthTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamInterpretLengthType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretLengthTypeConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// In case the Sequence tag contains "OffSet " as an operation, to offset to be added can be specified using this tag.
    ///</summary>
public partial class ParamsParamInterpreteOffSet : EditableElementValueNode<Read.IParamsParamInterpreteOffSet, uint?>
    {
        internal ParamsParamInterpreteOffSet(Read.IParamsParamInterpreteOffSet read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a OffSet node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteOffSet() : base("OffSet")
        {
            OnCreated();
        }

        public ParamsParamInterpreteOffSet(uint? value) : base("OffSet", value)
        {
        }

        private AttributeValue<uint?> _id;
        ///<summary>
        /// Specifies the ID of the parameter that holds the offset value.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        protected override void Initialize(Read.IParamsParamInterpreteOffSet read, XmlElement editNode)
        {
            if (read == null)
                return;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
        }

        public static ParamsParamInterpreteOffSet FromRead(Read.IParamsParamInterpreteOffSet read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteOffSet();
            item.Value = read.Value;
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteOffSet(this);
        }
    }

    ///<summary>
    /// Each parameter has a certain rawtype, but in some cases other characters are sent instead of the usual ones to indicate a rare condition.
    /// These symbols are often not allowed by the rawtype of the parameter. To catch those characters and display the singular state of the parameter, they can be specified in /Protocol/Params/Param/Interprete/Others.
    ///</summary>
public partial class ParamsParamInterpreteOthers : EditableListNode<Read.IParamsParamInterpreteOthers, Read.IParamsParamInterpreteOthersOther, ParamsParamInterpreteOthersOther>
    {
        internal ParamsParamInterpreteOthers(Read.IParamsParamInterpreteOthers read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Others node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteOthers() : base("Others")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamInterpreteOthers read, XmlElement editNode)
        {
        }

        public static ParamsParamInterpreteOthers FromRead(Read.IParamsParamInterpreteOthers read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteOthers();
            foreach (var x in read)
            {
                item.Add(ParamsParamInterpreteOthersOther.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteOthers(this);
        }
    }

    ///<summary>
    /// When an incoming character does not match the rawtype of a Parameter, DataMiner will try to match the symbol to the rawtype of the Parameter to which a /Protocol/Params/Param/Interprete/Others/Other element refers to, if any.
    ///</summary>
public partial class ParamsParamInterpreteOthersOther : EditableElementNode<Read.IParamsParamInterpreteOthersOther>
    {
        internal ParamsParamInterpreteOthersOther(Read.IParamsParamInterpreteOthersOther read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Other node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteOthersOther() : base("Other")
        {
            OnCreated();
        }

        private ParamsParamInterpreteOthersOtherDisplay _display;
        private ElementValue<decimal?> _valueElement;
        private AttributeValue<uint?> _id;
        ///<summary>
        /// When a /Protocol/Params/Param/Interprete/Others/Other element matches the incoming symbol, the contents of /Protocol/Params/Param/Interprete/Others/Other/Display will be shown.
        ///</summary>
public ParamsParamInterpreteOthersOtherDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// Adds a numeric value (&gt;= 10) to the parameter , which can be useful in case you want to show an alarm when this rare condition occurs.
        ///</summary>
public ElementValue<decimal?> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter to which the incoming symbol will be compared.
        /// If the incoming symbol matches the referred parameter, the contents of the/Protocol/Params/Param/Inter­prete/Others/Other/Display element will be shown.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        public ParamsParamInterpreteOthersOtherDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new ParamsParamInterpreteOthersOtherDisplay();
            return Display;
        }

        public ElementValue<decimal?> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<decimal?>();
            return ValueElement;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        protected override void Initialize(Read.IParamsParamInterpreteOthersOther read, XmlElement editNode)
        {
            if (read == null)
                return;
            _display = read.Display != null ? new ParamsParamInterpreteOthersOtherDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _valueElement = read.ValueElement != null ? new ElementValue<decimal?>(read.ValueElement, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
        }

        public static ParamsParamInterpreteOthersOther FromRead(Read.IParamsParamInterpreteOthersOther read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteOthersOther();
            item.Display = ParamsParamInterpreteOthersOtherDisplay.FromRead(read.Display);
            item.ValueElement = ElementValue<decimal?>.FromRead(read.ValueElement);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteOthersOther(this);
        }
    }

    ///<summary>
    /// When a /Protocol/Params/Param/Interprete/Others/Other element matches the incoming symbol, the contents of /Protocol/Params/Param/Interprete/Others/Other/Display will be shown.
    ///</summary>
public partial class ParamsParamInterpreteOthersOtherDisplay : EditableElementValueNode<Read.IParamsParamInterpreteOthersOtherDisplay, string>
    {
        internal ParamsParamInterpreteOthersOtherDisplay(Read.IParamsParamInterpreteOthersOtherDisplay read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Display node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteOthersOtherDisplay(bool useCDATA = false) : base("Display", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamInterpreteOthersOtherDisplay(string value, bool useCDATA = false) : base("Display", value, useCDATA: useCDATA)
        {
        }

        private ParamsParamInterpreteOthersOtherDisplayState _state;
        ///<summary>
        /// If set to "disabled", the parameter will be displayed in gray.
        ///</summary>
public ParamsParamInterpreteOthersOtherDisplayState State
        {
            get
            {
                return _state;
            }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    AttributeHandler.Assign(value, this, "state");
                }
            }
        }

        public ParamsParamInterpreteOthersOtherDisplayState GetOrCreateState()
        {
            if (State == null)
                State = new ParamsParamInterpreteOthersOtherDisplayState();
            return State;
        }

        protected override void Initialize(Read.IParamsParamInterpreteOthersOtherDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _state = read.State != null ? new ParamsParamInterpreteOthersOtherDisplayState(read.State, this) : null;
        }

        public static ParamsParamInterpreteOthersOtherDisplay FromRead(Read.IParamsParamInterpreteOthersOtherDisplay read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteOthersOtherDisplay();
            item.Value = read.Value;
            item.State = ParamsParamInterpreteOthersOtherDisplayState.FromRead(read.State);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteOthersOtherDisplay(this);
        }
    }

    public partial class ParamsParamInterpreteOthersOtherDisplayState : AttributeValue<Enums.EnumDisplayState?>
    {
        internal ParamsParamInterpreteOthersOtherDisplayState(Read.IValueTag<Enums.EnumDisplayState?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a state node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteOthersOtherDisplayState() : base()
        {
            OnCreated();
        }

        public ParamsParamInterpreteOthersOtherDisplayState(Enums.EnumDisplayState? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumDisplayStateConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumDisplayState? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDisplayStateConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamInterpreteOthersOtherDisplayState FromRead(Read.IValueTag<Enums.EnumDisplayState?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteOthersOtherDisplayState();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines a range for the parameter values. By adding a range to /Protocol/Params/Param/Interprete, a value outside this defined range will be ignored.
    /// The limits of the range are defined by /Protocol/Params/Param/Interprete/Range/Low and /Protocol/Params/Param/Interprete/Range/High.
    /// Note: This can also be used to specify a value range in case of a simulated element.
    ///</summary>
public partial class ParamsParamInterpreteRange : EditableElementNode<Read.IParamsParamInterpreteRange>
    {
        internal ParamsParamInterpreteRange(Read.IParamsParamInterpreteRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<decimal?> _low;
        private ElementValue<decimal?> _high;
        ///<summary>
        /// Specifies the lower limit of the range, i.e. the minimum value of a parameter.
        ///</summary>
public ElementValue<decimal?> Low
        {
            get
            {
                return _low;
            }

            set
            {
                if (_low != value)
                {
                    _low = value;
                    ElementHandler.Assign(value, this, "Low");
                }
            }
        }

        ///<summary>
        /// Specifies the upper limit of the range, i.e. the maximum value of a parameter.
        ///</summary>
public ElementValue<decimal?> High
        {
            get
            {
                return _high;
            }

            set
            {
                if (_high != value)
                {
                    _high = value;
                    ElementHandler.Assign(value, this, "High");
                }
            }
        }

        public ElementValue<decimal?> GetOrCreateLow()
        {
            if (Low == null)
                Low = new ElementValue<decimal?>();
            return Low;
        }

        public ElementValue<decimal?> GetOrCreateHigh()
        {
            if (High == null)
                High = new ElementValue<decimal?>();
            return High;
        }

        protected override void Initialize(Read.IParamsParamInterpreteRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _low = read.Low != null ? new ElementValue<decimal?>(read.Low, this) : null;
            _high = read.High != null ? new ElementValue<decimal?>(read.High, this) : null;
        }

        public static ParamsParamInterpreteRange FromRead(Read.IParamsParamInterpreteRange read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteRange();
            item.Low = ElementValue<decimal?>.FromRead(read.Low);
            item.High = ElementValue<decimal?>.FromRead(read.High);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteRange(this);
        }
    }

    public partial class ParamsParamInterpreteRawType : ElementValue<Enums.EnumParamInterpretRawType?>
    {
        internal ParamsParamInterpreteRawType(Read.IValueTag<Enums.EnumParamInterpretRawType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a RawType node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteRawType() : base()
        {
            OnCreated();
        }

        public ParamsParamInterpreteRawType(Enums.EnumParamInterpretRawType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamInterpretRawTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamInterpretRawType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretRawTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamInterpreteRawType FromRead(Read.IValueTag<Enums.EnumParamInterpretRawType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteRawType();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamInterpreteRounding : ElementValue<Enums.EnumRounding?>
    {
        internal ParamsParamInterpreteRounding(Read.IValueTag<Enums.EnumRounding?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Rounding node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteRounding() : base()
        {
            OnCreated();
        }

        public ParamsParamInterpreteRounding(Enums.EnumRounding? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumRoundingConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumRounding? ConvertRawValue(string rawValue)
        {
            return Enums.EnumRoundingConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamInterpreteRounding FromRead(Read.IValueTag<Enums.EnumRounding?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteRounding();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies that you want DataMiner to re-interpret the value range of a particular parameter.
    ///</summary>
public partial class ParamsParamInterpreteScale : EditableElementNode<Read.IParamsParamInterpreteScale>
    {
        internal ParamsParamInterpreteScale(Read.IParamsParamInterpreteScale read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Scale node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteScale() : base("Scale")
        {
            OnCreated();
        }

        private AttributeValue<decimal?> _lowData;
        private AttributeValue<decimal?> _highData;
        private AttributeValue<decimal?> _low;
        private AttributeValue<decimal?> _high;
        ///<summary>
        /// Specifies the lowest value that can be returned by the device for the parameter in question.
        ///</summary>
public AttributeValue<decimal?> LowData
        {
            get
            {
                return _lowData;
            }

            set
            {
                if (_lowData != value)
                {
                    _lowData = value;
                    AttributeHandler.Assign(value, this, "lowData");
                }
            }
        }

        ///<summary>
        /// Specifies the highest value that can be returned by the device for the parameter in question.
        ///</summary>
public AttributeValue<decimal?> HighData
        {
            get
            {
                return _highData;
            }

            set
            {
                if (_highData != value)
                {
                    _highData = value;
                    AttributeHandler.Assign(value, this, "highData");
                }
            }
        }

        ///<summary>
        /// Specifies the value to which DataMiner has to convert the lowest value that can be returned by the device.
        ///</summary>
public AttributeValue<decimal?> Low
        {
            get
            {
                return _low;
            }

            set
            {
                if (_low != value)
                {
                    _low = value;
                    AttributeHandler.Assign(value, this, "low");
                }
            }
        }

        ///<summary>
        /// Specifies the value to which DataMiner has to convert the highest value that can be returned by the device.
        ///</summary>
public AttributeValue<decimal?> High
        {
            get
            {
                return _high;
            }

            set
            {
                if (_high != value)
                {
                    _high = value;
                    AttributeHandler.Assign(value, this, "high");
                }
            }
        }

        public AttributeValue<decimal?> GetOrCreateLowData()
        {
            if (LowData == null)
                LowData = new AttributeValue<decimal?>();
            return LowData;
        }

        public AttributeValue<decimal?> GetOrCreateHighData()
        {
            if (HighData == null)
                HighData = new AttributeValue<decimal?>();
            return HighData;
        }

        public AttributeValue<decimal?> GetOrCreateLow()
        {
            if (Low == null)
                Low = new AttributeValue<decimal?>();
            return Low;
        }

        public AttributeValue<decimal?> GetOrCreateHigh()
        {
            if (High == null)
                High = new AttributeValue<decimal?>();
            return High;
        }

        protected override void Initialize(Read.IParamsParamInterpreteScale read, XmlElement editNode)
        {
            if (read == null)
                return;
            _lowData = read.LowData != null ? new AttributeValue<decimal?>(read.LowData, this) : null;
            _highData = read.HighData != null ? new AttributeValue<decimal?>(read.HighData, this) : null;
            _low = read.Low != null ? new AttributeValue<decimal?>(read.Low, this) : null;
            _high = read.High != null ? new AttributeValue<decimal?>(read.High, this) : null;
        }

        public static ParamsParamInterpreteScale FromRead(Read.IParamsParamInterpreteScale read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteScale();
            item.LowData = AttributeValue<decimal?>.FromRead(read.LowData);
            item.HighData = AttributeValue<decimal?>.FromRead(read.HighData);
            item.Low = AttributeValue<decimal?>.FromRead(read.Low);
            item.High = AttributeValue<decimal?>.FromRead(read.High);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteScale(this);
        }
    }

    ///<summary>
    /// Specifies a mathematical operation to be performed on the parameter value.
    /// Specify at least one mathematical operation. If you specify multiple operations, separate them using semi-colons (";").
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
public partial class ParamsParamInterpreteSequence : EditableElementValueNode<Read.IParamsParamInterpreteSequence, string>
    {
        internal ParamsParamInterpreteSequence(Read.IParamsParamInterpreteSequence read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Sequence node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteSequence(bool useCDATA = false) : base("Sequence", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamInterpreteSequence(string value, bool useCDATA = false) : base("Sequence", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _loop;
        private AttributeValue<bool?> _noset;
        ///<summary>
        /// Specifies the loop value for the sequence (integer).
        /// The value in the parameter will be automatically recalculated taking into account the loop (overflow) sequence.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<uint?> Loop
        {
            get
            {
                return _loop;
            }

            set
            {
                if (_loop != value)
                {
                    _loop = value;
                    AttributeHandler.Assign(value, this, "loop");
                }
            }
        }

        ///<summary>
        /// If you do not specify this attribute, or if you set it to "false", sequences will be taken into account when the parameter gets a new value.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<bool?> Noset
        {
            get
            {
                return _noset;
            }

            set
            {
                if (_noset != value)
                {
                    _noset = value;
                    AttributeHandler.Assign(value, this, "noset");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateLoop()
        {
            if (Loop == null)
                Loop = new AttributeValue<uint?>();
            return Loop;
        }

        public AttributeValue<bool?> GetOrCreateNoset()
        {
            if (Noset == null)
                Noset = new AttributeValue<bool?>();
            return Noset;
        }

        protected override void Initialize(Read.IParamsParamInterpreteSequence read, XmlElement editNode)
        {
            if (read == null)
                return;
            _loop = read.Loop != null ? new AttributeValue<uint?>(read.Loop, this) : null;
            _noset = read.Noset != null ? new AttributeValue<bool?>(read.Noset, this) : null;
        }

        public static ParamsParamInterpreteSequence FromRead(Read.IParamsParamInterpreteSequence read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteSequence();
            item.Value = read.Value;
            item.Loop = AttributeValue<uint?>.FromRead(read.Loop);
            item.Noset = AttributeValue<bool?>.FromRead(read.Noset);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteSequence(this);
        }
    }

    ///<summary>
    /// In this tag, you can specify how the parameter should be processed and saved.
    /// Specify one of the following values:
    /// - string: The parameter will be processed as an ASCII string.
    /// - double: The parameter will be processed as a number.
    /// - high nibble: The parameter will be processed as the high nibble (i.e. first four bits) of a byte.
    ///</summary>
public partial class ParamsParamInterpreteType : EditableElementValueNode<Read.IParamsParamInterpreteType, Enums.EnumParamInterpretType?>
    {
        internal ParamsParamInterpreteType(Read.IParamsParamInterpreteType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteType() : base("Type")
        {
            OnCreated();
        }

        public ParamsParamInterpreteType(Enums.EnumParamInterpretType? value) : base("Type", value)
        {
        }

        private AttributeValue<bool?> _filter;
        private ParamsParamInterpreteTypeTrim _trim;
        ///<summary>
        /// When set to "true", only printable characters will be displayed (default value: "false").
        ///</summary>
public AttributeValue<bool?> Filter
        {
            get
            {
                return _filter;
            }

            set
            {
                if (_filter != value)
                {
                    _filter = value;
                    AttributeHandler.Assign(value, this, "filter");
                }
            }
        }

        ///<summary>
        /// Add this attribute to remove leading and/or trailing whitespace.
        /// You can specify the following values. If you add both values, separate them by a semi-colon (";").
        /// -	left: all leading whitespace will be removed
        /// -	right: all trailing whitespace will be removed.
        ///</summary>
public ParamsParamInterpreteTypeTrim Trim
        {
            get
            {
                return _trim;
            }

            set
            {
                if (_trim != value)
                {
                    _trim = value;
                    AttributeHandler.Assign(value, this, "trim");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateFilter()
        {
            if (Filter == null)
                Filter = new AttributeValue<bool?>();
            return Filter;
        }

        public ParamsParamInterpreteTypeTrim GetOrCreateTrim()
        {
            if (Trim == null)
                Trim = new ParamsParamInterpreteTypeTrim();
            return Trim;
        }

        protected override void Initialize(Read.IParamsParamInterpreteType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _filter = read.Filter != null ? new AttributeValue<bool?>(read.Filter, this) : null;
            _trim = read.Trim != null ? new ParamsParamInterpreteTypeTrim(read.Trim, this) : null;
        }

        public static ParamsParamInterpreteType FromRead(Read.IParamsParamInterpreteType read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteType();
            item.Value = read.Value;
            item.Filter = AttributeValue<bool?>.FromRead(read.Filter);
            item.Trim = ParamsParamInterpreteTypeTrim.FromRead(read.Trim);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamInterpreteType(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamInterpretTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamInterpretType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamInterpretTypeConverter.Convert(rawValue?.Trim());
        }
    }

    public partial class ParamsParamInterpreteTypeTrim : AttributeValue<Enums.EnumInterpretTypeTrim?>
    {
        internal ParamsParamInterpreteTypeTrim(Read.IValueTag<Enums.EnumInterpretTypeTrim?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a trim node. None of it's properties will be set.
        ///</summary>
public ParamsParamInterpreteTypeTrim() : base()
        {
            OnCreated();
        }

        public ParamsParamInterpreteTypeTrim(Enums.EnumInterpretTypeTrim? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumInterpretTypeTrimConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumInterpretTypeTrim? ConvertRawValue(string rawValue)
        {
            return Enums.EnumInterpretTypeTrimConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamInterpreteTypeTrim FromRead(Read.IValueTag<Enums.EnumInterpretTypeTrim?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamInterpreteTypeTrim();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies the length of the command/response.
    ///</summary>
public partial class ParamsParamLength : EditableElementNode<Read.IParamsParamLength>
    {
        internal ParamsParamLength(Read.IParamsParamLength read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Length node. None of it's properties will be set.
        ///</summary>
public ParamsParamLength() : base("Length")
        {
            OnCreated();
        }

        private ParamsParamLengthContent _content;
        ///<summary>
        /// Specifies the parameters of the command/response that define the length of the com­mand/response.
        ///</summary>
public ParamsParamLengthContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        public ParamsParamLengthContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new ParamsParamLengthContent();
            return Content;
        }

        protected override void Initialize(Read.IParamsParamLength read, XmlElement editNode)
        {
            if (read == null)
                return;
            _content = read.Content != null ? new ParamsParamLengthContent(read.Content, this, editNode.Element["Content"]) : null;
        }

        public static ParamsParamLength FromRead(Read.IParamsParamLength read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamLength();
            item.Content = ParamsParamLengthContent.FromRead(read.Content);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamLength(this);
        }
    }

    ///<summary>
    /// Specifies the parameters of the command/response that define the length of the com­mand/response.
    ///</summary>
public partial class ParamsParamLengthContent : EditableListNode<Read.IParamsParamLengthContent, Read.IParamsParamLengthContentParam, ParamsParamLengthContentParam>
    {
        internal ParamsParamLengthContent(Read.IParamsParamLengthContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public ParamsParamLengthContent() : base("Content")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamLengthContent read, XmlElement editNode)
        {
        }

        public static ParamsParamLengthContent FromRead(Read.IParamsParamLengthContent read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamLengthContent();
            foreach (var x in read)
            {
                item.Add(ParamsParamLengthContentParam.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamLengthContent(this);
        }
    }

    ///<summary>
    /// Specifies a parameter of the command/response to be included in the length calculation.
    /// Note: The first parameter of the command/response has ID 0.
    ///</summary>
public partial class ParamsParamLengthContentParam : EditableElementValueNode<Read.IParamsParamLengthContentParam, uint?>
    {
        internal ParamsParamLengthContentParam(Read.IParamsParamLengthContentParam read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Param node. None of it's properties will be set.
        ///</summary>
public ParamsParamLengthContentParam() : base("Param")
        {
            OnCreated();
        }

        public ParamsParamLengthContentParam(uint? value) : base("Param", value)
        {
        }

        protected override void Initialize(Read.IParamsParamLengthContentParam read, XmlElement editNode)
        {
        }

        public static ParamsParamLengthContentParam FromRead(Read.IParamsParamLengthContentParam read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamLengthContentParam();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamLengthContentParam(this);
        }
    }

    ///<summary>
    /// If /Protocol/Params/Param/Type is set to "matrix", then this will allow you to define the matrix control. Feature introduced in DataMiner 10.3.1/10.4.0 (RN 34661).
    ///</summary>
public partial class ParamsParamMatrix : EditableElementNode<Read.IParamsParamMatrix>
    {
        internal ParamsParamMatrix(Read.IParamsParamMatrix read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Matrix node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrix() : base("Matrix")
        {
            OnCreated();
        }

        private ParamsParamMatrixInputs _inputs;
        private ParamsParamMatrixOutputs _outputs;
        private ParamsParamMatrixMatrixOptions _matrixOptions;
        ///<summary>
        /// Contains the linking between the inputs table and the matrix control.
        ///</summary>
public ParamsParamMatrixInputs Inputs
        {
            get
            {
                return _inputs;
            }

            set
            {
                if (_inputs != value)
                {
                    _inputs = value;
                    CombinedTagHandler.Assign(value, this, "Inputs");
                }
            }
        }

        ///<summary>
        /// Contains the linking between the outputs table and the matrix control.
        ///</summary>
public ParamsParamMatrixOutputs Outputs
        {
            get
            {
                return _outputs;
            }

            set
            {
                if (_outputs != value)
                {
                    _outputs = value;
                    CombinedTagHandler.Assign(value, this, "Outputs");
                }
            }
        }

        ///<summary>
        /// Contains additional options related to how the matrix should behave and look.
        ///</summary>
public ParamsParamMatrixMatrixOptions MatrixOptions
        {
            get
            {
                return _matrixOptions;
            }

            set
            {
                if (_matrixOptions != value)
                {
                    _matrixOptions = value;
                    CombinedTagHandler.Assign(value, this, "MatrixOptions");
                }
            }
        }

        public ParamsParamMatrixInputs GetOrCreateInputs()
        {
            if (Inputs == null)
                Inputs = new ParamsParamMatrixInputs();
            return Inputs;
        }

        public ParamsParamMatrixOutputs GetOrCreateOutputs()
        {
            if (Outputs == null)
                Outputs = new ParamsParamMatrixOutputs();
            return Outputs;
        }

        public ParamsParamMatrixMatrixOptions GetOrCreateMatrixOptions()
        {
            if (MatrixOptions == null)
                MatrixOptions = new ParamsParamMatrixMatrixOptions();
            return MatrixOptions;
        }

        protected override void Initialize(Read.IParamsParamMatrix read, XmlElement editNode)
        {
            if (read == null)
                return;
            _inputs = read.Inputs != null ? new ParamsParamMatrixInputs(read.Inputs, this, editNode.Element["Inputs"]) : null;
            _outputs = read.Outputs != null ? new ParamsParamMatrixOutputs(read.Outputs, this, editNode.Element["Outputs"]) : null;
            _matrixOptions = read.MatrixOptions != null ? new ParamsParamMatrixMatrixOptions(read.MatrixOptions, this, editNode.Element["MatrixOptions"]) : null;
        }

        public static ParamsParamMatrix FromRead(Read.IParamsParamMatrix read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrix();
            item.Inputs = ParamsParamMatrixInputs.FromRead(read.Inputs);
            item.Outputs = ParamsParamMatrixOutputs.FromRead(read.Outputs);
            item.MatrixOptions = ParamsParamMatrixMatrixOptions.FromRead(read.MatrixOptions);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrix(this);
        }
    }

    ///<summary>
    /// Contains the linking between the inputs table and the matrix control.
    ///</summary>
public partial class ParamsParamMatrixInputs : EditableElementNode<Read.IParamsParamMatrixInputs>
    {
        internal ParamsParamMatrixInputs(Read.IParamsParamMatrixInputs read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Inputs node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixInputs() : base("Inputs")
        {
            OnCreated();
        }

        private ParamsParamMatrixInputsMappings _mappings;
        private AttributeValue<uint?> _tablePid;
        ///<summary>
        /// Specifies the linking between the columns of the inputs table and the matrix control.
        ///</summary>
public ParamsParamMatrixInputsMappings Mappings
        {
            get
            {
                return _mappings;
            }

            set
            {
                if (_mappings != value)
                {
                    _mappings = value;
                    CombinedTagHandler.Assign(value, this, "Mappings");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the inputs table.
        ///</summary>
public AttributeValue<uint?> TablePid
        {
            get
            {
                return _tablePid;
            }

            set
            {
                if (_tablePid != value)
                {
                    _tablePid = value;
                    AttributeHandler.Assign(value, this, "tablePid");
                }
            }
        }

        public ParamsParamMatrixInputsMappings GetOrCreateMappings()
        {
            if (Mappings == null)
                Mappings = new ParamsParamMatrixInputsMappings();
            return Mappings;
        }

        public AttributeValue<uint?> GetOrCreateTablePid()
        {
            if (TablePid == null)
                TablePid = new AttributeValue<uint?>();
            return TablePid;
        }

        protected override void Initialize(Read.IParamsParamMatrixInputs read, XmlElement editNode)
        {
            if (read == null)
                return;
            _mappings = read.Mappings != null ? new ParamsParamMatrixInputsMappings(read.Mappings, this, editNode.Element["Mappings"]) : null;
            _tablePid = read.TablePid != null ? new AttributeValue<uint?>(read.TablePid, this) : null;
        }

        public static ParamsParamMatrixInputs FromRead(Read.IParamsParamMatrixInputs read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixInputs();
            item.Mappings = ParamsParamMatrixInputsMappings.FromRead(read.Mappings);
            item.TablePid = AttributeValue<uint?>.FromRead(read.TablePid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixInputs(this);
        }
    }

    ///<summary>
    /// Specifies the linking between the columns of the inputs table and the matrix control.
    ///</summary>
public partial class ParamsParamMatrixInputsMappings : EditableListNode<Read.IParamsParamMatrixInputsMappings, Read.IParamsParamMatrixInputsMappingsMapping, ParamsParamMatrixInputsMappingsMapping>
    {
        internal ParamsParamMatrixInputsMappings(Read.IParamsParamMatrixInputsMappings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Mappings node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixInputsMappings() : base("Mappings")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamMatrixInputsMappings read, XmlElement editNode)
        {
        }

        public static ParamsParamMatrixInputsMappings FromRead(Read.IParamsParamMatrixInputsMappings read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixInputsMappings();
            foreach (var x in read)
            {
                item.Add(ParamsParamMatrixInputsMappingsMapping.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixInputsMappings(this);
        }
    }

    ///<summary>
    /// Specifies the link between the column and the matrix column.
    ///</summary>
public partial class ParamsParamMatrixInputsMappingsMapping : EditableElementValueNode<Read.IParamsParamMatrixInputsMappingsMapping, string>
    {
        internal ParamsParamMatrixInputsMappingsMapping(Read.IParamsParamMatrixInputsMappingsMapping read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Mapping node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixInputsMappingsMapping(bool useCDATA = false) : base("Mapping", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamMatrixInputsMappingsMapping(string value, bool useCDATA = false) : base("Mapping", value, useCDATA: useCDATA)
        {
        }

        private ParamsParamMatrixInputsMappingsMappingType _type;
        private ParamsParamMatrixInputsMappingsMappingName _name;
        ///<summary>
        /// Specifies the type of value of the mapping.
        ///</summary>
public ParamsParamMatrixInputsMappingsMappingType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        ///<summary>
        /// Specifies the mapping type.
        ///</summary>
public ParamsParamMatrixInputsMappingsMappingName Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public ParamsParamMatrixInputsMappingsMappingType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamMatrixInputsMappingsMappingType();
            return Type;
        }

        public ParamsParamMatrixInputsMappingsMappingName GetOrCreateName()
        {
            if (Name == null)
                Name = new ParamsParamMatrixInputsMappingsMappingName();
            return Name;
        }

        protected override void Initialize(Read.IParamsParamMatrixInputsMappingsMapping read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new ParamsParamMatrixInputsMappingsMappingType(read.Type, this) : null;
            _name = read.Name != null ? new ParamsParamMatrixInputsMappingsMappingName(read.Name, this) : null;
        }

        public static ParamsParamMatrixInputsMappingsMapping FromRead(Read.IParamsParamMatrixInputsMappingsMapping read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixInputsMappingsMapping();
            item.Value = read.Value;
            item.Type = ParamsParamMatrixInputsMappingsMappingType.FromRead(read.Type);
            item.Name = ParamsParamMatrixInputsMappingsMappingName.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixInputsMappingsMapping(this);
        }
    }

    public partial class ParamsParamMatrixInputsMappingsMappingType : AttributeValue<Enums.EnumMatrixMappingType?>
    {
        internal ParamsParamMatrixInputsMappingsMappingType(Read.IValueTag<Enums.EnumMatrixMappingType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixInputsMappingsMappingType() : base()
        {
            OnCreated();
        }

        public ParamsParamMatrixInputsMappingsMappingType(Enums.EnumMatrixMappingType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumMatrixMappingTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumMatrixMappingType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixMappingTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMatrixInputsMappingsMappingType FromRead(Read.IValueTag<Enums.EnumMatrixMappingType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixInputsMappingsMappingType();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamMatrixInputsMappingsMappingName : AttributeValue<Enums.EnumMatrixInputsMappingNameType?>
    {
        internal ParamsParamMatrixInputsMappingsMappingName(Read.IValueTag<Enums.EnumMatrixInputsMappingNameType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a name node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixInputsMappingsMappingName() : base()
        {
            OnCreated();
        }

        public ParamsParamMatrixInputsMappingsMappingName(Enums.EnumMatrixInputsMappingNameType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumMatrixInputsMappingNameTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumMatrixInputsMappingNameType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixInputsMappingNameTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMatrixInputsMappingsMappingName FromRead(Read.IValueTag<Enums.EnumMatrixInputsMappingNameType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixInputsMappingsMappingName();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Contains the linking between the outputs table and the matrix control.
    ///</summary>
public partial class ParamsParamMatrixOutputs : EditableElementNode<Read.IParamsParamMatrixOutputs>
    {
        internal ParamsParamMatrixOutputs(Read.IParamsParamMatrixOutputs read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Outputs node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixOutputs() : base("Outputs")
        {
            OnCreated();
        }

        private ParamsParamMatrixOutputsMappings _mappings;
        private AttributeValue<uint?> _tablePid;
        ///<summary>
        /// Specifies the linking between the columns of the outputs table and the matrix control.
        ///</summary>
public ParamsParamMatrixOutputsMappings Mappings
        {
            get
            {
                return _mappings;
            }

            set
            {
                if (_mappings != value)
                {
                    _mappings = value;
                    CombinedTagHandler.Assign(value, this, "Mappings");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the outputs table.
        ///</summary>
public AttributeValue<uint?> TablePid
        {
            get
            {
                return _tablePid;
            }

            set
            {
                if (_tablePid != value)
                {
                    _tablePid = value;
                    AttributeHandler.Assign(value, this, "tablePid");
                }
            }
        }

        public ParamsParamMatrixOutputsMappings GetOrCreateMappings()
        {
            if (Mappings == null)
                Mappings = new ParamsParamMatrixOutputsMappings();
            return Mappings;
        }

        public AttributeValue<uint?> GetOrCreateTablePid()
        {
            if (TablePid == null)
                TablePid = new AttributeValue<uint?>();
            return TablePid;
        }

        protected override void Initialize(Read.IParamsParamMatrixOutputs read, XmlElement editNode)
        {
            if (read == null)
                return;
            _mappings = read.Mappings != null ? new ParamsParamMatrixOutputsMappings(read.Mappings, this, editNode.Element["Mappings"]) : null;
            _tablePid = read.TablePid != null ? new AttributeValue<uint?>(read.TablePid, this) : null;
        }

        public static ParamsParamMatrixOutputs FromRead(Read.IParamsParamMatrixOutputs read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixOutputs();
            item.Mappings = ParamsParamMatrixOutputsMappings.FromRead(read.Mappings);
            item.TablePid = AttributeValue<uint?>.FromRead(read.TablePid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixOutputs(this);
        }
    }

    ///<summary>
    /// Specifies the linking between the columns of the outputs table and the matrix control.
    ///</summary>
public partial class ParamsParamMatrixOutputsMappings : EditableListNode<Read.IParamsParamMatrixOutputsMappings, Read.IParamsParamMatrixOutputsMappingsMapping, ParamsParamMatrixOutputsMappingsMapping>
    {
        internal ParamsParamMatrixOutputsMappings(Read.IParamsParamMatrixOutputsMappings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Mappings node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixOutputsMappings() : base("Mappings")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamMatrixOutputsMappings read, XmlElement editNode)
        {
        }

        public static ParamsParamMatrixOutputsMappings FromRead(Read.IParamsParamMatrixOutputsMappings read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixOutputsMappings();
            foreach (var x in read)
            {
                item.Add(ParamsParamMatrixOutputsMappingsMapping.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixOutputsMappings(this);
        }
    }

    ///<summary>
    /// Specifies the link between the column and the matrix column.
    ///</summary>
public partial class ParamsParamMatrixOutputsMappingsMapping : EditableElementValueNode<Read.IParamsParamMatrixOutputsMappingsMapping, string>
    {
        internal ParamsParamMatrixOutputsMappingsMapping(Read.IParamsParamMatrixOutputsMappingsMapping read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Mapping node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixOutputsMappingsMapping(bool useCDATA = false) : base("Mapping", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamMatrixOutputsMappingsMapping(string value, bool useCDATA = false) : base("Mapping", value, useCDATA: useCDATA)
        {
        }

        private ParamsParamMatrixOutputsMappingsMappingType _type;
        private ParamsParamMatrixOutputsMappingsMappingName _name;
        ///<summary>
        /// Specifies the type of value of the mapping.
        ///</summary>
public ParamsParamMatrixOutputsMappingsMappingType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        ///<summary>
        /// Specifies the mapping type.
        ///</summary>
public ParamsParamMatrixOutputsMappingsMappingName Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public ParamsParamMatrixOutputsMappingsMappingType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamMatrixOutputsMappingsMappingType();
            return Type;
        }

        public ParamsParamMatrixOutputsMappingsMappingName GetOrCreateName()
        {
            if (Name == null)
                Name = new ParamsParamMatrixOutputsMappingsMappingName();
            return Name;
        }

        protected override void Initialize(Read.IParamsParamMatrixOutputsMappingsMapping read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new ParamsParamMatrixOutputsMappingsMappingType(read.Type, this) : null;
            _name = read.Name != null ? new ParamsParamMatrixOutputsMappingsMappingName(read.Name, this) : null;
        }

        public static ParamsParamMatrixOutputsMappingsMapping FromRead(Read.IParamsParamMatrixOutputsMappingsMapping read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixOutputsMappingsMapping();
            item.Value = read.Value;
            item.Type = ParamsParamMatrixOutputsMappingsMappingType.FromRead(read.Type);
            item.Name = ParamsParamMatrixOutputsMappingsMappingName.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixOutputsMappingsMapping(this);
        }
    }

    public partial class ParamsParamMatrixOutputsMappingsMappingType : AttributeValue<Enums.EnumMatrixMappingType?>
    {
        internal ParamsParamMatrixOutputsMappingsMappingType(Read.IValueTag<Enums.EnumMatrixMappingType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixOutputsMappingsMappingType() : base()
        {
            OnCreated();
        }

        public ParamsParamMatrixOutputsMappingsMappingType(Enums.EnumMatrixMappingType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumMatrixMappingTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumMatrixMappingType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixMappingTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMatrixOutputsMappingsMappingType FromRead(Read.IValueTag<Enums.EnumMatrixMappingType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixOutputsMappingsMappingType();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamMatrixOutputsMappingsMappingName : AttributeValue<Enums.EnumMatrixOutputsMappingNameType?>
    {
        internal ParamsParamMatrixOutputsMappingsMappingName(Read.IValueTag<Enums.EnumMatrixOutputsMappingNameType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a name node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixOutputsMappingsMappingName() : base()
        {
            OnCreated();
        }

        public ParamsParamMatrixOutputsMappingsMappingName(Enums.EnumMatrixOutputsMappingNameType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumMatrixOutputsMappingNameTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumMatrixOutputsMappingNameType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixOutputsMappingNameTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMatrixOutputsMappingsMappingName FromRead(Read.IValueTag<Enums.EnumMatrixOutputsMappingNameType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixOutputsMappingsMappingName();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Contains additional options related to how the matrix should behave and look.
    ///</summary>
public partial class ParamsParamMatrixMatrixOptions : EditableListNode<Read.IParamsParamMatrixMatrixOptions, Read.IParamsParamMatrixMatrixOptionsMatrixOption, ParamsParamMatrixMatrixOptionsMatrixOption>
    {
        internal ParamsParamMatrixMatrixOptions(Read.IParamsParamMatrixMatrixOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a MatrixOptions node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixMatrixOptions() : base("MatrixOptions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamMatrixMatrixOptions read, XmlElement editNode)
        {
        }

        public static ParamsParamMatrixMatrixOptions FromRead(Read.IParamsParamMatrixMatrixOptions read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixMatrixOptions();
            foreach (var x in read)
            {
                item.Add(ParamsParamMatrixMatrixOptionsMatrixOption.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixMatrixOptions(this);
        }
    }

    ///<summary>
    /// Specifies specific options for the look or behavior of the matrix.
    ///</summary>
public partial class ParamsParamMatrixMatrixOptionsMatrixOption : EditableElementValueNode<Read.IParamsParamMatrixMatrixOptionsMatrixOption, string>
    {
        internal ParamsParamMatrixMatrixOptionsMatrixOption(Read.IParamsParamMatrixMatrixOptionsMatrixOption read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a MatrixOption node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixMatrixOptionsMatrixOption(bool useCDATA = false) : base("MatrixOption", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamMatrixMatrixOptionsMatrixOption(string value, bool useCDATA = false) : base("MatrixOption", value, useCDATA: useCDATA)
        {
        }

        private ParamsParamMatrixMatrixOptionsMatrixOptionType _type;
        private ParamsParamMatrixMatrixOptionsMatrixOptionName _name;
        ///<summary>
        /// Specifies the type of value of the matrix option.
        ///</summary>
public ParamsParamMatrixMatrixOptionsMatrixOptionType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        ///<summary>
        /// Specifies the matrix option type.
        ///</summary>
public ParamsParamMatrixMatrixOptionsMatrixOptionName Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public ParamsParamMatrixMatrixOptionsMatrixOptionType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamMatrixMatrixOptionsMatrixOptionType();
            return Type;
        }

        public ParamsParamMatrixMatrixOptionsMatrixOptionName GetOrCreateName()
        {
            if (Name == null)
                Name = new ParamsParamMatrixMatrixOptionsMatrixOptionName();
            return Name;
        }

        protected override void Initialize(Read.IParamsParamMatrixMatrixOptionsMatrixOption read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new ParamsParamMatrixMatrixOptionsMatrixOptionType(read.Type, this) : null;
            _name = read.Name != null ? new ParamsParamMatrixMatrixOptionsMatrixOptionName(read.Name, this) : null;
        }

        public static ParamsParamMatrixMatrixOptionsMatrixOption FromRead(Read.IParamsParamMatrixMatrixOptionsMatrixOption read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixMatrixOptionsMatrixOption();
            item.Value = read.Value;
            item.Type = ParamsParamMatrixMatrixOptionsMatrixOptionType.FromRead(read.Type);
            item.Name = ParamsParamMatrixMatrixOptionsMatrixOptionName.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMatrixMatrixOptionsMatrixOption(this);
        }
    }

    public partial class ParamsParamMatrixMatrixOptionsMatrixOptionType : AttributeValue<Enums.EnumMatrixMatrixOptionType?>
    {
        internal ParamsParamMatrixMatrixOptionsMatrixOptionType(Read.IValueTag<Enums.EnumMatrixMatrixOptionType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixMatrixOptionsMatrixOptionType() : base()
        {
            OnCreated();
        }

        public ParamsParamMatrixMatrixOptionsMatrixOptionType(Enums.EnumMatrixMatrixOptionType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumMatrixMatrixOptionTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumMatrixMatrixOptionType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixMatrixOptionTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMatrixMatrixOptionsMatrixOptionType FromRead(Read.IValueTag<Enums.EnumMatrixMatrixOptionType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixMatrixOptionsMatrixOptionType();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamMatrixMatrixOptionsMatrixOptionName : AttributeValue<Enums.EnumMatrixMatrixOptionNameType?>
    {
        internal ParamsParamMatrixMatrixOptionsMatrixOptionName(Read.IValueTag<Enums.EnumMatrixMatrixOptionNameType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a name node. None of it's properties will be set.
        ///</summary>
public ParamsParamMatrixMatrixOptionsMatrixOptionName() : base()
        {
            OnCreated();
        }

        public ParamsParamMatrixMatrixOptionsMatrixOptionName(Enums.EnumMatrixMatrixOptionNameType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumMatrixMatrixOptionNameTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumMatrixMatrixOptionNameType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumMatrixMatrixOptionNameTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMatrixMatrixOptionsMatrixOptionName FromRead(Read.IValueTag<Enums.EnumMatrixMatrixOptionNameType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMatrixMatrixOptionsMatrixOptionName();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies how the parameter has to be displayed on the user interface (depending on the parameter type).
    ///</summary>
public partial class ParamsParamMeasurement : EditableElementNode<Read.IParamsParamMeasurement>
    {
        internal ParamsParamMeasurement(Read.IParamsParamMeasurement read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Measurement node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurement() : base("Measurement")
        {
            OnCreated();
        }

        private ParamsParamMeasurementDiscreets _discreets;
        private ElementValue<double?> _threshold;
        private ParamsParamMeasurementType _type;
        ///<summary>
        /// Contains the displayed value(s) of the parameter.
        /// For every value, page button or button to be displayed, a separate /Protocol/Params/Param/Measure­ment/Discreets/Discreet element has to be specified.
        /// In Data Display, the values will be displayed in the order in which they are specified in the /Protocol/Params/Param/Measure­ment/Discreets element.
        /// Note: The /Protocol/Params/Param/Measurement/Discreets element only has to be used if /Proto­col/Params/Param/Measurement/Type is set to "discreet", "pagebutton", or "togglebutton".
        ///</summary>
public ParamsParamMeasurementDiscreets Discreets
        {
            get
            {
                return _discreets;
            }

            set
            {
                if (_discreets != value)
                {
                    _discreets = value;
                    CombinedTagHandler.Assign(value, this, "Discreets");
                }
            }
        }

        ///<summary>
        /// Should only be used in case /Protocol/Params/Param/Measurement/Type is set to "threshold digital".
        /// In some cases, when only two states are allowed (e.g. "On" and "Off") but the parameter value lies within a range of values, a turnover point has to be defined (i.e. when value
        /// "On" is changed to "Off" and vice versa). This turnover point can be defined here. The actual "On" and "Off" values are defined as discrete entries.
        ///</summary>
public ElementValue<double?> Threshold
        {
            get
            {
                return _threshold;
            }

            set
            {
                if (_threshold != value)
                {
                    _threshold = value;
                    ElementHandler.Assign(value, this, "Threshold");
                }
            }
        }

        ///<summary>
        /// Specifies how the parameter has to be displayed on the user interface.
        /// For more information about the values that can be specified, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public ParamsParamMeasurementType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        public ParamsParamMeasurementDiscreets GetOrCreateDiscreets()
        {
            if (Discreets == null)
                Discreets = new ParamsParamMeasurementDiscreets();
            return Discreets;
        }

        public ElementValue<double?> GetOrCreateThreshold()
        {
            if (Threshold == null)
                Threshold = new ElementValue<double?>();
            return Threshold;
        }

        public ParamsParamMeasurementType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamMeasurementType();
            return Type;
        }

        protected override void Initialize(Read.IParamsParamMeasurement read, XmlElement editNode)
        {
            if (read == null)
                return;
            _discreets = read.Discreets != null ? new ParamsParamMeasurementDiscreets(read.Discreets, this, editNode.Element["Discreets"]) : null;
            _threshold = read.Threshold != null ? new ElementValue<double?>(read.Threshold, this) : null;
            _type = read.Type != null ? new ParamsParamMeasurementType(read.Type, this, editNode.Element["Type"]) : null;
        }

        public static ParamsParamMeasurement FromRead(Read.IParamsParamMeasurement read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurement();
            item.Discreets = ParamsParamMeasurementDiscreets.FromRead(read.Discreets);
            item.Threshold = ElementValue<double?>.FromRead(read.Threshold);
            item.Type = ParamsParamMeasurementType.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurement(this);
        }
    }

    ///<summary>
    /// Contains the displayed value(s) of the parameter.
    /// For every value, page button or button to be displayed, a separate /Protocol/Params/Param/Measure­ment/Discreets/Discreet element has to be specified.
    /// In Data Display, the values will be displayed in the order in which they are specified in the /Protocol/Params/Param/Measure­ment/Discreets element.
    /// Note: The /Protocol/Params/Param/Measurement/Discreets element only has to be used if /Proto­col/Params/Param/Measurement/Type is set to "discreet", "pagebutton", or "togglebutton".
    ///</summary>
public partial class ParamsParamMeasurementDiscreets : EditableListNode<Read.IParamsParamMeasurementDiscreets, Read.IParamsParamMeasurementDiscreetsDiscreet, ParamsParamMeasurementDiscreetsDiscreet>
    {
        internal ParamsParamMeasurementDiscreets(Read.IParamsParamMeasurementDiscreets read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Discreets node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementDiscreets() : base("Discreets")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _dependencyId;
        private AttributeValue<string> _matrixLayout;
        ///<summary>
        /// If the discrete values of the parameter depend on the current state of another parameter, the ID of that other parameter can be specified using this attribute.
        ///</summary>
public AttributeValue<uint?> DependencyId
        {
            get
            {
                return _dependencyId;
            }

            set
            {
                if (_dependencyId != value)
                {
                    _dependencyId = value;
                    AttributeHandler.Assign(value, this, "dependencyId");
                }
            }
        }

        ///<summary>
        /// Configures the layout of the matrix. Default: InputLeftOutputTop.
        ///</summary>
public AttributeValue<string> MatrixLayout
        {
            get
            {
                return _matrixLayout;
            }

            set
            {
                if (_matrixLayout != value)
                {
                    _matrixLayout = value;
                    AttributeHandler.Assign(value, this, "matrixLayout");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateDependencyId()
        {
            if (DependencyId == null)
                DependencyId = new AttributeValue<uint?>();
            return DependencyId;
        }

        public AttributeValue<string> GetOrCreateMatrixLayout()
        {
            if (MatrixLayout == null)
                MatrixLayout = new AttributeValue<string>();
            return MatrixLayout;
        }

        protected override void Initialize(Read.IParamsParamMeasurementDiscreets read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dependencyId = read.DependencyId != null ? new AttributeValue<uint?>(read.DependencyId, this) : null;
            _matrixLayout = read.MatrixLayout != null ? new AttributeValue<string>(read.MatrixLayout, this) : null;
        }

        public static ParamsParamMeasurementDiscreets FromRead(Read.IParamsParamMeasurementDiscreets read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementDiscreets();
            item.DependencyId = AttributeValue<uint?>.FromRead(read.DependencyId);
            item.MatrixLayout = AttributeValue<string>.FromRead(read.MatrixLayout);
            foreach (var x in read)
            {
                item.Add(ParamsParamMeasurementDiscreetsDiscreet.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementDiscreets(this);
        }
    }

    ///<summary>
    /// Specifies a value and a text string.
    /// The latter will be displayed on the user interface if the former matches the value of the parameter.
    ///</summary>
public partial class ParamsParamMeasurementDiscreetsDiscreet : EditableElementNode<Read.IParamsParamMeasurementDiscreetsDiscreet>
    {
        internal ParamsParamMeasurementDiscreetsDiscreet(Read.IParamsParamMeasurementDiscreetsDiscreet read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Discreet node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreet() : base("Discreet")
        {
            OnCreated();
        }

        private ParamsParamMeasurementDiscreetsDiscreetDisplay _display;
        private ParamsParamMeasurementDiscreetsDiscreetValue _valueElement;
        private ElementValue<string> _tooltip;
        private AttributeValue<string> _dependencyValues;
        private AttributeValue<bool?> _displayIconAndLabel;
        private AttributeValue<string> _export;
        private ParamsParamMeasurementDiscreetsDiscreetIconRef _iconRef;
        private AttributeValue<string> _options;
        ///<summary>
        /// Specifies the string to be displayed when the value of the parameter matches the contents of /Protocol/Params/Param/Measurement/Discreets/Discreet/Value.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// Specifies the discrete value has to be displayed.
        /// If the value of the parameter matches the value in this element, the contents of ../Discreet/Display will be displayed.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetValue ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    CombinedTagHandler.Assign(value, this, "Value");
                }
            }
        }

        ///<summary>
        /// Specifies the tooltip to be displayed when the mouse pointer hovers over the icon displayed in a table cell containing the discrete parameter value to which it is linked.
        ///</summary>
public ElementValue<string> Tooltip
        {
            get
            {
                return _tooltip;
            }

            set
            {
                if (_tooltip != value)
                {
                    _tooltip = value;
                    ElementHandler.Assign(value, this, "Tooltip");
                }
            }
        }

        ///<summary>
        /// When the parameter depends on the current value of another parameter, the dependencyValues attribute can be used to specify whether or not the discreet value
        /// should be available. If the other parameter has one of the values specified in the attribute, the discreet will be displayed, otherwise it will not. In case of a ContextMenu parameter (of which the name is identical to that of the table with “_ContextMenu” suffix), the dependencyValues will first ask the user to enter the value of each parameter specified in this attribute.
        ///</summary>
public AttributeValue<string> DependencyValues
        {
            get
            {
                return _dependencyValues;
            }

            set
            {
                if (_dependencyValues != value)
                {
                    _dependencyValues = value;
                    AttributeHandler.Assign(value, this, "dependencyValues");
                }
            }
        }

        ///<summary>
        /// Specifies whether to show only the icon (false) or to show the icon together with the display value of the discrete entry (true). Default: false.
        /// Feature introduced in DataMiner 9.5.7.
        ///</summary>
public AttributeValue<bool?> DisplayIconAndLabel
        {
            get
            {
                return _displayIconAndLabel;
            }

            set
            {
                if (_displayIconAndLabel != value)
                {
                    _displayIconAndLabel = value;
                    AttributeHandler.Assign(value, this, "displayIconAndLabel");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter values that have to be exported.
        ///</summary>
public AttributeValue<string> Export
        {
            get
            {
                return _export;
            }

            set
            {
                if (_export != value)
                {
                    _export = value;
                    AttributeHandler.Assign(value, this, "export");
                }
            }
        }

        ///<summary>
        /// Specifies the key of the icon as defined in the Icons.xml file.
        /// Using this attribute in a column parameter of a table will display an icon in the tree control.
        /// 
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetIconRef IconRef
        {
            get
            {
                return _iconRef;
            }

            set
            {
                if (_iconRef != value)
                {
                    _iconRef = value;
                    AttributeHandler.Assign(value, this, "iconRef");
                }
            }
        }

        ///<summary>
        /// Specifies the options to be used. Refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        public ParamsParamMeasurementDiscreetsDiscreetDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new ParamsParamMeasurementDiscreetsDiscreetDisplay();
            return Display;
        }

        public ParamsParamMeasurementDiscreetsDiscreetValue GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ParamsParamMeasurementDiscreetsDiscreetValue();
            return ValueElement;
        }

        public ElementValue<string> GetOrCreateTooltip()
        {
            if (Tooltip == null)
                Tooltip = new ElementValue<string>();
            return Tooltip;
        }

        public AttributeValue<string> GetOrCreateDependencyValues()
        {
            if (DependencyValues == null)
                DependencyValues = new AttributeValue<string>();
            return DependencyValues;
        }

        public AttributeValue<bool?> GetOrCreateDisplayIconAndLabel()
        {
            if (DisplayIconAndLabel == null)
                DisplayIconAndLabel = new AttributeValue<bool?>();
            return DisplayIconAndLabel;
        }

        public AttributeValue<string> GetOrCreateExport()
        {
            if (Export == null)
                Export = new AttributeValue<string>();
            return Export;
        }

        public ParamsParamMeasurementDiscreetsDiscreetIconRef GetOrCreateIconRef()
        {
            if (IconRef == null)
                IconRef = new ParamsParamMeasurementDiscreetsDiscreetIconRef();
            return IconRef;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        protected override void Initialize(Read.IParamsParamMeasurementDiscreetsDiscreet read, XmlElement editNode)
        {
            if (read == null)
                return;
            _display = read.Display != null ? new ParamsParamMeasurementDiscreetsDiscreetDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _valueElement = read.ValueElement != null ? new ParamsParamMeasurementDiscreetsDiscreetValue(read.ValueElement, this, editNode.Element["Value"]) : null;
            _tooltip = read.Tooltip != null ? new ElementValue<string>(read.Tooltip, this) : null;
            _dependencyValues = read.DependencyValues != null ? new AttributeValue<string>(read.DependencyValues, this) : null;
            _displayIconAndLabel = read.DisplayIconAndLabel != null ? new AttributeValue<bool?>(read.DisplayIconAndLabel, this) : null;
            _export = read.Export != null ? new AttributeValue<string>(read.Export, this) : null;
            _iconRef = read.IconRef != null ? new ParamsParamMeasurementDiscreetsDiscreetIconRef(read.IconRef, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
        }

        public static ParamsParamMeasurementDiscreetsDiscreet FromRead(Read.IParamsParamMeasurementDiscreetsDiscreet read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementDiscreetsDiscreet();
            item.Display = ParamsParamMeasurementDiscreetsDiscreetDisplay.FromRead(read.Display);
            item.ValueElement = ParamsParamMeasurementDiscreetsDiscreetValue.FromRead(read.ValueElement);
            item.Tooltip = ElementValue<string>.FromRead(read.Tooltip);
            item.DependencyValues = AttributeValue<string>.FromRead(read.DependencyValues);
            item.DisplayIconAndLabel = AttributeValue<bool?>.FromRead(read.DisplayIconAndLabel);
            item.Export = AttributeValue<string>.FromRead(read.Export);
            item.IconRef = ParamsParamMeasurementDiscreetsDiscreetIconRef.FromRead(read.IconRef);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementDiscreetsDiscreet(this);
        }
    }

    ///<summary>
    /// Specifies the string to be displayed when the value of the parameter matches the contents of /Protocol/Params/Param/Measurement/Discreets/Discreet/Value.
    ///</summary>
public partial class ParamsParamMeasurementDiscreetsDiscreetDisplay : EditableElementValueNode<Read.IParamsParamMeasurementDiscreetsDiscreetDisplay, string>
    {
        internal ParamsParamMeasurementDiscreetsDiscreetDisplay(Read.IParamsParamMeasurementDiscreetsDiscreetDisplay read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Display node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetDisplay(bool useCDATA = false) : base("Display", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamMeasurementDiscreetsDiscreetDisplay(string value, bool useCDATA = false) : base("Display", value, useCDATA: useCDATA)
        {
        }

        private ParamsParamMeasurementDiscreetsDiscreetDisplayState _state;
        ///<summary>
        /// When /Protocol/Params/Param/Interprete/Exceptions/Exception is used the same state needs to be placed in the write parameter.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetDisplayState State
        {
            get
            {
                return _state;
            }

            set
            {
                if (_state != value)
                {
                    _state = value;
                    AttributeHandler.Assign(value, this, "state");
                }
            }
        }

        public ParamsParamMeasurementDiscreetsDiscreetDisplayState GetOrCreateState()
        {
            if (State == null)
                State = new ParamsParamMeasurementDiscreetsDiscreetDisplayState();
            return State;
        }

        protected override void Initialize(Read.IParamsParamMeasurementDiscreetsDiscreetDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _state = read.State != null ? new ParamsParamMeasurementDiscreetsDiscreetDisplayState(read.State, this) : null;
        }

        public static ParamsParamMeasurementDiscreetsDiscreetDisplay FromRead(Read.IParamsParamMeasurementDiscreetsDiscreetDisplay read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementDiscreetsDiscreetDisplay();
            item.Value = read.Value;
            item.State = ParamsParamMeasurementDiscreetsDiscreetDisplayState.FromRead(read.State);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementDiscreetsDiscreetDisplay(this);
        }
    }

    public partial class ParamsParamMeasurementDiscreetsDiscreetDisplayState : AttributeValue<Enums.EnumDisplayState?>
    {
        internal ParamsParamMeasurementDiscreetsDiscreetDisplayState(Read.IValueTag<Enums.EnumDisplayState?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a state node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetDisplayState() : base()
        {
            OnCreated();
        }

        public ParamsParamMeasurementDiscreetsDiscreetDisplayState(Enums.EnumDisplayState? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumDisplayStateConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumDisplayState? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDisplayStateConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMeasurementDiscreetsDiscreetDisplayState FromRead(Read.IValueTag<Enums.EnumDisplayState?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementDiscreetsDiscreetDisplayState();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies the discrete value has to be displayed.
    /// If the value of the parameter matches the value in this element, the contents of ../Discreet/Display will be displayed.
    ///</summary>
public partial class ParamsParamMeasurementDiscreetsDiscreetValue : EditableElementValueNode<Read.IParamsParamMeasurementDiscreetsDiscreetValue, string>
    {
        internal ParamsParamMeasurementDiscreetsDiscreetValue(Read.IParamsParamMeasurementDiscreetsDiscreetValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamMeasurementDiscreetsDiscreetValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _location;
        private ParamsParamMeasurementDiscreetsDiscreetValueType _type;
        ///<summary>
        /// If type is “dll”, the location of the DLL file.
        ///</summary>
public AttributeValue<string> Location
        {
            get
            {
                return _location;
            }

            set
            {
                if (_location != value)
                {
                    _location = value;
                    AttributeHandler.Assign(value, this, "location");
                }
            }
        }

        ///<summary>
        /// Specifies the type.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetValueType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public AttributeValue<string> GetOrCreateLocation()
        {
            if (Location == null)
                Location = new AttributeValue<string>();
            return Location;
        }

        public ParamsParamMeasurementDiscreetsDiscreetValueType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamMeasurementDiscreetsDiscreetValueType();
            return Type;
        }

        protected override void Initialize(Read.IParamsParamMeasurementDiscreetsDiscreetValue read, XmlElement editNode)
        {
            if (read == null)
                return;
            _location = read.Location != null ? new AttributeValue<string>(read.Location, this) : null;
            _type = read.Type != null ? new ParamsParamMeasurementDiscreetsDiscreetValueType(read.Type, this) : null;
        }

        public static ParamsParamMeasurementDiscreetsDiscreetValue FromRead(Read.IParamsParamMeasurementDiscreetsDiscreetValue read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementDiscreetsDiscreetValue();
            item.Value = read.Value;
            item.Location = AttributeValue<string>.FromRead(read.Location);
            item.Type = ParamsParamMeasurementDiscreetsDiscreetValueType.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementDiscreetsDiscreetValue(this);
        }
    }

    public partial class ParamsParamMeasurementDiscreetsDiscreetValueType : AttributeValue<Enums.EnumDiscreteValue?>
    {
        internal ParamsParamMeasurementDiscreetsDiscreetValueType(Read.IValueTag<Enums.EnumDiscreteValue?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetValueType() : base()
        {
            OnCreated();
        }

        public ParamsParamMeasurementDiscreetsDiscreetValueType(Enums.EnumDiscreteValue? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumDiscreteValueConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumDiscreteValue? ConvertRawValue(string rawValue)
        {
            return Enums.EnumDiscreteValueConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMeasurementDiscreetsDiscreetValueType FromRead(Read.IValueTag<Enums.EnumDiscreteValue?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementDiscreetsDiscreetValueType();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamMeasurementDiscreetsDiscreetIconRef : AttributeValue<Enums.EnumIcons?>
    {
        internal ParamsParamMeasurementDiscreetsDiscreetIconRef(Read.IValueTag<Enums.EnumIcons?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a iconRef node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementDiscreetsDiscreetIconRef() : base()
        {
            OnCreated();
        }

        public ParamsParamMeasurementDiscreetsDiscreetIconRef(Enums.EnumIcons? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumIconsConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumIcons? ConvertRawValue(string rawValue)
        {
            return Enums.EnumIconsConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMeasurementDiscreetsDiscreetIconRef FromRead(Read.IValueTag<Enums.EnumIcons?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementDiscreetsDiscreetIconRef();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies how the parameter has to be displayed on the user interface.
    /// For more information about the values that can be specified, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
public partial class ParamsParamMeasurementType : EditableElementValueNode<Read.IParamsParamMeasurementType, Enums.EnumParamMeasurementType?>
    {
        internal ParamsParamMeasurementType(Read.IParamsParamMeasurementType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementType() : base("Type")
        {
            OnCreated();
        }

        public ParamsParamMeasurementType(Enums.EnumParamMeasurementType? value) : base("Type", value)
        {
        }

        private ParamsParamMeasurementTypeCase _case;
        private ParamsParamMeasurementTypeContinuous _continuous;
        private AttributeValue<bool?> _hex;
        private AttributeValue<uint?> _lines;
        private AttributeValue<string> _link;
        private AttributeValue<string> _number;
        private AttributeValue<string> _options;
        private ParamsParamMeasurementTypeScientificNotation _scientificNotation;
        private AttributeValue<decimal?> _verificationDeviation;
        private AttributeValue<uint?> _width;
        ///<summary>
        /// Specifies the casing to be used. Only to be specified in case of measurement type "string":
        /// -	upper: upper case
        /// -	lower: lower case
        ///</summary>
public ParamsParamMeasurementTypeCase Case
        {
            get
            {
                return _case;
            }

            set
            {
                if (_case != value)
                {
                    _case = value;
                    AttributeHandler.Assign(value, this, "case");
                }
            }
        }

        ///<summary>
        /// Only to be specified in case of measurement type "string":
        /// -	On
        /// -	Off
        ///</summary>
public ParamsParamMeasurementTypeContinuous Continuous
        {
            get
            {
                return _continuous;
            }

            set
            {
                if (_continuous != value)
                {
                    _continuous = value;
                    AttributeHandler.Assign(value, this, "continuous");
                }
            }
        }

        ///<summary>
        /// Specifies whether the parameter value should be displayed as a hexadecimal number.
        ///</summary>
public AttributeValue<bool?> Hex
        {
            get
            {
                return _hex;
            }

            set
            {
                if (_hex != value)
                {
                    _hex = value;
                    AttributeHandler.Assign(value, this, "hex");
                }
            }
        }

        ///<summary>
        /// Specifies the number of lines that will be displayed. Only to be specified in case of measurement type "string".
        ///</summary>
public AttributeValue<uint?> Lines
        {
            get
            {
                return _lines;
            }

            set
            {
                if (_lines != value)
                {
                    _lines = value;
                    AttributeHandler.Assign(value, this, "lines");
                }
            }
        }

        ///<summary>
        /// Specifies the file name in which the input and output labels are stored. Only to be specified in case of measurement type "matrix".
        ///</summary>
public AttributeValue<string> Link
        {
            get
            {
                return _link;
            }

            set
            {
                if (_link != value)
                {
                    _link = value;
                    AttributeHandler.Assign(value, this, "link");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> Number
        {
            get
            {
                return _number;
            }

            set
            {
                if (_number != value)
                {
                    _number = value;
                    AttributeHandler.Assign(value, this, "number");
                }
            }
        }

        ///<summary>
        /// The options that can be specified in this attribute depend on the specified measurement type.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        /// If you specify multiple options, separate these by semi-colons (";").
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the scientific notation to be used.
        ///</summary>
public ParamsParamMeasurementTypeScientificNotation ScientificNotation
        {
            get
            {
                return _scientificNotation;
            }

            set
            {
                if (_scientificNotation != value)
                {
                    _scientificNotation = value;
                    AttributeHandler.Assign(value, this, "scientificNotation");
                }
            }
        }

        ///<summary>
        /// Specifies a deviation on analog parameters.
        ///</summary>
public AttributeValue<decimal?> VerificationDeviation
        {
            get
            {
                return _verificationDeviation;
            }

            set
            {
                if (_verificationDeviation != value)
                {
                    _verificationDeviation = value;
                    AttributeHandler.Assign(value, this, "verificationDeviation");
                }
            }
        }

        ///<summary>
        /// Specifies the width of a (page) button. Only to be specified in case of measurement types "pagebutton" or "button".
        ///</summary>
public AttributeValue<uint?> Width
        {
            get
            {
                return _width;
            }

            set
            {
                if (_width != value)
                {
                    _width = value;
                    AttributeHandler.Assign(value, this, "width");
                }
            }
        }

        public ParamsParamMeasurementTypeCase GetOrCreateCase()
        {
            if (Case == null)
                Case = new ParamsParamMeasurementTypeCase();
            return Case;
        }

        public ParamsParamMeasurementTypeContinuous GetOrCreateContinuous()
        {
            if (Continuous == null)
                Continuous = new ParamsParamMeasurementTypeContinuous();
            return Continuous;
        }

        public AttributeValue<bool?> GetOrCreateHex()
        {
            if (Hex == null)
                Hex = new AttributeValue<bool?>();
            return Hex;
        }

        public AttributeValue<uint?> GetOrCreateLines()
        {
            if (Lines == null)
                Lines = new AttributeValue<uint?>();
            return Lines;
        }

        public AttributeValue<string> GetOrCreateLink()
        {
            if (Link == null)
                Link = new AttributeValue<string>();
            return Link;
        }

        public AttributeValue<string> GetOrCreateNumber()
        {
            if (Number == null)
                Number = new AttributeValue<string>();
            return Number;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public ParamsParamMeasurementTypeScientificNotation GetOrCreateScientificNotation()
        {
            if (ScientificNotation == null)
                ScientificNotation = new ParamsParamMeasurementTypeScientificNotation();
            return ScientificNotation;
        }

        public AttributeValue<decimal?> GetOrCreateVerificationDeviation()
        {
            if (VerificationDeviation == null)
                VerificationDeviation = new AttributeValue<decimal?>();
            return VerificationDeviation;
        }

        public AttributeValue<uint?> GetOrCreateWidth()
        {
            if (Width == null)
                Width = new AttributeValue<uint?>();
            return Width;
        }

        protected override void Initialize(Read.IParamsParamMeasurementType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _case = read.Case != null ? new ParamsParamMeasurementTypeCase(read.Case, this) : null;
            _continuous = read.Continuous != null ? new ParamsParamMeasurementTypeContinuous(read.Continuous, this) : null;
            _hex = read.Hex != null ? new AttributeValue<bool?>(read.Hex, this) : null;
            _lines = read.Lines != null ? new AttributeValue<uint?>(read.Lines, this) : null;
            _link = read.Link != null ? new AttributeValue<string>(read.Link, this) : null;
            _number = read.Number != null ? new AttributeValue<string>(read.Number, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _scientificNotation = read.ScientificNotation != null ? new ParamsParamMeasurementTypeScientificNotation(read.ScientificNotation, this) : null;
            _verificationDeviation = read.VerificationDeviation != null ? new AttributeValue<decimal?>(read.VerificationDeviation, this) : null;
            _width = read.Width != null ? new AttributeValue<uint?>(read.Width, this) : null;
        }

        public static ParamsParamMeasurementType FromRead(Read.IParamsParamMeasurementType read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementType();
            item.Value = read.Value;
            item.Case = ParamsParamMeasurementTypeCase.FromRead(read.Case);
            item.Continuous = ParamsParamMeasurementTypeContinuous.FromRead(read.Continuous);
            item.Hex = AttributeValue<bool?>.FromRead(read.Hex);
            item.Lines = AttributeValue<uint?>.FromRead(read.Lines);
            item.Link = AttributeValue<string>.FromRead(read.Link);
            item.Number = AttributeValue<string>.FromRead(read.Number);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.ScientificNotation = ParamsParamMeasurementTypeScientificNotation.FromRead(read.ScientificNotation);
            item.VerificationDeviation = AttributeValue<decimal?>.FromRead(read.VerificationDeviation);
            item.Width = AttributeValue<uint?>.FromRead(read.Width);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMeasurementType(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamMeasurementTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamMeasurementType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamMeasurementTypeConverter.Convert(rawValue?.Trim());
        }
    }

    public partial class ParamsParamMeasurementTypeCase : AttributeValue<Enums.EnumParamMeasurementTypeCase?>
    {
        internal ParamsParamMeasurementTypeCase(Read.IValueTag<Enums.EnumParamMeasurementTypeCase?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a case node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementTypeCase() : base()
        {
            OnCreated();
        }

        public ParamsParamMeasurementTypeCase(Enums.EnumParamMeasurementTypeCase? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamMeasurementTypeCaseConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamMeasurementTypeCase? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamMeasurementTypeCaseConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMeasurementTypeCase FromRead(Read.IValueTag<Enums.EnumParamMeasurementTypeCase?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementTypeCase();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamMeasurementTypeContinuous : AttributeValue<Enums.EnumOnOff?>
    {
        internal ParamsParamMeasurementTypeContinuous(Read.IValueTag<Enums.EnumOnOff?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a continuous node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementTypeContinuous() : base()
        {
            OnCreated();
        }

        public ParamsParamMeasurementTypeContinuous(Enums.EnumOnOff? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOnOffConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOnOff? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOnOffConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMeasurementTypeContinuous FromRead(Read.IValueTag<Enums.EnumOnOff?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementTypeContinuous();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamMeasurementTypeScientificNotation : AttributeValue<Enums.EnumScientificNotation?>
    {
        internal ParamsParamMeasurementTypeScientificNotation(Read.IValueTag<Enums.EnumScientificNotation?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a scientificNotation node. None of it's properties will be set.
        ///</summary>
public ParamsParamMeasurementTypeScientificNotation() : base()
        {
            OnCreated();
        }

        public ParamsParamMeasurementTypeScientificNotation(Enums.EnumScientificNotation? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumScientificNotationConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumScientificNotation? ConvertRawValue(string rawValue)
        {
            return Enums.EnumScientificNotationConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamMeasurementTypeScientificNotation FromRead(Read.IValueTag<Enums.EnumScientificNotation?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMeasurementTypeScientificNotation();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Contains the links between parameters of a base protocol and parameters of this protocol.
    ///</summary>
public partial class ParamsParamMediation : EditableListNode<Read.IParamsParamMediation, Read.IParamsParamMediationLinkTo, ParamsParamMediationLinkTo>
    {
        internal ParamsParamMediation(Read.IParamsParamMediation read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Mediation node. None of it's properties will be set.
        ///</summary>
public ParamsParamMediation() : base("Mediation")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamMediation read, XmlElement editNode)
        {
        }

        public static ParamsParamMediation FromRead(Read.IParamsParamMediation read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMediation();
            foreach (var x in read)
            {
                item.Add(ParamsParamMediationLinkTo.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMediation(this);
        }
    }

    ///<summary>
    /// Defines a link between a parameter of a base protocol and a parameter of this protocol.
    /// For more information, refer to the DataMiner Protocol Markup Language documentation.
    ///</summary>
public partial class ParamsParamMediationLinkTo : EditableListNode<Read.IParamsParamMediationLinkTo, Read.IParamsParamMediationLinkToValueMapping, ParamsParamMediationLinkToValueMapping>
    {
        internal ParamsParamMediationLinkTo(Read.IParamsParamMediationLinkTo read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LinkTo node. None of it's properties will be set.
        ///</summary>
public ParamsParamMediationLinkTo() : base("LinkTo")
        {
            OnCreated();
        }

        private AttributeValue<string> _description;
        private AttributeValue<string> _ops;
        private AttributeValue<uint?> _pid;
        private AttributeValue<string> _protocol;
        ///<summary>
        /// Allows to provide a description about the defined link.
        ///</summary>
public AttributeValue<string> Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    AttributeHandler.Assign(value, this, "description");
                }
            }
        }

        ///<summary>
        /// Specifies one or more conversion operations separated by semicolons (";").
        /// Supported operations:
        /// *: factor
        /// /: division
        /// -: minus
        /// +: offset
        /// %: remainder
        /// Example: &lt;LinkTo pid="176" protocol="Philips DVS3810" ops="*:1024;+:5" /&gt;
        ///</summary>
public AttributeValue<string> Ops
        {
            get
            {
                return _ops;
            }

            set
            {
                if (_ops != value)
                {
                    _ops = value;
                    AttributeHandler.Assign(value, this, "ops");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter this parameter is linked to.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the protocol that holds the parameter to which this parameter is linked.
        ///</summary>
public AttributeValue<string> Protocol
        {
            get
            {
                return _protocol;
            }

            set
            {
                if (_protocol != value)
                {
                    _protocol = value;
                    AttributeHandler.Assign(value, this, "protocol");
                }
            }
        }

        public AttributeValue<string> GetOrCreateDescription()
        {
            if (Description == null)
                Description = new AttributeValue<string>();
            return Description;
        }

        public AttributeValue<string> GetOrCreateOps()
        {
            if (Ops == null)
                Ops = new AttributeValue<string>();
            return Ops;
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        public AttributeValue<string> GetOrCreateProtocol()
        {
            if (Protocol == null)
                Protocol = new AttributeValue<string>();
            return Protocol;
        }

        protected override void Initialize(Read.IParamsParamMediationLinkTo read, XmlElement editNode)
        {
            if (read == null)
                return;
            _description = read.Description != null ? new AttributeValue<string>(read.Description, this) : null;
            _ops = read.Ops != null ? new AttributeValue<string>(read.Ops, this) : null;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
            _protocol = read.Protocol != null ? new AttributeValue<string>(read.Protocol, this) : null;
        }

        public static ParamsParamMediationLinkTo FromRead(Read.IParamsParamMediationLinkTo read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMediationLinkTo();
            item.Description = AttributeValue<string>.FromRead(read.Description);
            item.Ops = AttributeValue<string>.FromRead(read.Ops);
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            item.Protocol = AttributeValue<string>.FromRead(read.Protocol);
            foreach (var x in read)
            {
                item.Add(ParamsParamMediationLinkToValueMapping.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMediationLinkTo(this);
        }
    }

    ///<summary>
    /// Defines a value mapping.
    ///</summary>
public partial class ParamsParamMediationLinkToValueMapping : EditableElementNode<Read.IParamsParamMediationLinkToValueMapping>
    {
        internal ParamsParamMediationLinkToValueMapping(Read.IParamsParamMediationLinkToValueMapping read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ValueMapping node. None of it's properties will be set.
        ///</summary>
public ParamsParamMediationLinkToValueMapping() : base("ValueMapping")
        {
            OnCreated();
        }

        private AttributeValue<string> _remoteValue;
        private AttributeValue<string> _valueAttribute;
        ///<summary>
        /// Specifies the value in the other protocol.
        ///</summary>
public AttributeValue<string> RemoteValue
        {
            get
            {
                return _remoteValue;
            }

            set
            {
                if (_remoteValue != value)
                {
                    _remoteValue = value;
                    AttributeHandler.Assign(value, this, "remoteValue");
                }
            }
        }

        ///<summary>
        /// Specifies the value in the current protocol.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        public AttributeValue<string> GetOrCreateRemoteValue()
        {
            if (RemoteValue == null)
                RemoteValue = new AttributeValue<string>();
            return RemoteValue;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        protected override void Initialize(Read.IParamsParamMediationLinkToValueMapping read, XmlElement editNode)
        {
            if (read == null)
                return;
            _remoteValue = read.RemoteValue != null ? new AttributeValue<string>(read.RemoteValue, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
        }

        public static ParamsParamMediationLinkToValueMapping FromRead(Read.IParamsParamMediationLinkToValueMapping read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamMediationLinkToValueMapping();
            item.RemoteValue = AttributeValue<string>.FromRead(read.RemoteValue);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamMediationLinkToValueMapping(this);
        }
    }

    ///<summary>
    /// Used to replicate specific parameters from another element.
    ///</summary>
public partial class ParamsParamReplication : EditableElementNode<Read.IParamsParamReplication>
    {
        internal ParamsParamReplication(Read.IParamsParamReplication read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Replication node. None of it's properties will be set.
        ///</summary>
public ParamsParamReplication() : base("Replication")
        {
            OnCreated();
        }

        private ParamsParamReplicationElement _element;
        private ParamsParamReplicationParameter _parameter;
        private AttributeValue<string> _ip;
        private AttributeValue<string> _uid;
        private AttributeValue<string> _pwd;
        private AttributeValue<string> _domain;
        ///<summary>
        /// Specifies the DataMiner Agent ID/element ID of the replicated element.
        ///</summary>
public ParamsParamReplicationElement Element
        {
            get
            {
                return _element;
            }

            set
            {
                if (_element != value)
                {
                    _element = value;
                    CombinedTagHandler.Assign(value, this, "Element");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter that has to be replicated.
        ///</summary>
public ParamsParamReplicationParameter Parameter
        {
            get
            {
                return _parameter;
            }

            set
            {
                if (_parameter != value)
                {
                    _parameter = value;
                    CombinedTagHandler.Assign(value, this, "Parameter");
                }
            }
        }

        ///<summary>
        /// Specifies the IP address of the DataMiner Agent on which the element is located.
        ///</summary>
public AttributeValue<string> Ip
        {
            get
            {
                return _ip;
            }

            set
            {
                if (_ip != value)
                {
                    _ip = value;
                    AttributeHandler.Assign(value, this, "ip");
                }
            }
        }

        ///<summary>
        /// Specifies the user name to log on to the DataMiner Agent on which the element is located.
        ///</summary>
public AttributeValue<string> Uid
        {
            get
            {
                return _uid;
            }

            set
            {
                if (_uid != value)
                {
                    _uid = value;
                    AttributeHandler.Assign(value, this, "uid");
                }
            }
        }

        ///<summary>
        /// Specifies the password to log on to the DataMiner Agent on which the element is located.
        ///</summary>
public AttributeValue<string> Pwd
        {
            get
            {
                return _pwd;
            }

            set
            {
                if (_pwd != value)
                {
                    _pwd = value;
                    AttributeHandler.Assign(value, this, "pwd");
                }
            }
        }

        ///<summary>
        /// Specifies the domain containing the DataMiner Agent on which the element is located..
        ///</summary>
public AttributeValue<string> Domain
        {
            get
            {
                return _domain;
            }

            set
            {
                if (_domain != value)
                {
                    _domain = value;
                    AttributeHandler.Assign(value, this, "domain");
                }
            }
        }

        public ParamsParamReplicationElement GetOrCreateElement()
        {
            if (Element == null)
                Element = new ParamsParamReplicationElement();
            return Element;
        }

        public ParamsParamReplicationParameter GetOrCreateParameter()
        {
            if (Parameter == null)
                Parameter = new ParamsParamReplicationParameter();
            return Parameter;
        }

        public AttributeValue<string> GetOrCreateIp()
        {
            if (Ip == null)
                Ip = new AttributeValue<string>();
            return Ip;
        }

        public AttributeValue<string> GetOrCreateUid()
        {
            if (Uid == null)
                Uid = new AttributeValue<string>();
            return Uid;
        }

        public AttributeValue<string> GetOrCreatePwd()
        {
            if (Pwd == null)
                Pwd = new AttributeValue<string>();
            return Pwd;
        }

        public AttributeValue<string> GetOrCreateDomain()
        {
            if (Domain == null)
                Domain = new AttributeValue<string>();
            return Domain;
        }

        protected override void Initialize(Read.IParamsParamReplication read, XmlElement editNode)
        {
            if (read == null)
                return;
            _element = read.Element != null ? new ParamsParamReplicationElement(read.Element, this, editNode.Element["Element"]) : null;
            _parameter = read.Parameter != null ? new ParamsParamReplicationParameter(read.Parameter, this, editNode.Element["Parameter"]) : null;
            _ip = read.Ip != null ? new AttributeValue<string>(read.Ip, this) : null;
            _uid = read.Uid != null ? new AttributeValue<string>(read.Uid, this) : null;
            _pwd = read.Pwd != null ? new AttributeValue<string>(read.Pwd, this) : null;
            _domain = read.Domain != null ? new AttributeValue<string>(read.Domain, this) : null;
        }

        public static ParamsParamReplication FromRead(Read.IParamsParamReplication read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamReplication();
            item.Element = ParamsParamReplicationElement.FromRead(read.Element);
            item.Parameter = ParamsParamReplicationParameter.FromRead(read.Parameter);
            item.Ip = AttributeValue<string>.FromRead(read.Ip);
            item.Uid = AttributeValue<string>.FromRead(read.Uid);
            item.Pwd = AttributeValue<string>.FromRead(read.Pwd);
            item.Domain = AttributeValue<string>.FromRead(read.Domain);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamReplication(this);
        }
    }

    ///<summary>
    /// Specifies the DataMiner Agent ID/element ID of the replicated element.
    ///</summary>
public partial class ParamsParamReplicationElement : EditableElementValueNode<Read.IParamsParamReplicationElement, string>
    {
        internal ParamsParamReplicationElement(Read.IParamsParamReplicationElement read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Element node. None of it's properties will be set.
        ///</summary>
public ParamsParamReplicationElement(bool useCDATA = false) : base("Element", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamReplicationElement(string value, bool useCDATA = false) : base("Element", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _dynamic;
        ///<summary>
        /// Specifies the ID of the parameter that holds the element ID (DMA ID/element ID) of the element from which the parameter should be replicated. Feature introduced in DataMiner 9.6.1 (RN 19311).
        ///</summary>
public AttributeValue<uint?> Dynamic
        {
            get
            {
                return _dynamic;
            }

            set
            {
                if (_dynamic != value)
                {
                    _dynamic = value;
                    AttributeHandler.Assign(value, this, "dynamic");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateDynamic()
        {
            if (Dynamic == null)
                Dynamic = new AttributeValue<uint?>();
            return Dynamic;
        }

        protected override void Initialize(Read.IParamsParamReplicationElement read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dynamic = read.Dynamic != null ? new AttributeValue<uint?>(read.Dynamic, this) : null;
        }

        public static ParamsParamReplicationElement FromRead(Read.IParamsParamReplicationElement read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamReplicationElement();
            item.Value = read.Value;
            item.Dynamic = AttributeValue<uint?>.FromRead(read.Dynamic);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamReplicationElement(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the parameter that has to be replicated.
    ///</summary>
public partial class ParamsParamReplicationParameter : EditableElementValueNode<Read.IParamsParamReplicationParameter, string>
    {
        internal ParamsParamReplicationParameter(Read.IParamsParamReplicationParameter read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Parameter node. None of it's properties will be set.
        ///</summary>
public ParamsParamReplicationParameter(bool useCDATA = false) : base("Parameter", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamReplicationParameter(string value, bool useCDATA = false) : base("Parameter", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _dynamic;
        ///<summary>
        /// Specifies the ID of the parameter that holds the ID of the parameter that should be replicated. Feature introduced in DataMiner 9.6.1 (RN 19311).
        ///</summary>
public AttributeValue<uint?> Dynamic
        {
            get
            {
                return _dynamic;
            }

            set
            {
                if (_dynamic != value)
                {
                    _dynamic = value;
                    AttributeHandler.Assign(value, this, "dynamic");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateDynamic()
        {
            if (Dynamic == null)
                Dynamic = new AttributeValue<uint?>();
            return Dynamic;
        }

        protected override void Initialize(Read.IParamsParamReplicationParameter read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dynamic = read.Dynamic != null ? new AttributeValue<uint?>(read.Dynamic, this) : null;
        }

        public static ParamsParamReplicationParameter FromRead(Read.IParamsParamReplicationParameter read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamReplicationParameter();
            item.Value = read.Value;
            item.Dynamic = AttributeValue<uint?>.FromRead(read.Dynamic);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamReplicationParameter(this);
        }
    }

    ///<summary>
    /// Specifies SNMP related functionality for this parameter.
    /// Only used in protocols for elements that are SNMP-compliant. In case of such an element, DataMiner will interrogate the SNMP agent specified in /Proto­col/Params/Param/SNMP/OID or capture traps defined in /Protocol/Params/Param/SNMP/TrapOID.
    ///</summary>
public partial class ParamsParamSNMP : EditableElementNode<Read.IParamsParamSNMP>
    {
        internal ParamsParamSNMP(Read.IParamsParamSNMP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SNMP node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMP() : base("SNMP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _enabled;
        private ElementValue<uint?> _factor;
        private ParamsParamSNMPInvalidResponseHandling _invalidResponseHandling;
        private ParamsParamSNMPOID _oID;
        private ParamsParamSNMPTrapMappings _trapMappings;
        private ParamsParamSNMPTrapOID _trapOID;
        private ParamsParamSNMPType _type;
        private AttributeValue<string> _options;
        ///<summary>
        /// Specifies whether DataMiner is allowed to interrogate the SNMP Agent.
        ///</summary>
public ElementValue<bool?> Enabled
        {
            get
            {
                return _enabled;
            }

            set
            {
                if (_enabled != value)
                {
                    _enabled = value;
                    ElementHandler.Assign(value, this, "Enabled");
                }
            }
        }

        ///<summary>
        /// Specifies that all values will be divided by the specified factor. By default, SNMP does not support decimal values. In a DataMiner protocol, however, you can use this Factor element to produce decimal values.
        /// If you specify a factor, all values will be divided by that factor.
        /// Default factor: 1
        ///</summary>
public ElementValue<uint?> Factor
        {
            get
            {
                return _factor;
            }

            set
            {
                if (_factor != value)
                {
                    _factor = value;
                    ElementHandler.Assign(value, this, "Factor");
                }
            }
        }

        ///<summary>
        /// Specifies the invalid response handling strategy.
        ///</summary>
public ParamsParamSNMPInvalidResponseHandling InvalidResponseHandling
        {
            get
            {
                return _invalidResponseHandling;
            }

            set
            {
                if (_invalidResponseHandling != value)
                {
                    _invalidResponseHandling = value;
                    CombinedTagHandler.Assign(value, this, "InvalidResponseHandling");
                }
            }
        }

        ///<summary>
        /// Specifies the OID.
        ///</summary>
public ParamsParamSNMPOID OID
        {
            get
            {
                return _oID;
            }

            set
            {
                if (_oID != value)
                {
                    _oID = value;
                    CombinedTagHandler.Assign(value, this, "OID");
                }
            }
        }

        ///<summary>
        /// Specifies trap mappings. Use this if the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute is too limited.
        /// If you want to make more advanced Alarm mappings, add one or more /Protocol/Params/Param/SNMP/Trap­Mappings/TrapMapping elements to this TrapMappings element.
        /// Note that it is possible to combine the TrapMappings element with the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute.
        ///</summary>
public ParamsParamSNMPTrapMappings TrapMappings
        {
            get
            {
                return _trapMappings;
            }

            set
            {
                if (_trapMappings != value)
                {
                    _trapMappings = value;
                    CombinedTagHandler.Assign(value, this, "TrapMappings");
                }
            }
        }

        ///<summary>
        /// Specifies the SNMP traps DataMiner has to capture via this parameter.
        ///</summary>
public ParamsParamSNMPTrapOID TrapOID
        {
            get
            {
                return _trapOID;
            }

            set
            {
                if (_trapOID != value)
                {
                    _trapOID = value;
                    CombinedTagHandler.Assign(value, this, "TrapOID");
                }
            }
        }

        ///<summary>
        /// Specifies the SNMP type.
        ///</summary>
public ParamsParamSNMPType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    ElementHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Use this attribute to change the community get or the community set string for a particular connection.
        /// Specify 'GetCommunity:' or 'SetCommunity:', followed by the connection. Example: options="GetCommunity:0"
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateEnabled()
        {
            if (Enabled == null)
                Enabled = new ElementValue<bool?>();
            return Enabled;
        }

        public ElementValue<uint?> GetOrCreateFactor()
        {
            if (Factor == null)
                Factor = new ElementValue<uint?>();
            return Factor;
        }

        public ParamsParamSNMPInvalidResponseHandling GetOrCreateInvalidResponseHandling()
        {
            if (InvalidResponseHandling == null)
                InvalidResponseHandling = new ParamsParamSNMPInvalidResponseHandling();
            return InvalidResponseHandling;
        }

        public ParamsParamSNMPOID GetOrCreateOID()
        {
            if (OID == null)
                OID = new ParamsParamSNMPOID();
            return OID;
        }

        public ParamsParamSNMPTrapMappings GetOrCreateTrapMappings()
        {
            if (TrapMappings == null)
                TrapMappings = new ParamsParamSNMPTrapMappings();
            return TrapMappings;
        }

        public ParamsParamSNMPTrapOID GetOrCreateTrapOID()
        {
            if (TrapOID == null)
                TrapOID = new ParamsParamSNMPTrapOID();
            return TrapOID;
        }

        public ParamsParamSNMPType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamSNMPType();
            return Type;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        protected override void Initialize(Read.IParamsParamSNMP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _enabled = read.Enabled != null ? new ElementValue<bool?>(read.Enabled, this) : null;
            _factor = read.Factor != null ? new ElementValue<uint?>(read.Factor, this) : null;
            _invalidResponseHandling = read.InvalidResponseHandling != null ? new ParamsParamSNMPInvalidResponseHandling(read.InvalidResponseHandling, this, editNode.Element["InvalidResponseHandling"]) : null;
            _oID = read.OID != null ? new ParamsParamSNMPOID(read.OID, this, editNode.Element["OID"]) : null;
            _trapMappings = read.TrapMappings != null ? new ParamsParamSNMPTrapMappings(read.TrapMappings, this, editNode.Element["TrapMappings"]) : null;
            _trapOID = read.TrapOID != null ? new ParamsParamSNMPTrapOID(read.TrapOID, this, editNode.Element["TrapOID"]) : null;
            _type = read.Type != null ? new ParamsParamSNMPType(read.Type, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
        }

        public static ParamsParamSNMP FromRead(Read.IParamsParamSNMP read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMP();
            item.Enabled = ElementValue<bool?>.FromRead(read.Enabled);
            item.Factor = ElementValue<uint?>.FromRead(read.Factor);
            item.InvalidResponseHandling = ParamsParamSNMPInvalidResponseHandling.FromRead(read.InvalidResponseHandling);
            item.OID = ParamsParamSNMPOID.FromRead(read.OID);
            item.TrapMappings = ParamsParamSNMPTrapMappings.FromRead(read.TrapMappings);
            item.TrapOID = ParamsParamSNMPTrapOID.FromRead(read.TrapOID);
            item.Type = ParamsParamSNMPType.FromRead(read.Type);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMP(this);
        }
    }

    ///<summary>
    /// Specifies the invalid response handling strategy.
    ///</summary>
public partial class ParamsParamSNMPInvalidResponseHandling : EditableElementNode<Read.IParamsParamSNMPInvalidResponseHandling>
    {
        internal ParamsParamSNMPInvalidResponseHandling(Read.IParamsParamSNMPInvalidResponseHandling read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a InvalidResponseHandling node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMPInvalidResponseHandling() : base("InvalidResponseHandling")
        {
            OnCreated();
        }

        private ElementValue<string> _infiniteLoop;
        ///<summary>
        /// Specifies the response handling in case an infinite loop was detected when polling a table.
        ///</summary>
public ElementValue<string> InfiniteLoop
        {
            get
            {
                return _infiniteLoop;
            }

            set
            {
                if (_infiniteLoop != value)
                {
                    _infiniteLoop = value;
                    ElementHandler.Assign(value, this, "InfiniteLoop");
                }
            }
        }

        public ElementValue<string> GetOrCreateInfiniteLoop()
        {
            if (InfiniteLoop == null)
                InfiniteLoop = new ElementValue<string>();
            return InfiniteLoop;
        }

        protected override void Initialize(Read.IParamsParamSNMPInvalidResponseHandling read, XmlElement editNode)
        {
            if (read == null)
                return;
            _infiniteLoop = read.InfiniteLoop != null ? new ElementValue<string>(read.InfiniteLoop, this) : null;
        }

        public static ParamsParamSNMPInvalidResponseHandling FromRead(Read.IParamsParamSNMPInvalidResponseHandling read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMPInvalidResponseHandling();
            item.InfiniteLoop = ElementValue<string>.FromRead(read.InfiniteLoop);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPInvalidResponseHandling(this);
        }
    }

    ///<summary>
    /// Specifies the OID.
    ///</summary>
public partial class ParamsParamSNMPOID : EditableElementValueNode<Read.IParamsParamSNMPOID, string>
    {
        internal ParamsParamSNMPOID(Read.IParamsParamSNMPOID read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a OID node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMPOID(bool useCDATA = false) : base("OID", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamSNMPOID(string value, bool useCDATA = false) : base("OID", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _id;
        private AttributeValue<uint?> _ipid;
        private AttributeValue<string> _options;
        private AttributeValue<bool?> _skipDynamicSNMPGet;
        private ParamsParamSNMPOIDType _type;
        ///<summary>
        /// Specifies the ID of the parameter holding the (partial) OID.
        /// The OID (or a part of it) can be made variable. To do so, replace the variable part of the OID by an asterisk (*), and specify the ID of the parameter holding (part of) the OID in the id attribute.
        /// In case of options=subtable, “id” has to contain the ID of the parameter holding the instance filter for the table.
        /// 
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter holding the IP address that needs to be used to poll this SNMP parameter.
        ///</summary>
public AttributeValue<uint?> Ipid
        {
            get
            {
                return _ipid;
            }

            set
            {
                if (_ipid != value)
                {
                    _ipid = value;
                    AttributeHandler.Assign(value, this, "ipid");
                }
            }
        }

        ///<summary>
        /// Specifies some options.
        /// For more information about the available options, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies that the evaluation of a certain parameter is skipped if it needs to be retrieved via a dynamic SNMP Get.
        ///</summary>
public AttributeValue<bool?> SkipDynamicSNMPGet
        {
            get
            {
                return _skipDynamicSNMPGet;
            }

            set
            {
                if (_skipDynamicSNMPGet != value)
                {
                    _skipDynamicSNMPGet = value;
                    AttributeHandler.Assign(value, this, "skipDynamicSNMPGet");
                }
            }
        }

        ///<summary>
        /// Specifies how the OID is constructed.
        /// For more information refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public ParamsParamSNMPOIDType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<uint?> GetOrCreateIpid()
        {
            if (Ipid == null)
                Ipid = new AttributeValue<uint?>();
            return Ipid;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<bool?> GetOrCreateSkipDynamicSNMPGet()
        {
            if (SkipDynamicSNMPGet == null)
                SkipDynamicSNMPGet = new AttributeValue<bool?>();
            return SkipDynamicSNMPGet;
        }

        public ParamsParamSNMPOIDType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamSNMPOIDType();
            return Type;
        }

        protected override void Initialize(Read.IParamsParamSNMPOID read, XmlElement editNode)
        {
            if (read == null)
                return;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _ipid = read.Ipid != null ? new AttributeValue<uint?>(read.Ipid, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _skipDynamicSNMPGet = read.SkipDynamicSNMPGet != null ? new AttributeValue<bool?>(read.SkipDynamicSNMPGet, this) : null;
            _type = read.Type != null ? new ParamsParamSNMPOIDType(read.Type, this) : null;
        }

        public static ParamsParamSNMPOID FromRead(Read.IParamsParamSNMPOID read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMPOID();
            item.Value = read.Value;
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Ipid = AttributeValue<uint?>.FromRead(read.Ipid);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.SkipDynamicSNMPGet = AttributeValue<bool?>.FromRead(read.SkipDynamicSNMPGet);
            item.Type = ParamsParamSNMPOIDType.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPOID(this);
        }
    }

    public partial class ParamsParamSNMPOIDType : AttributeValue<Enums.EnumOIDType?>
    {
        internal ParamsParamSNMPOIDType(Read.IValueTag<Enums.EnumOIDType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMPOIDType() : base()
        {
            OnCreated();
        }

        public ParamsParamSNMPOIDType(Enums.EnumOIDType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumOIDTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumOIDType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumOIDTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamSNMPOIDType FromRead(Read.IValueTag<Enums.EnumOIDType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMPOIDType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies trap mappings. Use this if the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute is too limited.
    /// If you want to make more advanced Alarm mappings, add one or more /Protocol/Params/Param/SNMP/Trap­Mappings/TrapMapping elements to this TrapMappings element.
    /// Note that it is possible to combine the TrapMappings element with the /Protocol/Params/Param/SNMP/TrapOID@mapAlarm attribute.
    ///</summary>
public partial class ParamsParamSNMPTrapMappings : EditableListNode<Read.IParamsParamSNMPTrapMappings, Read.IParamsParamSNMPTrapMappingsTrapMapping, ParamsParamSNMPTrapMappingsTrapMapping>
    {
        internal ParamsParamSNMPTrapMappings(Read.IParamsParamSNMPTrapMappings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TrapMappings node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMPTrapMappings() : base("TrapMappings")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IParamsParamSNMPTrapMappings read, XmlElement editNode)
        {
        }

        public static ParamsParamSNMPTrapMappings FromRead(Read.IParamsParamSNMPTrapMappings read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMPTrapMappings();
            foreach (var x in read)
            {
                item.Add(ParamsParamSNMPTrapMappingsTrapMapping.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPTrapMappings(this);
        }
    }

    ///<summary>
    /// Specifies a trap mapping. When a trap is received, all TrapMapping elements will be evaluated top down. When a TrapMapping element matches the incoming trap, the severity
    /// and/or the value specified in that mapping will be kept in memory. As soon as both the severity and the value are known, the search will stop and the alarm will be generated.
    /// At the end of the list of /Protocol/Params/Param/SNMP/TrapMappings/TrapMapping elements, you can add a TrapMapping element in which you specify a wildcard. In the event that severity or value still
    /// cannot be determined, the method with the mapAlarm attribute on the /Protocol/Params/Param/SNMP/TrapOID element will be executed in order to try to determine the severity and value.
    ///</summary>
public partial class ParamsParamSNMPTrapMappingsTrapMapping : EditableElementNode<Read.IParamsParamSNMPTrapMappingsTrapMapping>
    {
        internal ParamsParamSNMPTrapMappingsTrapMapping(Read.IParamsParamSNMPTrapMappingsTrapMapping read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TrapMapping node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMPTrapMappingsTrapMapping() : base("TrapMapping")
        {
            OnCreated();
        }

        private AttributeValue<string> _bindingMatch;
        private AttributeValue<string> _severity;
        private AttributeValue<string> _valueAttribute;
        ///<summary>
        /// Specifies one or more values for a specific binding.
        /// This attribute consists of two parts, separated by a colon:
        /// -	The number of the binding, and
        /// -	A pipe-separated enumeration of values you want to compare to the value of the binding.
        /// Note: Wildcards are allowed.
        ///</summary>
public AttributeValue<string> BindingMatch
        {
            get
            {
                return _bindingMatch;
            }

            set
            {
                if (_bindingMatch != value)
                {
                    _bindingMatch = value;
                    AttributeHandler.Assign(value, this, "bindingMatch");
                }
            }
        }

        ///<summary>
        /// Specifies a DataMiner severity level.
        /// Instead, you can also specify "NoAlarm" (or "NoTrap") to indicate that no Alarm should be generated.
        /// Note: The severity level information will always overwrite previously assigned severity levels.
        ///</summary>
public AttributeValue<string> Severity
        {
            get
            {
                return _severity;
            }

            set
            {
                if (_severity != value)
                {
                    _severity = value;
                    AttributeHandler.Assign(value, this, "severity");
                }
            }
        }

        ///<summary>
        /// This attribute contains an alarm value, specified in the same way as the alarm value in the mapAlarm attribute of the /Protocol/Params/Param/SNMP/TrapOID element.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        public AttributeValue<string> GetOrCreateBindingMatch()
        {
            if (BindingMatch == null)
                BindingMatch = new AttributeValue<string>();
            return BindingMatch;
        }

        public AttributeValue<string> GetOrCreateSeverity()
        {
            if (Severity == null)
                Severity = new AttributeValue<string>();
            return Severity;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        protected override void Initialize(Read.IParamsParamSNMPTrapMappingsTrapMapping read, XmlElement editNode)
        {
            if (read == null)
                return;
            _bindingMatch = read.BindingMatch != null ? new AttributeValue<string>(read.BindingMatch, this) : null;
            _severity = read.Severity != null ? new AttributeValue<string>(read.Severity, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
        }

        public static ParamsParamSNMPTrapMappingsTrapMapping FromRead(Read.IParamsParamSNMPTrapMappingsTrapMapping read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMPTrapMappingsTrapMapping();
            item.BindingMatch = AttributeValue<string>.FromRead(read.BindingMatch);
            item.Severity = AttributeValue<string>.FromRead(read.Severity);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPTrapMappingsTrapMapping(this);
        }
    }

    ///<summary>
    /// Specifies the SNMP traps DataMiner has to capture via this parameter.
    ///</summary>
public partial class ParamsParamSNMPTrapOID : EditableElementValueNode<Read.IParamsParamSNMPTrapOID, string>
    {
        internal ParamsParamSNMPTrapOID(Read.IParamsParamSNMPTrapOID read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TrapOID node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMPTrapOID(bool useCDATA = false) : base("TrapOID", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public ParamsParamSNMPTrapOID(string value, bool useCDATA = false) : base("TrapOID", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _checkBindings;
        private AttributeValue<string> _ipid;
        private AttributeValue<string> _mapAlarm;
        private AttributeValue<string> _setBindings;
        private ParamsParamSNMPTrapOIDType _type;
        ///<summary>
        /// Specifies basic filtering on the trap bindings.
        /// You can compare a certain binding to a fixed string (which optionally contains wildcards), or you can compare it to the value of another parameter.
        /// Checks must be separated by pipe characters.
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> CheckBindings
        {
            get
            {
                return _checkBindings;
            }

            set
            {
                if (_checkBindings != value)
                {
                    _checkBindings = value;
                    AttributeHandler.Assign(value, this, "checkBindings");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter holding IP addresses.
        /// By default, only the traps received from the polling IP address of an element will be captured. However, using the ipid attribute, you can point to a parameter that contains another IP address.
        /// If you use the ipid attribute, only traps received from the IP address found in the parameter referenced by the ipid attribute will be captured. Traps originating from the polling IP address will be disregarded.
        ///</summary>
public AttributeValue<string> Ipid
        {
            get
            {
                return _ipid;
            }

            set
            {
                if (_ipid != value)
                {
                    _ipid = value;
                    AttributeHandler.Assign(value, this, "ipid");
                }
            }
        }

        ///<summary>
        /// Allows an alarm to be generated when a trap is received.
        /// - The first part must be "true" or "false", to enable or disable the mapping of alarms.
        /// - The order of the following items (separated by pipe characters) is irrelevant: Severity, Value, Link, IgnoreSingleClear
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> MapAlarm
        {
            get
            {
                return _mapAlarm;
            }

            set
            {
                if (_mapAlarm != value)
                {
                    _mapAlarm = value;
                    AttributeHandler.Assign(value, this, "mapAlarm");
                }
            }
        }

        ///<summary>
        /// Specifies that the value of a certain binding should be set as the value of another parameter.
        /// Use this attribute to take the value of a certain binding and immediately set (copy) it to another parameter.
        /// Set pairs have to be separated by semi-colons. Every set pair consists of a binding position (1-based) containing the value to be set and the ID of the parameter to set,
        /// separated by a comma. If you want to set a dynamic table parameter, you can add more items to the set pair (which will then be concatenated with a "." to build an index).
        /// For examples, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> SetBindings
        {
            get
            {
                return _setBindings;
            }

            set
            {
                if (_setBindings != value)
                {
                    _setBindings = value;
                    AttributeHandler.Assign(value, this, "setBindings");
                }
            }
        }

        ///<summary>
        /// Specifies how the OID is constructed.
        /// For more information refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public ParamsParamSNMPTrapOIDType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public AttributeValue<string> GetOrCreateCheckBindings()
        {
            if (CheckBindings == null)
                CheckBindings = new AttributeValue<string>();
            return CheckBindings;
        }

        public AttributeValue<string> GetOrCreateIpid()
        {
            if (Ipid == null)
                Ipid = new AttributeValue<string>();
            return Ipid;
        }

        public AttributeValue<string> GetOrCreateMapAlarm()
        {
            if (MapAlarm == null)
                MapAlarm = new AttributeValue<string>();
            return MapAlarm;
        }

        public AttributeValue<string> GetOrCreateSetBindings()
        {
            if (SetBindings == null)
                SetBindings = new AttributeValue<string>();
            return SetBindings;
        }

        public ParamsParamSNMPTrapOIDType GetOrCreateType()
        {
            if (Type == null)
                Type = new ParamsParamSNMPTrapOIDType();
            return Type;
        }

        protected override void Initialize(Read.IParamsParamSNMPTrapOID read, XmlElement editNode)
        {
            if (read == null)
                return;
            _checkBindings = read.CheckBindings != null ? new AttributeValue<string>(read.CheckBindings, this) : null;
            _ipid = read.Ipid != null ? new AttributeValue<string>(read.Ipid, this) : null;
            _mapAlarm = read.MapAlarm != null ? new AttributeValue<string>(read.MapAlarm, this) : null;
            _setBindings = read.SetBindings != null ? new AttributeValue<string>(read.SetBindings, this) : null;
            _type = read.Type != null ? new ParamsParamSNMPTrapOIDType(read.Type, this) : null;
        }

        public static ParamsParamSNMPTrapOID FromRead(Read.IParamsParamSNMPTrapOID read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMPTrapOID();
            item.Value = read.Value;
            item.CheckBindings = AttributeValue<string>.FromRead(read.CheckBindings);
            item.Ipid = AttributeValue<string>.FromRead(read.Ipid);
            item.MapAlarm = AttributeValue<string>.FromRead(read.MapAlarm);
            item.SetBindings = AttributeValue<string>.FromRead(read.SetBindings);
            item.Type = ParamsParamSNMPTrapOIDType.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamSNMPTrapOID(this);
        }
    }

    public partial class ParamsParamSNMPTrapOIDType : AttributeValue<Enums.EnumTrapOIDType?>
    {
        internal ParamsParamSNMPTrapOIDType(Read.IValueTag<Enums.EnumTrapOIDType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMPTrapOIDType() : base()
        {
            OnCreated();
        }

        public ParamsParamSNMPTrapOIDType(Enums.EnumTrapOIDType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumTrapOIDTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumTrapOIDType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTrapOIDTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamSNMPTrapOIDType FromRead(Read.IValueTag<Enums.EnumTrapOIDType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMPTrapOIDType();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamSNMPType : ElementValue<Enums.EnumSNMPType?>
    {
        internal ParamsParamSNMPType(Read.IValueTag<Enums.EnumSNMPType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ParamsParamSNMPType() : base()
        {
            OnCreated();
        }

        public ParamsParamSNMPType(Enums.EnumSNMPType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumSNMPTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumSNMPType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumSNMPTypeConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamSNMPType FromRead(Read.IValueTag<Enums.EnumSNMPType?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamSNMPType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies the parameter type.
    /// For more information about the different types, refer to the DataMiner Protocol Markup Language documentation.
    /// Parameters of type "elementid", "elementname", "elementdmaid" and "dataminer info" are the first parameters that are loaded by a protocol. Although they hold information, they cannot, as such,
    /// be displayed in Element Display. Therefore, for these types of parameters, always set /Protocol/Params/Param/Display/RTDisplay "false".
    /// If you do want to display the information in one of these parameters in Element Display, there is a workaround: create another parameter of type "read", and copy the value from its invisible parameter to this new parameter after protocol start-up. You can then display the "read" parameter in Element Display.
    ///</summary>
public partial class ParamsParamType : EditableElementValueNode<Read.IParamsParamType, Enums.EnumParamType?>
    {
        internal ParamsParamType(Read.IParamsParamType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ParamsParamType() : base("Type")
        {
            OnCreated();
        }

        public ParamsParamType(Enums.EnumParamType? value) : base("Type", value)
        {
        }

        private AttributeValue<string> _alarmRegistration;
        private AttributeValue<string> _distribution;
        private AttributeValue<string> _dynamicSnmpGet;
        private AttributeValue<string> _id;
        private AttributeValue<string> _options;
        private ParamsParamTypeRelativeTimers _relativeTimers;
        private AttributeValue<uint?> _times;
        private AttributeValue<string> _virtual;
        ///<summary>
        /// Allows to trigger a QAction when specific parameters go into alarm.
        ///</summary>
public AttributeValue<string> AlarmRegistration
        {
            get
            {
                return _alarmRegistration;
            }

            set
            {
                if (_alarmRegistration != value)
                {
                    _alarmRegistration = value;
                    AttributeHandler.Assign(value, this, "alarmRegistration");
                }
            }
        }

        ///<summary>
        /// This attribute is used in situations in which elements of a certain type are linked to each-other as parent and child.
        /// By using data distribution, you can prevent data from being retrieved more than once, and also make sure that the data in your master and child are the same.
        /// In a protocol, these data distribution parameters can be defined in either a fixed or a dynamic way.
        /// To use data distribution, you have to add the "distribution" attribute to a Parameter in your master element. This parameter can be a "simple" parameter, or a column parameter from a table.
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> Distribution
        {
            get
            {
                return _distribution;
            }

            set
            {
                if (_distribution != value)
                {
                    _distribution = value;
                    AttributeHandler.Assign(value, this, "distribution");
                }
            }
        }

        ///<summary>
        /// Specifies what to retrieve (cell, row, etc.) and the way this request is added to the group execution queue.
        ///</summary>
public AttributeValue<string> DynamicSnmpGet
        {
            get
            {
                return _dynamicSnmpGet;
            }

            set
            {
                if (_dynamicSnmpGet != value)
                {
                    _dynamicSnmpGet = value;
                    AttributeHandler.Assign(value, this, "dynamicSnmpGet");
                }
            }
        }

        ///<summary>
        /// If Type is "read bit" or "response", this attribute specifies the ID of the parameter or response to which to refer, respectively.
        ///</summary>
public AttributeValue<string> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options, separated by semi-colons (";").
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// In this attribute, you can specify "true" or "true with reset".
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public ParamsParamTypeRelativeTimers RelativeTimers
        {
            get
            {
                return _relativeTimers;
            }

            set
            {
                if (_relativeTimers != value)
                {
                    _relativeTimers = value;
                    AttributeHandler.Assign(value, this, "relativeTimers");
                }
            }
        }

        ///<summary>
        /// If Type is "trailer", use this attribute to indicate how many times the trailer is allowed to occur before it is considered to be the trailer.
        ///</summary>
public AttributeValue<uint?> Times
        {
            get
            {
                return _times;
            }

            set
            {
                if (_times != value)
                {
                    _times = value;
                    AttributeHandler.Assign(value, this, "times");
                }
            }
        }

        ///<summary>
        /// Configures which virtual element connections are allowed to and from elements based on the protocol you are creating.
        /// You can specify multiple connection restraints, separated by a pipe character ("|").
        /// A connection restraint has the following format (building blocks separated by ":")
        /// -	keyword "source" or "destination",
        /// -	optionally followed by one or more Protocol definitions ("Protocol=...") and one or more parameter descriptions ("Parameterdescription=...").
        ///</summary>
public AttributeValue<string> Virtual
        {
            get
            {
                return _virtual;
            }

            set
            {
                if (_virtual != value)
                {
                    _virtual = value;
                    AttributeHandler.Assign(value, this, "virtual");
                }
            }
        }

        public AttributeValue<string> GetOrCreateAlarmRegistration()
        {
            if (AlarmRegistration == null)
                AlarmRegistration = new AttributeValue<string>();
            return AlarmRegistration;
        }

        public AttributeValue<string> GetOrCreateDistribution()
        {
            if (Distribution == null)
                Distribution = new AttributeValue<string>();
            return Distribution;
        }

        public AttributeValue<string> GetOrCreateDynamicSnmpGet()
        {
            if (DynamicSnmpGet == null)
                DynamicSnmpGet = new AttributeValue<string>();
            return DynamicSnmpGet;
        }

        public AttributeValue<string> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<string>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public ParamsParamTypeRelativeTimers GetOrCreateRelativeTimers()
        {
            if (RelativeTimers == null)
                RelativeTimers = new ParamsParamTypeRelativeTimers();
            return RelativeTimers;
        }

        public AttributeValue<uint?> GetOrCreateTimes()
        {
            if (Times == null)
                Times = new AttributeValue<uint?>();
            return Times;
        }

        public AttributeValue<string> GetOrCreateVirtual()
        {
            if (Virtual == null)
                Virtual = new AttributeValue<string>();
            return Virtual;
        }

        protected override void Initialize(Read.IParamsParamType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _alarmRegistration = read.AlarmRegistration != null ? new AttributeValue<string>(read.AlarmRegistration, this) : null;
            _distribution = read.Distribution != null ? new AttributeValue<string>(read.Distribution, this) : null;
            _dynamicSnmpGet = read.DynamicSnmpGet != null ? new AttributeValue<string>(read.DynamicSnmpGet, this) : null;
            _id = read.Id != null ? new AttributeValue<string>(read.Id, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _relativeTimers = read.RelativeTimers != null ? new ParamsParamTypeRelativeTimers(read.RelativeTimers, this) : null;
            _times = read.Times != null ? new AttributeValue<uint?>(read.Times, this) : null;
            _virtual = read.Virtual != null ? new AttributeValue<string>(read.Virtual, this) : null;
        }

        public static ParamsParamType FromRead(Read.IParamsParamType read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamType();
            item.Value = read.Value;
            item.AlarmRegistration = AttributeValue<string>.FromRead(read.AlarmRegistration);
            item.Distribution = AttributeValue<string>.FromRead(read.Distribution);
            item.DynamicSnmpGet = AttributeValue<string>.FromRead(read.DynamicSnmpGet);
            item.Id = AttributeValue<string>.FromRead(read.Id);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.RelativeTimers = ParamsParamTypeRelativeTimers.FromRead(read.RelativeTimers);
            item.Times = AttributeValue<uint?>.FromRead(read.Times);
            item.Virtual = AttributeValue<string>.FromRead(read.Virtual);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitParamsParamType(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamTypeConverter.Convert(rawValue?.Trim());
        }
    }

    public partial class ParamsParamTypeRelativeTimers : AttributeValue<Enums.EnumProtocolTypeRelativeTimers?>
    {
        internal ParamsParamTypeRelativeTimers(Read.IValueTag<Enums.EnumProtocolTypeRelativeTimers?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a relativeTimers node. None of it's properties will be set.
        ///</summary>
public ParamsParamTypeRelativeTimers() : base()
        {
            OnCreated();
        }

        public ParamsParamTypeRelativeTimers(Enums.EnumProtocolTypeRelativeTimers? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumProtocolTypeRelativeTimersConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumProtocolTypeRelativeTimers? ConvertRawValue(string rawValue)
        {
            return Enums.EnumProtocolTypeRelativeTimersConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamTypeRelativeTimers FromRead(Read.IValueTag<Enums.EnumProtocolTypeRelativeTimers?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamTypeRelativeTimers();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class ParamsParamConfirmPopup : AttributeValue<Enums.EnumParamConfirmPopup?>
    {
        internal ParamsParamConfirmPopup(Read.IValueTag<Enums.EnumParamConfirmPopup?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a confirmPopup node. None of it's properties will be set.
        ///</summary>
public ParamsParamConfirmPopup() : base()
        {
            OnCreated();
        }

        public ParamsParamConfirmPopup(Enums.EnumParamConfirmPopup? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumParamConfirmPopupConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumParamConfirmPopup? ConvertRawValue(string rawValue)
        {
            return Enums.EnumParamConfirmPopupConverter.Convert(rawValue?.Trim());
        }

        public new static ParamsParamConfirmPopup FromRead(Read.IValueTag<Enums.EnumParamConfirmPopup?> read)
        {
            if (read == null)
                return null;
            var item = new ParamsParamConfirmPopup();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// For every protocol, you have to specify its type in /Protocol/Type, and its port settings in /Protocol/Portsettings.
    /// In case of a multi-type protocol, the /Protocol/Type@advanced attribute is used to any additional protocol types.
    /// The port settings for those additional protocol types then have to be specified in a /Protocol/Ports/Portsettings element in which the name attribute contains the name of the additional type as specified in the /Protocol/Type@advanced attribute.
    ///</summary>
public partial class Ports : EditableListNode<Read.IPorts, Read.IPortSettings, PortSettings>
    {
        internal Ports(Read.IPorts read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Ports node. None of it's properties will be set.
        ///</summary>
public Ports() : base("Ports")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IPorts read, XmlElement editNode)
        {
        }

        public static Ports FromRead(Read.IPorts read)
        {
            if (read == null)
                return null;
            var item = new Ports();
            foreach (var x in read)
            {
                item.Add(PortSettings.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPorts(this);
        }
    }

    public partial class ProcessAutomation : EditableElementNode<Read.IProcessAutomation>
    {
        internal ProcessAutomation(Read.IProcessAutomation read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ProcessAutomation node. None of it's properties will be set.
        ///</summary>
public ProcessAutomation() : base("ProcessAutomation")
        {
            OnCreated();
        }

        private ProcessAutomationProcessAutomationOptions _processAutomationOptions;
        ///<summary>
        /// Additional options for the Process Automation Queue.
        ///</summary>
public ProcessAutomationProcessAutomationOptions ProcessAutomationOptions
        {
            get
            {
                return _processAutomationOptions;
            }

            set
            {
                if (_processAutomationOptions != value)
                {
                    _processAutomationOptions = value;
                    CombinedTagHandler.Assign(value, this, "ProcessAutomationOptions");
                }
            }
        }

        public ProcessAutomationProcessAutomationOptions GetOrCreateProcessAutomationOptions()
        {
            if (ProcessAutomationOptions == null)
                ProcessAutomationOptions = new ProcessAutomationProcessAutomationOptions();
            return ProcessAutomationOptions;
        }

        protected override void Initialize(Read.IProcessAutomation read, XmlElement editNode)
        {
            if (read == null)
                return;
            _processAutomationOptions = read.ProcessAutomationOptions != null ? new ProcessAutomationProcessAutomationOptions(read.ProcessAutomationOptions, this, editNode.Element["ProcessAutomationOptions"]) : null;
        }

        public static ProcessAutomation FromRead(Read.IProcessAutomation read)
        {
            if (read == null)
                return null;
            var item = new ProcessAutomation();
            item.ProcessAutomationOptions = ProcessAutomationProcessAutomationOptions.FromRead(read.ProcessAutomationOptions);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProcessAutomation(this);
        }
    }

    ///<summary>
    /// Additional options for the Process Automation Queue.
    ///</summary>
public partial class ProcessAutomationProcessAutomationOptions : EditableListNode<Read.IProcessAutomationProcessAutomationOptions, Read.IProcessAutomationProcessAutomationOptionsProcessAutomationOption, ProcessAutomationProcessAutomationOptionsProcessAutomationOption>
    {
        internal ProcessAutomationProcessAutomationOptions(Read.IProcessAutomationProcessAutomationOptions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ProcessAutomationOptions node. None of it's properties will be set.
        ///</summary>
public ProcessAutomationProcessAutomationOptions() : base("ProcessAutomationOptions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IProcessAutomationProcessAutomationOptions read, XmlElement editNode)
        {
        }

        public static ProcessAutomationProcessAutomationOptions FromRead(Read.IProcessAutomationProcessAutomationOptions read)
        {
            if (read == null)
                return null;
            var item = new ProcessAutomationProcessAutomationOptions();
            foreach (var x in read)
            {
                item.Add(ProcessAutomationProcessAutomationOptionsProcessAutomationOption.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProcessAutomationProcessAutomationOptions(this);
        }
    }

    ///<summary>
    /// The additional options for the Process Automation Queue.
    ///</summary>
public partial class ProcessAutomationProcessAutomationOptionsProcessAutomationOption : EditableElementNode<Read.IProcessAutomationProcessAutomationOptionsProcessAutomationOption>
    {
        internal ProcessAutomationProcessAutomationOptionsProcessAutomationOption(Read.IProcessAutomationProcessAutomationOptionsProcessAutomationOption read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ProcessAutomationOption node. None of it's properties will be set.
        ///</summary>
public ProcessAutomationProcessAutomationOptionsProcessAutomationOption() : base("ProcessAutomationOption")
        {
            OnCreated();
        }

        private AttributeValue<string> _name;
        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Name of the option.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Parameter ID of the parameter that will contain the option value.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IProcessAutomationProcessAutomationOptionsProcessAutomationOption read, XmlElement editNode)
        {
            if (read == null)
                return;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static ProcessAutomationProcessAutomationOptionsProcessAutomationOption FromRead(Read.IProcessAutomationProcessAutomationOptionsProcessAutomationOption read)
        {
            if (read == null)
                return null;
            var item = new ProcessAutomationProcessAutomationOptionsProcessAutomationOption();
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProcessAutomationProcessAutomationOptionsProcessAutomationOption(this);
        }
    }

    ///<summary>
    /// Contains all the QActions defined in the protocol.
    /// A QAction (i.e. Quick Action) is a script that can be executed when a parameter or a row changes. Inside a QAction, the following scripting languages can be used:
    /// -	JScript
    /// -	VBScript
    /// -	C#
    ///</summary>
public partial class QActions : EditableListNode<Read.IQActions, Read.IQActionsQAction, QActionsQAction>
    {
        internal QActions(Read.IQActions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a QActions node. None of it's properties will be set.
        ///</summary>
public QActions() : base("QActions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IQActions read, XmlElement editNode)
        {
        }

        public static QActions FromRead(Read.IQActions read)
        {
            if (read == null)
                return null;
            var item = new QActions();
            foreach (var x in read)
            {
                item.Add(QActionsQAction.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitQActions(this);
        }
    }

    ///<summary>
    /// A QAction is a script that can be executed when a parameter or a row has changed.
    /// The actual script code of a QAction must be placed inside a CDATA section.
    /// By placing code inside a CDATA section, characters like "&lt;" and "&amp;", which are normally illegal when placed inside normal XML elements, will no longer be considered as such.
    /// In order to interact with SLProtocol (e.g. to access parameters or to notify DataMiner of certain events)
    /// - in JScript or VBScript code, use the SLScript object
    /// - in C# code, use the Skyline.DataMiner.Scripting namespace
    /// For information on how to use C# in protocols, refer to the appendices of the DaaMiner Protocol Development Guide.
    ///</summary>
public partial class QActionsQAction : EditableElementValueNode<Read.IQActionsQAction, string>
    {
        internal QActionsQAction(Read.IQActionsQAction read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a QAction node. None of it's properties will be set.
        ///</summary>
public QActionsQAction() : base("QAction")
        {
            OnCreated();
        }

        private ElementValue<string> _condition;
        private AttributeValue<string> _dllImport;
        private QActionsQActionEncoding _encoding;
        private AttributeValue<string> _entryPoint;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _include;
        private AttributeValue<string> _inputParameters;
        private AttributeValue<string> _name;
        private AttributeValue<string> _options;
        private AttributeValue<bool?> _row;
        private AttributeValue<string> _triggers;
        ///<summary>
        /// Specifies a condition that must be met in order for the QAction to execute.
        ///</summary>
public ElementValue<string> Condition
        {
            get
            {
                return _condition;
            }

            set
            {
                if (_condition != value)
                {
                    _condition = value;
                    ElementHandler.Assign(value, this, "Condition");
                }
            }
        }

        ///<summary>
        /// Specifies external DLL files used by the QAction.
        /// Multiple values have to be separated by semi-colons (";").
        /// System DLL files must be stored in the system dll directory; all other DLL files must be stored in the C:\Skyline DataMiner\ProtocolScripts directory.
        /// Note: The following DLL files do not have to be specified in this dllImport attribute. They are loaded by default.
        /// -	System.dll
        /// -	SLManagedScripting.dll
        /// -	Interop.sldms.dll
        ///</summary>
public AttributeValue<string> DllImport
        {
            get
            {
                return _dllImport;
            }

            set
            {
                if (_dllImport != value)
                {
                    _dllImport = value;
                    AttributeHandler.Assign(value, this, "dllImport");
                }
            }
        }

        ///<summary>
        /// Specifies the language in which the script has been written:
        /// -	JScript
        /// -	VBScript
        /// -	CSharp
        /// (case insensitive)
        ///</summary>
public QActionsQActionEncoding Encoding
        {
            get
            {
                return _encoding;
            }

            set
            {
                if (_encoding != value)
                {
                    _encoding = value;
                    AttributeHandler.Assign(value, this, "encoding");
                }
            }
        }

        ///<summary>
        /// Defines the entry point method(s) corresponding with the parameter(s) triggering the QAction execution.
        ///</summary>
public AttributeValue<string> EntryPoint
        {
            get
            {
                return _entryPoint;
            }

            set
            {
                if (_entryPoint != value)
                {
                    _entryPoint = value;
                    AttributeHandler.Assign(value, this, "entryPoint");
                }
            }
        }

        ///<summary>
        /// Specifies the unique QAction ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the external script to be executed.
        ///</summary>
public AttributeValue<string> Include
        {
            get
            {
                return _include;
            }

            set
            {
                if (_include != value)
                {
                    _include = value;
                    AttributeHandler.Assign(value, this, "include");
                }
            }
        }

        ///<summary>
        /// Specifies the IDs of the parameters that will be passed to functions inside the QAction script.
        /// Multiple values have to be separated by semi-colons (";").
        ///</summary>
public AttributeValue<string> InputParameters
        {
            get
            {
                return _inputParameters;
            }

            set
            {
                if (_inputParameters != value)
                {
                    _inputParameters = value;
                    AttributeHandler.Assign(value, this, "inputParameters");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the QAction.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options (multiple options can be separated by semicolons (';'). Possible options:
        /// - binary: If specified, all values in “inputParameters” are forwarded to the QAction as a byte array holding the raw content of the parameter.
        /// - debug: Compiles the QAction in debug mode.
        /// - dllName=name: With this option, the specified name will be included in the DLL name. The name of the DLL will be as follows: [ProtocolName].[ProtocolVersion].[name].dll.
        /// - queued: The QAction will be executed asynchronously. This implies that the QAction is triggered and set in the background. Be careful when using this option and make sure to also implement thread synchronization when this QAction is called more than once.
        /// - group: When this option is specified, the "OldRow()" method will return the values retrieved by that group. This option can be used in case of high-volume polling. Use it with care.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// If "true", the QAction will be executed when a row of a table has changed.
        ///</summary>
public AttributeValue<bool?> Row
        {
            get
            {
                return _row;
            }

            set
            {
                if (_row != value)
                {
                    _row = value;
                    AttributeHandler.Assign(value, this, "row");
                }
            }
        }

        ///<summary>
        /// Specifies the IDs of the parameters that will cause the QAction to be executed each time their value changes.
        /// Multiple values have to be separated by semi-colons (";").
        ///</summary>
public AttributeValue<string> Triggers
        {
            get
            {
                return _triggers;
            }

            set
            {
                if (_triggers != value)
                {
                    _triggers = value;
                    AttributeHandler.Assign(value, this, "triggers");
                }
            }
        }

        public ElementValue<string> GetOrCreateCondition()
        {
            if (Condition == null)
                Condition = new ElementValue<string>();
            return Condition;
        }

        public AttributeValue<string> GetOrCreateDllImport()
        {
            if (DllImport == null)
                DllImport = new AttributeValue<string>();
            return DllImport;
        }

        public QActionsQActionEncoding GetOrCreateEncoding()
        {
            if (Encoding == null)
                Encoding = new QActionsQActionEncoding();
            return Encoding;
        }

        public AttributeValue<string> GetOrCreateEntryPoint()
        {
            if (EntryPoint == null)
                EntryPoint = new AttributeValue<string>();
            return EntryPoint;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateInclude()
        {
            if (Include == null)
                Include = new AttributeValue<string>();
            return Include;
        }

        public AttributeValue<string> GetOrCreateInputParameters()
        {
            if (InputParameters == null)
                InputParameters = new AttributeValue<string>();
            return InputParameters;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<bool?> GetOrCreateRow()
        {
            if (Row == null)
                Row = new AttributeValue<bool?>();
            return Row;
        }

        public AttributeValue<string> GetOrCreateTriggers()
        {
            if (Triggers == null)
                Triggers = new AttributeValue<string>();
            return Triggers;
        }

        protected override void Initialize(Read.IQActionsQAction read, XmlElement editNode)
        {
            if (read == null)
                return;
            _condition = read.Condition != null ? new ElementValue<string>(read.Condition, this) : null;
            _dllImport = read.DllImport != null ? new AttributeValue<string>(read.DllImport, this) : null;
            _encoding = read.Encoding != null ? new QActionsQActionEncoding(read.Encoding, this) : null;
            _entryPoint = read.EntryPoint != null ? new AttributeValue<string>(read.EntryPoint, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _include = read.Include != null ? new AttributeValue<string>(read.Include, this) : null;
            _inputParameters = read.InputParameters != null ? new AttributeValue<string>(read.InputParameters, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _row = read.Row != null ? new AttributeValue<bool?>(read.Row, this) : null;
            _triggers = read.Triggers != null ? new AttributeValue<string>(read.Triggers, this) : null;
        }

        public static QActionsQAction FromRead(Read.IQActionsQAction read)
        {
            if (read == null)
                return null;
            var item = new QActionsQAction();
            item.Value = read.Value;
            item.Condition = ElementValue<string>.FromRead(read.Condition);
            item.DllImport = AttributeValue<string>.FromRead(read.DllImport);
            item.Encoding = QActionsQActionEncoding.FromRead(read.Encoding);
            item.EntryPoint = AttributeValue<string>.FromRead(read.EntryPoint);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Include = AttributeValue<string>.FromRead(read.Include);
            item.InputParameters = AttributeValue<string>.FromRead(read.InputParameters);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Row = AttributeValue<bool?>.FromRead(read.Row);
            item.Triggers = AttributeValue<string>.FromRead(read.Triggers);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitQActionsQAction(this);
        }
    }

    public partial class QActionsQActionEncoding : AttributeValue<Enums.EnumQActionEncoding?>
    {
        internal QActionsQActionEncoding(Read.IValueTag<Enums.EnumQActionEncoding?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a encoding node. None of it's properties will be set.
        ///</summary>
public QActionsQActionEncoding() : base()
        {
            OnCreated();
        }

        public QActionsQActionEncoding(Enums.EnumQActionEncoding? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumQActionEncodingConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumQActionEncoding? ConvertRawValue(string rawValue)
        {
            return Enums.EnumQActionEncodingConverter.Convert(rawValue?.Trim());
        }

        public new static QActionsQActionEncoding FromRead(Read.IValueTag<Enums.EnumQActionEncoding?> read)
        {
            if (read == null)
                return null;
            var item = new QActionsQActionEncoding();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Configures Root Cause Analysis (RCA).
    ///</summary>
public partial class RCA : EditableElementNode<Read.IRCA>
    {
        internal RCA(Read.IRCA read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a RCA node. None of it's properties will be set.
        ///</summary>
public RCA() : base("RCA")
        {
            OnCreated();
        }

        private RCAProtocol _protocol;
        ///<summary>
        /// *** No documentation available yet. ***
        ///</summary>
public RCAProtocol Protocol
        {
            get
            {
                return _protocol;
            }

            set
            {
                if (_protocol != value)
                {
                    _protocol = value;
                    CombinedTagHandler.Assign(value, this, "Protocol");
                }
            }
        }

        public RCAProtocol GetOrCreateProtocol()
        {
            if (Protocol == null)
                Protocol = new RCAProtocol();
            return Protocol;
        }

        protected override void Initialize(Read.IRCA read, XmlElement editNode)
        {
            if (read == null)
                return;
            _protocol = read.Protocol != null ? new RCAProtocol(read.Protocol, this, editNode.Element["Protocol"]) : null;
        }

        public static RCA FromRead(Read.IRCA read)
        {
            if (read == null)
                return null;
            var item = new RCA();
            item.Protocol = RCAProtocol.FromRead(read.Protocol);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRCA(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet. ***
    ///</summary>
public partial class RCAProtocol : EditableListNode<Read.IRCAProtocol, Read.IRCAProtocolLink, RCAProtocolLink>
    {
        internal RCAProtocol(Read.IRCAProtocol read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Protocol node. None of it's properties will be set.
        ///</summary>
public RCAProtocol() : base("Protocol")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IRCAProtocol read, XmlElement editNode)
        {
        }

        public static RCAProtocol FromRead(Read.IRCAProtocol read)
        {
            if (read == null)
                return null;
            var item = new RCAProtocol();
            foreach (var x in read)
            {
                item.Add(RCAProtocolLink.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRCAProtocol(this);
        }
    }

    ///<summary>
    /// Defines an RCA chain by defining relations.
    ///</summary>
public partial class RCAProtocolLink : EditableElementNode<Read.IRCAProtocolLink>
    {
        internal RCAProtocolLink(Read.IRCAProtocolLink read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Link node. None of it's properties will be set.
        ///</summary>
public RCAProtocolLink() : base("Link")
        {
            OnCreated();
        }

        private AttributeValue<string> _distribute;
        private AttributeValue<string> _path;
        private AttributeValue<string> _valueFilter;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> Distribute
        {
            get
            {
                return _distribute;
            }

            set
            {
                if (_distribute != value)
                {
                    _distribute = value;
                    AttributeHandler.Assign(value, this, "distribute");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> Path
        {
            get
            {
                return _path;
            }

            set
            {
                if (_path != value)
                {
                    _path = value;
                    AttributeHandler.Assign(value, this, "path");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> ValueFilter
        {
            get
            {
                return _valueFilter;
            }

            set
            {
                if (_valueFilter != value)
                {
                    _valueFilter = value;
                    AttributeHandler.Assign(value, this, "valueFilter");
                }
            }
        }

        public AttributeValue<string> GetOrCreateDistribute()
        {
            if (Distribute == null)
                Distribute = new AttributeValue<string>();
            return Distribute;
        }

        public AttributeValue<string> GetOrCreatePath()
        {
            if (Path == null)
                Path = new AttributeValue<string>();
            return Path;
        }

        public AttributeValue<string> GetOrCreateValueFilter()
        {
            if (ValueFilter == null)
                ValueFilter = new AttributeValue<string>();
            return ValueFilter;
        }

        protected override void Initialize(Read.IRCAProtocolLink read, XmlElement editNode)
        {
            if (read == null)
                return;
            _distribute = read.Distribute != null ? new AttributeValue<string>(read.Distribute, this) : null;
            _path = read.Path != null ? new AttributeValue<string>(read.Path, this) : null;
            _valueFilter = read.ValueFilter != null ? new AttributeValue<string>(read.ValueFilter, this) : null;
        }

        public static RCAProtocolLink FromRead(Read.IRCAProtocolLink read)
        {
            if (read == null)
                return null;
            var item = new RCAProtocolLink();
            item.Distribute = AttributeValue<string>.FromRead(read.Distribute);
            item.Path = AttributeValue<string>.FromRead(read.Path);
            item.ValueFilter = AttributeValue<string>.FromRead(read.ValueFilter);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRCAProtocolLink(this);
        }
    }

    ///<summary>
    /// Defines relations between tables.
    ///</summary>
public partial class Relations : EditableListNode<Read.IRelations, Read.IRelationsRelation, RelationsRelation>
    {
        internal Relations(Read.IRelations read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Relations node. None of it's properties will be set.
        ///</summary>
public Relations() : base("Relations")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IRelations read, XmlElement editNode)
        {
        }

        public static Relations FromRead(Read.IRelations read)
        {
            if (read == null)
                return null;
            var item = new Relations();
            foreach (var x in read)
            {
                item.Add(RelationsRelation.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRelations(this);
        }
    }

    ///<summary>
    /// Defines a relation between tables.
    ///</summary>
public partial class RelationsRelation : EditableElementNode<Read.IRelationsRelation>
    {
        internal RelationsRelation(Read.IRelationsRelation read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Relation node. None of it's properties will be set.
        ///</summary>
public RelationsRelation() : base("Relation")
        {
            OnCreated();
        }

        private AttributeValue<string> _options;
        private AttributeValue<string> _path;
        private AttributeValue<string> _name;
        ///<summary>
        /// Defines a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the IDs of the tables that are linked to each other.
        ///</summary>
public AttributeValue<string> Path
        {
            get
            {
                return _path;
            }

            set
            {
                if (_path != value)
                {
                    _path = value;
                    AttributeHandler.Assign(value, this, "path");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the relation.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<string> GetOrCreatePath()
        {
            if (Path == null)
                Path = new AttributeValue<string>();
            return Path;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.IRelationsRelation read, XmlElement editNode)
        {
            if (read == null)
                return;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _path = read.Path != null ? new AttributeValue<string>(read.Path, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static RelationsRelation FromRead(Read.IRelationsRelation read)
        {
            if (read == null)
                return null;
            var item = new RelationsRelation();
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Path = AttributeValue<string>.FromRead(read.Path);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitRelationsRelation(this);
        }
    }

    ///<summary>
    /// Contains all responses defined in the protocol.
    ///</summary>
public partial class Responses : EditableListNode<Read.IResponses, Read.IResponsesResponse, ResponsesResponse>
    {
        internal Responses(Read.IResponses read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Responses node. None of it's properties will be set.
        ///</summary>
public Responses() : base("Responses")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IResponses read, XmlElement editNode)
        {
        }

        public static Responses FromRead(Read.IResponses read)
        {
            if (read == null)
                return null;
            var item = new Responses();
            foreach (var x in read)
            {
                item.Add(ResponsesResponse.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitResponses(this);
        }
    }

    ///<summary>
    /// Specifies a response that DataMiner can expect after having sent a specific command to the device.
    /// Similar to a command, a response is a collection of parameters that describe the message that the device is expected to send back to DataMiner after having received a command.
    /// When it receives a response from the device, DataMiner will compare that response to the response definition specified in /Protocol/Responses/Response. If the response does not match
    /// the definition, DataMiner will send the command again. In the device's Element Display, a red block will indicate that an error has occurred. The log files of the device will contain
    /// more detailed information. If the response still does not match, DataMiner will send the command for the third and last time. If, at that point, no valid response has been received, DataMiner
    /// will skip the command, and move to the next one.
    /// Note: By default, the number of retries in case of an invalid response is set to 3. This setting can be changed when adding or editing the device in System Display or DataMiner Cube.
    ///</summary>
public partial class ResponsesResponse : EditableElementNode<Read.IResponsesResponse>
    {
        internal ResponsesResponse(Read.IResponsesResponse read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Response node. None of it's properties will be set.
        ///</summary>
public ResponsesResponse() : base("Response")
        {
            OnCreated();
        }

        private ResponsesResponseContent _content;
        private ElementValue<string> _description;
        private ElementValue<string> _name;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _options;
        ///<summary>
        /// Specifies the consecutive parameters that together form the response that is expected from the device.
        ///</summary>
public ResponsesResponseContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        ///<summary>
        /// Specifies a textual description of the response.
        ///</summary>
public ElementValue<string> Description
        {
            get
            {
                return _description;
            }

            set
            {
                if (_description != value)
                {
                    _description = value;
                    ElementHandler.Assign(value, this, "Description");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the response. Often, the response will have the same name as the command with which it is associated.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Specifies the unique response ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Defines a number of options. Possible values:
        /// - Connection: This option allows you to specify the ID of the connection (in case of multiple ports). Adding the connection ID at response level is only done in protocols of type "smart serial".
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        public ResponsesResponseContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new ResponsesResponseContent();
            return Content;
        }

        public ElementValue<string> GetOrCreateDescription()
        {
            if (Description == null)
                Description = new ElementValue<string>();
            return Description;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        protected override void Initialize(Read.IResponsesResponse read, XmlElement editNode)
        {
            if (read == null)
                return;
            _content = read.Content != null ? new ResponsesResponseContent(read.Content, this, editNode.Element["Content"]) : null;
            _description = read.Description != null ? new ElementValue<string>(read.Description, this) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
        }

        public static ResponsesResponse FromRead(Read.IResponsesResponse read)
        {
            if (read == null)
                return null;
            var item = new ResponsesResponse();
            item.Content = ResponsesResponseContent.FromRead(read.Content);
            item.Description = ElementValue<string>.FromRead(read.Description);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitResponsesResponse(this);
        }
    }

    ///<summary>
    /// Specifies the consecutive parameters that together form the response that is expected from the device.
    ///</summary>
public partial class ResponsesResponseContent : EditableListNode<Read.IResponsesResponseContent, Read.IResponsesResponseContentParam, ResponsesResponseContentParam>
    {
        internal ResponsesResponseContent(Read.IResponsesResponseContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public ResponsesResponseContent() : base("Content")
        {
            OnCreated();
        }

        private AttributeValue<string> _optional;
        ///<summary>
        /// Specifies that no error will occur if they are not found in the response received from the device.
        /// Parameters included in a response definition can be marked as optional. This means, that no error will occur if they are not found in the response received from the device.
        /// If a parameter matches, DataMiner will simply go on to the next parameter and check that one.
        /// If an optional parameter does not match, the following special characters can be included in the "optional" attribute of the /Protocol/Responses/Response element to tell DataMiner what to do:
        /// +: tells DataMiner to skip the next parameter. Multiple "+" characters can be entered to have several parameters skipped.
        /// *: tells DataMiner to skip the parameters in the response until it reaches the next optional parameter.
        ///</summary>
public AttributeValue<string> Optional
        {
            get
            {
                return _optional;
            }

            set
            {
                if (_optional != value)
                {
                    _optional = value;
                    AttributeHandler.Assign(value, this, "optional");
                }
            }
        }

        public AttributeValue<string> GetOrCreateOptional()
        {
            if (Optional == null)
                Optional = new AttributeValue<string>();
            return Optional;
        }

        protected override void Initialize(Read.IResponsesResponseContent read, XmlElement editNode)
        {
            if (read == null)
                return;
            _optional = read.Optional != null ? new AttributeValue<string>(read.Optional, this) : null;
        }

        public static ResponsesResponseContent FromRead(Read.IResponsesResponseContent read)
        {
            if (read == null)
                return null;
            var item = new ResponsesResponseContent();
            item.Optional = AttributeValue<string>.FromRead(read.Optional);
            foreach (var x in read)
            {
                item.Add(ResponsesResponseContentParam.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitResponsesResponseContent(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the parameter that you want to include in the response.
    ///</summary>
public partial class ResponsesResponseContentParam : EditableElementValueNode<Read.IResponsesResponseContentParam, uint?>
    {
        internal ResponsesResponseContentParam(Read.IResponsesResponseContentParam read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Param node. None of it's properties will be set.
        ///</summary>
public ResponsesResponseContentParam() : base("Param")
        {
            OnCreated();
        }

        public ResponsesResponseContentParam(uint? value) : base("Param", value)
        {
        }

        protected override void Initialize(Read.IResponsesResponseContentParam read, XmlElement editNode)
        {
        }

        public static ResponsesResponseContentParam FromRead(Read.IResponsesResponseContentParam read)
        {
            if (read == null)
                return null;
            var item = new ResponsesResponseContentParam();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitResponsesResponseContentParam(this);
        }
    }

    ///<summary>
    /// Used to pass alarm severities to linked tables.
    ///</summary>
public partial class SeverityBubbleUp : EditableListNode<Read.ISeverityBubbleUp, Read.ISeverityBubbleUpPath, SeverityBubbleUpPath>
    {
        internal SeverityBubbleUp(Read.ISeverityBubbleUp read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SeverityBubbleUp node. None of it's properties will be set.
        ///</summary>
public SeverityBubbleUp() : base("SeverityBubbleUp")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ISeverityBubbleUp read, XmlElement editNode)
        {
        }

        public static SeverityBubbleUp FromRead(Read.ISeverityBubbleUp read)
        {
            if (read == null)
                return null;
            var item = new SeverityBubbleUp();
            foreach (var x in read)
            {
                item.Add(SeverityBubbleUpPath.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSeverityBubbleUp(this);
        }
    }

    ///<summary>
    /// Specifies the table path that needs to be followed when passing alarm severities.
    ///</summary>
public partial class SeverityBubbleUpPath : EditableElementValueNode<Read.ISeverityBubbleUpPath, string>
    {
        internal SeverityBubbleUpPath(Read.ISeverityBubbleUpPath read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Path node. None of it's properties will be set.
        ///</summary>
public SeverityBubbleUpPath(bool useCDATA = false) : base("Path", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public SeverityBubbleUpPath(string value, bool useCDATA = false) : base("Path", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _statePid;
        ///<summary>
        /// Refers to a parameter that indicates whether the bubble-up path is disabled or enabled.
        /// The referred parameter must have 0 and 1 as possible values.
        /// While the element is running, if the parameter value is set to 0, the bubble-up path will be disabled.
        /// If the parameter value is set to 1, the bubble-up path will be enabled.
        /// If this attribute is absent, the bubble-up path will be enabled by default.
        /// Feature introduced in DataMiner 9.5.3 (RN 15103, RN 15843).
        /// 
        ///</summary>
public AttributeValue<uint?> StatePid
        {
            get
            {
                return _statePid;
            }

            set
            {
                if (_statePid != value)
                {
                    _statePid = value;
                    AttributeHandler.Assign(value, this, "statePid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateStatePid()
        {
            if (StatePid == null)
                StatePid = new AttributeValue<uint?>();
            return StatePid;
        }

        protected override void Initialize(Read.ISeverityBubbleUpPath read, XmlElement editNode)
        {
            if (read == null)
                return;
            _statePid = read.StatePid != null ? new AttributeValue<uint?>(read.StatePid, this) : null;
        }

        public static SeverityBubbleUpPath FromRead(Read.ISeverityBubbleUpPath read)
        {
            if (read == null)
                return null;
            var item = new SeverityBubbleUpPath();
            item.Value = read.Value;
            item.StatePid = AttributeValue<uint?>.FromRead(read.StatePid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSeverityBubbleUpPath(this);
        }
    }

    ///<summary>
    /// Specifies how the MIB file for the protocol will be created.
    ///</summary>
public partial class SNMP : EditableElementValueNode<Read.ISNMP, Enums.EnumSNMP?>
    {
        internal SNMP(Read.ISNMP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SNMP node. None of it's properties will be set.
        ///</summary>
public SNMP() : base("SNMP")
        {
            OnCreated();
        }

        public SNMP(Enums.EnumSNMP? value) : base("SNMP", value)
        {
        }

        private AttributeValue<bool?> _includepages;
        ///<summary>
        /// If "true", the MIB of the protocol will contain several submaps: one for each page defined in the protocol.
        /// Example: When a number of parameters are placed on a page called "General", the MIB will automatically create a submap named "General", which will contain all the parameters on that page.
        ///</summary>
public AttributeValue<bool?> Includepages
        {
            get
            {
                return _includepages;
            }

            set
            {
                if (_includepages != value)
                {
                    _includepages = value;
                    AttributeHandler.Assign(value, this, "includepages");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateIncludepages()
        {
            if (Includepages == null)
                Includepages = new AttributeValue<bool?>();
            return Includepages;
        }

        protected override void Initialize(Read.ISNMP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _includepages = read.Includepages != null ? new AttributeValue<bool?>(read.Includepages, this) : null;
        }

        public static SNMP FromRead(Read.ISNMP read)
        {
            if (read == null)
                return null;
            var item = new SNMP();
            item.Value = read.Value;
            item.Includepages = AttributeValue<bool?>.FromRead(read.Includepages);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSNMP(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumSNMPConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumSNMP? ConvertRawValue(string rawValue)
        {
            return Enums.EnumSNMPConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies additional threads that will be used by the protocol. This allows you to separate time-critical actions from device-polling actions. Use with caution.
    ///</summary>
public partial class Threads : EditableListNode<Read.IThreads, Read.IThreadsThread, ThreadsThread>
    {
        internal Threads(Read.IThreads read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Threads node. None of it's properties will be set.
        ///</summary>
public Threads() : base("Threads")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IThreads read, XmlElement editNode)
        {
        }

        public static Threads FromRead(Read.IThreads read)
        {
            if (read == null)
                return null;
            var item = new Threads();
            foreach (var x in read)
            {
                item.Add(ThreadsThread.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitThreads(this);
        }
    }

    ///<summary>
    /// Defines an additional thread. This will allow you to e.g. separate time-critical actions from device-polling actions.
    /// Each additional thread you create, has its own protocol group execution queue as well as its own run-time error thread registration.
    /// Note: The main protocol group execution queue will always be active, no matter how many additional threads you create.
    ///</summary>
public partial class ThreadsThread : EditableElementNode<Read.IThreadsThread>
    {
        internal ThreadsThread(Read.IThreadsThread read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Thread node. None of it's properties will be set.
        ///</summary>
public ThreadsThread() : base("Thread")
        {
            OnCreated();
        }

        private AttributeValue<string> _connection;
        ///<summary>
        /// When you create an additional thread, you have to link it to a particular connection.
        /// This can be either a real connection or a virtual connection. All groups linked to that connection will then be executed on that thread.
        /// In the connection attribute, you can specify a single connection ID or a comma-separated list of multiple connection IDs in case you want to combine a number of connections into one single thread).
        ///</summary>
public AttributeValue<string> Connection
        {
            get
            {
                return _connection;
            }

            set
            {
                if (_connection != value)
                {
                    _connection = value;
                    AttributeHandler.Assign(value, this, "connection");
                }
            }
        }

        public AttributeValue<string> GetOrCreateConnection()
        {
            if (Connection == null)
                Connection = new AttributeValue<string>();
            return Connection;
        }

        protected override void Initialize(Read.IThreadsThread read, XmlElement editNode)
        {
            if (read == null)
                return;
            _connection = read.Connection != null ? new AttributeValue<string>(read.Connection, this) : null;
        }

        public static ThreadsThread FromRead(Read.IThreadsThread read)
        {
            if (read == null)
                return null;
            var item = new ThreadsThread();
            item.Connection = AttributeValue<string>.FromRead(read.Connection);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitThreadsThread(this);
        }
    }

    ///<summary>
    /// Contains all timers defined in the protocol.
    /// Timers are used to configure recurring events (group execution, device polling, ...). Basically, a timer defines the interval between two consecutive executions of a given event.
    /// By default, the interval specified in a timer is a fixed interval. However, in the protocol, you can make the interval dynamic.
    /// The interval can be modified by changing the value of the [Timer base] Parameter (ID: 65017). The value of this parameter is the factor by which the interval time is multiplied.
    /// So "1" means the original interval, "2" means twice as slow, "0.5" means twice as fast, etc.
    ///</summary>
public partial class Timers : EditableListNode<Read.ITimers, Read.ITimersTimer, TimersTimer>
    {
        internal Timers(Read.ITimers read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Timers node. None of it's properties will be set.
        ///</summary>
public Timers() : base("Timers")
        {
            OnCreated();
        }

        private AttributeValue<bool?> _relativeTimers;
        public AttributeValue<bool?> RelativeTimers
        {
            get
            {
                return _relativeTimers;
            }

            set
            {
                if (_relativeTimers != value)
                {
                    _relativeTimers = value;
                    AttributeHandler.Assign(value, this, "relativeTimers");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateRelativeTimers()
        {
            if (RelativeTimers == null)
                RelativeTimers = new AttributeValue<bool?>();
            return RelativeTimers;
        }

        protected override void Initialize(Read.ITimers read, XmlElement editNode)
        {
            if (read == null)
                return;
            _relativeTimers = read.RelativeTimers != null ? new AttributeValue<bool?>(read.RelativeTimers, this) : null;
        }

        public static Timers FromRead(Read.ITimers read)
        {
            if (read == null)
                return null;
            var item = new Timers();
            item.RelativeTimers = AttributeValue<bool?>.FromRead(read.RelativeTimers);
            foreach (var x in read)
            {
                item.Add(TimersTimer.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimers(this);
        }
    }

    ///<summary>
    /// Specifies which groups have to be executed, and when.
    /// It is recommended to define multiple timers. That way, you can separate the important groups (which will be polled more frequently) from the less important groups
    /// (which will be polled less frequently).
    ///</summary>
public partial class TimersTimer : EditableElementNode<Read.ITimersTimer>
    {
        internal TimersTimer(Read.ITimersTimer read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Timer node. None of it's properties will be set.
        ///</summary>
public TimersTimer() : base("Timer")
        {
            OnCreated();
        }

        private ElementValue<string> _condition;
        private ElementValue<string> _name;
        private TimersTimerContent _content;
        private ElementValue<uint?> _interval;
        private TimersTimerTime _time;
        private AttributeValue<uint?> _id;
        private AttributeValue<bool?> _fixedTimer;
        private AttributeValue<string> _options;
        ///<summary>
        /// Specifies a condition that must be met in order for the timer to execute. Note: Avoid using conditions on timers.
        ///</summary>
public ElementValue<string> Condition
        {
            get
            {
                return _condition;
            }

            set
            {
                if (_condition != value)
                {
                    _condition = value;
                    ElementHandler.Assign(value, this, "Condition");
                }
            }
        }

        ///<summary>
        /// Specifies the timer name.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Contains all the groups that have to be executed when the timer is triggered.
        /// Important: Do not include too much groups in one timer.
        ///</summary>
public TimersTimerContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        ///<summary>
        /// Specifies the interval (in milliseconds) between two consecutive executions of groups within a timer and also between two consecutive pairs within a timer group.
        ///</summary>
public ElementValue<uint?> Interval
        {
            get
            {
                return _interval;
            }

            set
            {
                if (_interval != value)
                {
                    _interval = value;
                    ElementHandler.Assign(value, this, "Interval");
                }
            }
        }

        ///<summary>
        /// Specifies how frequently the included groups will be executed.
        /// If you enter "loop", the included groups will be executed over and over again.
        /// If you enter an integer value &gt; 0, the included groups will be executed every X milliseconds.
        ///</summary>
public TimersTimerTime Time
        {
            get
            {
                return _time;
            }

            set
            {
                if (_time != value)
                {
                    _time = value;
                    CombinedTagHandler.Assign(value, this, "Time");
                }
            }
        }

        ///<summary>
        /// Specifies the unique timer ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// If, in case of a relative-timer protocol, this attribute is set to "true", the user will not be able to change the interval.
        /// See also: The /Protocol/Type@relativeTimers attribute.
        ///</summary>
public AttributeValue<bool?> FixedTimer
        {
            get
            {
                return _fixedTimer;
            }

            set
            {
                if (_fixedTimer != value)
                {
                    _fixedTimer = value;
                    AttributeHandler.Assign(value, this, "fixedTimer");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        /// 
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        public ElementValue<string> GetOrCreateCondition()
        {
            if (Condition == null)
                Condition = new ElementValue<string>();
            return Condition;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public TimersTimerContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new TimersTimerContent();
            return Content;
        }

        public ElementValue<uint?> GetOrCreateInterval()
        {
            if (Interval == null)
                Interval = new ElementValue<uint?>();
            return Interval;
        }

        public TimersTimerTime GetOrCreateTime()
        {
            if (Time == null)
                Time = new TimersTimerTime();
            return Time;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<bool?> GetOrCreateFixedTimer()
        {
            if (FixedTimer == null)
                FixedTimer = new AttributeValue<bool?>();
            return FixedTimer;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        protected override void Initialize(Read.ITimersTimer read, XmlElement editNode)
        {
            if (read == null)
                return;
            _condition = read.Condition != null ? new ElementValue<string>(read.Condition, this) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _content = read.Content != null ? new TimersTimerContent(read.Content, this, editNode.Element["Content"]) : null;
            _interval = read.Interval != null ? new ElementValue<uint?>(read.Interval, this) : null;
            _time = read.Time != null ? new TimersTimerTime(read.Time, this, editNode.Element["Time"]) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _fixedTimer = read.FixedTimer != null ? new AttributeValue<bool?>(read.FixedTimer, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
        }

        public static TimersTimer FromRead(Read.ITimersTimer read)
        {
            if (read == null)
                return null;
            var item = new TimersTimer();
            item.Condition = ElementValue<string>.FromRead(read.Condition);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.Content = TimersTimerContent.FromRead(read.Content);
            item.Interval = ElementValue<uint?>.FromRead(read.Interval);
            item.Time = TimersTimerTime.FromRead(read.Time);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.FixedTimer = AttributeValue<bool?>.FromRead(read.FixedTimer);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimersTimer(this);
        }
    }

    ///<summary>
    /// Contains all the groups that have to be executed when the timer is triggered.
    /// Important: Do not include too much groups in one timer.
    ///</summary>
public partial class TimersTimerContent : EditableListNode<Read.ITimersTimerContent, Read.ITimersTimerContentGroup, TimersTimerContentGroup>
    {
        internal TimersTimerContent(Read.ITimersTimerContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public TimersTimerContent() : base("Content")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITimersTimerContent read, XmlElement editNode)
        {
        }

        public static TimersTimerContent FromRead(Read.ITimersTimerContent read)
        {
            if (read == null)
                return null;
            var item = new TimersTimerContent();
            foreach (var x in read)
            {
                item.Add(TimersTimerContentGroup.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimersTimerContent(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the group to be included.
    ///</summary>
public partial class TimersTimerContentGroup : EditableElementValueNode<Read.ITimersTimerContentGroup, string>
    {
        internal TimersTimerContentGroup(Read.ITimersTimerContentGroup read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Group node. None of it's properties will be set.
        ///</summary>
public TimersTimerContentGroup(bool useCDATA = false) : base("Group", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public TimersTimerContentGroup(string value, bool useCDATA = false) : base("Group", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.ITimersTimerContentGroup read, XmlElement editNode)
        {
        }

        public static TimersTimerContentGroup FromRead(Read.ITimersTimerContentGroup read)
        {
            if (read == null)
                return null;
            var item = new TimersTimerContentGroup();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimersTimerContentGroup(this);
        }
    }

    ///<summary>
    /// Specifies how frequently the included groups will be executed.
    /// If you enter "loop", the included groups will be executed over and over again.
    /// If you enter an integer value &gt; 0, the included groups will be executed every X milliseconds.
    ///</summary>
public partial class TimersTimerTime : EditableElementValueNode<Read.ITimersTimerTime, string>
    {
        internal TimersTimerTime(Read.ITimersTimerTime read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Time node. None of it's properties will be set.
        ///</summary>
public TimersTimerTime(bool useCDATA = false) : base("Time", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public TimersTimerTime(string value, bool useCDATA = false) : base("Time", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _dataDisplay;
        private AttributeValue<string> _initial;
        ///<summary>
        /// Specifies the execution frequency of the included groups when a Data Display has been opened.
        /// It is good practice to set this interval to 30000 (30 seconds).
        /// Note: If you set this attribute to "loop", the included groups will be executed as frequently as possible.
        /// In some cases, this can affect overall DataMiner performance.
        ///</summary>
public AttributeValue<uint?> DataDisplay
        {
            get
            {
                return _dataDisplay;
            }

            set
            {
                if (_dataDisplay != value)
                {
                    _dataDisplay = value;
                    AttributeHandler.Assign(value, this, "dataDisplay");
                }
            }
        }

        ///<summary>
        /// Specifies whether the timer should be started when the element is started.
        /// - true: the timer will be started when the element is started.
        /// - false: the timer will not be started when the element is started. This allows you to dynamically start the timer by performing an action.
        /// - random=startvalue:endvalue : the timer will be started a random number of seconds after the start of the element. The random value will be a value between startvalue and endvalue.
        /// E.g. random=0:300
        /// By default, this attribute is omitted. As a consequence, the groups will be executed the moment the element is started.
        ///</summary>
public AttributeValue<string> Initial
        {
            get
            {
                return _initial;
            }

            set
            {
                if (_initial != value)
                {
                    _initial = value;
                    AttributeHandler.Assign(value, this, "initial");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateDataDisplay()
        {
            if (DataDisplay == null)
                DataDisplay = new AttributeValue<uint?>();
            return DataDisplay;
        }

        public AttributeValue<string> GetOrCreateInitial()
        {
            if (Initial == null)
                Initial = new AttributeValue<string>();
            return Initial;
        }

        protected override void Initialize(Read.ITimersTimerTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dataDisplay = read.DataDisplay != null ? new AttributeValue<uint?>(read.DataDisplay, this) : null;
            _initial = read.Initial != null ? new AttributeValue<string>(read.Initial, this) : null;
        }

        public static TimersTimerTime FromRead(Read.ITimersTimerTime read)
        {
            if (read == null)
                return null;
            var item = new TimersTimerTime();
            item.Value = read.Value;
            item.DataDisplay = AttributeValue<uint?>.FromRead(read.DataDisplay);
            item.Initial = AttributeValue<string>.FromRead(read.Initial);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTimersTimerTime(this);
        }
    }

    ///<summary>
    /// Groups topologies defined in the protocol.
    ///</summary>
public partial class Topologies : EditableListNode<Read.ITopologies, Read.ITopologiesTopology, TopologiesTopology>
    {
        internal Topologies(Read.ITopologies read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Topologies node. None of it's properties will be set.
        ///</summary>
public Topologies() : base("Topologies")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITopologies read, XmlElement editNode)
        {
        }

        public static Topologies FromRead(Read.ITopologies read)
        {
            if (read == null)
                return null;
            var item = new Topologies();
            foreach (var x in read)
            {
                item.Add(TopologiesTopology.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologies(this);
        }
    }

    ///<summary>
    /// Defines a topology. In this element, you can specify several Cell elements, each representing a cell in the diagram displayed in the CPE Manager.
    ///</summary>
public partial class TopologiesTopology : EditableListNode<Read.ITopologiesTopology, Read.ITopologiesTopologyCell, TopologiesTopologyCell>
    {
        internal TopologiesTopology(Read.ITopologiesTopology read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Topology node. None of it's properties will be set.
        ///</summary>
public TopologiesTopology() : base("Topology")
        {
            OnCreated();
        }

        private AttributeValue<string> _name;
        ///<summary>
        /// Specifies the name of the topology (Service Overview Manager only).
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.ITopologiesTopology read, XmlElement editNode)
        {
            if (read == null)
                return;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static TopologiesTopology FromRead(Read.ITopologiesTopology read)
        {
            if (read == null)
                return null;
            var item = new TopologiesTopology();
            item.Name = AttributeValue<string>.FromRead(read.Name);
            foreach (var x in read)
            {
                item.Add(TopologiesTopologyCell.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopology(this);
        }
    }

    ///<summary>
    /// Specifies a cell within a CPE topology.
    ///</summary>
public partial class TopologiesTopologyCell : EditableListNode<Read.ITopologiesTopologyCell, Read.ITypeTopologyCellLink, TypeTopologyCellLink>
    {
        internal TopologiesTopologyCell(Read.ITopologiesTopologyCell read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Cell node. None of it's properties will be set.
        ///</summary>
public TopologiesTopologyCell() : base("Cell")
        {
            OnCreated();
        }

        private TopologiesTopologyCellExposer _exposer;
        private AttributeValue<string> _detailColumns;
        private AttributeValue<string> _listColumns;
        private AttributeValue<string> _name;
        private AttributeValue<string> _options;
        private AttributeValue<string> _table;
        ///<summary>
        /// Exposes this cell to the CPE crawler.
        ///</summary>
public TopologiesTopologyCellExposer Exposer
        {
            get
            {
                return _exposer;
            }

            set
            {
                if (_exposer != value)
                {
                    _exposer = value;
                    CombinedTagHandler.Assign(value, this, "Exposer");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> DetailColumns
        {
            get
            {
                return _detailColumns;
            }

            set
            {
                if (_detailColumns != value)
                {
                    _detailColumns = value;
                    AttributeHandler.Assign(value, this, "detailColumns");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> ListColumns
        {
            get
            {
                return _listColumns;
            }

            set
            {
                if (_listColumns != value)
                {
                    _listColumns = value;
                    AttributeHandler.Assign(value, this, "listColumns");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the cell.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options (Deprecated).
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the table parameter to which the cell is linked.
        ///</summary>
public AttributeValue<string> Table
        {
            get
            {
                return _table;
            }

            set
            {
                if (_table != value)
                {
                    _table = value;
                    AttributeHandler.Assign(value, this, "table");
                }
            }
        }

        public TopologiesTopologyCellExposer GetOrCreateExposer()
        {
            if (Exposer == null)
                Exposer = new TopologiesTopologyCellExposer();
            return Exposer;
        }

        public AttributeValue<string> GetOrCreateDetailColumns()
        {
            if (DetailColumns == null)
                DetailColumns = new AttributeValue<string>();
            return DetailColumns;
        }

        public AttributeValue<string> GetOrCreateListColumns()
        {
            if (ListColumns == null)
                ListColumns = new AttributeValue<string>();
            return ListColumns;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<string> GetOrCreateTable()
        {
            if (Table == null)
                Table = new AttributeValue<string>();
            return Table;
        }

        protected override void Initialize(Read.ITopologiesTopologyCell read, XmlElement editNode)
        {
            if (read == null)
                return;
            _exposer = read.Exposer != null ? new TopologiesTopologyCellExposer(read.Exposer, this, editNode.Element["Exposer"]) : null;
            _detailColumns = read.DetailColumns != null ? new AttributeValue<string>(read.DetailColumns, this) : null;
            _listColumns = read.ListColumns != null ? new AttributeValue<string>(read.ListColumns, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _table = read.Table != null ? new AttributeValue<string>(read.Table, this) : null;
        }

        public static TopologiesTopologyCell FromRead(Read.ITopologiesTopologyCell read)
        {
            if (read == null)
                return null;
            var item = new TopologiesTopologyCell();
            item.Exposer = TopologiesTopologyCellExposer.FromRead(read.Exposer);
            item.DetailColumns = AttributeValue<string>.FromRead(read.DetailColumns);
            item.ListColumns = AttributeValue<string>.FromRead(read.ListColumns);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Table = AttributeValue<string>.FromRead(read.Table);
            foreach (var x in read)
            {
                item.Add(TypeTopologyCellLink.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopologyCell(this);
        }
    }

    ///<summary>
    /// Exposes this cell to the CPE crawler.
    ///</summary>
public partial class TopologiesTopologyCellExposer : EditableElementNode<Read.ITopologiesTopologyCellExposer>
    {
        internal TopologiesTopologyCellExposer(Read.ITopologiesTopologyCellExposer read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Exposer node. None of it's properties will be set.
        ///</summary>
public TopologiesTopologyCellExposer() : base("Exposer")
        {
            OnCreated();
        }

        private TopologiesTopologyCellExposerLinkedIds _linkedIds;
        private AttributeValue<bool?> _enabled;
        ///<summary>
        /// Specifies the linked tables.
        ///</summary>
public TopologiesTopologyCellExposerLinkedIds LinkedIds
        {
            get
            {
                return _linkedIds;
            }

            set
            {
                if (_linkedIds != value)
                {
                    _linkedIds = value;
                    CombinedTagHandler.Assign(value, this, "LinkedIds");
                }
            }
        }

        ///<summary>
        /// Specifies whether the exposer is enabled.
        ///</summary>
public AttributeValue<bool?> Enabled
        {
            get
            {
                return _enabled;
            }

            set
            {
                if (_enabled != value)
                {
                    _enabled = value;
                    AttributeHandler.Assign(value, this, "enabled");
                }
            }
        }

        public TopologiesTopologyCellExposerLinkedIds GetOrCreateLinkedIds()
        {
            if (LinkedIds == null)
                LinkedIds = new TopologiesTopologyCellExposerLinkedIds();
            return LinkedIds;
        }

        public AttributeValue<bool?> GetOrCreateEnabled()
        {
            if (Enabled == null)
                Enabled = new AttributeValue<bool?>();
            return Enabled;
        }

        protected override void Initialize(Read.ITopologiesTopologyCellExposer read, XmlElement editNode)
        {
            if (read == null)
                return;
            _linkedIds = read.LinkedIds != null ? new TopologiesTopologyCellExposerLinkedIds(read.LinkedIds, this, editNode.Element["LinkedIds"]) : null;
            _enabled = read.Enabled != null ? new AttributeValue<bool?>(read.Enabled, this) : null;
        }

        public static TopologiesTopologyCellExposer FromRead(Read.ITopologiesTopologyCellExposer read)
        {
            if (read == null)
                return null;
            var item = new TopologiesTopologyCellExposer();
            item.LinkedIds = TopologiesTopologyCellExposerLinkedIds.FromRead(read.LinkedIds);
            item.Enabled = AttributeValue<bool?>.FromRead(read.Enabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopologyCellExposer(this);
        }
    }

    ///<summary>
    /// Specifies the linked tables.
    ///</summary>
public partial class TopologiesTopologyCellExposerLinkedIds : EditableListNode<Read.ITopologiesTopologyCellExposerLinkedIds, Read.ITopologiesTopologyCellExposerLinkedIdsLinkedId, TopologiesTopologyCellExposerLinkedIdsLinkedId>
    {
        internal TopologiesTopologyCellExposerLinkedIds(Read.ITopologiesTopologyCellExposerLinkedIds read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LinkedIds node. None of it's properties will be set.
        ///</summary>
public TopologiesTopologyCellExposerLinkedIds() : base("LinkedIds")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITopologiesTopologyCellExposerLinkedIds read, XmlElement editNode)
        {
        }

        public static TopologiesTopologyCellExposerLinkedIds FromRead(Read.ITopologiesTopologyCellExposerLinkedIds read)
        {
            if (read == null)
                return null;
            var item = new TopologiesTopologyCellExposerLinkedIds();
            foreach (var x in read)
            {
                item.Add(TopologiesTopologyCellExposerLinkedIdsLinkedId.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopologyCellExposerLinkedIds(this);
        }
    }

    ///<summary>
    /// Specifies the table parameter ID of the linked table.
    ///</summary>
public partial class TopologiesTopologyCellExposerLinkedIdsLinkedId : EditableElementValueNode<Read.ITopologiesTopologyCellExposerLinkedIdsLinkedId, int?>
    {
        internal TopologiesTopologyCellExposerLinkedIdsLinkedId(Read.ITopologiesTopologyCellExposerLinkedIdsLinkedId read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LinkedId node. None of it's properties will be set.
        ///</summary>
public TopologiesTopologyCellExposerLinkedIdsLinkedId() : base("LinkedId")
        {
            OnCreated();
        }

        public TopologiesTopologyCellExposerLinkedIdsLinkedId(int? value) : base("LinkedId", value)
        {
        }

        private AttributeValue<int?> _columnPid;
        ///<summary>
        /// Specifies the ID of the column parameter that is used to link the specified table.
        ///</summary>
public AttributeValue<int?> ColumnPid
        {
            get
            {
                return _columnPid;
            }

            set
            {
                if (_columnPid != value)
                {
                    _columnPid = value;
                    AttributeHandler.Assign(value, this, "columnPid");
                }
            }
        }

        public AttributeValue<int?> GetOrCreateColumnPid()
        {
            if (ColumnPid == null)
                ColumnPid = new AttributeValue<int?>();
            return ColumnPid;
        }

        protected override void Initialize(Read.ITopologiesTopologyCellExposerLinkedIdsLinkedId read, XmlElement editNode)
        {
            if (read == null)
                return;
            _columnPid = read.ColumnPid != null ? new AttributeValue<int?>(read.ColumnPid, this) : null;
        }

        public static TopologiesTopologyCellExposerLinkedIdsLinkedId FromRead(Read.ITopologiesTopologyCellExposerLinkedIdsLinkedId read)
        {
            if (read == null)
                return null;
            var item = new TopologiesTopologyCellExposerLinkedIdsLinkedId();
            item.Value = read.Value;
            item.ColumnPid = AttributeValue<int?>.FromRead(read.ColumnPid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologiesTopologyCellExposerLinkedIdsLinkedId(this);
        }
    }

    ///<summary>
    /// Contains all the tree controls defined in the protocol.
    ///</summary>
public partial class TreeControls : EditableListNode<Read.ITreeControls, Read.ITreeControlsTreeControl, TreeControlsTreeControl>
    {
        internal TreeControls(Read.ITreeControls read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TreeControls node. None of it's properties will be set.
        ///</summary>
public TreeControls() : base("TreeControls")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITreeControls read, XmlElement editNode)
        {
        }

        public static TreeControls FromRead(Read.ITreeControls read)
        {
            if (read == null)
                return null;
            var item = new TreeControls();
            foreach (var x in read)
            {
                item.Add(TreeControlsTreeControl.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControls(this);
        }
    }

    ///<summary>
    /// Defines a tree control.
    ///</summary>
public partial class TreeControlsTreeControl : EditableElementNode<Read.ITreeControlsTreeControl>
    {
        internal TreeControlsTreeControl(Read.ITreeControlsTreeControl read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TreeControl node. None of it's properties will be set.
        ///</summary>
public TreeControlsTreeControl() : base("TreeControl")
        {
            OnCreated();
        }

        private TreeControlsTreeControlExtraDetails _extraDetails;
        private TreeControlsTreeControlExtraTabs _extraTabs;
        private ElementValue<string> _hiddenColumns;
        private TreeControlsTreeControlHierarchy _hierarchy;
        private ElementValue<string> _readonlyColumns;
        private ElementValue<string> _overrideDisplayColumns;
        private ElementValue<string> _overrideIconColumns;
        private AttributeValue<uint?> _parameterId;
        private AttributeValue<bool?> _readOnly;
        ///<summary>
        /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
        ///</summary>
public TreeControlsTreeControlExtraDetails ExtraDetails
        {
            get
            {
                return _extraDetails;
            }

            set
            {
                if (_extraDetails != value)
                {
                    _extraDetails = value;
                    CombinedTagHandler.Assign(value, this, "ExtraDetails");
                }
            }
        }

        ///<summary>
        /// Contains additional tab definitions in the tree control.
        ///</summary>
public TreeControlsTreeControlExtraTabs ExtraTabs
        {
            get
            {
                return _extraTabs;
            }

            set
            {
                if (_extraTabs != value)
                {
                    _extraTabs = value;
                    CombinedTagHandler.Assign(value, this, "ExtraTabs");
                }
            }
        }

        ///<summary>
        /// Specifies the columns to be hidden.
        ///</summary>
public ElementValue<string> HiddenColumns
        {
            get
            {
                return _hiddenColumns;
            }

            set
            {
                if (_hiddenColumns != value)
                {
                    _hiddenColumns = value;
                    ElementHandler.Assign(value, this, "HiddenColumns");
                }
            }
        }

        ///<summary>
        /// Defines the relationship between the (visible) tables.
        /// Rows from these tables will become items in the tree.
        ///</summary>
public TreeControlsTreeControlHierarchy Hierarchy
        {
            get
            {
                return _hierarchy;
            }

            set
            {
                if (_hierarchy != value)
                {
                    _hierarchy = value;
                    CombinedTagHandler.Assign(value, this, "Hierarchy");
                }
            }
        }

        ///<summary>
        /// Used to hide write controls for certain table columns.
        ///</summary>
public ElementValue<string> ReadonlyColumns
        {
            get
            {
                return _readonlyColumns;
            }

            set
            {
                if (_readonlyColumns != value)
                {
                    _readonlyColumns = value;
                    ElementHandler.Assign(value, this, "ReadonlyColumns");
                }
            }
        }

        ///<summary>
        /// Used to override the display key or the index of a row by a different column of the same table.
        ///</summary>
public ElementValue<string> OverrideDisplayColumns
        {
            get
            {
                return _overrideDisplayColumns;
            }

            set
            {
                if (_overrideDisplayColumns != value)
                {
                    _overrideDisplayColumns = value;
                    ElementHandler.Assign(value, this, "OverrideDisplayColumns");
                }
            }
        }

        ///<summary>
        /// By specifying a column in this element, you can apply a custom icon based on a cell value in a row.
        /// The column must be a parameter of type Discreet and all discreet values must have an IconRef referring to an icon. If not, a default icon will be displayed.
        ///</summary>
public ElementValue<string> OverrideIconColumns
        {
            get
            {
                return _overrideIconColumns;
            }

            set
            {
                if (_overrideIconColumns != value)
                {
                    _overrideIconColumns = value;
                    ElementHandler.Assign(value, this, "OverrideIconColumns");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter ID of the tree control.
        ///</summary>
public AttributeValue<uint?> ParameterId
        {
            get
            {
                return _parameterId;
            }

            set
            {
                if (_parameterId != value)
                {
                    _parameterId = value;
                    AttributeHandler.Assign(value, this, "parameterId");
                }
            }
        }

        ///<summary>
        /// If set to "true", disables all the write parameters in the tree control. Default: false.
        ///</summary>
public AttributeValue<bool?> ReadOnly
        {
            get
            {
                return _readOnly;
            }

            set
            {
                if (_readOnly != value)
                {
                    _readOnly = value;
                    AttributeHandler.Assign(value, this, "readOnly");
                }
            }
        }

        public TreeControlsTreeControlExtraDetails GetOrCreateExtraDetails()
        {
            if (ExtraDetails == null)
                ExtraDetails = new TreeControlsTreeControlExtraDetails();
            return ExtraDetails;
        }

        public TreeControlsTreeControlExtraTabs GetOrCreateExtraTabs()
        {
            if (ExtraTabs == null)
                ExtraTabs = new TreeControlsTreeControlExtraTabs();
            return ExtraTabs;
        }

        public ElementValue<string> GetOrCreateHiddenColumns()
        {
            if (HiddenColumns == null)
                HiddenColumns = new ElementValue<string>();
            return HiddenColumns;
        }

        public TreeControlsTreeControlHierarchy GetOrCreateHierarchy()
        {
            if (Hierarchy == null)
                Hierarchy = new TreeControlsTreeControlHierarchy();
            return Hierarchy;
        }

        public ElementValue<string> GetOrCreateReadonlyColumns()
        {
            if (ReadonlyColumns == null)
                ReadonlyColumns = new ElementValue<string>();
            return ReadonlyColumns;
        }

        public ElementValue<string> GetOrCreateOverrideDisplayColumns()
        {
            if (OverrideDisplayColumns == null)
                OverrideDisplayColumns = new ElementValue<string>();
            return OverrideDisplayColumns;
        }

        public ElementValue<string> GetOrCreateOverrideIconColumns()
        {
            if (OverrideIconColumns == null)
                OverrideIconColumns = new ElementValue<string>();
            return OverrideIconColumns;
        }

        public AttributeValue<uint?> GetOrCreateParameterId()
        {
            if (ParameterId == null)
                ParameterId = new AttributeValue<uint?>();
            return ParameterId;
        }

        public AttributeValue<bool?> GetOrCreateReadOnly()
        {
            if (ReadOnly == null)
                ReadOnly = new AttributeValue<bool?>();
            return ReadOnly;
        }

        protected override void Initialize(Read.ITreeControlsTreeControl read, XmlElement editNode)
        {
            if (read == null)
                return;
            _extraDetails = read.ExtraDetails != null ? new TreeControlsTreeControlExtraDetails(read.ExtraDetails, this, editNode.Element["ExtraDetails"]) : null;
            _extraTabs = read.ExtraTabs != null ? new TreeControlsTreeControlExtraTabs(read.ExtraTabs, this, editNode.Element["ExtraTabs"]) : null;
            _hiddenColumns = read.HiddenColumns != null ? new ElementValue<string>(read.HiddenColumns, this) : null;
            _hierarchy = read.Hierarchy != null ? new TreeControlsTreeControlHierarchy(read.Hierarchy, this, editNode.Element["Hierarchy"]) : null;
            _readonlyColumns = read.ReadonlyColumns != null ? new ElementValue<string>(read.ReadonlyColumns, this) : null;
            _overrideDisplayColumns = read.OverrideDisplayColumns != null ? new ElementValue<string>(read.OverrideDisplayColumns, this) : null;
            _overrideIconColumns = read.OverrideIconColumns != null ? new ElementValue<string>(read.OverrideIconColumns, this) : null;
            _parameterId = read.ParameterId != null ? new AttributeValue<uint?>(read.ParameterId, this) : null;
            _readOnly = read.ReadOnly != null ? new AttributeValue<bool?>(read.ReadOnly, this) : null;
        }

        public static TreeControlsTreeControl FromRead(Read.ITreeControlsTreeControl read)
        {
            if (read == null)
                return null;
            var item = new TreeControlsTreeControl();
            item.ExtraDetails = TreeControlsTreeControlExtraDetails.FromRead(read.ExtraDetails);
            item.ExtraTabs = TreeControlsTreeControlExtraTabs.FromRead(read.ExtraTabs);
            item.HiddenColumns = ElementValue<string>.FromRead(read.HiddenColumns);
            item.Hierarchy = TreeControlsTreeControlHierarchy.FromRead(read.Hierarchy);
            item.ReadonlyColumns = ElementValue<string>.FromRead(read.ReadonlyColumns);
            item.OverrideDisplayColumns = ElementValue<string>.FromRead(read.OverrideDisplayColumns);
            item.OverrideIconColumns = ElementValue<string>.FromRead(read.OverrideIconColumns);
            item.ParameterId = AttributeValue<uint?>.FromRead(read.ParameterId);
            item.ReadOnly = AttributeValue<bool?>.FromRead(read.ReadOnly);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControl(this);
        }
    }

    ///<summary>
    /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
    ///</summary>
public partial class TreeControlsTreeControlExtraDetails : EditableListNode<Read.ITreeControlsTreeControlExtraDetails, Read.ITreeControlsTreeControlExtraDetailsLinkedDetails, TreeControlsTreeControlExtraDetailsLinkedDetails>
    {
        internal TreeControlsTreeControlExtraDetails(Read.ITreeControlsTreeControlExtraDetails read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ExtraDetails node. None of it's properties will be set.
        ///</summary>
public TreeControlsTreeControlExtraDetails() : base("ExtraDetails")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITreeControlsTreeControlExtraDetails read, XmlElement editNode)
        {
        }

        public static TreeControlsTreeControlExtraDetails FromRead(Read.ITreeControlsTreeControlExtraDetails read)
        {
            if (read == null)
                return null;
            var item = new TreeControlsTreeControlExtraDetails();
            foreach (var x in read)
            {
                item.Add(TreeControlsTreeControlExtraDetailsLinkedDetails.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlExtraDetails(this);
        }
    }

    ///<summary>
    /// Defines additional tree item information to be displayed in the details section of the tree control lay­out.
    ///</summary>
public partial class TreeControlsTreeControlExtraDetailsLinkedDetails : EditableElementNode<Read.ITreeControlsTreeControlExtraDetailsLinkedDetails>
    {
        internal TreeControlsTreeControlExtraDetailsLinkedDetails(Read.ITreeControlsTreeControlExtraDetailsLinkedDetails read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LinkedDetails node. None of it's properties will be set.
        ///</summary>
public TreeControlsTreeControlExtraDetailsLinkedDetails() : base("LinkedDetails")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _detailsTableId;
        private AttributeValue<uint?> _discreetColumnId;
        private AttributeValue<string> _valueAttribute;
        ///<summary>
        /// Specifies the parameter ID of the table containing the additional information.
        /// If this table has multiple foreign keys, a foreign key column ID can be specified instead.
        ///</summary>
public AttributeValue<uint?> DetailsTableId
        {
            get
            {
                return _detailsTableId;
            }

            set
            {
                if (_detailsTableId != value)
                {
                    _detailsTableId = value;
                    AttributeHandler.Assign(value, this, "detailsTableId");
                }
            }
        }

        ///<summary>
        /// Specifies a column in the main table.
        /// This must be a parameter of type Discreet. The value of this column determines from which other table(s) additional information can be retrieved.
        /// 
        ///</summary>
public AttributeValue<uint?> DiscreetColumnId
        {
            get
            {
                return _discreetColumnId;
            }

            set
            {
                if (_discreetColumnId != value)
                {
                    _discreetColumnId = value;
                    AttributeHandler.Assign(value, this, "discreetColumnId");
                }
            }
        }

        ///<summary>
        /// Specifies one of the possible discrete values.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateDetailsTableId()
        {
            if (DetailsTableId == null)
                DetailsTableId = new AttributeValue<uint?>();
            return DetailsTableId;
        }

        public AttributeValue<uint?> GetOrCreateDiscreetColumnId()
        {
            if (DiscreetColumnId == null)
                DiscreetColumnId = new AttributeValue<uint?>();
            return DiscreetColumnId;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        protected override void Initialize(Read.ITreeControlsTreeControlExtraDetailsLinkedDetails read, XmlElement editNode)
        {
            if (read == null)
                return;
            _detailsTableId = read.DetailsTableId != null ? new AttributeValue<uint?>(read.DetailsTableId, this) : null;
            _discreetColumnId = read.DiscreetColumnId != null ? new AttributeValue<uint?>(read.DiscreetColumnId, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
        }

        public static TreeControlsTreeControlExtraDetailsLinkedDetails FromRead(Read.ITreeControlsTreeControlExtraDetailsLinkedDetails read)
        {
            if (read == null)
                return null;
            var item = new TreeControlsTreeControlExtraDetailsLinkedDetails();
            item.DetailsTableId = AttributeValue<uint?>.FromRead(read.DetailsTableId);
            item.DiscreetColumnId = AttributeValue<uint?>.FromRead(read.DiscreetColumnId);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlExtraDetailsLinkedDetails(this);
        }
    }

    ///<summary>
    /// Contains additional tab definitions in the tree control.
    ///</summary>
public partial class TreeControlsTreeControlExtraTabs : EditableListNode<Read.ITreeControlsTreeControlExtraTabs, Read.ITreeControlsTreeControlExtraTabsTab, TreeControlsTreeControlExtraTabsTab>
    {
        internal TreeControlsTreeControlExtraTabs(Read.ITreeControlsTreeControlExtraTabs read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ExtraTabs node. None of it's properties will be set.
        ///</summary>
public TreeControlsTreeControlExtraTabs() : base("ExtraTabs")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITreeControlsTreeControlExtraTabs read, XmlElement editNode)
        {
        }

        public static TreeControlsTreeControlExtraTabs FromRead(Read.ITreeControlsTreeControlExtraTabs read)
        {
            if (read == null)
                return null;
            var item = new TreeControlsTreeControlExtraTabs();
            foreach (var x in read)
            {
                item.Add(TreeControlsTreeControlExtraTabsTab.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlExtraTabs(this);
        }
    }

    ///<summary>
    /// Defines an additional tab.
    ///</summary>
public partial class TreeControlsTreeControlExtraTabsTab : EditableElementNode<Read.ITreeControlsTreeControlExtraTabsTab>
    {
        internal TreeControlsTreeControlExtraTabsTab(Read.ITreeControlsTreeControlExtraTabsTab read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Tab node. None of it's properties will be set.
        ///</summary>
public TreeControlsTreeControlExtraTabsTab() : base("Tab")
        {
            OnCreated();
        }

        private AttributeValue<string> _parameter;
        private AttributeValue<uint?> _tableId;
        private AttributeValue<string> _title;
        private AttributeValue<string> _type;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> Parameter
        {
            get
            {
                return _parameter;
            }

            set
            {
                if (_parameter != value)
                {
                    _parameter = value;
                    AttributeHandler.Assign(value, this, "parameter");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the table this additional tab configuration relates to.
        ///</summary>
public AttributeValue<uint?> TableId
        {
            get
            {
                return _tableId;
            }

            set
            {
                if (_tableId != value)
                {
                    _tableId = value;
                    AttributeHandler.Assign(value, this, "tableId");
                }
            }
        }

        ///<summary>
        /// Specifies the title description of the tab.
        ///</summary>
public AttributeValue<string> Title
        {
            get
            {
                return _title;
            }

            set
            {
                if (_title != value)
                {
                    _title = value;
                    AttributeHandler.Assign(value, this, "title");
                }
            }
        }

        ///<summary>
        /// Specifies the tab type.
        ///</summary>
public AttributeValue<string> Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public AttributeValue<string> GetOrCreateParameter()
        {
            if (Parameter == null)
                Parameter = new AttributeValue<string>();
            return Parameter;
        }

        public AttributeValue<uint?> GetOrCreateTableId()
        {
            if (TableId == null)
                TableId = new AttributeValue<uint?>();
            return TableId;
        }

        public AttributeValue<string> GetOrCreateTitle()
        {
            if (Title == null)
                Title = new AttributeValue<string>();
            return Title;
        }

        public AttributeValue<string> GetOrCreateType()
        {
            if (Type == null)
                Type = new AttributeValue<string>();
            return Type;
        }

        protected override void Initialize(Read.ITreeControlsTreeControlExtraTabsTab read, XmlElement editNode)
        {
            if (read == null)
                return;
            _parameter = read.Parameter != null ? new AttributeValue<string>(read.Parameter, this) : null;
            _tableId = read.TableId != null ? new AttributeValue<uint?>(read.TableId, this) : null;
            _title = read.Title != null ? new AttributeValue<string>(read.Title, this) : null;
            _type = read.Type != null ? new AttributeValue<string>(read.Type, this) : null;
        }

        public static TreeControlsTreeControlExtraTabsTab FromRead(Read.ITreeControlsTreeControlExtraTabsTab read)
        {
            if (read == null)
                return null;
            var item = new TreeControlsTreeControlExtraTabsTab();
            item.Parameter = AttributeValue<string>.FromRead(read.Parameter);
            item.TableId = AttributeValue<uint?>.FromRead(read.TableId);
            item.Title = AttributeValue<string>.FromRead(read.Title);
            item.Type = AttributeValue<string>.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlExtraTabsTab(this);
        }
    }

    ///<summary>
    /// Defines the relationship between the (visible) tables.
    /// Rows from these tables will become items in the tree.
    ///</summary>
public partial class TreeControlsTreeControlHierarchy : EditableListNode<Read.ITreeControlsTreeControlHierarchy, Read.ITreeControlsTreeControlHierarchyTable, TreeControlsTreeControlHierarchyTable>
    {
        internal TreeControlsTreeControlHierarchy(Read.ITreeControlsTreeControlHierarchy read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Hierarchy node. None of it's properties will be set.
        ///</summary>
public TreeControlsTreeControlHierarchy() : base("Hierarchy")
        {
            OnCreated();
        }

        private AttributeValue<string> _path;
        ///<summary>
        /// When no advanced hierarchy is needed, you can use this attribute to define the table links using a comma-separated list.
        ///</summary>
public AttributeValue<string> Path
        {
            get
            {
                return _path;
            }

            set
            {
                if (_path != value)
                {
                    _path = value;
                    AttributeHandler.Assign(value, this, "path");
                }
            }
        }

        public AttributeValue<string> GetOrCreatePath()
        {
            if (Path == null)
                Path = new AttributeValue<string>();
            return Path;
        }

        protected override void Initialize(Read.ITreeControlsTreeControlHierarchy read, XmlElement editNode)
        {
            if (read == null)
                return;
            _path = read.Path != null ? new AttributeValue<string>(read.Path, this) : null;
        }

        public static TreeControlsTreeControlHierarchy FromRead(Read.ITreeControlsTreeControlHierarchy read)
        {
            if (read == null)
                return null;
            var item = new TreeControlsTreeControlHierarchy();
            item.Path = AttributeValue<string>.FromRead(read.Path);
            foreach (var x in read)
            {
                item.Add(TreeControlsTreeControlHierarchyTable.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlHierarchy(this);
        }
    }

    ///<summary>
    /// Specifies the table links.
    /// When using a more advanced hierarchy, the table links can be defined using Table tags. In the hierarchy, the path attribute must be omitted or empty.
    ///</summary>
public partial class TreeControlsTreeControlHierarchyTable : EditableElementNode<Read.ITreeControlsTreeControlHierarchyTable>
    {
        internal TreeControlsTreeControlHierarchyTable(Read.ITreeControlsTreeControlHierarchyTable read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Table node. None of it's properties will be set.
        ///</summary>
public TreeControlsTreeControlHierarchyTable() : base("Table")
        {
            OnCreated();
        }

        private AttributeValue<string> _condition;
        private AttributeValue<uint?> _id;
        private AttributeValue<uint?> _parentAttribute;
        ///<summary>
        /// Specifies a condition.
        ///</summary>
public AttributeValue<string> Condition
        {
            get
            {
                return _condition;
            }

            set
            {
                if (_condition != value)
                {
                    _condition = value;
                    AttributeHandler.Assign(value, this, "condition");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter ID of the table that is needed in the tree.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter ID of the table that is the parent of the table specified in the id attribute.
        ///</summary>
public AttributeValue<uint?> ParentAttribute
        {
            get
            {
                return _parentAttribute;
            }

            set
            {
                if (_parentAttribute != value)
                {
                    _parentAttribute = value;
                    AttributeHandler.Assign(value, this, "parent");
                }
            }
        }

        public AttributeValue<string> GetOrCreateCondition()
        {
            if (Condition == null)
                Condition = new AttributeValue<string>();
            return Condition;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<uint?> GetOrCreateParentAttribute()
        {
            if (ParentAttribute == null)
                ParentAttribute = new AttributeValue<uint?>();
            return ParentAttribute;
        }

        protected override void Initialize(Read.ITreeControlsTreeControlHierarchyTable read, XmlElement editNode)
        {
            if (read == null)
                return;
            _condition = read.Condition != null ? new AttributeValue<string>(read.Condition, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _parentAttribute = read.ParentAttribute != null ? new AttributeValue<uint?>(read.ParentAttribute, this) : null;
        }

        public static TreeControlsTreeControlHierarchyTable FromRead(Read.ITreeControlsTreeControlHierarchyTable read)
        {
            if (read == null)
                return null;
            var item = new TreeControlsTreeControlHierarchyTable();
            item.Condition = AttributeValue<string>.FromRead(read.Condition);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.ParentAttribute = AttributeValue<uint?>.FromRead(read.ParentAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTreeControlsTreeControlHierarchyTable(this);
        }
    }

    ///<summary>
    /// Contains the triggers defined in the protocol.
    /// In a trigger, you define when it should go off, and which actions it should execute.
    ///</summary>
public partial class Triggers : EditableListNode<Read.ITriggers, Read.ITriggersTrigger, TriggersTrigger>
    {
        internal Triggers(Read.ITriggers read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Triggers node. None of it's properties will be set.
        ///</summary>
public Triggers() : base("Triggers")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITriggers read, XmlElement editNode)
        {
        }

        public static Triggers FromRead(Read.ITriggers read)
        {
            if (read == null)
                return null;
            var item = new Triggers();
            foreach (var x in read)
            {
                item.Add(TriggersTrigger.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggers(this);
        }
    }

    ///<summary>
    /// Defines a trigger.
    /// Triggers allow you to define the exact moment at which certain actions have to be executed.
    /// They can, for example, be used to set the exact time at which to perform a copy operation, to calculate a CRC, etc.
    ///</summary>
public partial class TriggersTrigger : EditableElementNode<Read.ITriggersTrigger>
    {
        internal TriggersTrigger(Read.ITriggersTrigger read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Trigger node. None of it's properties will be set.
        ///</summary>
public TriggersTrigger() : base("Trigger")
        {
            OnCreated();
        }

        private ElementValue<string> _condition;
        private TriggersTriggerContent _content;
        private ElementValue<string> _name;
        private TriggersTriggerOn _on;
        private TriggersTriggerTime _time;
        private TriggersTriggerType _type;
        private AttributeValue<uint?> _id;
        ///<summary>
        /// Specifies a condition that must be met in order for the trigger to go off.
        ///</summary>
public ElementValue<string> Condition
        {
            get
            {
                return _condition;
            }

            set
            {
                if (_condition != value)
                {
                    _condition = value;
                    ElementHandler.Assign(value, this, "Condition");
                }
            }
        }

        ///<summary>
        /// Specifies the actions to be executed, or triggers to be activated the moment the trigger goes off.
        /// Recommendation: Do not include more than 10 items tags.
        ///</summary>
public TriggersTriggerContent Content
        {
            get
            {
                return _content;
            }

            set
            {
                if (_content != value)
                {
                    _content = value;
                    CombinedTagHandler.Assign(value, this, "Content");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the trigger.
        ///</summary>
public ElementValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    ElementHandler.Assign(value, this, "Name");
                }
            }
        }

        ///<summary>
        /// Defines what will set off the trigger. Used together with /Protocol/Triggers/Trigger/Time, which defines the exact moment the trigger has to go off.
        /// This /Protocol/Triggers/Trigger/On element is always used when defining a trigger, except when the trigger has to be activated by another trigger.
        /// In that case, the moment at which the trigger has to go off will already be defined in the initializing trigger. The /Protocol/Triggers/Trigger/Time element will then also be empty.
        ///</summary>
public TriggersTriggerOn On
        {
            get
            {
                return _on;
            }

            set
            {
                if (_on != value)
                {
                    _on = value;
                    CombinedTagHandler.Assign(value, this, "On");
                }
            }
        }

        ///<summary>
        /// Defines, together with /Protocol/Triggers/Trigger/On, the exact moment at which a trigger will go off.
        /// Note: Not all /Protocol/Triggers/Trigger/Time values can be used in combination with the different /Protocol/Trig­gers/Trigger/On types.
        /// Refer to the DataMiner Protocol Markup Language documentatio. for an overview of the possible combinations.
        ///</summary>
public TriggersTriggerTime Time
        {
            get
            {
                return _time;
            }

            set
            {
                if (_time != value)
                {
                    _time = value;
                    CombinedTagHandler.Assign(value, this, "Time");
                }
            }
        }

        ///<summary>
        /// Specifies what should happen when the trigger goes off:
        /// - execute one or more actions, or
        /// - activate one or more triggers.
        ///</summary>
public TriggersTriggerType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    ElementHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Specifies the unique trigger ID.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        public ElementValue<string> GetOrCreateCondition()
        {
            if (Condition == null)
                Condition = new ElementValue<string>();
            return Condition;
        }

        public TriggersTriggerContent GetOrCreateContent()
        {
            if (Content == null)
                Content = new TriggersTriggerContent();
            return Content;
        }

        public ElementValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new ElementValue<string>();
            return Name;
        }

        public TriggersTriggerOn GetOrCreateOn()
        {
            if (On == null)
                On = new TriggersTriggerOn();
            return On;
        }

        public TriggersTriggerTime GetOrCreateTime()
        {
            if (Time == null)
                Time = new TriggersTriggerTime();
            return Time;
        }

        public TriggersTriggerType GetOrCreateType()
        {
            if (Type == null)
                Type = new TriggersTriggerType();
            return Type;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        protected override void Initialize(Read.ITriggersTrigger read, XmlElement editNode)
        {
            if (read == null)
                return;
            _condition = read.Condition != null ? new ElementValue<string>(read.Condition, this) : null;
            _content = read.Content != null ? new TriggersTriggerContent(read.Content, this, editNode.Element["Content"]) : null;
            _name = read.Name != null ? new ElementValue<string>(read.Name, this) : null;
            _on = read.On != null ? new TriggersTriggerOn(read.On, this, editNode.Element["On"]) : null;
            _time = read.Time != null ? new TriggersTriggerTime(read.Time, this, editNode.Element["Time"]) : null;
            _type = read.Type != null ? new TriggersTriggerType(read.Type, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
        }

        public static TriggersTrigger FromRead(Read.ITriggersTrigger read)
        {
            if (read == null)
                return null;
            var item = new TriggersTrigger();
            item.Condition = ElementValue<string>.FromRead(read.Condition);
            item.Content = TriggersTriggerContent.FromRead(read.Content);
            item.Name = ElementValue<string>.FromRead(read.Name);
            item.On = TriggersTriggerOn.FromRead(read.On);
            item.Time = TriggersTriggerTime.FromRead(read.Time);
            item.Type = TriggersTriggerType.FromRead(read.Type);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTrigger(this);
        }
    }

    ///<summary>
    /// Specifies the actions to be executed, or triggers to be activated the moment the trigger goes off.
    /// Recommendation: Do not include more than 10 items tags.
    ///</summary>
public partial class TriggersTriggerContent : EditableListNode<Read.ITriggersTriggerContent, Read.ITriggersTriggerContentId, TriggersTriggerContentId>
    {
        internal TriggersTriggerContent(Read.ITriggersTriggerContent read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Content node. None of it's properties will be set.
        ///</summary>
public TriggersTriggerContent() : base("Content")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITriggersTriggerContent read, XmlElement editNode)
        {
        }

        public static TriggersTriggerContent FromRead(Read.ITriggersTriggerContent read)
        {
            if (read == null)
                return null;
            var item = new TriggersTriggerContent();
            foreach (var x in read)
            {
                item.Add(TriggersTriggerContentId.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTriggerContent(this);
        }
    }

    ///<summary>
    /// Specifies the ID of the action to be executed or the trigger to be activated when the trigger goes off.
    ///</summary>
public partial class TriggersTriggerContentId : EditableElementValueNode<Read.ITriggersTriggerContentId, uint?>
    {
        internal TriggersTriggerContentId(Read.ITriggersTriggerContentId read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Id node. None of it's properties will be set.
        ///</summary>
public TriggersTriggerContentId() : base("Id")
        {
            OnCreated();
        }

        public TriggersTriggerContentId(uint? value) : base("Id", value)
        {
        }

        private AttributeValue<bool?> _else;
        ///<summary>
        /// When a condition has been added to the trigger, the action of which the ID is specified in this attribute will be executed when the condition is not met.
        ///</summary>
public AttributeValue<bool?> Else
        {
            get
            {
                return _else;
            }

            set
            {
                if (_else != value)
                {
                    _else = value;
                    AttributeHandler.Assign(value, this, "else");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateElse()
        {
            if (Else == null)
                Else = new AttributeValue<bool?>();
            return Else;
        }

        protected override void Initialize(Read.ITriggersTriggerContentId read, XmlElement editNode)
        {
            if (read == null)
                return;
            _else = read.Else != null ? new AttributeValue<bool?>(read.Else, this) : null;
        }

        public static TriggersTriggerContentId FromRead(Read.ITriggersTriggerContentId read)
        {
            if (read == null)
                return null;
            var item = new TriggersTriggerContentId();
            item.Value = read.Value;
            item.Else = AttributeValue<bool?>.FromRead(read.Else);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTriggerContentId(this);
        }
    }

    ///<summary>
    /// Defines what will set off the trigger. Used together with /Protocol/Triggers/Trigger/Time, which defines the exact moment the trigger has to go off.
    /// This /Protocol/Triggers/Trigger/On element is always used when defining a trigger, except when the trigger has to be activated by another trigger.
    /// In that case, the moment at which the trigger has to go off will already be defined in the initializing trigger. The /Protocol/Triggers/Trigger/Time element will then also be empty.
    ///</summary>
public partial class TriggersTriggerOn : EditableElementValueNode<Read.ITriggersTriggerOn, Enums.EnumTriggerOn?>
    {
        internal TriggersTriggerOn(Read.ITriggersTriggerOn read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a On node. None of it's properties will be set.
        ///</summary>
public TriggersTriggerOn() : base("On")
        {
            OnCreated();
        }

        public TriggersTriggerOn(Enums.EnumTriggerOn? value) : base("On", value)
        {
        }

        private AttributeValue<string> _id;
        ///<summary>
        /// Specifies the ID of the parameter, command, response, etc.
        /// If you do not specify an id attribute, the trigger will apply to all items of the type specified in the /Protocol/Triggers/Trigger/On element.
        ///</summary>
public AttributeValue<string> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        public AttributeValue<string> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<string>();
            return Id;
        }

        protected override void Initialize(Read.ITriggersTriggerOn read, XmlElement editNode)
        {
            if (read == null)
                return;
            _id = read.Id != null ? new AttributeValue<string>(read.Id, this) : null;
        }

        public static TriggersTriggerOn FromRead(Read.ITriggersTriggerOn read)
        {
            if (read == null)
                return null;
            var item = new TriggersTriggerOn();
            item.Value = read.Value;
            item.Id = AttributeValue<string>.FromRead(read.Id);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTriggerOn(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumTriggerOnConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumTriggerOn? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTriggerOnConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Defines, together with /Protocol/Triggers/Trigger/On, the exact moment at which a trigger will go off.
    /// Note: Not all /Protocol/Triggers/Trigger/Time values can be used in combination with the different /Protocol/Trig­gers/Trigger/On types.
    /// Refer to the DataMiner Protocol Markup Language documentatio. for an overview of the possible combinations.
    ///</summary>
public partial class TriggersTriggerTime : EditableElementValueNode<Read.ITriggersTriggerTime, string>
    {
        internal TriggersTriggerTime(Read.ITriggersTriggerTime read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Time node. None of it's properties will be set.
        ///</summary>
public TriggersTriggerTime(bool useCDATA = false) : base("Time", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public TriggersTriggerTime(string value, bool useCDATA = false) : base("Time", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _case;
        private AttributeValue<uint?> _id;
        private AttributeValue<bool?> _nr;
        private AttributeValue<string> _valueAttribute;
        ///<summary>
        /// Specifies the condition: equal, not equal, greater, less, or a logical combination of those operators.
        ///</summary>
public AttributeValue<string> Case
        {
            get
            {
                return _case;
            }

            set
            {
                if (_case != value)
                {
                    _case = value;
                    AttributeHandler.Assign(value, this, "case");
                }
            }
        }

        ///<summary>
        /// The ID of the parameter, command, response, etc. (defined in /Protocol/Triggers/Trigger/On) of which the value will be checked.
        /// If this attribute is omitted, the ID specified in /Protocol/Triggers/Trigger/On will be taken.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// Set this attribute to "true" if the value attribute contains a parameter ID instead of a parameter value.
        ///</summary>
public AttributeValue<bool?> Nr
        {
            get
            {
                return _nr;
            }

            set
            {
                if (_nr != value)
                {
                    _nr = value;
                    AttributeHandler.Assign(value, this, "nr");
                }
            }
        }

        ///<summary>
        /// Specifies the value that will be used as condition operand.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        public AttributeValue<string> GetOrCreateCase()
        {
            if (Case == null)
                Case = new AttributeValue<string>();
            return Case;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<bool?> GetOrCreateNr()
        {
            if (Nr == null)
                Nr = new AttributeValue<bool?>();
            return Nr;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        protected override void Initialize(Read.ITriggersTriggerTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _case = read.Case != null ? new AttributeValue<string>(read.Case, this) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _nr = read.Nr != null ? new AttributeValue<bool?>(read.Nr, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
        }

        public static TriggersTriggerTime FromRead(Read.ITriggersTriggerTime read)
        {
            if (read == null)
                return null;
            var item = new TriggersTriggerTime();
            item.Value = read.Value;
            item.Case = AttributeValue<string>.FromRead(read.Case);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.Nr = AttributeValue<bool?>.FromRead(read.Nr);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTriggersTriggerTime(this);
        }
    }

    public partial class TriggersTriggerType : ElementValue<Enums.EnumTriggerType?>
    {
        internal TriggersTriggerType(Read.IValueTag<Enums.EnumTriggerType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public TriggersTriggerType() : base()
        {
            OnCreated();
        }

        public TriggersTriggerType(Enums.EnumTriggerType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumTriggerTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumTriggerType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTriggerTypeConverter.Convert(rawValue?.Trim());
        }

        public new static TriggersTriggerType FromRead(Read.IValueTag<Enums.EnumTriggerType?> read)
        {
            if (read == null)
                return null;
            var item = new TriggersTriggerType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies the protocol type. In multi-connection protocols, it specifies the type of the main connection.
    ///</summary>
public partial class ProtocolType : EditableElementValueNode<Read.IProtocolType, Enums.EnumProtocolType?>
    {
        internal ProtocolType(Read.IProtocolType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public ProtocolType() : base("Type")
        {
            OnCreated();
        }

        public ProtocolType(Enums.EnumProtocolType? value) : base("Type", value)
        {
        }

        private AttributeValue<string> _advanced;
        private AttributeValue<string> _communicationOptions;
        private AttributeValue<string> _databaseOptions;
        private AttributeValue<string> _options;
        private AttributeValue<bool?> _overrideTimeoutDVE;
        private ProtocolTypeRelativeTimers _relativeTimers;
        ///<summary>
        /// Specifies additional connections. This allows you to create e.g. a serial protocol containing some SNMP commands, or a protocol that is capable of communicating with multiple ports.
        /// Protocol types have to be separated by semi-colon (";").
        /// For more information on ports, see:	/Protocol/Ports and /Protocol/Portsettings.
        ///</summary>
public AttributeValue<string> Advanced
        {
            get
            {
                return _advanced;
            }

            set
            {
                if (_advanced != value)
                {
                    _advanced = value;
                    AttributeHandler.Assign(value, this, "advanced");
                }
            }
        }

        ///<summary>
        /// Specifies a number of communication options.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> CommunicationOptions
        {
            get
            {
                return _communicationOptions;
            }

            set
            {
                if (_communicationOptions != value)
                {
                    _communicationOptions = value;
                    AttributeHandler.Assign(value, this, "communicationOptions");
                }
            }
        }

        ///<summary>
        /// Specifies a number of database options.
        /// For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> DatabaseOptions
        {
            get
            {
                return _databaseOptions;
            }

            set
            {
                if (_databaseOptions != value)
                {
                    _databaseOptions = value;
                    AttributeHandler.Assign(value, this, "databaseOptions");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options. For more information, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies whether the DVE will go into timeout when the main element is in timeout.
        ///</summary>
public AttributeValue<bool?> OverrideTimeoutDVE
        {
            get
            {
                return _overrideTimeoutDVE;
            }

            set
            {
                if (_overrideTimeoutDVE != value)
                {
                    _overrideTimeoutDVE = value;
                    AttributeHandler.Assign(value, this, "overrideTimeoutDVE");
                }
            }
        }

        ///<summary>
        /// This attribute can have one of two values:	"true"* and	"true with reset".
        /// *If the /Protocol/Timers/Timer@fixedTimer attribute is also set to "true", then users cannot change the timer interval.
        ///</summary>
public ProtocolTypeRelativeTimers RelativeTimers
        {
            get
            {
                return _relativeTimers;
            }

            set
            {
                if (_relativeTimers != value)
                {
                    _relativeTimers = value;
                    AttributeHandler.Assign(value, this, "relativeTimers");
                }
            }
        }

        public AttributeValue<string> GetOrCreateAdvanced()
        {
            if (Advanced == null)
                Advanced = new AttributeValue<string>();
            return Advanced;
        }

        public AttributeValue<string> GetOrCreateCommunicationOptions()
        {
            if (CommunicationOptions == null)
                CommunicationOptions = new AttributeValue<string>();
            return CommunicationOptions;
        }

        public AttributeValue<string> GetOrCreateDatabaseOptions()
        {
            if (DatabaseOptions == null)
                DatabaseOptions = new AttributeValue<string>();
            return DatabaseOptions;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<bool?> GetOrCreateOverrideTimeoutDVE()
        {
            if (OverrideTimeoutDVE == null)
                OverrideTimeoutDVE = new AttributeValue<bool?>();
            return OverrideTimeoutDVE;
        }

        public ProtocolTypeRelativeTimers GetOrCreateRelativeTimers()
        {
            if (RelativeTimers == null)
                RelativeTimers = new ProtocolTypeRelativeTimers();
            return RelativeTimers;
        }

        protected override void Initialize(Read.IProtocolType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _advanced = read.Advanced != null ? new AttributeValue<string>(read.Advanced, this) : null;
            _communicationOptions = read.CommunicationOptions != null ? new AttributeValue<string>(read.CommunicationOptions, this) : null;
            _databaseOptions = read.DatabaseOptions != null ? new AttributeValue<string>(read.DatabaseOptions, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _overrideTimeoutDVE = read.OverrideTimeoutDVE != null ? new AttributeValue<bool?>(read.OverrideTimeoutDVE, this) : null;
            _relativeTimers = read.RelativeTimers != null ? new ProtocolTypeRelativeTimers(read.RelativeTimers, this) : null;
        }

        public static ProtocolType FromRead(Read.IProtocolType read)
        {
            if (read == null)
                return null;
            var item = new ProtocolType();
            item.Value = read.Value;
            item.Advanced = AttributeValue<string>.FromRead(read.Advanced);
            item.CommunicationOptions = AttributeValue<string>.FromRead(read.CommunicationOptions);
            item.DatabaseOptions = AttributeValue<string>.FromRead(read.DatabaseOptions);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.OverrideTimeoutDVE = AttributeValue<bool?>.FromRead(read.OverrideTimeoutDVE);
            item.RelativeTimers = ProtocolTypeRelativeTimers.FromRead(read.RelativeTimers);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitProtocolType(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumProtocolTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumProtocolType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumProtocolTypeConverter.Convert(rawValue?.Trim());
        }
    }

    public partial class ProtocolTypeRelativeTimers : AttributeValue<Enums.EnumProtocolTypeRelativeTimers?>
    {
        internal ProtocolTypeRelativeTimers(Read.IValueTag<Enums.EnumProtocolTypeRelativeTimers?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a relativeTimers node. None of it's properties will be set.
        ///</summary>
public ProtocolTypeRelativeTimers() : base()
        {
            OnCreated();
        }

        public ProtocolTypeRelativeTimers(Enums.EnumProtocolTypeRelativeTimers? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumProtocolTypeRelativeTimersConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumProtocolTypeRelativeTimers? ConvertRawValue(string rawValue)
        {
            return Enums.EnumProtocolTypeRelativeTimersConverter.Convert(rawValue?.Trim());
        }

        public new static ProtocolTypeRelativeTimers FromRead(Read.IValueTag<Enums.EnumProtocolTypeRelativeTimers?> read)
        {
            if (read == null)
                return null;
            var item = new ProtocolTypeRelativeTimers();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Contains an overview of the version history of this protocol.
    /// Feature introduced in DataMiner 9.5.11 (RN 17697, RN 18360).
    ///</summary>
public partial class VersionHistory : EditableElementNode<Read.IVersionHistory>
    {
        internal VersionHistory(Read.IVersionHistory read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a VersionHistory node. None of it's properties will be set.
        ///</summary>
public VersionHistory() : base("VersionHistory")
        {
            OnCreated();
        }

        private VersionHistoryBranches _branches;
        ///<summary>
        /// Contains the different branches of this protocol.
        ///</summary>
public VersionHistoryBranches Branches
        {
            get
            {
                return _branches;
            }

            set
            {
                if (_branches != value)
                {
                    _branches = value;
                    CombinedTagHandler.Assign(value, this, "Branches");
                }
            }
        }

        public VersionHistoryBranches GetOrCreateBranches()
        {
            if (Branches == null)
                Branches = new VersionHistoryBranches();
            return Branches;
        }

        protected override void Initialize(Read.IVersionHistory read, XmlElement editNode)
        {
            if (read == null)
                return;
            _branches = read.Branches != null ? new VersionHistoryBranches(read.Branches, this, editNode.Element["Branches"]) : null;
        }

        public static VersionHistory FromRead(Read.IVersionHistory read)
        {
            if (read == null)
                return null;
            var item = new VersionHistory();
            item.Branches = VersionHistoryBranches.FromRead(read.Branches);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistory(this);
        }
    }

    ///<summary>
    /// Contains the different branches of this protocol.
    ///</summary>
public partial class VersionHistoryBranches : EditableListNode<Read.IVersionHistoryBranches, Read.IVersionHistoryBranchesBranch, VersionHistoryBranchesBranch>
    {
        internal VersionHistoryBranches(Read.IVersionHistoryBranches read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Branches node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranches() : base("Branches")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranches read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranches FromRead(Read.IVersionHistoryBranches read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranches();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranch.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranches(this);
        }
    }

    ///<summary>
    /// Defines a branch of this protocol.
    ///</summary>
public partial class VersionHistoryBranchesBranch : EditableElementNode<Read.IVersionHistoryBranchesBranch>
    {
        internal VersionHistoryBranchesBranch(Read.IVersionHistoryBranchesBranch read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Branch node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranch() : base("Branch")
        {
            OnCreated();
        }

        private ElementValue<string> _comment;
        private VersionHistoryBranchesBranchFeatures _features;
        private VersionHistoryBranchesBranchSystemVersions _systemVersions;
        private AttributeValue<uint?> _id;
        ///<summary>
        /// Provides information about this branch.
        ///</summary>
public ElementValue<string> Comment
        {
            get
            {
                return _comment;
            }

            set
            {
                if (_comment != value)
                {
                    _comment = value;
                    ElementHandler.Assign(value, this, "Comment");
                }
            }
        }

        ///<summary>
        /// Provides information about the features this branch supports.
        ///</summary>
public VersionHistoryBranchesBranchFeatures Features
        {
            get
            {
                return _features;
            }

            set
            {
                if (_features != value)
                {
                    _features = value;
                    CombinedTagHandler.Assign(value, this, "Features");
                }
            }
        }

        ///<summary>
        /// Contains the different SystemVersion entries.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersions SystemVersions
        {
            get
            {
                return _systemVersions;
            }

            set
            {
                if (_systemVersions != value)
                {
                    _systemVersions = value;
                    CombinedTagHandler.Assign(value, this, "SystemVersions");
                }
            }
        }

        ///<summary>
        /// The unique ID of the branch version component.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        public ElementValue<string> GetOrCreateComment()
        {
            if (Comment == null)
                Comment = new ElementValue<string>();
            return Comment;
        }

        public VersionHistoryBranchesBranchFeatures GetOrCreateFeatures()
        {
            if (Features == null)
                Features = new VersionHistoryBranchesBranchFeatures();
            return Features;
        }

        public VersionHistoryBranchesBranchSystemVersions GetOrCreateSystemVersions()
        {
            if (SystemVersions == null)
                SystemVersions = new VersionHistoryBranchesBranchSystemVersions();
            return SystemVersions;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranch read, XmlElement editNode)
        {
            if (read == null)
                return;
            _comment = read.Comment != null ? new ElementValue<string>(read.Comment, this) : null;
            _features = read.Features != null ? new VersionHistoryBranchesBranchFeatures(read.Features, this, editNode.Element["Features"]) : null;
            _systemVersions = read.SystemVersions != null ? new VersionHistoryBranchesBranchSystemVersions(read.SystemVersions, this, editNode.Element["SystemVersions"]) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
        }

        public static VersionHistoryBranchesBranch FromRead(Read.IVersionHistoryBranchesBranch read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranch();
            item.Comment = ElementValue<string>.FromRead(read.Comment);
            item.Features = VersionHistoryBranchesBranchFeatures.FromRead(read.Features);
            item.SystemVersions = VersionHistoryBranchesBranchSystemVersions.FromRead(read.SystemVersions);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranch(this);
        }
    }

    ///<summary>
    /// Provides information about the features this branch supports.
    ///</summary>
public partial class VersionHistoryBranchesBranchFeatures : EditableListNode<Read.IVersionHistoryBranchesBranchFeatures, Read.IVersionHistoryBranchesBranchFeaturesFeature, VersionHistoryBranchesBranchFeaturesFeature>
    {
        internal VersionHistoryBranchesBranchFeatures(Read.IVersionHistoryBranchesBranchFeatures read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Features node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchFeatures() : base("Features")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchFeatures read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchFeatures FromRead(Read.IVersionHistoryBranchesBranchFeatures read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchFeatures();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchFeaturesFeature.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchFeatures(this);
        }
    }

    ///<summary>
    /// Provides information about a specific feature of this branch.
    ///</summary>
public partial class VersionHistoryBranchesBranchFeaturesFeature : EditableElementValueNode<Read.IVersionHistoryBranchesBranchFeaturesFeature, string>
    {
        internal VersionHistoryBranchesBranchFeaturesFeature(Read.IVersionHistoryBranchesBranchFeaturesFeature read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Feature node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchFeaturesFeature(bool useCDATA = false) : base("Feature", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchFeaturesFeature(string value, bool useCDATA = false) : base("Feature", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchFeaturesFeature read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchFeaturesFeature FromRead(Read.IVersionHistoryBranchesBranchFeaturesFeature read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchFeaturesFeature();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchFeaturesFeature(this);
        }
    }

    ///<summary>
    /// Contains the different SystemVersion entries.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersions : EditableListNode<Read.IVersionHistoryBranchesBranchSystemVersions, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersion, VersionHistoryBranchesBranchSystemVersionsSystemVersion>
    {
        internal VersionHistoryBranchesBranchSystemVersions(Read.IVersionHistoryBranchesBranchSystemVersions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SystemVersions node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersions() : base("SystemVersions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersions read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersions FromRead(Read.IVersionHistoryBranchesBranchSystemVersions read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersions();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersion.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersions(this);
        }
    }

    ///<summary>
    /// Defines a SystemVersion entry.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersion : EditableElementNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersion>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersion(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersion read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SystemVersion node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersion() : base("SystemVersion")
        {
            OnCreated();
        }

        private ElementValue<string> _comment;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions _majorVersions;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions _supportedVersions;
        private AttributeValue<uint?> _id;
        ///<summary>
        /// Provides information about this entry.
        ///</summary>
public ElementValue<string> Comment
        {
            get
            {
                return _comment;
            }

            set
            {
                if (_comment != value)
                {
                    _comment = value;
                    ElementHandler.Assign(value, this, "Comment");
                }
            }
        }

        ///<summary>
        /// Contains the different major versions within this branch of this protocol.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions MajorVersions
        {
            get
            {
                return _majorVersions;
            }

            set
            {
                if (_majorVersions != value)
                {
                    _majorVersions = value;
                    CombinedTagHandler.Assign(value, this, "MajorVersions");
                }
            }
        }

        ///<summary>
        /// Specifies the system version support.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions SupportedVersions
        {
            get
            {
                return _supportedVersions;
            }

            set
            {
                if (_supportedVersions != value)
                {
                    _supportedVersions = value;
                    CombinedTagHandler.Assign(value, this, "SupportedVersions");
                }
            }
        }

        ///<summary>
        /// The unique ID of the system version component.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        public ElementValue<string> GetOrCreateComment()
        {
            if (Comment == null)
                Comment = new ElementValue<string>();
            return Comment;
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions GetOrCreateMajorVersions()
        {
            if (MajorVersions == null)
                MajorVersions = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions();
            return MajorVersions;
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions GetOrCreateSupportedVersions()
        {
            if (SupportedVersions == null)
                SupportedVersions = new VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions();
            return SupportedVersions;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersion read, XmlElement editNode)
        {
            if (read == null)
                return;
            _comment = read.Comment != null ? new ElementValue<string>(read.Comment, this) : null;
            _majorVersions = read.MajorVersions != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions(read.MajorVersions, this, editNode.Element["MajorVersions"]) : null;
            _supportedVersions = read.SupportedVersions != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions(read.SupportedVersions, this, editNode.Element["SupportedVersions"]) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersion FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersion read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersion();
            item.Comment = ElementValue<string>.FromRead(read.Comment);
            item.MajorVersions = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions.FromRead(read.MajorVersions);
            item.SupportedVersions = VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions.FromRead(read.SupportedVersions);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersion(this);
        }
    }

    ///<summary>
    /// Contains the different major versions within this branch of this protocol.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions : EditableListNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion, VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a MajorVersions node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions() : base("MajorVersions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions(this);
        }
    }

    ///<summary>
    /// Defines a major version of this protocol.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion : EditableElementNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a MajorVersion node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion() : base("MajorVersion")
        {
            OnCreated();
        }

        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges _changes;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions _minorVersions;
        private AttributeValue<uint?> _id;
        ///<summary>
        /// Contains information about the changes.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges Changes
        {
            get
            {
                return _changes;
            }

            set
            {
                if (_changes != value)
                {
                    _changes = value;
                    CombinedTagHandler.Assign(value, this, "Changes");
                }
            }
        }

        ///<summary>
        /// Contains the different minor versions of this protocol within this major version of this protocol.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions MinorVersions
        {
            get
            {
                return _minorVersions;
            }

            set
            {
                if (_minorVersions != value)
                {
                    _minorVersions = value;
                    CombinedTagHandler.Assign(value, this, "MinorVersions");
                }
            }
        }

        ///<summary>
        /// The unique ID of the major version component.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges GetOrCreateChanges()
        {
            if (Changes == null)
                Changes = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges();
            return Changes;
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions GetOrCreateMinorVersions()
        {
            if (MinorVersions == null)
                MinorVersions = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions();
            return MinorVersions;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion read, XmlElement editNode)
        {
            if (read == null)
                return;
            _changes = read.Changes != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges(read.Changes, this, editNode.Element["Changes"]) : null;
            _minorVersions = read.MinorVersions != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions(read.MinorVersions, this, editNode.Element["MinorVersions"]) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion();
            item.Changes = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges.FromRead(read.Changes);
            item.MinorVersions = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions.FromRead(read.MinorVersions);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion(this);
        }
    }

    ///<summary>
    /// Contains information about the changes.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges : EditableListNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange, VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Changes node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges() : base("Changes")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges(this);
        }
    }

    ///<summary>
    /// Describes a change.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange : EditableElementNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Change node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange() : base("Change")
        {
            OnCreated();
        }

        private ElementValue<string> _impact;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake _actionsToTake;
        private AttributeValue<string> _coversMajorChanges;
        ///<summary>
        /// Describes the impact of this change.
        ///</summary>
public ElementValue<string> Impact
        {
            get
            {
                return _impact;
            }

            set
            {
                if (_impact != value)
                {
                    _impact = value;
                    ElementHandler.Assign(value, this, "Impact");
                }
            }
        }

        ///<summary>
        /// Lists the actions to take.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake ActionsToTake
        {
            get
            {
                return _actionsToTake;
            }

            set
            {
                if (_actionsToTake != value)
                {
                    _actionsToTake = value;
                    CombinedTagHandler.Assign(value, this, "ActionsToTake");
                }
            }
        }

        ///<summary>
        /// Specifies the major changes this major change covers.
        ///</summary>
public AttributeValue<string> CoversMajorChanges
        {
            get
            {
                return _coversMajorChanges;
            }

            set
            {
                if (_coversMajorChanges != value)
                {
                    _coversMajorChanges = value;
                    AttributeHandler.Assign(value, this, "coversMajorChanges");
                }
            }
        }

        public ElementValue<string> GetOrCreateImpact()
        {
            if (Impact == null)
                Impact = new ElementValue<string>();
            return Impact;
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake GetOrCreateActionsToTake()
        {
            if (ActionsToTake == null)
                ActionsToTake = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake();
            return ActionsToTake;
        }

        public AttributeValue<string> GetOrCreateCoversMajorChanges()
        {
            if (CoversMajorChanges == null)
                CoversMajorChanges = new AttributeValue<string>();
            return CoversMajorChanges;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _impact = read.Impact != null ? new ElementValue<string>(read.Impact, this) : null;
            _actionsToTake = read.ActionsToTake != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake(read.ActionsToTake, this, editNode.Element["ActionsToTake"]) : null;
            _coversMajorChanges = read.CoversMajorChanges != null ? new AttributeValue<string>(read.CoversMajorChanges, this) : null;
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange();
            item.Impact = ElementValue<string>.FromRead(read.Impact);
            item.ActionsToTake = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake.FromRead(read.ActionsToTake);
            item.CoversMajorChanges = AttributeValue<string>.FromRead(read.CoversMajorChanges);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange(this);
        }
    }

    ///<summary>
    /// Lists the actions to take.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake : EditableListNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake, VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ActionsToTake node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake() : base("ActionsToTake")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake(this);
        }
    }

    ///<summary>
    /// Describes an action to take.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake : EditableElementValueNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake, string>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ActionToTake node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake(bool useCDATA = false) : base("ActionToTake", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake(string value, bool useCDATA = false) : base("ActionToTake", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake(this);
        }
    }

    ///<summary>
    /// Contains the different minor versions of this protocol within this major version of this protocol.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions : EditableListNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion, VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a MinorVersions node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions() : base("MinorVersions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions(this);
        }
    }

    ///<summary>
    /// Defines a minor version of this protocol.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion : EditableElementNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a MinorVersion node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion() : base("MinorVersion")
        {
            OnCreated();
        }

        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges _changes;
        private ElementValue<System.DateTime?> _date;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider _provider;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences _references;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions _suppressions;
        private AttributeValue<uint?> _id;
        private AttributeValue<string> _basedOn;
        ///<summary>
        /// Contains information about the changes implemented in this minor version of this protocol.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges Changes
        {
            get
            {
                return _changes;
            }

            set
            {
                if (_changes != value)
                {
                    _changes = value;
                    CombinedTagHandler.Assign(value, this, "Changes");
                }
            }
        }

        ///<summary>
        /// Specifies the date on which this version of this protocol has been released. (Format: YYYY-MM-DD)
        ///</summary>
public ElementValue<System.DateTime?> Date
        {
            get
            {
                return _date;
            }

            set
            {
                if (_date != value)
                {
                    _date = value;
                    ElementHandler.Assign(value, this, "Date");
                }
            }
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider Provider
        {
            get
            {
                return _provider;
            }

            set
            {
                if (_provider != value)
                {
                    _provider = value;
                    CombinedTagHandler.Assign(value, this, "Provider");
                }
            }
        }

        ///<summary>
        /// Provides references to e.g. registration systems.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences References
        {
            get
            {
                return _references;
            }

            set
            {
                if (_references != value)
                {
                    _references = value;
                    CombinedTagHandler.Assign(value, this, "References");
                }
            }
        }

        ///<summary>
        /// List of all the suppressions for this version.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions Suppressions
        {
            get
            {
                return _suppressions;
            }

            set
            {
                if (_suppressions != value)
                {
                    _suppressions = value;
                    CombinedTagHandler.Assign(value, this, "Suppressions");
                }
            }
        }

        ///<summary>
        /// The unique ID of the minor version component.
        ///</summary>
public AttributeValue<uint?> Id
        {
            get
            {
                return _id;
            }

            set
            {
                if (_id != value)
                {
                    _id = value;
                    AttributeHandler.Assign(value, this, "id");
                }
            }
        }

        ///<summary>
        /// The version of the protocol on which this protocol is based.
        ///</summary>
public AttributeValue<string> BasedOn
        {
            get
            {
                return _basedOn;
            }

            set
            {
                if (_basedOn != value)
                {
                    _basedOn = value;
                    AttributeHandler.Assign(value, this, "basedOn");
                }
            }
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges GetOrCreateChanges()
        {
            if (Changes == null)
                Changes = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges();
            return Changes;
        }

        public ElementValue<System.DateTime?> GetOrCreateDate()
        {
            if (Date == null)
                Date = new ElementValue<System.DateTime?>();
            return Date;
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider GetOrCreateProvider()
        {
            if (Provider == null)
                Provider = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider();
            return Provider;
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences GetOrCreateReferences()
        {
            if (References == null)
                References = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences();
            return References;
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions GetOrCreateSuppressions()
        {
            if (Suppressions == null)
                Suppressions = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions();
            return Suppressions;
        }

        public AttributeValue<uint?> GetOrCreateId()
        {
            if (Id == null)
                Id = new AttributeValue<uint?>();
            return Id;
        }

        public AttributeValue<string> GetOrCreateBasedOn()
        {
            if (BasedOn == null)
                BasedOn = new AttributeValue<string>();
            return BasedOn;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion read, XmlElement editNode)
        {
            if (read == null)
                return;
            _changes = read.Changes != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges(read.Changes, this, editNode.Element["Changes"]) : null;
            _date = read.Date != null ? new ElementValue<System.DateTime?>(read.Date, this) : null;
            _provider = read.Provider != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider(read.Provider, this, editNode.Element["Provider"]) : null;
            _references = read.References != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences(read.References, this, editNode.Element["References"]) : null;
            _suppressions = read.Suppressions != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions(read.Suppressions, this, editNode.Element["Suppressions"]) : null;
            _id = read.Id != null ? new AttributeValue<uint?>(read.Id, this) : null;
            _basedOn = read.BasedOn != null ? new AttributeValue<string>(read.BasedOn, this) : null;
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion();
            item.Changes = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges.FromRead(read.Changes);
            item.Date = ElementValue<System.DateTime?>.FromRead(read.Date);
            item.Provider = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider.FromRead(read.Provider);
            item.References = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences.FromRead(read.References);
            item.Suppressions = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions.FromRead(read.Suppressions);
            item.Id = AttributeValue<uint?>.FromRead(read.Id);
            item.BasedOn = AttributeValue<string>.FromRead(read.BasedOn);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion(this);
        }
    }

    ///<summary>
    /// Contains information about the changes implemented in this minor version of this protocol.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges : ComplexEditableListNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode, new Dictionary<string, Type>() { { "Fix", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix) }, { "Change", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange) }, { "NewFeature", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature) }, { "", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem) } })
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Changes node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges() : base("Changes", new Dictionary<string, Type>() { { "Fix", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix) }, { "Change", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange) }, { "NewFeature", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature) }, { "", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem) } })
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem.ItemFromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges(this);
        }
    }

    public interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem : IEditableNode
    {
    }

    public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem : EditableElementNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem
    {
        protected VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem(string tagName) : base(tagName)
        {
        }

        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem read, XmlElement editNode)
        {
        }

        public static IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem ItemFromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem read)
        {
            if (read == null)
                return null;
            switch (read.TagName)
            {
                case "Fix":
                    return VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix.FromRead(read as Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix);
                case "Change":
                    return VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange.FromRead(read as Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange);
                case "NewFeature":
                    return VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature.FromRead(read as Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature);
                default:
                    return new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem(read.TagName);
            }
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem(this);
        }
    }

    ///<summary>
    /// Describes a fix.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix : EditableElementValueNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix, string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Fix node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix(bool useCDATA = false) : base("Fix", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix(string value, bool useCDATA = false) : base("Fix", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix(this);
        }
    }

    ///<summary>
    /// Describes a change.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange : EditableElementValueNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange, string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Change node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange(bool useCDATA = false) : base("Change", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange(string value, bool useCDATA = false) : base("Change", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange(this);
        }
    }

    ///<summary>
    /// Describes a new feature.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature : EditableElementValueNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature, string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a NewFeature node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature(bool useCDATA = false) : base("NewFeature", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature(string value, bool useCDATA = false) : base("NewFeature", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature(this);
        }
    }

    public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider : EditableElementNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Provider node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider() : base("Provider")
        {
            OnCreated();
        }

        private ElementValue<string> _company;
        private ElementValue<string> _author;
        ///<summary>
        /// Specifies the company providing this version of this protocol.
        ///</summary>
public ElementValue<string> Company
        {
            get
            {
                return _company;
            }

            set
            {
                if (_company != value)
                {
                    _company = value;
                    ElementHandler.Assign(value, this, "Company");
                }
            }
        }

        ///<summary>
        /// Specifies the author of this version of this protocol.
        ///</summary>
public ElementValue<string> Author
        {
            get
            {
                return _author;
            }

            set
            {
                if (_author != value)
                {
                    _author = value;
                    ElementHandler.Assign(value, this, "Author");
                }
            }
        }

        public ElementValue<string> GetOrCreateCompany()
        {
            if (Company == null)
                Company = new ElementValue<string>();
            return Company;
        }

        public ElementValue<string> GetOrCreateAuthor()
        {
            if (Author == null)
                Author = new ElementValue<string>();
            return Author;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider read, XmlElement editNode)
        {
            if (read == null)
                return;
            _company = read.Company != null ? new ElementValue<string>(read.Company, this) : null;
            _author = read.Author != null ? new ElementValue<string>(read.Author, this) : null;
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider();
            item.Company = ElementValue<string>.FromRead(read.Company);
            item.Author = ElementValue<string>.FromRead(read.Author);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider(this);
        }
    }

    ///<summary>
    /// Provides references to e.g. registration systems.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences : ComplexEditableListNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode, new Dictionary<string, Type>() { { "TaskId", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId) }, { "Reference", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference) }, { "", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem) } })
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a References node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences() : base("References", new Dictionary<string, Type>() { { "TaskId", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId) }, { "Reference", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference) }, { "", typeof(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem) } })
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem.ItemFromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences(this);
        }
    }

    public interface IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem : IEditableNode
    {
    }

    public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem : EditableElementNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem
    {
        protected VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem(string tagName) : base(tagName)
        {
        }

        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem read, XmlElement editNode)
        {
        }

        public static IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem ItemFromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem read)
        {
            if (read == null)
                return null;
            switch (read.TagName)
            {
                case "TaskId":
                    return VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId.FromRead(read as Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId);
                case "Reference":
                    return VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference.FromRead(read as Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference);
                default:
                    return new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem(read.TagName);
            }
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem(this);
        }
    }

    ///<summary>
    /// Provides a reference to a corresponding task.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId : EditableElementValueNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId, uint?>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TaskId node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId() : base("TaskId")
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId(uint? value) : base("TaskId", value)
        {
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId(this);
        }
    }

    ///<summary>
    /// Provides a reference to e.g. a registration system.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference : EditableElementValueNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference, string>, IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Reference node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference(bool useCDATA = false) : base("Reference", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference(string value, bool useCDATA = false) : base("Reference", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _type;
        ///<summary>
        /// Specifies the type of reference.
        ///</summary>
public AttributeValue<string> Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        public AttributeValue<string> GetOrCreateType()
        {
            if (Type == null)
                Type = new AttributeValue<string>();
            return Type;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference read, XmlElement editNode)
        {
            if (read == null)
                return;
            _type = read.Type != null ? new AttributeValue<string>(read.Type, this) : null;
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference();
            item.Value = read.Value;
            item.Type = AttributeValue<string>.FromRead(read.Type);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference(this);
        }
    }

    ///<summary>
    /// List of all the suppressions for this version.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions : EditableListNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression, VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Suppressions node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions() : base("Suppressions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions(this);
        }
    }

    ///<summary>
    /// A single suppression.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression : EditableElementNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Suppression node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression() : base("Suppression")
        {
            OnCreated();
        }

        private ElementValue<string> _reason;
        private ElementValue<string> _location;
        private ElementValue<string> _resultId;
        private VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType _type;
        private AttributeValue<uint?> _taskId;
        ///<summary>
        /// Reason for the suppression.
        ///</summary>
public ElementValue<string> Reason
        {
            get
            {
                return _reason;
            }

            set
            {
                if (_reason != value)
                {
                    _reason = value;
                    ElementHandler.Assign(value, this, "Reason");
                }
            }
        }

        ///<summary>
        /// Location of the suppression.
        ///</summary>
public ElementValue<string> Location
        {
            get
            {
                return _location;
            }

            set
            {
                if (_location != value)
                {
                    _location = value;
                    ElementHandler.Assign(value, this, "Location");
                }
            }
        }

        ///<summary>
        /// ID of the result that is being suppressed.
        ///</summary>
public ElementValue<string> ResultId
        {
            get
            {
                return _resultId;
            }

            set
            {
                if (_resultId != value)
                {
                    _resultId = value;
                    ElementHandler.Assign(value, this, "ResultId");
                }
            }
        }

        ///<summary>
        /// Type of the suppression.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        ///<summary>
        /// Task ID.
        ///</summary>
public AttributeValue<uint?> TaskId
        {
            get
            {
                return _taskId;
            }

            set
            {
                if (_taskId != value)
                {
                    _taskId = value;
                    AttributeHandler.Assign(value, this, "taskId");
                }
            }
        }

        public ElementValue<string> GetOrCreateReason()
        {
            if (Reason == null)
                Reason = new ElementValue<string>();
            return Reason;
        }

        public ElementValue<string> GetOrCreateLocation()
        {
            if (Location == null)
                Location = new ElementValue<string>();
            return Location;
        }

        public ElementValue<string> GetOrCreateResultId()
        {
            if (ResultId == null)
                ResultId = new ElementValue<string>();
            return ResultId;
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType GetOrCreateType()
        {
            if (Type == null)
                Type = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType();
            return Type;
        }

        public AttributeValue<uint?> GetOrCreateTaskId()
        {
            if (TaskId == null)
                TaskId = new AttributeValue<uint?>();
            return TaskId;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression read, XmlElement editNode)
        {
            if (read == null)
                return;
            _reason = read.Reason != null ? new ElementValue<string>(read.Reason, this) : null;
            _location = read.Location != null ? new ElementValue<string>(read.Location, this) : null;
            _resultId = read.ResultId != null ? new ElementValue<string>(read.ResultId, this) : null;
            _type = read.Type != null ? new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType(read.Type, this) : null;
            _taskId = read.TaskId != null ? new AttributeValue<uint?>(read.TaskId, this) : null;
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression();
            item.Reason = ElementValue<string>.FromRead(read.Reason);
            item.Location = ElementValue<string>.FromRead(read.Location);
            item.ResultId = ElementValue<string>.FromRead(read.ResultId);
            item.Type = VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType.FromRead(read.Type);
            item.TaskId = AttributeValue<uint?>.FromRead(read.TaskId);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression(this);
        }
    }

    public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType : AttributeValue<Enums.EnumSuppressionType?>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType(Read.IValueTag<Enums.EnumSuppressionType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType() : base()
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType(Enums.EnumSuppressionType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumSuppressionTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumSuppressionType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumSuppressionTypeConverter.Convert(rawValue?.Trim());
        }

        public new static VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType FromRead(Read.IValueTag<Enums.EnumSuppressionType?> read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppressionType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies the system version support.
    ///</summary>
public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions : EditableListNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions, Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion, VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SupportedVersions node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions() : base("SupportedVersions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions read, XmlElement editNode)
        {
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions();
            foreach (var x in read)
            {
                item.Add(VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions(this);
        }
    }

    public partial class VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion : EditableElementValueNode<Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion, string>
    {
        internal VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Version node. None of it's properties will be set.
        ///</summary>
public VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion(bool useCDATA = false) : base("Version", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion(string value, bool useCDATA = false) : base("Version", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _min;
        private AttributeValue<string> _max;
        ///<summary>
        /// The minimum system version supported by this protocol range.
        ///</summary>
public AttributeValue<string> Min
        {
            get
            {
                return _min;
            }

            set
            {
                if (_min != value)
                {
                    _min = value;
                    AttributeHandler.Assign(value, this, "min");
                }
            }
        }

        ///<summary>
        /// The maximum system version supported by this protocol range.
        ///</summary>
public AttributeValue<string> Max
        {
            get
            {
                return _max;
            }

            set
            {
                if (_max != value)
                {
                    _max = value;
                    AttributeHandler.Assign(value, this, "max");
                }
            }
        }

        public AttributeValue<string> GetOrCreateMin()
        {
            if (Min == null)
                Min = new AttributeValue<string>();
            return Min;
        }

        public AttributeValue<string> GetOrCreateMax()
        {
            if (Max == null)
                Max = new AttributeValue<string>();
            return Max;
        }

        protected override void Initialize(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion read, XmlElement editNode)
        {
            if (read == null)
                return;
            _min = read.Min != null ? new AttributeValue<string>(read.Min, this) : null;
            _max = read.Max != null ? new AttributeValue<string>(read.Max, this) : null;
        }

        public static VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion FromRead(Read.IVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion read)
        {
            if (read == null)
                return null;
            var item = new VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion();
            item.Value = read.Value;
            item.Min = AttributeValue<string>.FromRead(read.Min);
            item.Max = AttributeValue<string>.FromRead(read.Max);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion(this);
        }
    }

    ///<summary>
    /// Defines a table column. Each table column is defined by one or two parameters: one for read, and/or one for write.
    ///</summary>
public partial class TypeColumnOption : EditableElementNode<Read.ITypeColumnOption>
    {
        internal TypeColumnOption(Read.ITypeColumnOption read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeColumnOption node. None of it's properties will be set.
        ///</summary>
public TypeColumnOption(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private TypeColumnOptionCpeAlignment _cpeAlignment;
        private AttributeValue<uint?> _idx;
        private AttributeValue<string> _options;
        private AttributeValue<uint?> _pid;
        private AttributeValue<uint?> _pollingRate;
        private TypeColumnOptionType _type;
        private AttributeValue<string> _valueAttribute;
        ///<summary>
        /// Sets the alignment of KPI values in a CPE interface.
        /// Default value: right.
        /// Feature introduced in DataMiner 8.5.4.3 (RN 9430).
        ///</summary>
public TypeColumnOptionCpeAlignment CpeAlignment
        {
            get
            {
                return _cpeAlignment;
            }

            set
            {
                if (_cpeAlignment != value)
                {
                    _cpeAlignment = value;
                    AttributeHandler.Assign(value, this, "cpeAlignment");
                }
            }
        }

        ///<summary>
        /// Defines the (0-based) position of the column in the table.
        /// Note: The ColumnOption elements have to be defined in order of their idx attribute.
        ///</summary>
public AttributeValue<uint?> Idx
        {
            get
            {
                return _idx;
            }

            set
            {
                if (_idx != value)
                {
                    _idx = value;
                    AttributeHandler.Assign(value, this, "idx");
                }
            }
        }

        ///<summary>
        /// Defines different options.
        /// For more information about this attribute, refer to the DataMiner Protocol Markup Language documentation.
        /// Note: In this attribute, you can specify multiple values separated by a character of choice (a semicolon is recommended).
        /// This character has to be the first character in the value of the options attribute.
        /// If, for example, you want to separate the different options by a semi-colon, the first character of the options value has to be a semi-colon.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter ID of the column data.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        ///<summary>
        /// Specifies the polling rate of this column (in ms).
        /// Feature introduced in DataMiner 9.5.6 (RN 16411).
        /// Refer to the DataMiner Protocol Markup Language documentation for more information.
        ///</summary>
public AttributeValue<uint?> PollingRate
        {
            get
            {
                return _pollingRate;
            }

            set
            {
                if (_pollingRate != value)
                {
                    _pollingRate = value;
                    AttributeHandler.Assign(value, this, "pollingRate");
                }
            }
        }

        ///<summary>
        /// Specifies column type options. For more information on the values allowed in this attribute, refer to the DataMiner Protocol Markup Language documentation.
        ///</summary>
public TypeColumnOptionType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    AttributeHandler.Assign(value, this, "type");
                }
            }
        }

        ///<summary>
        /// The interpretation of this attribute depends on the value of the "type" attribute:
        /// -	If type is "concatenation", then value is the comma-separated list of the indexes of the columns to be concatenated.
        /// -	If type is "autoincrement", then value is the offset for the automatic increment of the indexes.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        public TypeColumnOptionCpeAlignment GetOrCreateCpeAlignment()
        {
            if (CpeAlignment == null)
                CpeAlignment = new TypeColumnOptionCpeAlignment();
            return CpeAlignment;
        }

        public AttributeValue<uint?> GetOrCreateIdx()
        {
            if (Idx == null)
                Idx = new AttributeValue<uint?>();
            return Idx;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        public AttributeValue<uint?> GetOrCreatePollingRate()
        {
            if (PollingRate == null)
                PollingRate = new AttributeValue<uint?>();
            return PollingRate;
        }

        public TypeColumnOptionType GetOrCreateType()
        {
            if (Type == null)
                Type = new TypeColumnOptionType();
            return Type;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        protected override void Initialize(Read.ITypeColumnOption read, XmlElement editNode)
        {
            if (read == null)
                return;
            _cpeAlignment = read.CpeAlignment != null ? new TypeColumnOptionCpeAlignment(read.CpeAlignment, this) : null;
            _idx = read.Idx != null ? new AttributeValue<uint?>(read.Idx, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
            _pollingRate = read.PollingRate != null ? new AttributeValue<uint?>(read.PollingRate, this) : null;
            _type = read.Type != null ? new TypeColumnOptionType(read.Type, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
        }

        public static TypeColumnOption FromRead(Read.ITypeColumnOption read)
        {
            if (read == null)
                return null;
            var item = new TypeColumnOption(read.TagName);
            item.CpeAlignment = TypeColumnOptionCpeAlignment.FromRead(read.CpeAlignment);
            item.Idx = AttributeValue<uint?>.FromRead(read.Idx);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            item.PollingRate = AttributeValue<uint?>.FromRead(read.PollingRate);
            item.Type = TypeColumnOptionType.FromRead(read.Type);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeColumnOption(this);
        }
    }

    public partial class TypeColumnOptionCpeAlignment : AttributeValue<Enums.EnumCpeAlignment?>
    {
        internal TypeColumnOptionCpeAlignment(Read.IValueTag<Enums.EnumCpeAlignment?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a cpeAlignment node. None of it's properties will be set.
        ///</summary>
public TypeColumnOptionCpeAlignment() : base()
        {
            OnCreated();
        }

        public TypeColumnOptionCpeAlignment(Enums.EnumCpeAlignment? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumCpeAlignmentConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumCpeAlignment? ConvertRawValue(string rawValue)
        {
            return Enums.EnumCpeAlignmentConverter.Convert(rawValue?.Trim());
        }

        public new static TypeColumnOptionCpeAlignment FromRead(Read.IValueTag<Enums.EnumCpeAlignment?> read)
        {
            if (read == null)
                return null;
            var item = new TypeColumnOptionCpeAlignment();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class TypeColumnOptionType : AttributeValue<Enums.EnumColumnOptionType?>
    {
        internal TypeColumnOptionType(Read.IValueTag<Enums.EnumColumnOptionType?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a type node. None of it's properties will be set.
        ///</summary>
public TypeColumnOptionType() : base()
        {
            OnCreated();
        }

        public TypeColumnOptionType(Enums.EnumColumnOptionType? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumColumnOptionTypeConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumColumnOptionType? ConvertRawValue(string rawValue)
        {
            return Enums.EnumColumnOptionTypeConverter.Convert(rawValue?.Trim());
        }

        public new static TypeColumnOptionType FromRead(Read.IValueTag<Enums.EnumColumnOptionType?> read)
        {
            if (read == null)
                return null;
            var item = new TypeColumnOptionType();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Represents export rules.
    ///</summary>
public partial class ExportRules : EditableListNode<Read.IExportRules, Read.IExportRulesExportRule, ExportRulesExportRule>
    {
        internal ExportRules(Read.IExportRules read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ExportRules node. None of it's properties will be set.
        ///</summary>
public ExportRules(string tagName) : base(tagName)
        {
            OnCreated();
        }

        protected override void Initialize(Read.IExportRules read, XmlElement editNode)
        {
        }

        public static ExportRules FromRead(Read.IExportRules read)
        {
            if (read == null)
                return null;
            var item = new ExportRules(read.TagName);
            foreach (var x in read)
            {
                item.Add(ExportRulesExportRule.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitExportRules(this);
        }
    }

    ///<summary>
    /// Defines a rule that are used for changing the displayed items in a Dynamic Virtual Element (DVE), for example changing the location of a parameter.
    ///</summary>
public partial class ExportRulesExportRule : EditableElementNode<Read.IExportRulesExportRule>
    {
        internal ExportRulesExportRule(Read.IExportRulesExportRule read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ExportRule node. None of it's properties will be set.
        ///</summary>
public ExportRulesExportRule() : base("ExportRule")
        {
            OnCreated();
        }

        private AttributeValue<string> _attribute;
        private AttributeValue<string> _name;
        private AttributeValue<string> _regex;
        private AttributeValue<string> _table;
        private AttributeValue<string> _tag;
        private AttributeValue<string> _valueAttribute;
        private AttributeValue<string> _whereAttribute;
        private AttributeValue<string> _whereTag;
        private AttributeValue<string> _whereValue;
        ///<summary>
        /// Specifies the attribute of the XML element specified in the "tag" attribute on which to apply this rule.
        ///</summary>
public AttributeValue<string> Attribute
        {
            get
            {
                return _attribute;
            }

            set
            {
                if (_attribute != value)
                {
                    _attribute = value;
                    AttributeHandler.Assign(value, this, "attribute");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the export rule.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Specifies a regular expression to match particular values.
        ///</summary>
public AttributeValue<string> Regex
        {
            get
            {
                return _regex;
            }

            set
            {
                if (_regex != value)
                {
                    _regex = value;
                    AttributeHandler.Assign(value, this, "regex");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of table parameter that will generate the DVEs.
        ///</summary>
public AttributeValue<string> Table
        {
            get
            {
                return _table;
            }

            set
            {
                if (_table != value)
                {
                    _table = value;
                    AttributeHandler.Assign(value, this, "table");
                }
            }
        }

        ///<summary>
        /// Specifies the XML element on which to apply this rule.
        ///</summary>
public AttributeValue<string> Tag
        {
            get
            {
                return _tag;
            }

            set
            {
                if (_tag != value)
                {
                    _tag = value;
                    AttributeHandler.Assign(value, this, "tag");
                }
            }
        }

        ///<summary>
        /// Specifies the value that needs to be set.
        ///</summary>
public AttributeValue<string> ValueAttribute
        {
            get
            {
                return _valueAttribute;
            }

            set
            {
                if (_valueAttribute != value)
                {
                    _valueAttribute = value;
                    AttributeHandler.Assign(value, this, "value");
                }
            }
        }

        ///<summary>
        /// Specifies, together with the whereTag and whereValue attributes, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
public AttributeValue<string> WhereAttribute
        {
            get
            {
                return _whereAttribute;
            }

            set
            {
                if (_whereAttribute != value)
                {
                    _whereAttribute = value;
                    AttributeHandler.Assign(value, this, "whereAttribute");
                }
            }
        }

        ///<summary>
        /// Specifies, together with the whereValue attribute, and optionally the whereAttribute attribute, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
public AttributeValue<string> WhereTag
        {
            get
            {
                return _whereTag;
            }

            set
            {
                if (_whereTag != value)
                {
                    _whereTag = value;
                    AttributeHandler.Assign(value, this, "whereTag");
                }
            }
        }

        ///<summary>
        /// Specifies, together with the whereTag attribute, and optionally the whereAttribute attribute, a condition so the export rule will only be applied if the condition is met.&lt;/br&gt;
        /// If the whereAttribute is defined, the whereValue will be the indication to verify the attribute's value of the XML element defined by the whereTag.&lt;/br&gt;
        /// If the whereAttribute is not defined, the whereValue will be the indication to verify the value of the XML element defined by the whereTag.&lt;/br&gt;
        /// Example with a condition on the value of an attribute: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param" whereAttribute="trending" whereValue="true" /&gt;&lt;/br&gt;
        /// Example with a condition on the value of an XML element: &lt;ExportRule table="*" ... whereTag="Protocol/Params/Param/Name" whereValue="My param" /&gt;
        ///</summary>
public AttributeValue<string> WhereValue
        {
            get
            {
                return _whereValue;
            }

            set
            {
                if (_whereValue != value)
                {
                    _whereValue = value;
                    AttributeHandler.Assign(value, this, "whereValue");
                }
            }
        }

        public AttributeValue<string> GetOrCreateAttribute()
        {
            if (Attribute == null)
                Attribute = new AttributeValue<string>();
            return Attribute;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<string> GetOrCreateRegex()
        {
            if (Regex == null)
                Regex = new AttributeValue<string>();
            return Regex;
        }

        public AttributeValue<string> GetOrCreateTable()
        {
            if (Table == null)
                Table = new AttributeValue<string>();
            return Table;
        }

        public AttributeValue<string> GetOrCreateTag()
        {
            if (Tag == null)
                Tag = new AttributeValue<string>();
            return Tag;
        }

        public AttributeValue<string> GetOrCreateValueAttribute()
        {
            if (ValueAttribute == null)
                ValueAttribute = new AttributeValue<string>();
            return ValueAttribute;
        }

        public AttributeValue<string> GetOrCreateWhereAttribute()
        {
            if (WhereAttribute == null)
                WhereAttribute = new AttributeValue<string>();
            return WhereAttribute;
        }

        public AttributeValue<string> GetOrCreateWhereTag()
        {
            if (WhereTag == null)
                WhereTag = new AttributeValue<string>();
            return WhereTag;
        }

        public AttributeValue<string> GetOrCreateWhereValue()
        {
            if (WhereValue == null)
                WhereValue = new AttributeValue<string>();
            return WhereValue;
        }

        protected override void Initialize(Read.IExportRulesExportRule read, XmlElement editNode)
        {
            if (read == null)
                return;
            _attribute = read.Attribute != null ? new AttributeValue<string>(read.Attribute, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _regex = read.Regex != null ? new AttributeValue<string>(read.Regex, this) : null;
            _table = read.Table != null ? new AttributeValue<string>(read.Table, this) : null;
            _tag = read.Tag != null ? new AttributeValue<string>(read.Tag, this) : null;
            _valueAttribute = read.ValueAttribute != null ? new AttributeValue<string>(read.ValueAttribute, this) : null;
            _whereAttribute = read.WhereAttribute != null ? new AttributeValue<string>(read.WhereAttribute, this) : null;
            _whereTag = read.WhereTag != null ? new AttributeValue<string>(read.WhereTag, this) : null;
            _whereValue = read.WhereValue != null ? new AttributeValue<string>(read.WhereValue, this) : null;
        }

        public static ExportRulesExportRule FromRead(Read.IExportRulesExportRule read)
        {
            if (read == null)
                return null;
            var item = new ExportRulesExportRule();
            item.Attribute = AttributeValue<string>.FromRead(read.Attribute);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Regex = AttributeValue<string>.FromRead(read.Regex);
            item.Table = AttributeValue<string>.FromRead(read.Table);
            item.Tag = AttributeValue<string>.FromRead(read.Tag);
            item.ValueAttribute = AttributeValue<string>.FromRead(read.ValueAttribute);
            item.WhereAttribute = AttributeValue<string>.FromRead(read.WhereAttribute);
            item.WhereTag = AttributeValue<string>.FromRead(read.WhereTag);
            item.WhereValue = AttributeValue<string>.FromRead(read.WhereValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitExportRulesExportRule(this);
        }
    }

    ///<summary>
    /// Specifies the request data to be sent.
    /// Alternatively, you can put this data in parameters, which you should then specify in the Parameters element.
    ///</summary>
public partial class HttpRequestData : EditableElementValueNode<Read.IHttpRequestData, string>
    {
        internal HttpRequestData(Read.IHttpRequestData read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a HttpRequestData node. None of it's properties will be set.
        ///</summary>
public HttpRequestData(string tagName, bool useCDATA = false) : base(tagName, useCDATA: useCDATA)
        {
            OnCreated();
        }

        public HttpRequestData(string tagName, string value, bool useCDATA = false) : base(tagName, value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the data to be sent.
        /// Note: either use this attribute (and provide the data to be sent in the referred parameter) or specify the data to be sent in Data (e.g. &lt;Data&gt;data&lt;/Data&gt;.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IHttpRequestData read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static HttpRequestData FromRead(Read.IHttpRequestData read)
        {
            if (read == null)
                return null;
            var item = new HttpRequestData(read.TagName);
            item.Value = read.Value;
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestData(this);
        }
    }

    ///<summary>
    /// Specifies additional headers that need to be sent as part of the HTTP request.
    ///</summary>
public partial class HttpRequestHeaders : EditableListNode<Read.IHttpRequestHeaders, Read.IHttpRequestHeadersHeader, HttpRequestHeadersHeader>
    {
        internal HttpRequestHeaders(Read.IHttpRequestHeaders read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a HttpRequestHeaders node. None of it's properties will be set.
        ///</summary>
public HttpRequestHeaders(string tagName) : base(tagName)
        {
            OnCreated();
        }

        protected override void Initialize(Read.IHttpRequestHeaders read, XmlElement editNode)
        {
        }

        public static HttpRequestHeaders FromRead(Read.IHttpRequestHeaders read)
        {
            if (read == null)
                return null;
            var item = new HttpRequestHeaders(read.TagName);
            foreach (var x in read)
            {
                item.Add(HttpRequestHeadersHeader.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestHeaders(this);
        }
    }

    ///<summary>
    /// Specifies a parameter of which the contents will be put in one of the headers of the HTTP request.
    /// Via HTTP, this has to be done by means of key/value pairs.
    ///</summary>
public partial class HttpRequestHeadersHeader : EditableElementValueNode<Read.IHttpRequestHeadersHeader, string>
    {
        internal HttpRequestHeadersHeader(Read.IHttpRequestHeadersHeader read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Header node. None of it's properties will be set.
        ///</summary>
public HttpRequestHeadersHeader(bool useCDATA = false) : base("Header", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public HttpRequestHeadersHeader(string value, bool useCDATA = false) : base("Header", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _key;
        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the key of the key/value pair.
        ///</summary>
public AttributeValue<string> Key
        {
            get
            {
                return _key;
            }

            set
            {
                if (_key != value)
                {
                    _key = value;
                    AttributeHandler.Assign(value, this, "key");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter that contains the value to be put in the header.&lt;BR /&gt;
        /// If you do not specify the pid attribute, you have to provide a fixed value in the Header element.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<string> GetOrCreateKey()
        {
            if (Key == null)
                Key = new AttributeValue<string>();
            return Key;
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IHttpRequestHeadersHeader read, XmlElement editNode)
        {
            if (read == null)
                return;
            _key = read.Key != null ? new AttributeValue<string>(read.Key, this) : null;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static HttpRequestHeadersHeader FromRead(Read.IHttpRequestHeadersHeader read)
        {
            if (read == null)
                return null;
            var item = new HttpRequestHeadersHeader();
            item.Value = read.Value;
            item.Key = AttributeValue<string>.FromRead(read.Key);
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestHeadersHeader(this);
        }
    }

    ///<summary>
    /// If you do not want to specify a fixed block of data in Data, but rather a number of parameters containing the data to be sent, then use this element to define the list of parameters of which you want the contents to be sent in the HTTP request.
    ///</summary>
public partial class HttpRequestParameters : EditableListNode<Read.IHttpRequestParameters, Read.IHttpRequestParametersParameter, HttpRequestParametersParameter>
    {
        internal HttpRequestParameters(Read.IHttpRequestParameters read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a HttpRequestParameters node. None of it's properties will be set.
        ///</summary>
public HttpRequestParameters(string tagName) : base(tagName)
        {
            OnCreated();
        }

        protected override void Initialize(Read.IHttpRequestParameters read, XmlElement editNode)
        {
        }

        public static HttpRequestParameters FromRead(Read.IHttpRequestParameters read)
        {
            if (read == null)
                return null;
            var item = new HttpRequestParameters(read.TagName);
            foreach (var x in read)
            {
                item.Add(HttpRequestParametersParameter.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestParameters(this);
        }
    }

    ///<summary>
    /// Specifies a parameter of which you want its content to be included in the HTTP request.
    /// Via HTTP, this has to be done by means of key/value pairs.
    ///</summary>
public partial class HttpRequestParametersParameter : EditableElementValueNode<Read.IHttpRequestParametersParameter, string>
    {
        internal HttpRequestParametersParameter(Read.IHttpRequestParametersParameter read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Parameter node. None of it's properties will be set.
        ///</summary>
public HttpRequestParametersParameter(bool useCDATA = false) : base("Parameter", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public HttpRequestParametersParameter(string value, bool useCDATA = false) : base("Parameter", value, useCDATA: useCDATA)
        {
        }

        private AttributeValue<string> _key;
        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the key of the key/value pair.
        ///</summary>
public AttributeValue<string> Key
        {
            get
            {
                return _key;
            }

            set
            {
                if (_key != value)
                {
                    _key = value;
                    AttributeHandler.Assign(value, this, "key");
                }
            }
        }

        ///<summary>
        /// Specifies the ID of the parameter that contains the value to be sent.&lt;BR /&gt;
        /// If you do not specify the pid attribute, you have to provide a value in the Parameter element.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<string> GetOrCreateKey()
        {
            if (Key == null)
                Key = new AttributeValue<string>();
            return Key;
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IHttpRequestParametersParameter read, XmlElement editNode)
        {
            if (read == null)
                return;
            _key = read.Key != null ? new AttributeValue<string>(read.Key, this) : null;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static HttpRequestParametersParameter FromRead(Read.IHttpRequestParametersParameter read)
        {
            if (read == null)
                return null;
            var item = new HttpRequestParametersParameter();
            item.Value = read.Value;
            item.Key = AttributeValue<string>.FromRead(read.Key);
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitHttpRequestParametersParameter(this);
        }
    }

    ///<summary>
    /// Represents an icon.
    ///</summary>
public partial class Icon : EditableElementValueNode<Read.IIcon, string>
    {
        internal Icon(Read.IIcon read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Icon node. None of it's properties will be set.
        ///</summary>
public Icon(string tagName, bool useCDATA = false) : base(tagName, useCDATA: useCDATA)
        {
            OnCreated();
        }

        public Icon(string tagName, string value, bool useCDATA = false) : base(tagName, value, useCDATA: useCDATA)
        {
        }

        private IconRef _ref;
        ///<summary>
        /// Specifies the key of the icon as defined in the Icons.xml file.
        /// Using this attribute in a table or table column parameter will display an icon in the tree control.
        ///</summary>
public IconRef Ref
        {
            get
            {
                return _ref;
            }

            set
            {
                if (_ref != value)
                {
                    _ref = value;
                    AttributeHandler.Assign(value, this, "ref");
                }
            }
        }

        public IconRef GetOrCreateRef()
        {
            if (Ref == null)
                Ref = new IconRef();
            return Ref;
        }

        protected override void Initialize(Read.IIcon read, XmlElement editNode)
        {
            if (read == null)
                return;
            _ref = read.Ref != null ? new IconRef(read.Ref, this) : null;
        }

        public static Icon FromRead(Read.IIcon read)
        {
            if (read == null)
                return null;
            var item = new Icon(read.TagName);
            item.Value = read.Value;
            item.Ref = IconRef.FromRead(read.Ref);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitIcon(this);
        }
    }

    public partial class IconRef : AttributeValue<Enums.EnumIcons?>
    {
        internal IconRef(Read.IValueTag<Enums.EnumIcons?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a ref node. None of it's properties will be set.
        ///</summary>
public IconRef() : base()
        {
            OnCreated();
        }

        public IconRef(Enums.EnumIcons? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumIconsConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumIcons? ConvertRawValue(string rawValue)
        {
            return Enums.EnumIconsConverter.Convert(rawValue?.Trim());
        }

        public new static IconRef FromRead(Read.IValueTag<Enums.EnumIcons?> read)
        {
            if (read == null)
                return null;
            var item = new IconRef();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines a ping interval.
    ///</summary>
public partial class PingInterval : EditableElementNode<Read.IPingInterval>
    {
        internal PingInterval(Read.IPingInterval read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PingInterval node. None of it's properties will be set.
        ///</summary>
public PingInterval(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default ping interval in milliseconds. The specified value must be in the range [1000,300000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the ping interval can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPingInterval read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PingInterval FromRead(Read.IPingInterval read)
        {
            if (read == null)
                return null;
            var item = new PingInterval(read.TagName);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPingInterval(this);
        }
    }

    ///<summary>
    /// Defines a slow poll configuration.
    ///</summary>
public partial class SlowPoll : EditableElementNode<Read.ISlowPoll>
    {
        internal SlowPoll(Read.ISlowPoll read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SlowPoll node. None of it's properties will be set.
        ///</summary>
public SlowPoll(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default slow poll settings.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the slow poll settings can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.ISlowPoll read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static SlowPoll FromRead(Read.ISlowPoll read)
        {
            if (read == null)
                return null;
            var item = new SlowPoll(read.TagName);
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSlowPoll(this);
        }
    }

    ///<summary>
    /// Defines a slow poll base.
    ///</summary>
public partial class SlowPollBase : EditableElementNode<Read.ISlowPollBase>
    {
        internal SlowPollBase(Read.ISlowPollBase read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SlowPollBase node. None of it's properties will be set.
        ///</summary>
public SlowPollBase(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private SlowPollBaseDefaultValue _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default slow poll base.
        ///</summary>
public SlowPollBaseDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the slow poll settings can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public SlowPollBaseDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new SlowPollBaseDefaultValue();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.ISlowPollBase read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new SlowPollBaseDefaultValue(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static SlowPollBase FromRead(Read.ISlowPollBase read)
        {
            if (read == null)
                return null;
            var item = new SlowPollBase(read.TagName);
            item.DefaultValue = SlowPollBaseDefaultValue.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitSlowPollBase(this);
        }
    }

    public partial class SlowPollBaseDefaultValue : ElementValue<Enums.EnumTypePortSlowPollBase?>
    {
        internal SlowPollBaseDefaultValue(Read.IValueTag<Enums.EnumTypePortSlowPollBase?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public SlowPollBaseDefaultValue() : base()
        {
            OnCreated();
        }

        public SlowPollBaseDefaultValue(Enums.EnumTypePortSlowPollBase? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumTypePortSlowPollBaseConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumTypePortSlowPollBase? ConvertRawValue(string rawValue)
        {
            return Enums.EnumTypePortSlowPollBaseConverter.Convert(rawValue?.Trim());
        }

        public new static SlowPollBaseDefaultValue FromRead(Read.IValueTag<Enums.EnumTypePortSlowPollBase?> read)
        {
            if (read == null)
                return null;
            var item = new SlowPollBaseDefaultValue();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines user settings.
    ///</summary>
public partial class TypeUserSettings : EditableElementNode<Read.ITypeUserSettings>
    {
        internal TypeUserSettings(Read.ITypeUserSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeUserSettings node. None of it's properties will be set.
        ///</summary>
public TypeUserSettings(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private TypeUserSettingsValues _values;
        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private TypeUserSettingsRange _range;
        public TypeUserSettingsValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public TypeUserSettingsRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public TypeUserSettingsValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new TypeUserSettingsValues();
            return Values;
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public TypeUserSettingsRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new TypeUserSettingsRange();
            return Range;
        }

        protected override void Initialize(Read.ITypeUserSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _values = read.Values != null ? new TypeUserSettingsValues(read.Values, this, editNode.Element["Values"]) : null;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new TypeUserSettingsRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static TypeUserSettings FromRead(Read.ITypeUserSettings read)
        {
            if (read == null)
                return null;
            var item = new TypeUserSettings(read.TagName);
            item.Values = TypeUserSettingsValues.FromRead(read.Values);
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = TypeUserSettingsRange.FromRead(read.Range);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeUserSettings(this);
        }
    }

    public partial class TypeUserSettingsValues : EditableListNode<Read.ITypeUserSettingsValues, Read.ITypeUserSettingsValuesValue, TypeUserSettingsValuesValue>
    {
        internal TypeUserSettingsValues(Read.ITypeUserSettingsValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public TypeUserSettingsValues() : base("Values")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITypeUserSettingsValues read, XmlElement editNode)
        {
        }

        public static TypeUserSettingsValues FromRead(Read.ITypeUserSettingsValues read)
        {
            if (read == null)
                return null;
            var item = new TypeUserSettingsValues();
            foreach (var x in read)
            {
                item.Add(TypeUserSettingsValuesValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeUserSettingsValues(this);
        }
    }

    public partial class TypeUserSettingsValuesValue : EditableElementValueNode<Read.ITypeUserSettingsValuesValue, string>
    {
        internal TypeUserSettingsValuesValue(Read.ITypeUserSettingsValuesValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public TypeUserSettingsValuesValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public TypeUserSettingsValuesValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.ITypeUserSettingsValuesValue read, XmlElement editNode)
        {
        }

        public static TypeUserSettingsValuesValue FromRead(Read.ITypeUserSettingsValuesValue read)
        {
            if (read == null)
                return null;
            var item = new TypeUserSettingsValuesValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeUserSettingsValuesValue(this);
        }
    }

    public partial class TypeUserSettingsRange : EditableElementNode<Read.ITypeUserSettingsRange>
    {
        internal TypeUserSettingsRange(Read.ITypeUserSettingsRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public TypeUserSettingsRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.ITypeUserSettingsRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static TypeUserSettingsRange FromRead(Read.ITypeUserSettingsRange read)
        {
            if (read == null)
                return null;
            var item = new TypeUserSettingsRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeUserSettingsRange(this);
        }
    }

    ///<summary>
    /// Defines port settings.
    ///</summary>
public partial class PortSettings : EditableElementNode<Read.IPortSettings>
    {
        internal PortSettings(Read.IPortSettings read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortSettings node. None of it's properties will be set.
        ///</summary>
public PortSettings(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private PortSettingsBaudrate _baudrate;
        private PortSettingsBusAddress _busAddress;
        private PortSettingsDatabits _databits;
        private PortSettingsFlowcontrol _flowcontrol;
        private ElementValue<bool?> _flushPerDatagram;
        private PortSettingsGetCommunity _getCommunity;
        private PortSettingsIPport _iPport;
        private PortSettingsLocalIPport _localIPport;
        private PortSettingsParity _parity;
        private PingInterval _pingInterval;
        private PortSettingsPortTypeIP _portTypeIP;
        private PortSettingsPortTypeSerial _portTypeSerial;
        private PortSettingsPortTypeUDP _portTypeUDP;
        private PortSettingsRetries _retries;
        private PortSettingsSetCommunity _setCommunity;
        private PortSettingsSSH _sSH;
        private PortSettingsStopbits _stopbits;
        private PortSettingsTimeoutTimeElement _timeoutTimeElement;
        private PortSettingsTimeoutTime _timeoutTime;
        private PortSettingsType _type;
        private AttributeValue<string> _name;
        private AttributeValue<bool?> _visibleInUi;
        ///<summary>
        /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public PortSettingsBaudrate Baudrate
        {
            get
            {
                return _baudrate;
            }

            set
            {
                if (_baudrate != value)
                {
                    _baudrate = value;
                    CombinedTagHandler.Assign(value, this, "Baudrate");
                }
            }
        }

        ///<summary>
        /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public PortSettingsBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
public PortSettingsDatabits Databits
        {
            get
            {
                return _databits;
            }

            set
            {
                if (_databits != value)
                {
                    _databits = value;
                    CombinedTagHandler.Assign(value, this, "Databits");
                }
            }
        }

        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
public PortSettingsFlowcontrol Flowcontrol
        {
            get
            {
                return _flowcontrol;
            }

            set
            {
                if (_flowcontrol != value)
                {
                    _flowcontrol = value;
                    CombinedTagHandler.Assign(value, this, "Flowcontrol");
                }
            }
        }

        ///<summary>
        /// When set to true, any datagram received on the connection will be forwarded to SLProtocol immediately, which will then store it in the response parameter. Only applicable for a smart-serial UDP connection.
        ///</summary>
public ElementValue<bool?> FlushPerDatagram
        {
            get
            {
                return _flushPerDatagram;
            }

            set
            {
                if (_flushPerDatagram != value)
                {
                    _flushPerDatagram = value;
                    ElementHandler.Assign(value, this, "FlushPerDatagram");
                }
            }
        }

        ///<summary>
        /// Specifies the GetCommunity string of an SNMP protocol.
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
public PortSettingsGetCommunity GetCommunity
        {
            get
            {
                return _getCommunity;
            }

            set
            {
                if (_getCommunity != value)
                {
                    _getCommunity = value;
                    CombinedTagHandler.Assign(value, this, "GetCommunity");
                }
            }
        }

        ///<summary>
        /// Specifies the IP port configuration.
        ///</summary>
public PortSettingsIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        ///<summary>
        /// Specifies the local IP port configuration.
        ///</summary>
public PortSettingsLocalIPport LocalIPport
        {
            get
            {
                return _localIPport;
            }

            set
            {
                if (_localIPport != value)
                {
                    _localIPport = value;
                    CombinedTagHandler.Assign(value, this, "LocalIPport");
                }
            }
        }

        ///<summary>
        /// Allows to limit parity settings and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
public PortSettingsParity Parity
        {
            get
            {
                return _parity;
            }

            set
            {
                if (_parity != value)
                {
                    _parity = value;
                    CombinedTagHandler.Assign(value, this, "Parity");
                }
            }
        }

        ///<summary>
        /// Configures the ping interval.
        ///</summary>
public PingInterval PingInterval
        {
            get
            {
                return _pingInterval;
            }

            set
            {
                if (_pingInterval != value)
                {
                    _pingInterval = value;
                    CombinedTagHandler.Assign(value, this, "PingInterval");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
public PortSettingsPortTypeIP PortTypeIP
        {
            get
            {
                return _portTypeIP;
            }

            set
            {
                if (_portTypeIP != value)
                {
                    _portTypeIP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeIP");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
public PortSettingsPortTypeSerial PortTypeSerial
        {
            get
            {
                return _portTypeSerial;
            }

            set
            {
                if (_portTypeSerial != value)
                {
                    _portTypeSerial = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeSerial");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
public PortSettingsPortTypeUDP PortTypeUDP
        {
            get
            {
                return _portTypeUDP;
            }

            set
            {
                if (_portTypeUDP != value)
                {
                    _portTypeUDP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeUDP");
                }
            }
        }

        ///<summary>
        /// Configures the number of retries.
        ///</summary>
public PortSettingsRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        ///<summary>
        /// Specifies the SNMP set community string.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
public PortSettingsSetCommunity SetCommunity
        {
            get
            {
                return _setCommunity;
            }

            set
            {
                if (_setCommunity != value)
                {
                    _setCommunity = value;
                    CombinedTagHandler.Assign(value, this, "SetCommunity");
                }
            }
        }

        ///<summary>
        /// Specifies the SSH settings (only applicable for serial connections of type TCP).
        /// Feature introduced in DataMiner 9.5.9 (RN 17732).
        ///</summary>
public PortSettingsSSH SSH
        {
            get
            {
                return _sSH;
            }

            set
            {
                if (_sSH != value)
                {
                    _sSH = value;
                    CombinedTagHandler.Assign(value, this, "SSH");
                }
            }
        }

        ///<summary>
        /// Specifies the stop bits settings.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
public PortSettingsStopbits Stopbits
        {
            get
            {
                return _stopbits;
            }

            set
            {
                if (_stopbits != value)
                {
                    _stopbits = value;
                    CombinedTagHandler.Assign(value, this, "Stopbits");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the element timeout.
        ///</summary>
public PortSettingsTimeoutTimeElement TimeoutTimeElement
        {
            get
            {
                return _timeoutTimeElement;
            }

            set
            {
                if (_timeoutTimeElement != value)
                {
                    _timeoutTimeElement = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTimeElement");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the timeout of a command/request.
        ///</summary>
public PortSettingsTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
public PortSettingsType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the additional protocol type as specified in the advanced attribute of the /Protocol/Type element.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// If set to “false”, users cannot see or change the port settings for this additional protocol type when creating or editing an element.
        ///</summary>
public AttributeValue<bool?> VisibleInUi
        {
            get
            {
                return _visibleInUi;
            }

            set
            {
                if (_visibleInUi != value)
                {
                    _visibleInUi = value;
                    AttributeHandler.Assign(value, this, "visibleInUi");
                }
            }
        }

        public PortSettingsBaudrate GetOrCreateBaudrate()
        {
            if (Baudrate == null)
                Baudrate = new PortSettingsBaudrate();
            return Baudrate;
        }

        public PortSettingsBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new PortSettingsBusAddress();
            return BusAddress;
        }

        public PortSettingsDatabits GetOrCreateDatabits()
        {
            if (Databits == null)
                Databits = new PortSettingsDatabits();
            return Databits;
        }

        public PortSettingsFlowcontrol GetOrCreateFlowcontrol()
        {
            if (Flowcontrol == null)
                Flowcontrol = new PortSettingsFlowcontrol();
            return Flowcontrol;
        }

        public ElementValue<bool?> GetOrCreateFlushPerDatagram()
        {
            if (FlushPerDatagram == null)
                FlushPerDatagram = new ElementValue<bool?>();
            return FlushPerDatagram;
        }

        public PortSettingsGetCommunity GetOrCreateGetCommunity()
        {
            if (GetCommunity == null)
                GetCommunity = new PortSettingsGetCommunity();
            return GetCommunity;
        }

        public PortSettingsIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new PortSettingsIPport();
            return IPport;
        }

        public PortSettingsLocalIPport GetOrCreateLocalIPport()
        {
            if (LocalIPport == null)
                LocalIPport = new PortSettingsLocalIPport();
            return LocalIPport;
        }

        public PortSettingsParity GetOrCreateParity()
        {
            if (Parity == null)
                Parity = new PortSettingsParity();
            return Parity;
        }

        public PingInterval GetOrCreatePingInterval()
        {
            if (PingInterval == null)
                PingInterval = new PingInterval("PingInterval");
            return PingInterval;
        }

        public PortSettingsPortTypeIP GetOrCreatePortTypeIP()
        {
            if (PortTypeIP == null)
                PortTypeIP = new PortSettingsPortTypeIP();
            return PortTypeIP;
        }

        public PortSettingsPortTypeSerial GetOrCreatePortTypeSerial()
        {
            if (PortTypeSerial == null)
                PortTypeSerial = new PortSettingsPortTypeSerial();
            return PortTypeSerial;
        }

        public PortSettingsPortTypeUDP GetOrCreatePortTypeUDP()
        {
            if (PortTypeUDP == null)
                PortTypeUDP = new PortSettingsPortTypeUDP();
            return PortTypeUDP;
        }

        public PortSettingsRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new PortSettingsRetries();
            return Retries;
        }

        public PortSettingsSetCommunity GetOrCreateSetCommunity()
        {
            if (SetCommunity == null)
                SetCommunity = new PortSettingsSetCommunity();
            return SetCommunity;
        }

        public PortSettingsSSH GetOrCreateSSH()
        {
            if (SSH == null)
                SSH = new PortSettingsSSH();
            return SSH;
        }

        public PortSettingsStopbits GetOrCreateStopbits()
        {
            if (Stopbits == null)
                Stopbits = new PortSettingsStopbits();
            return Stopbits;
        }

        public PortSettingsTimeoutTimeElement GetOrCreateTimeoutTimeElement()
        {
            if (TimeoutTimeElement == null)
                TimeoutTimeElement = new PortSettingsTimeoutTimeElement();
            return TimeoutTimeElement;
        }

        public PortSettingsTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new PortSettingsTimeoutTime();
            return TimeoutTime;
        }

        public PortSettingsType GetOrCreateType()
        {
            if (Type == null)
                Type = new PortSettingsType();
            return Type;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<bool?> GetOrCreateVisibleInUi()
        {
            if (VisibleInUi == null)
                VisibleInUi = new AttributeValue<bool?>();
            return VisibleInUi;
        }

        protected override void Initialize(Read.IPortSettings read, XmlElement editNode)
        {
            if (read == null)
                return;
            _baudrate = read.Baudrate != null ? new PortSettingsBaudrate(read.Baudrate, this, editNode.Element["Baudrate"]) : null;
            _busAddress = read.BusAddress != null ? new PortSettingsBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _databits = read.Databits != null ? new PortSettingsDatabits(read.Databits, this, editNode.Element["Databits"]) : null;
            _flowcontrol = read.Flowcontrol != null ? new PortSettingsFlowcontrol(read.Flowcontrol, this, editNode.Element["Flowcontrol"]) : null;
            _flushPerDatagram = read.FlushPerDatagram != null ? new ElementValue<bool?>(read.FlushPerDatagram, this) : null;
            _getCommunity = read.GetCommunity != null ? new PortSettingsGetCommunity(read.GetCommunity, this, editNode.Element["GetCommunity"]) : null;
            _iPport = read.IPport != null ? new PortSettingsIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _localIPport = read.LocalIPport != null ? new PortSettingsLocalIPport(read.LocalIPport, this, editNode.Element["LocalIPport"]) : null;
            _parity = read.Parity != null ? new PortSettingsParity(read.Parity, this, editNode.Element["Parity"]) : null;
            _pingInterval = read.PingInterval != null ? new PingInterval(read.PingInterval, this, editNode.Element["PingInterval"]) : null;
            _portTypeIP = read.PortTypeIP != null ? new PortSettingsPortTypeIP(read.PortTypeIP, this, editNode.Element["PortTypeIP"]) : null;
            _portTypeSerial = read.PortTypeSerial != null ? new PortSettingsPortTypeSerial(read.PortTypeSerial, this, editNode.Element["PortTypeSerial"]) : null;
            _portTypeUDP = read.PortTypeUDP != null ? new PortSettingsPortTypeUDP(read.PortTypeUDP, this, editNode.Element["PortTypeUDP"]) : null;
            _retries = read.Retries != null ? new PortSettingsRetries(read.Retries, this, editNode.Element["Retries"]) : null;
            _setCommunity = read.SetCommunity != null ? new PortSettingsSetCommunity(read.SetCommunity, this, editNode.Element["SetCommunity"]) : null;
            _sSH = read.SSH != null ? new PortSettingsSSH(read.SSH, this, editNode.Element["SSH"]) : null;
            _stopbits = read.Stopbits != null ? new PortSettingsStopbits(read.Stopbits, this, editNode.Element["Stopbits"]) : null;
            _timeoutTimeElement = read.TimeoutTimeElement != null ? new PortSettingsTimeoutTimeElement(read.TimeoutTimeElement, this, editNode.Element["TimeoutTimeElement"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new PortSettingsTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _type = read.Type != null ? new PortSettingsType(read.Type, this, editNode.Element["Type"]) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _visibleInUi = read.VisibleInUi != null ? new AttributeValue<bool?>(read.VisibleInUi, this) : null;
        }

        public static PortSettings FromRead(Read.IPortSettings read)
        {
            if (read == null)
                return null;
            var item = new PortSettings(read.TagName);
            item.Baudrate = PortSettingsBaudrate.FromRead(read.Baudrate);
            item.BusAddress = PortSettingsBusAddress.FromRead(read.BusAddress);
            item.Databits = PortSettingsDatabits.FromRead(read.Databits);
            item.Flowcontrol = PortSettingsFlowcontrol.FromRead(read.Flowcontrol);
            item.FlushPerDatagram = ElementValue<bool?>.FromRead(read.FlushPerDatagram);
            item.GetCommunity = PortSettingsGetCommunity.FromRead(read.GetCommunity);
            item.IPport = PortSettingsIPport.FromRead(read.IPport);
            item.LocalIPport = PortSettingsLocalIPport.FromRead(read.LocalIPport);
            item.Parity = PortSettingsParity.FromRead(read.Parity);
            item.PingInterval = PingInterval.FromRead(read.PingInterval);
            item.PortTypeIP = PortSettingsPortTypeIP.FromRead(read.PortTypeIP);
            item.PortTypeSerial = PortSettingsPortTypeSerial.FromRead(read.PortTypeSerial);
            item.PortTypeUDP = PortSettingsPortTypeUDP.FromRead(read.PortTypeUDP);
            item.Retries = PortSettingsRetries.FromRead(read.Retries);
            item.SetCommunity = PortSettingsSetCommunity.FromRead(read.SetCommunity);
            item.SSH = PortSettingsSSH.FromRead(read.SSH);
            item.Stopbits = PortSettingsStopbits.FromRead(read.Stopbits);
            item.TimeoutTimeElement = PortSettingsTimeoutTimeElement.FromRead(read.TimeoutTimeElement);
            item.TimeoutTime = PortSettingsTimeoutTime.FromRead(read.TimeoutTime);
            item.Type = PortSettingsType.FromRead(read.Type);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.VisibleInUi = AttributeValue<bool?>.FromRead(read.VisibleInUi);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettings(this);
        }
    }

    ///<summary>
    /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial class PortSettingsBaudrate : EditableListNode<Read.IPortSettingsBaudrate, Read.IPortSettingsBaudrateValue, PortSettingsBaudrateValue>
    {
        internal PortSettingsBaudrate(Read.IPortSettingsBaudrate read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Baudrate node. None of it's properties will be set.
        ///</summary>
public PortSettingsBaudrate() : base("Baudrate")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsBaudrateRange _range;
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
public PortSettingsBaudrateRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsBaudrateRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsBaudrateRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsBaudrate read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsBaudrateRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsBaudrate FromRead(Read.IPortSettingsBaudrate read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBaudrate();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsBaudrateRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsBaudrateValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrate(this);
        }
    }

    ///<summary>
    /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
    ///</summary>
public partial class PortSettingsBaudrateDefaultValue : ElementValue<uint?>
    {
        internal PortSettingsBaudrateDefaultValue(Read.IPortSettingsBaudrateDefaultValue read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsBaudrateDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsBaudrateDefaultValue(uint? value) : base(value)
        {
        }

        public static PortSettingsBaudrateDefaultValue FromRead(Read.IPortSettingsBaudrateDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBaudrateDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrateDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the baud rate can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsBaudrateDisabled : ElementValue<bool?>
    {
        internal PortSettingsBaudrateDisabled(Read.IPortSettingsBaudrateDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsBaudrateDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsBaudrateDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsBaudrateDisabled FromRead(Read.IPortSettingsBaudrateDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBaudrateDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrateDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
public partial class PortSettingsBaudrateRange : EditableElementNode<Read.IPortSettingsBaudrateRange>
    {
        internal PortSettingsBaudrateRange(Read.IPortSettingsBaudrateRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsBaudrateRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<uint?> _from;
        private ElementValue<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
public ElementValue<uint?> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
public ElementValue<uint?> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<uint?>();
            return From;
        }

        public ElementValue<uint?> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<uint?>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsBaudrateRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<uint?>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<uint?>(read.To, this) : null;
        }

        public static PortSettingsBaudrateRange FromRead(Read.IPortSettingsBaudrateRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBaudrateRange();
            item.From = ElementValue<uint?>.FromRead(read.From);
            item.To = ElementValue<uint?>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrateRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
public partial class PortSettingsBaudrateValue : EditableElementValueNode<Read.IPortSettingsBaudrateValue, string>
    {
        internal PortSettingsBaudrateValue(Read.IPortSettingsBaudrateValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsBaudrateValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsBaudrateValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IPortSettingsBaudrateValue read, XmlElement editNode)
        {
        }

        public static PortSettingsBaudrateValue FromRead(Read.IPortSettingsBaudrateValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBaudrateValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBaudrateValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial class PortSettingsBusAddress : EditableListNode<Read.IPortSettingsBusAddress, Read.IPortSettingsBusAddressValue, PortSettingsBusAddressValue>
    {
        internal PortSettingsBusAddress(Read.IPortSettingsBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public PortSettingsBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsBusAddressRange _range;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public PortSettingsBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsBusAddressRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsBusAddress FromRead(Read.IPortSettingsBusAddress read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsBusAddressRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsBusAddressValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddress(this);
        }
    }

    ///<summary>
    /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
    /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
    ///</summary>
public partial class PortSettingsBusAddressDefaultValue : ElementValue<string>
    {
        internal PortSettingsBusAddressDefaultValue(Read.IPortSettingsBusAddressDefaultValue read, IEditableNode parent, bool useCDATA = false) : base(read, parent, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsBusAddressDefaultValue(bool useCDATA = false) : base(useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsBusAddressDefaultValue(string value, bool useCDATA = false) : base(value, useCDATA: useCDATA)
        {
        }

        public static PortSettingsBusAddressDefaultValue FromRead(Read.IPortSettingsBusAddressDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBusAddressDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddressDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the bus address can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsBusAddressDisabled : ElementValue<bool?>
    {
        internal PortSettingsBusAddressDisabled(Read.IPortSettingsBusAddressDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsBusAddressDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsBusAddressDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsBusAddressDisabled FromRead(Read.IPortSettingsBusAddressDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBusAddressDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddressDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class PortSettingsBusAddressRange : EditableElementNode<Read.IPortSettingsBusAddressRange>
    {
        internal PortSettingsBusAddressRange(Read.IPortSettingsBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static PortSettingsBusAddressRange FromRead(Read.IPortSettingsBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddressRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class PortSettingsBusAddressValue : EditableElementValueNode<Read.IPortSettingsBusAddressValue, string>
    {
        internal PortSettingsBusAddressValue(Read.IPortSettingsBusAddressValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsBusAddressValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsBusAddressValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IPortSettingsBusAddressValue read, XmlElement editNode)
        {
        }

        public static PortSettingsBusAddressValue FromRead(Read.IPortSettingsBusAddressValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsBusAddressValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsBusAddressValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
public partial class PortSettingsDatabits : EditableListNode<Read.IPortSettingsDatabits, Read.IPortSettingsDatabitsValue, PortSettingsDatabitsValue>
    {
        internal PortSettingsDatabits(Read.IPortSettingsDatabits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Databits node. None of it's properties will be set.
        ///</summary>
public PortSettingsDatabits() : base("Databits")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsDatabitsRange _range;
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
public PortSettingsDatabitsRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsDatabitsRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsDatabitsRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsDatabits read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsDatabitsRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsDatabits FromRead(Read.IPortSettingsDatabits read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsDatabits();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsDatabitsRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsDatabitsValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabits(this);
        }
    }

    ///<summary>
    /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
    ///</summary>
public partial class PortSettingsDatabitsDefaultValue : ElementValue<string>
    {
        internal PortSettingsDatabitsDefaultValue(Read.IPortSettingsDatabitsDefaultValue read, IEditableNode parent, bool useCDATA = false) : base(read, parent, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsDatabitsDefaultValue(bool useCDATA = false) : base(useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsDatabitsDefaultValue(string value, bool useCDATA = false) : base(value, useCDATA: useCDATA)
        {
        }

        public static PortSettingsDatabitsDefaultValue FromRead(Read.IPortSettingsDatabitsDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsDatabitsDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabitsDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the databits can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsDatabitsDisabled : ElementValue<bool?>
    {
        internal PortSettingsDatabitsDisabled(Read.IPortSettingsDatabitsDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsDatabitsDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsDatabitsDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsDatabitsDisabled FromRead(Read.IPortSettingsDatabitsDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsDatabitsDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabitsDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
public partial class PortSettingsDatabitsRange : EditableElementNode<Read.IPortSettingsDatabitsRange>
    {
        internal PortSettingsDatabitsRange(Read.IPortSettingsDatabitsRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsDatabitsRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<uint?> _from;
        private ElementValue<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
public ElementValue<uint?> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
public ElementValue<uint?> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<uint?>();
            return From;
        }

        public ElementValue<uint?> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<uint?>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsDatabitsRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<uint?>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<uint?>(read.To, this) : null;
        }

        public static PortSettingsDatabitsRange FromRead(Read.IPortSettingsDatabitsRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsDatabitsRange();
            item.From = ElementValue<uint?>.FromRead(read.From);
            item.To = ElementValue<uint?>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabitsRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class PortSettingsDatabitsValue : EditableElementValueNode<Read.IPortSettingsDatabitsValue, uint?>
    {
        internal PortSettingsDatabitsValue(Read.IPortSettingsDatabitsValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsDatabitsValue() : base("Value")
        {
            OnCreated();
        }

        public PortSettingsDatabitsValue(uint? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IPortSettingsDatabitsValue read, XmlElement editNode)
        {
        }

        public static PortSettingsDatabitsValue FromRead(Read.IPortSettingsDatabitsValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsDatabitsValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsDatabitsValue(this);
        }
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
public partial class PortSettingsFlowcontrol : EditableListNode<Read.IPortSettingsFlowcontrol, Read.IPortSettingsFlowcontrolValue, PortSettingsFlowcontrolValue>
    {
        internal PortSettingsFlowcontrol(Read.IPortSettingsFlowcontrol read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Flowcontrol node. None of it's properties will be set.
        ///</summary>
public PortSettingsFlowcontrol() : base("Flowcontrol")
        {
            OnCreated();
        }

        private PortSettingsFlowcontrolDefaultValue _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsFlowcontrolRange _range;
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
public PortSettingsFlowcontrolDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
public PortSettingsFlowcontrolRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public PortSettingsFlowcontrolDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new PortSettingsFlowcontrolDefaultValue();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsFlowcontrolRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsFlowcontrolRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsFlowcontrol read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new PortSettingsFlowcontrolDefaultValue(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsFlowcontrolRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsFlowcontrol FromRead(Read.IPortSettingsFlowcontrol read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsFlowcontrol();
            item.DefaultValue = PortSettingsFlowcontrolDefaultValue.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsFlowcontrolRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsFlowcontrolValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrol(this);
        }
    }

    ///<summary>
    /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
    ///</summary>
public partial class PortSettingsFlowcontrolDefaultValue : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsFlowcontrolDefaultValue(Read.IPortSettingsFlowcontrolDefaultValue read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsFlowcontrolDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsFlowcontrolDefaultValue(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        public static PortSettingsFlowcontrolDefaultValue FromRead(Read.IPortSettingsFlowcontrolDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsFlowcontrolDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrolDefaultValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies whether the flow control can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsFlowcontrolDisabled : ElementValue<bool?>
    {
        internal PortSettingsFlowcontrolDisabled(Read.IPortSettingsFlowcontrolDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsFlowcontrolDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsFlowcontrolDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsFlowcontrolDisabled FromRead(Read.IPortSettingsFlowcontrolDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsFlowcontrolDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrolDisabled(this);
        }
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
public partial class PortSettingsFlowcontrolRange : EditableElementNode<Read.IPortSettingsFlowcontrolRange>
    {
        internal PortSettingsFlowcontrolRange(Read.IPortSettingsFlowcontrolRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsFlowcontrolRange() : base("Range")
        {
            OnCreated();
        }

        private PortSettingsFlowcontrolRangeFrom _from;
        private PortSettingsFlowcontrolRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
public PortSettingsFlowcontrolRangeFrom From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
public PortSettingsFlowcontrolRangeTo To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public PortSettingsFlowcontrolRangeFrom GetOrCreateFrom()
        {
            if (From == null)
                From = new PortSettingsFlowcontrolRangeFrom();
            return From;
        }

        public PortSettingsFlowcontrolRangeTo GetOrCreateTo()
        {
            if (To == null)
                To = new PortSettingsFlowcontrolRangeTo();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsFlowcontrolRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new PortSettingsFlowcontrolRangeFrom(read.From, this) : null;
            _to = read.To != null ? new PortSettingsFlowcontrolRangeTo(read.To, this) : null;
        }

        public static PortSettingsFlowcontrolRange FromRead(Read.IPortSettingsFlowcontrolRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsFlowcontrolRange();
            item.From = PortSettingsFlowcontrolRangeFrom.FromRead(read.From);
            item.To = PortSettingsFlowcontrolRangeTo.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrolRange(this);
        }
    }

    public partial class PortSettingsFlowcontrolRangeFrom : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsFlowcontrolRangeFrom(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a From node. None of it's properties will be set.
        ///</summary>
public PortSettingsFlowcontrolRangeFrom() : base()
        {
            OnCreated();
        }

        public PortSettingsFlowcontrolRangeFrom(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsFlowcontrolRangeFrom FromRead(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsFlowcontrolRangeFrom();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class PortSettingsFlowcontrolRangeTo : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsFlowcontrolRangeTo(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a To node. None of it's properties will be set.
        ///</summary>
public PortSettingsFlowcontrolRangeTo() : base()
        {
            OnCreated();
        }

        public PortSettingsFlowcontrolRangeTo(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsFlowcontrolRangeTo FromRead(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsFlowcontrolRangeTo();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class PortSettingsFlowcontrolValue : EditableElementValueNode<Read.IPortSettingsFlowcontrolValue, Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsFlowcontrolValue(Read.IPortSettingsFlowcontrolValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsFlowcontrolValue() : base("Value")
        {
            OnCreated();
        }

        public PortSettingsFlowcontrolValue(Enums.EnumPortSettingsFlowControl? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IPortSettingsFlowcontrolValue read, XmlElement editNode)
        {
        }

        public static PortSettingsFlowcontrolValue FromRead(Read.IPortSettingsFlowcontrolValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsFlowcontrolValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsFlowcontrolValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the GetCommunity string of an SNMP protocol.
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
public partial class PortSettingsGetCommunity : EditableElementNode<Read.IPortSettingsGetCommunity>
    {
        internal PortSettingsGetCommunity(Read.IPortSettingsGetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a GetCommunity node. None of it's properties will be set.
        ///</summary>
public PortSettingsGetCommunity() : base("GetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value of the GetCommunity string that will be used in the DataMiner user interface for SNMP protocols.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the get community string can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsGetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsGetCommunity FromRead(Read.IPortSettingsGetCommunity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsGetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsGetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies the IP port configuration.
    ///</summary>
public partial class PortSettingsIPport : EditableElementNode<Read.IPortSettingsIPport>
    {
        internal PortSettingsIPport(Read.IPortSettingsIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public PortSettingsIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the port number can be configured via the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsIPport FromRead(Read.IPortSettingsIPport read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsIPport(this);
        }
    }

    ///<summary>
    /// Specifies the local IP port configuration.
    ///</summary>
public partial class PortSettingsLocalIPport : EditableElementNode<Read.IPortSettingsLocalIPport>
    {
        internal PortSettingsLocalIPport(Read.IPortSettingsLocalIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LocalIPport node. None of it's properties will be set.
        ///</summary>
public PortSettingsLocalIPport() : base("LocalIPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the local port number can be configured via the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsLocalIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsLocalIPport FromRead(Read.IPortSettingsLocalIPport read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsLocalIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsLocalIPport(this);
        }
    }

    ///<summary>
    /// Allows to limit parity settings and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
public partial class PortSettingsParity : EditableListNode<Read.IPortSettingsParity, Read.IPortSettingsParityValue, PortSettingsParityValue>
    {
        internal PortSettingsParity(Read.IPortSettingsParity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Parity node. None of it's properties will be set.
        ///</summary>
public PortSettingsParity() : base("Parity")
        {
            OnCreated();
        }

        private PortSettingsParityDefaultValue _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsParityRange _range;
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
public PortSettingsParityDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
public PortSettingsParityRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public PortSettingsParityDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new PortSettingsParityDefaultValue();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsParityRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsParityRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsParity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new PortSettingsParityDefaultValue(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsParityRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsParity FromRead(Read.IPortSettingsParity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsParity();
            item.DefaultValue = PortSettingsParityDefaultValue.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsParityRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsParityValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParity(this);
        }
    }

    ///<summary>
    /// Specifies the default parity.
    ///</summary>
public partial class PortSettingsParityDefaultValue : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsParityDefaultValue(Read.IPortSettingsParityDefaultValue read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsParityDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsParityDefaultValue(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        public static PortSettingsParityDefaultValue FromRead(Read.IPortSettingsParityDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsParityDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParityDefaultValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies whether the parity can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsParityDisabled : ElementValue<bool?>
    {
        internal PortSettingsParityDisabled(Read.IPortSettingsParityDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsParityDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsParityDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsParityDisabled FromRead(Read.IPortSettingsParityDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsParityDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParityDisabled(this);
        }
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
public partial class PortSettingsParityRange : EditableElementNode<Read.IPortSettingsParityRange>
    {
        internal PortSettingsParityRange(Read.IPortSettingsParityRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsParityRange() : base("Range")
        {
            OnCreated();
        }

        private PortSettingsParityRangeFrom _from;
        private PortSettingsParityRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
public PortSettingsParityRangeFrom From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
public PortSettingsParityRangeTo To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public PortSettingsParityRangeFrom GetOrCreateFrom()
        {
            if (From == null)
                From = new PortSettingsParityRangeFrom();
            return From;
        }

        public PortSettingsParityRangeTo GetOrCreateTo()
        {
            if (To == null)
                To = new PortSettingsParityRangeTo();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsParityRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new PortSettingsParityRangeFrom(read.From, this) : null;
            _to = read.To != null ? new PortSettingsParityRangeTo(read.To, this) : null;
        }

        public static PortSettingsParityRange FromRead(Read.IPortSettingsParityRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsParityRange();
            item.From = PortSettingsParityRangeFrom.FromRead(read.From);
            item.To = PortSettingsParityRangeTo.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParityRange(this);
        }
    }

    public partial class PortSettingsParityRangeFrom : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsParityRangeFrom(Read.IValueTag<Enums.EnumPortSettingsParity?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a From node. None of it's properties will be set.
        ///</summary>
public PortSettingsParityRangeFrom() : base()
        {
            OnCreated();
        }

        public PortSettingsParityRangeFrom(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsParityRangeFrom FromRead(Read.IValueTag<Enums.EnumPortSettingsParity?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsParityRangeFrom();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class PortSettingsParityRangeTo : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsParityRangeTo(Read.IValueTag<Enums.EnumPortSettingsParity?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a To node. None of it's properties will be set.
        ///</summary>
public PortSettingsParityRangeTo() : base()
        {
            OnCreated();
        }

        public PortSettingsParityRangeTo(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsParityRangeTo FromRead(Read.IValueTag<Enums.EnumPortSettingsParity?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsParityRangeTo();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
public partial class PortSettingsParityValue : EditableElementValueNode<Read.IPortSettingsParityValue, Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsParityValue(Read.IPortSettingsParityValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsParityValue() : base("Value")
        {
            OnCreated();
        }

        public PortSettingsParityValue(Enums.EnumPortSettingsParity? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IPortSettingsParityValue read, XmlElement editNode)
        {
        }

        public static PortSettingsParityValue FromRead(Read.IPortSettingsParityValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsParityValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsParityValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
public partial class PortSettingsPortTypeIP : EditableElementNode<Read.IPortSettingsPortTypeIP>
    {
        internal PortSettingsPortTypeIP(Read.IPortSettingsPortTypeIP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeIP node. None of it's properties will be set.
        ///</summary>
public PortSettingsPortTypeIP() : base("PortTypeIP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsPortTypeIP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsPortTypeIP FromRead(Read.IPortSettingsPortTypeIP read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsPortTypeIP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsPortTypeIP(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
public partial class PortSettingsPortTypeSerial : EditableElementNode<Read.IPortSettingsPortTypeSerial>
    {
        internal PortSettingsPortTypeSerial(Read.IPortSettingsPortTypeSerial read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeSerial node. None of it's properties will be set.
        ///</summary>
public PortSettingsPortTypeSerial() : base("PortTypeSerial")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsPortTypeSerial read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsPortTypeSerial FromRead(Read.IPortSettingsPortTypeSerial read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsPortTypeSerial();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsPortTypeSerial(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
public partial class PortSettingsPortTypeUDP : EditableElementNode<Read.IPortSettingsPortTypeUDP>
    {
        internal PortSettingsPortTypeUDP(Read.IPortSettingsPortTypeUDP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeUDP node. None of it's properties will be set.
        ///</summary>
public PortSettingsPortTypeUDP() : base("PortTypeUDP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsPortTypeUDP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsPortTypeUDP FromRead(Read.IPortSettingsPortTypeUDP read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsPortTypeUDP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsPortTypeUDP(this);
        }
    }

    ///<summary>
    /// Configures the number of retries.
    ///</summary>
public partial class PortSettingsRetries : EditableElementNode<Read.IPortSettingsRetries>
    {
        internal PortSettingsRetries(Read.IPortSettingsRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public PortSettingsRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value for the maximum number of times that a request will be re-sent.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the maximum number of retries can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsRetries FromRead(Read.IPortSettingsRetries read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsRetries();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsRetries(this);
        }
    }

    ///<summary>
    /// Specifies the SNMP set community string.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
public partial class PortSettingsSetCommunity : EditableElementNode<Read.IPortSettingsSetCommunity>
    {
        internal PortSettingsSetCommunity(Read.IPortSettingsSetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SetCommunity node. None of it's properties will be set.
        ///</summary>
public PortSettingsSetCommunity() : base("SetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value of the SNMP set community string that will be used.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the SetCommunity string can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsSetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsSetCommunity FromRead(Read.IPortSettingsSetCommunity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsSetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies the SSH settings (only applicable for serial connections of type TCP).
    /// Feature introduced in DataMiner 9.5.9 (RN 17732).
    ///</summary>
public partial class PortSettingsSSH : EditableElementNode<Read.IPortSettingsSSH>
    {
        internal PortSettingsSSH(Read.IPortSettingsSSH read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SSH node. None of it's properties will be set.
        ///</summary>
public PortSettingsSSH() : base("SSH")
        {
            OnCreated();
        }

        private PortSettingsSSHCredentials _credentials;
        private PortSettingsSSHIdentity _identity;
        ///<summary>
        /// Specifies the SSH credentials.
        ///</summary>
public PortSettingsSSHCredentials Credentials
        {
            get
            {
                return _credentials;
            }

            set
            {
                if (_credentials != value)
                {
                    _credentials = value;
                    CombinedTagHandler.Assign(value, this, "Credentials");
                }
            }
        }

        ///<summary>
        /// Specifies the identity settings.
        ///</summary>
public PortSettingsSSHIdentity Identity
        {
            get
            {
                return _identity;
            }

            set
            {
                if (_identity != value)
                {
                    _identity = value;
                    CombinedTagHandler.Assign(value, this, "Identity");
                }
            }
        }

        public PortSettingsSSHCredentials GetOrCreateCredentials()
        {
            if (Credentials == null)
                Credentials = new PortSettingsSSHCredentials();
            return Credentials;
        }

        public PortSettingsSSHIdentity GetOrCreateIdentity()
        {
            if (Identity == null)
                Identity = new PortSettingsSSHIdentity();
            return Identity;
        }

        protected override void Initialize(Read.IPortSettingsSSH read, XmlElement editNode)
        {
            if (read == null)
                return;
            _credentials = read.Credentials != null ? new PortSettingsSSHCredentials(read.Credentials, this, editNode.Element["Credentials"]) : null;
            _identity = read.Identity != null ? new PortSettingsSSHIdentity(read.Identity, this, editNode.Element["Identity"]) : null;
        }

        public static PortSettingsSSH FromRead(Read.IPortSettingsSSH read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsSSH();
            item.Credentials = PortSettingsSSHCredentials.FromRead(read.Credentials);
            item.Identity = PortSettingsSSHIdentity.FromRead(read.Identity);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSH(this);
        }
    }

    ///<summary>
    /// Specifies the SSH credentials.
    ///</summary>
public partial class PortSettingsSSHCredentials : EditableElementNode<Read.IPortSettingsSSHCredentials>
    {
        internal PortSettingsSSHCredentials(Read.IPortSettingsSSHCredentials read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Credentials node. None of it's properties will be set.
        ///</summary>
public PortSettingsSSHCredentials() : base("Credentials")
        {
            OnCreated();
        }

        private PortSettingsSSHCredentialsUsername _username;
        private PortSettingsSSHCredentialsPassword _password;
        ///<summary>
        /// Specifies the user name.
        ///</summary>
public PortSettingsSSHCredentialsUsername Username
        {
            get
            {
                return _username;
            }

            set
            {
                if (_username != value)
                {
                    _username = value;
                    CombinedTagHandler.Assign(value, this, "Username");
                }
            }
        }

        ///<summary>
        /// Specifies the password.
        ///</summary>
public PortSettingsSSHCredentialsPassword Password
        {
            get
            {
                return _password;
            }

            set
            {
                if (_password != value)
                {
                    _password = value;
                    CombinedTagHandler.Assign(value, this, "Password");
                }
            }
        }

        public PortSettingsSSHCredentialsUsername GetOrCreateUsername()
        {
            if (Username == null)
                Username = new PortSettingsSSHCredentialsUsername();
            return Username;
        }

        public PortSettingsSSHCredentialsPassword GetOrCreatePassword()
        {
            if (Password == null)
                Password = new PortSettingsSSHCredentialsPassword();
            return Password;
        }

        protected override void Initialize(Read.IPortSettingsSSHCredentials read, XmlElement editNode)
        {
            if (read == null)
                return;
            _username = read.Username != null ? new PortSettingsSSHCredentialsUsername(read.Username, this, editNode.Element["Username"]) : null;
            _password = read.Password != null ? new PortSettingsSSHCredentialsPassword(read.Password, this, editNode.Element["Password"]) : null;
        }

        public static PortSettingsSSHCredentials FromRead(Read.IPortSettingsSSHCredentials read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsSSHCredentials();
            item.Username = PortSettingsSSHCredentialsUsername.FromRead(read.Username);
            item.Password = PortSettingsSSHCredentialsPassword.FromRead(read.Password);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSHCredentials(this);
        }
    }

    ///<summary>
    /// Specifies the user name.
    ///</summary>
public partial class PortSettingsSSHCredentialsUsername : EditableElementNode<Read.IPortSettingsSSHCredentialsUsername>
    {
        internal PortSettingsSSHCredentialsUsername(Read.IPortSettingsSSHCredentialsUsername read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Username node. None of it's properties will be set.
        ///</summary>
public PortSettingsSSHCredentialsUsername() : base("Username")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the user name.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IPortSettingsSSHCredentialsUsername read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static PortSettingsSSHCredentialsUsername FromRead(Read.IPortSettingsSSHCredentialsUsername read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsSSHCredentialsUsername();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSHCredentialsUsername(this);
        }
    }

    ///<summary>
    /// Specifies the password.
    ///</summary>
public partial class PortSettingsSSHCredentialsPassword : EditableElementNode<Read.IPortSettingsSSHCredentialsPassword>
    {
        internal PortSettingsSSHCredentialsPassword(Read.IPortSettingsSSHCredentialsPassword read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Password node. None of it's properties will be set.
        ///</summary>
public PortSettingsSSHCredentialsPassword() : base("Password")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the password.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IPortSettingsSSHCredentialsPassword read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static PortSettingsSSHCredentialsPassword FromRead(Read.IPortSettingsSSHCredentialsPassword read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsSSHCredentialsPassword();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSHCredentialsPassword(this);
        }
    }

    ///<summary>
    /// Specifies the identity settings.
    ///</summary>
public partial class PortSettingsSSHIdentity : EditableElementNode<Read.IPortSettingsSSHIdentity>
    {
        internal PortSettingsSSHIdentity(Read.IPortSettingsSSHIdentity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Identity node. None of it's properties will be set.
        ///</summary>
public PortSettingsSSHIdentity() : base("Identity")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the identity info.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IPortSettingsSSHIdentity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static PortSettingsSSHIdentity FromRead(Read.IPortSettingsSSHIdentity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsSSHIdentity();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsSSHIdentity(this);
        }
    }

    ///<summary>
    /// Specifies the stop bits settings.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
public partial class PortSettingsStopbits : EditableListNode<Read.IPortSettingsStopbits, Read.IPortSettingsStopbitsValue, PortSettingsStopbitsValue>
    {
        internal PortSettingsStopbits(Read.IPortSettingsStopbits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Stopbits node. None of it's properties will be set.
        ///</summary>
public PortSettingsStopbits() : base("Stopbits")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsStopbits read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsStopbits FromRead(Read.IPortSettingsStopbits read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsStopbits();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            foreach (var x in read)
            {
                item.Add(PortSettingsStopbitsValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsStopbits(this);
        }
    }

    ///<summary>
    /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
    /// Set the default to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial class PortSettingsStopbitsDefaultValue : ElementValue<string>
    {
        internal PortSettingsStopbitsDefaultValue(Read.IPortSettingsStopbitsDefaultValue read, IEditableNode parent, bool useCDATA = false) : base(read, parent, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsStopbitsDefaultValue(bool useCDATA = false) : base(useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsStopbitsDefaultValue(string value, bool useCDATA = false) : base(value, useCDATA: useCDATA)
        {
        }

        public static PortSettingsStopbitsDefaultValue FromRead(Read.IPortSettingsStopbitsDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsStopbitsDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsStopbitsDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsStopbitsDisabled : ElementValue<bool?>
    {
        internal PortSettingsStopbitsDisabled(Read.IPortSettingsStopbitsDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsStopbitsDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsStopbitsDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsStopbitsDisabled FromRead(Read.IPortSettingsStopbitsDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsStopbitsDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsStopbitsDisabled(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial class PortSettingsStopbitsValue : EditableElementValueNode<Read.IPortSettingsStopbitsValue, Enums.EnumPortSettingsStopBits?>
    {
        internal PortSettingsStopbitsValue(Read.IPortSettingsStopbitsValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsStopbitsValue() : base("Value")
        {
            OnCreated();
        }

        public PortSettingsStopbitsValue(Enums.EnumPortSettingsStopBits? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IPortSettingsStopbitsValue read, XmlElement editNode)
        {
        }

        public static PortSettingsStopbitsValue FromRead(Read.IPortSettingsStopbitsValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsStopbitsValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsStopbitsValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsStopBitsConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsStopBits? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsStopBitsConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies settings related to the element timeout.
    ///</summary>
public partial class PortSettingsTimeoutTimeElement : EditableElementNode<Read.IPortSettingsTimeoutTimeElement>
    {
        internal PortSettingsTimeoutTimeElement(Read.IPortSettingsTimeoutTimeElement read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTimeElement node. None of it's properties will be set.
        ///</summary>
public PortSettingsTimeoutTimeElement() : base("TimeoutTimeElement")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default element timeout value (in milliseconds). The specified value must be in the range [1000, 120000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the element timeout time for this connection can be configured via the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsTimeoutTimeElement read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsTimeoutTimeElement FromRead(Read.IPortSettingsTimeoutTimeElement read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsTimeoutTimeElement();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsTimeoutTimeElement(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the timeout of a command/request.
    ///</summary>
public partial class PortSettingsTimeoutTime : EditableElementNode<Read.IPortSettingsTimeoutTime>
    {
        internal PortSettingsTimeoutTime(Read.IPortSettingsTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public PortSettingsTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default timeout value (in milliseconds).
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the timeout value can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsTimeoutTime FromRead(Read.IPortSettingsTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsTimeoutTime();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsTimeoutTime(this);
        }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
public partial class PortSettingsType : EditableElementNode<Read.IPortSettingsType>
    {
        internal PortSettingsType(Read.IPortSettingsType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public PortSettingsType() : base("Type")
        {
            OnCreated();
        }

        private PortSettingsTypeDefaultValue _defaultValue;
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
public PortSettingsTypeDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public PortSettingsTypeDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new PortSettingsTypeDefaultValue();
            return DefaultValue;
        }

        protected override void Initialize(Read.IPortSettingsType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new PortSettingsTypeDefaultValue(read.DefaultValue, this) : null;
        }

        public static PortSettingsType FromRead(Read.IPortSettingsType read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsType();
            item.DefaultValue = PortSettingsTypeDefaultValue.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsType(this);
        }
    }

    public partial class PortSettingsTypeDefaultValue : ElementValue<Enums.EnumPortTypes?>
    {
        internal PortSettingsTypeDefaultValue(Read.IValueTag<Enums.EnumPortTypes?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsTypeDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsTypeDefaultValue(Enums.EnumPortTypes? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortTypesConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsTypeDefaultValue FromRead(Read.IValueTag<Enums.EnumPortTypes?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsTypeDefaultValue();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines main port settings.
    ///</summary>
public partial class PortSettingsMain : EditableElementNode<Read.IPortSettingsMain>
    {
        internal PortSettingsMain(Read.IPortSettingsMain read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortSettingsMain node. None of it's properties will be set.
        ///</summary>
public PortSettingsMain(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private PortSettingsMainBaudrate _baudrate;
        private PortSettingsMainBusAddress _busAddress;
        private PortSettingsMainDatabits _databits;
        private PortSettingsMainFlowcontrol _flowcontrol;
        private ElementValue<bool?> _flushPerDatagram;
        private PortSettingsMainGetCommunity _getCommunity;
        private PortSettingsMainIPport _iPport;
        private PortSettingsMainLocalIPport _localIPport;
        private PortSettingsMainParity _parity;
        private PingInterval _pingInterval;
        private PortSettingsMainPortTypeIP _portTypeIP;
        private PortSettingsMainPortTypeSerial _portTypeSerial;
        private PortSettingsMainPortTypeUDP _portTypeUDP;
        private PortSettingsMainRetries _retries;
        private PortSettingsMainSetCommunity _setCommunity;
        private SlowPoll _slowPoll;
        private SlowPollBase _slowPollBase;
        private PortSettingsMainSSH _sSH;
        private PortSettingsMainStopbits _stopbits;
        private PortSettingsMainTimeoutTimeElement _timeoutTimeElement;
        private PortSettingsMainTimeoutTime _timeoutTime;
        private PortSettingsMainType _type;
        private AttributeValue<string> _name;
        ///<summary>
        /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public PortSettingsMainBaudrate Baudrate
        {
            get
            {
                return _baudrate;
            }

            set
            {
                if (_baudrate != value)
                {
                    _baudrate = value;
                    CombinedTagHandler.Assign(value, this, "Baudrate");
                }
            }
        }

        ///<summary>
        /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public PortSettingsMainBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// Allows to limit bus databit settings and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
public PortSettingsMainDatabits Databits
        {
            get
            {
                return _databits;
            }

            set
            {
                if (_databits != value)
                {
                    _databits = value;
                    CombinedTagHandler.Assign(value, this, "Databits");
                }
            }
        }

        ///<summary>
        /// Allows to limit flow control settings and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
public PortSettingsMainFlowcontrol Flowcontrol
        {
            get
            {
                return _flowcontrol;
            }

            set
            {
                if (_flowcontrol != value)
                {
                    _flowcontrol = value;
                    CombinedTagHandler.Assign(value, this, "Flowcontrol");
                }
            }
        }

        ///<summary>
        /// When set to true, any datagram received on the connection will be forwarded to SLProtocol immediately, which will then store it in the response parameter. Only applicable for a smart-serial UDP connection.
        ///</summary>
public ElementValue<bool?> FlushPerDatagram
        {
            get
            {
                return _flushPerDatagram;
            }

            set
            {
                if (_flushPerDatagram != value)
                {
                    _flushPerDatagram = value;
                    ElementHandler.Assign(value, this, "FlushPerDatagram");
                }
            }
        }

        ///<summary>
        /// Specifies the GetCommunity string of an SNMP protocol.
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
public PortSettingsMainGetCommunity GetCommunity
        {
            get
            {
                return _getCommunity;
            }

            set
            {
                if (_getCommunity != value)
                {
                    _getCommunity = value;
                    CombinedTagHandler.Assign(value, this, "GetCommunity");
                }
            }
        }

        ///<summary>
        /// Specifies the IP port configuration.
        ///</summary>
public PortSettingsMainIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        ///<summary>
        /// Specifies the local IP port configuration.
        ///</summary>
public PortSettingsMainLocalIPport LocalIPport
        {
            get
            {
                return _localIPport;
            }

            set
            {
                if (_localIPport != value)
                {
                    _localIPport = value;
                    CombinedTagHandler.Assign(value, this, "LocalIPport");
                }
            }
        }

        ///<summary>
        /// Allows to limit parity settings and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
public PortSettingsMainParity Parity
        {
            get
            {
                return _parity;
            }

            set
            {
                if (_parity != value)
                {
                    _parity = value;
                    CombinedTagHandler.Assign(value, this, "Parity");
                }
            }
        }

        ///<summary>
        /// Configures the ping interval.
        ///</summary>
public PingInterval PingInterval
        {
            get
            {
                return _pingInterval;
            }

            set
            {
                if (_pingInterval != value)
                {
                    _pingInterval = value;
                    CombinedTagHandler.Assign(value, this, "PingInterval");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the TCP/IP port type.
        ///</summary>
public PortSettingsMainPortTypeIP PortTypeIP
        {
            get
            {
                return _portTypeIP;
            }

            set
            {
                if (_portTypeIP != value)
                {
                    _portTypeIP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeIP");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the serial port type.
        ///</summary>
public PortSettingsMainPortTypeSerial PortTypeSerial
        {
            get
            {
                return _portTypeSerial;
            }

            set
            {
                if (_portTypeSerial != value)
                {
                    _portTypeSerial = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeSerial");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the UDP/IP port type.
        ///</summary>
public PortSettingsMainPortTypeUDP PortTypeUDP
        {
            get
            {
                return _portTypeUDP;
            }

            set
            {
                if (_portTypeUDP != value)
                {
                    _portTypeUDP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeUDP");
                }
            }
        }

        ///<summary>
        /// Configures the number of retries.
        ///</summary>
public PortSettingsMainRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        ///<summary>
        /// Specifies the SNMP set community string.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
public PortSettingsMainSetCommunity SetCommunity
        {
            get
            {
                return _setCommunity;
            }

            set
            {
                if (_setCommunity != value)
                {
                    _setCommunity = value;
                    CombinedTagHandler.Assign(value, this, "SetCommunity");
                }
            }
        }

        ///<summary>
        /// Specifies the slow poll configuration.
        ///</summary>
public SlowPoll SlowPoll
        {
            get
            {
                return _slowPoll;
            }

            set
            {
                if (_slowPoll != value)
                {
                    _slowPoll = value;
                    CombinedTagHandler.Assign(value, this, "SlowPoll");
                }
            }
        }

        ///<summary>
        /// Specifies the slow poll base settings.
        ///</summary>
public SlowPollBase SlowPollBase
        {
            get
            {
                return _slowPollBase;
            }

            set
            {
                if (_slowPollBase != value)
                {
                    _slowPollBase = value;
                    CombinedTagHandler.Assign(value, this, "SlowPollBase");
                }
            }
        }

        ///<summary>
        /// Specifies the SSH settings (only applicable for serial connections of type TCP).
        /// Feature introduced in DataMiner 9.5.9 (RN 17732).
        ///</summary>
public PortSettingsMainSSH SSH
        {
            get
            {
                return _sSH;
            }

            set
            {
                if (_sSH != value)
                {
                    _sSH = value;
                    CombinedTagHandler.Assign(value, this, "SSH");
                }
            }
        }

        ///<summary>
        /// Specifies the stop bits settings.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
public PortSettingsMainStopbits Stopbits
        {
            get
            {
                return _stopbits;
            }

            set
            {
                if (_stopbits != value)
                {
                    _stopbits = value;
                    CombinedTagHandler.Assign(value, this, "Stopbits");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the element timeout.
        ///</summary>
public PortSettingsMainTimeoutTimeElement TimeoutTimeElement
        {
            get
            {
                return _timeoutTimeElement;
            }

            set
            {
                if (_timeoutTimeElement != value)
                {
                    _timeoutTimeElement = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTimeElement");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the timeout of a command/request.
        ///</summary>
public PortSettingsMainTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// Specifies the port type settings.
        ///</summary>
public PortSettingsMainType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the additional protocol type as specified in the advanced attribute of the /Protocol/Type element.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public PortSettingsMainBaudrate GetOrCreateBaudrate()
        {
            if (Baudrate == null)
                Baudrate = new PortSettingsMainBaudrate();
            return Baudrate;
        }

        public PortSettingsMainBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new PortSettingsMainBusAddress();
            return BusAddress;
        }

        public PortSettingsMainDatabits GetOrCreateDatabits()
        {
            if (Databits == null)
                Databits = new PortSettingsMainDatabits();
            return Databits;
        }

        public PortSettingsMainFlowcontrol GetOrCreateFlowcontrol()
        {
            if (Flowcontrol == null)
                Flowcontrol = new PortSettingsMainFlowcontrol();
            return Flowcontrol;
        }

        public ElementValue<bool?> GetOrCreateFlushPerDatagram()
        {
            if (FlushPerDatagram == null)
                FlushPerDatagram = new ElementValue<bool?>();
            return FlushPerDatagram;
        }

        public PortSettingsMainGetCommunity GetOrCreateGetCommunity()
        {
            if (GetCommunity == null)
                GetCommunity = new PortSettingsMainGetCommunity();
            return GetCommunity;
        }

        public PortSettingsMainIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new PortSettingsMainIPport();
            return IPport;
        }

        public PortSettingsMainLocalIPport GetOrCreateLocalIPport()
        {
            if (LocalIPport == null)
                LocalIPport = new PortSettingsMainLocalIPport();
            return LocalIPport;
        }

        public PortSettingsMainParity GetOrCreateParity()
        {
            if (Parity == null)
                Parity = new PortSettingsMainParity();
            return Parity;
        }

        public PingInterval GetOrCreatePingInterval()
        {
            if (PingInterval == null)
                PingInterval = new PingInterval("PingInterval");
            return PingInterval;
        }

        public PortSettingsMainPortTypeIP GetOrCreatePortTypeIP()
        {
            if (PortTypeIP == null)
                PortTypeIP = new PortSettingsMainPortTypeIP();
            return PortTypeIP;
        }

        public PortSettingsMainPortTypeSerial GetOrCreatePortTypeSerial()
        {
            if (PortTypeSerial == null)
                PortTypeSerial = new PortSettingsMainPortTypeSerial();
            return PortTypeSerial;
        }

        public PortSettingsMainPortTypeUDP GetOrCreatePortTypeUDP()
        {
            if (PortTypeUDP == null)
                PortTypeUDP = new PortSettingsMainPortTypeUDP();
            return PortTypeUDP;
        }

        public PortSettingsMainRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new PortSettingsMainRetries();
            return Retries;
        }

        public PortSettingsMainSetCommunity GetOrCreateSetCommunity()
        {
            if (SetCommunity == null)
                SetCommunity = new PortSettingsMainSetCommunity();
            return SetCommunity;
        }

        public SlowPoll GetOrCreateSlowPoll()
        {
            if (SlowPoll == null)
                SlowPoll = new SlowPoll("SlowPoll");
            return SlowPoll;
        }

        public SlowPollBase GetOrCreateSlowPollBase()
        {
            if (SlowPollBase == null)
                SlowPollBase = new SlowPollBase("SlowPollBase");
            return SlowPollBase;
        }

        public PortSettingsMainSSH GetOrCreateSSH()
        {
            if (SSH == null)
                SSH = new PortSettingsMainSSH();
            return SSH;
        }

        public PortSettingsMainStopbits GetOrCreateStopbits()
        {
            if (Stopbits == null)
                Stopbits = new PortSettingsMainStopbits();
            return Stopbits;
        }

        public PortSettingsMainTimeoutTimeElement GetOrCreateTimeoutTimeElement()
        {
            if (TimeoutTimeElement == null)
                TimeoutTimeElement = new PortSettingsMainTimeoutTimeElement();
            return TimeoutTimeElement;
        }

        public PortSettingsMainTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new PortSettingsMainTimeoutTime();
            return TimeoutTime;
        }

        public PortSettingsMainType GetOrCreateType()
        {
            if (Type == null)
                Type = new PortSettingsMainType();
            return Type;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.IPortSettingsMain read, XmlElement editNode)
        {
            if (read == null)
                return;
            _baudrate = read.Baudrate != null ? new PortSettingsMainBaudrate(read.Baudrate, this, editNode.Element["Baudrate"]) : null;
            _busAddress = read.BusAddress != null ? new PortSettingsMainBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _databits = read.Databits != null ? new PortSettingsMainDatabits(read.Databits, this, editNode.Element["Databits"]) : null;
            _flowcontrol = read.Flowcontrol != null ? new PortSettingsMainFlowcontrol(read.Flowcontrol, this, editNode.Element["Flowcontrol"]) : null;
            _flushPerDatagram = read.FlushPerDatagram != null ? new ElementValue<bool?>(read.FlushPerDatagram, this) : null;
            _getCommunity = read.GetCommunity != null ? new PortSettingsMainGetCommunity(read.GetCommunity, this, editNode.Element["GetCommunity"]) : null;
            _iPport = read.IPport != null ? new PortSettingsMainIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _localIPport = read.LocalIPport != null ? new PortSettingsMainLocalIPport(read.LocalIPport, this, editNode.Element["LocalIPport"]) : null;
            _parity = read.Parity != null ? new PortSettingsMainParity(read.Parity, this, editNode.Element["Parity"]) : null;
            _pingInterval = read.PingInterval != null ? new PingInterval(read.PingInterval, this, editNode.Element["PingInterval"]) : null;
            _portTypeIP = read.PortTypeIP != null ? new PortSettingsMainPortTypeIP(read.PortTypeIP, this, editNode.Element["PortTypeIP"]) : null;
            _portTypeSerial = read.PortTypeSerial != null ? new PortSettingsMainPortTypeSerial(read.PortTypeSerial, this, editNode.Element["PortTypeSerial"]) : null;
            _portTypeUDP = read.PortTypeUDP != null ? new PortSettingsMainPortTypeUDP(read.PortTypeUDP, this, editNode.Element["PortTypeUDP"]) : null;
            _retries = read.Retries != null ? new PortSettingsMainRetries(read.Retries, this, editNode.Element["Retries"]) : null;
            _setCommunity = read.SetCommunity != null ? new PortSettingsMainSetCommunity(read.SetCommunity, this, editNode.Element["SetCommunity"]) : null;
            _slowPoll = read.SlowPoll != null ? new SlowPoll(read.SlowPoll, this, editNode.Element["SlowPoll"]) : null;
            _slowPollBase = read.SlowPollBase != null ? new SlowPollBase(read.SlowPollBase, this, editNode.Element["SlowPollBase"]) : null;
            _sSH = read.SSH != null ? new PortSettingsMainSSH(read.SSH, this, editNode.Element["SSH"]) : null;
            _stopbits = read.Stopbits != null ? new PortSettingsMainStopbits(read.Stopbits, this, editNode.Element["Stopbits"]) : null;
            _timeoutTimeElement = read.TimeoutTimeElement != null ? new PortSettingsMainTimeoutTimeElement(read.TimeoutTimeElement, this, editNode.Element["TimeoutTimeElement"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new PortSettingsMainTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _type = read.Type != null ? new PortSettingsMainType(read.Type, this, editNode.Element["Type"]) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static PortSettingsMain FromRead(Read.IPortSettingsMain read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMain(read.TagName);
            item.Baudrate = PortSettingsMainBaudrate.FromRead(read.Baudrate);
            item.BusAddress = PortSettingsMainBusAddress.FromRead(read.BusAddress);
            item.Databits = PortSettingsMainDatabits.FromRead(read.Databits);
            item.Flowcontrol = PortSettingsMainFlowcontrol.FromRead(read.Flowcontrol);
            item.FlushPerDatagram = ElementValue<bool?>.FromRead(read.FlushPerDatagram);
            item.GetCommunity = PortSettingsMainGetCommunity.FromRead(read.GetCommunity);
            item.IPport = PortSettingsMainIPport.FromRead(read.IPport);
            item.LocalIPport = PortSettingsMainLocalIPport.FromRead(read.LocalIPport);
            item.Parity = PortSettingsMainParity.FromRead(read.Parity);
            item.PingInterval = PingInterval.FromRead(read.PingInterval);
            item.PortTypeIP = PortSettingsMainPortTypeIP.FromRead(read.PortTypeIP);
            item.PortTypeSerial = PortSettingsMainPortTypeSerial.FromRead(read.PortTypeSerial);
            item.PortTypeUDP = PortSettingsMainPortTypeUDP.FromRead(read.PortTypeUDP);
            item.Retries = PortSettingsMainRetries.FromRead(read.Retries);
            item.SetCommunity = PortSettingsMainSetCommunity.FromRead(read.SetCommunity);
            item.SlowPoll = SlowPoll.FromRead(read.SlowPoll);
            item.SlowPollBase = SlowPollBase.FromRead(read.SlowPollBase);
            item.SSH = PortSettingsMainSSH.FromRead(read.SSH);
            item.Stopbits = PortSettingsMainStopbits.FromRead(read.Stopbits);
            item.TimeoutTimeElement = PortSettingsMainTimeoutTimeElement.FromRead(read.TimeoutTimeElement);
            item.TimeoutTime = PortSettingsMainTimeoutTime.FromRead(read.TimeoutTime);
            item.Type = PortSettingsMainType.FromRead(read.Type);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMain(this);
        }
    }

    ///<summary>
    /// Allows to limit baud rate settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial class PortSettingsMainBaudrate : EditableListNode<Read.IPortSettingsMainBaudrate, Read.IPortSettingsMainBaudrateValue, PortSettingsMainBaudrateValue>
    {
        internal PortSettingsMainBaudrate(Read.IPortSettingsMainBaudrate read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Baudrate node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBaudrate() : base("Baudrate")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsMainBaudrateRange _range;
        ///<summary>
        /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the baud rate can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible baud rate settings.
        ///</summary>
public PortSettingsMainBaudrateRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsMainBaudrateRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsMainBaudrateRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsMainBaudrate read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsMainBaudrateRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsMainBaudrate FromRead(Read.IPortSettingsMainBaudrate read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBaudrate();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsMainBaudrateRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsMainBaudrateValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrate(this);
        }
    }

    ///<summary>
    /// Specifies the default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
    ///</summary>
public partial class PortSettingsMainBaudrateDefaultValue : ElementValue<uint?>
    {
        internal PortSettingsMainBaudrateDefaultValue(Read.IPortSettingsMainBaudrateDefaultValue read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBaudrateDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsMainBaudrateDefaultValue(uint? value) : base(value)
        {
        }

        public static PortSettingsMainBaudrateDefaultValue FromRead(Read.IPortSettingsMainBaudrateDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBaudrateDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrateDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the baud rate can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsMainBaudrateDisabled : ElementValue<bool?>
    {
        internal PortSettingsMainBaudrateDisabled(Read.IPortSettingsMainBaudrateDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBaudrateDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsMainBaudrateDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsMainBaudrateDisabled FromRead(Read.IPortSettingsMainBaudrateDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBaudrateDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrateDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible baud rate settings.
    ///</summary>
public partial class PortSettingsMainBaudrateRange : EditableElementNode<Read.IPortSettingsMainBaudrateRange>
    {
        internal PortSettingsMainBaudrateRange(Read.IPortSettingsMainBaudrateRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBaudrateRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<uint?> _from;
        private ElementValue<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of baud rates.
        ///</summary>
public ElementValue<uint?> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of baud rates.
        ///</summary>
public ElementValue<uint?> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<uint?>();
            return From;
        }

        public ElementValue<uint?> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<uint?>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsMainBaudrateRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<uint?>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<uint?>(read.To, this) : null;
        }

        public static PortSettingsMainBaudrateRange FromRead(Read.IPortSettingsMainBaudrateRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBaudrateRange();
            item.From = ElementValue<uint?>.FromRead(read.From);
            item.To = ElementValue<uint?>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrateRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// The following wildcards can be used: * (a series of characters) and ? (one single character)
    ///</summary>
public partial class PortSettingsMainBaudrateValue : EditableElementValueNode<Read.IPortSettingsMainBaudrateValue, string>
    {
        internal PortSettingsMainBaudrateValue(Read.IPortSettingsMainBaudrateValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBaudrateValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsMainBaudrateValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IPortSettingsMainBaudrateValue read, XmlElement editNode)
        {
        }

        public static PortSettingsMainBaudrateValue FromRead(Read.IPortSettingsMainBaudrateValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBaudrateValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBaudrateValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus address settings and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial class PortSettingsMainBusAddress : EditableListNode<Read.IPortSettingsMainBusAddress, Read.IPortSettingsMainBusAddressValue, PortSettingsMainBusAddressValue>
    {
        internal PortSettingsMainBusAddress(Read.IPortSettingsMainBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsMainBusAddressRange _range;
        ///<summary>
        /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the bus address can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible bus addresses.
        ///</summary>
public PortSettingsMainBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsMainBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsMainBusAddressRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsMainBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsMainBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsMainBusAddress FromRead(Read.IPortSettingsMainBusAddress read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsMainBusAddressRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsMainBusAddressValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddress(this);
        }
    }

    ///<summary>
    /// Specifies a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
    /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
    ///</summary>
public partial class PortSettingsMainBusAddressDefaultValue : ElementValue<string>
    {
        internal PortSettingsMainBusAddressDefaultValue(Read.IPortSettingsMainBusAddressDefaultValue read, IEditableNode parent, bool useCDATA = false) : base(read, parent, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBusAddressDefaultValue(bool useCDATA = false) : base(useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsMainBusAddressDefaultValue(string value, bool useCDATA = false) : base(value, useCDATA: useCDATA)
        {
        }

        public static PortSettingsMainBusAddressDefaultValue FromRead(Read.IPortSettingsMainBusAddressDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBusAddressDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddressDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the bus address can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsMainBusAddressDisabled : ElementValue<bool?>
    {
        internal PortSettingsMainBusAddressDisabled(Read.IPortSettingsMainBusAddressDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBusAddressDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsMainBusAddressDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsMainBusAddressDisabled FromRead(Read.IPortSettingsMainBusAddressDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBusAddressDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddressDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible bus addresses.
    ///</summary>
public partial class PortSettingsMainBusAddressRange : EditableElementNode<Read.IPortSettingsMainBusAddressRange>
    {
        internal PortSettingsMainBusAddressRange(Read.IPortSettingsMainBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// Specifies the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsMainBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static PortSettingsMainBusAddressRange FromRead(Read.IPortSettingsMainBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddressRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class PortSettingsMainBusAddressValue : EditableElementValueNode<Read.IPortSettingsMainBusAddressValue, string>
    {
        internal PortSettingsMainBusAddressValue(Read.IPortSettingsMainBusAddressValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainBusAddressValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsMainBusAddressValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.IPortSettingsMainBusAddressValue read, XmlElement editNode)
        {
        }

        public static PortSettingsMainBusAddressValue FromRead(Read.IPortSettingsMainBusAddressValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainBusAddressValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainBusAddressValue(this);
        }
    }

    ///<summary>
    /// Allows to limit bus databit settings and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
public partial class PortSettingsMainDatabits : EditableListNode<Read.IPortSettingsMainDatabits, Read.IPortSettingsMainDatabitsValue, PortSettingsMainDatabitsValue>
    {
        internal PortSettingsMainDatabits(Read.IPortSettingsMainDatabits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Databits node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainDatabits() : base("Databits")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsMainDatabitsRange _range;
        ///<summary>
        /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the databits can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines a range of possible databit settings.
        ///</summary>
public PortSettingsMainDatabitsRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsMainDatabitsRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsMainDatabitsRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsMainDatabits read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsMainDatabitsRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsMainDatabits FromRead(Read.IPortSettingsMainDatabits read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainDatabits();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsMainDatabitsRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsMainDatabitsValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabits(this);
        }
    }

    ///<summary>
    /// Specifies the default number of data bits. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
    ///</summary>
public partial class PortSettingsMainDatabitsDefaultValue : ElementValue<string>
    {
        internal PortSettingsMainDatabitsDefaultValue(Read.IPortSettingsMainDatabitsDefaultValue read, IEditableNode parent, bool useCDATA = false) : base(read, parent, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainDatabitsDefaultValue(bool useCDATA = false) : base(useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsMainDatabitsDefaultValue(string value, bool useCDATA = false) : base(value, useCDATA: useCDATA)
        {
        }

        public static PortSettingsMainDatabitsDefaultValue FromRead(Read.IPortSettingsMainDatabitsDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainDatabitsDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabitsDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the databits can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsMainDatabitsDisabled : ElementValue<bool?>
    {
        internal PortSettingsMainDatabitsDisabled(Read.IPortSettingsMainDatabitsDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainDatabitsDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsMainDatabitsDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsMainDatabitsDisabled FromRead(Read.IPortSettingsMainDatabitsDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainDatabitsDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabitsDisabled(this);
        }
    }

    ///<summary>
    /// Defines a range of possible databit settings.
    ///</summary>
public partial class PortSettingsMainDatabitsRange : EditableElementNode<Read.IPortSettingsMainDatabitsRange>
    {
        internal PortSettingsMainDatabitsRange(Read.IPortSettingsMainDatabitsRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainDatabitsRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<uint?> _from;
        private ElementValue<uint?> _to;
        ///<summary>
        /// Specifies the first of a range of databits.
        ///</summary>
public ElementValue<uint?> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of databits.
        ///</summary>
public ElementValue<uint?> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<uint?>();
            return From;
        }

        public ElementValue<uint?> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<uint?>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsMainDatabitsRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<uint?>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<uint?>(read.To, this) : null;
        }

        public static PortSettingsMainDatabitsRange FromRead(Read.IPortSettingsMainDatabitsRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainDatabitsRange();
            item.From = ElementValue<uint?>.FromRead(read.From);
            item.To = ElementValue<uint?>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabitsRange(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class PortSettingsMainDatabitsValue : EditableElementValueNode<Read.IPortSettingsMainDatabitsValue, uint?>
    {
        internal PortSettingsMainDatabitsValue(Read.IPortSettingsMainDatabitsValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainDatabitsValue() : base("Value")
        {
            OnCreated();
        }

        public PortSettingsMainDatabitsValue(uint? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IPortSettingsMainDatabitsValue read, XmlElement editNode)
        {
        }

        public static PortSettingsMainDatabitsValue FromRead(Read.IPortSettingsMainDatabitsValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainDatabitsValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainDatabitsValue(this);
        }
    }

    ///<summary>
    /// Allows to limit flow control settings and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
public partial class PortSettingsMainFlowcontrol : EditableListNode<Read.IPortSettingsMainFlowcontrol, Read.IPortSettingsMainFlowcontrolValue, PortSettingsMainFlowcontrolValue>
    {
        internal PortSettingsMainFlowcontrol(Read.IPortSettingsMainFlowcontrol read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Flowcontrol node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainFlowcontrol() : base("Flowcontrol")
        {
            OnCreated();
        }

        private PortSettingsMainFlowcontrolDefaultValue _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsMainFlowcontrolRange _range;
        ///<summary>
        /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
public PortSettingsMainFlowcontrolDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the flow control can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines the range of possible flow control values.
        ///</summary>
public PortSettingsMainFlowcontrolRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public PortSettingsMainFlowcontrolDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new PortSettingsMainFlowcontrolDefaultValue();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsMainFlowcontrolRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsMainFlowcontrolRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsMainFlowcontrol read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new PortSettingsMainFlowcontrolDefaultValue(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsMainFlowcontrolRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsMainFlowcontrol FromRead(Read.IPortSettingsMainFlowcontrol read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainFlowcontrol();
            item.DefaultValue = PortSettingsMainFlowcontrolDefaultValue.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsMainFlowcontrolRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsMainFlowcontrolValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrol(this);
        }
    }

    ///<summary>
    /// Specifies the default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
    ///</summary>
public partial class PortSettingsMainFlowcontrolDefaultValue : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsMainFlowcontrolDefaultValue(Read.IPortSettingsMainFlowcontrolDefaultValue read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainFlowcontrolDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsMainFlowcontrolDefaultValue(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        public static PortSettingsMainFlowcontrolDefaultValue FromRead(Read.IPortSettingsMainFlowcontrolDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainFlowcontrolDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrolDefaultValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies whether the flow control can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsMainFlowcontrolDisabled : ElementValue<bool?>
    {
        internal PortSettingsMainFlowcontrolDisabled(Read.IPortSettingsMainFlowcontrolDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainFlowcontrolDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsMainFlowcontrolDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsMainFlowcontrolDisabled FromRead(Read.IPortSettingsMainFlowcontrolDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainFlowcontrolDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrolDisabled(this);
        }
    }

    ///<summary>
    /// Defines the range of possible flow control values.
    ///</summary>
public partial class PortSettingsMainFlowcontrolRange : EditableElementNode<Read.IPortSettingsMainFlowcontrolRange>
    {
        internal PortSettingsMainFlowcontrolRange(Read.IPortSettingsMainFlowcontrolRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainFlowcontrolRange() : base("Range")
        {
            OnCreated();
        }

        private PortSettingsMainFlowcontrolRangeFrom _from;
        private PortSettingsMainFlowcontrolRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of flow control values.
        ///</summary>
public PortSettingsMainFlowcontrolRangeFrom From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of flow control values.
        ///</summary>
public PortSettingsMainFlowcontrolRangeTo To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public PortSettingsMainFlowcontrolRangeFrom GetOrCreateFrom()
        {
            if (From == null)
                From = new PortSettingsMainFlowcontrolRangeFrom();
            return From;
        }

        public PortSettingsMainFlowcontrolRangeTo GetOrCreateTo()
        {
            if (To == null)
                To = new PortSettingsMainFlowcontrolRangeTo();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsMainFlowcontrolRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new PortSettingsMainFlowcontrolRangeFrom(read.From, this) : null;
            _to = read.To != null ? new PortSettingsMainFlowcontrolRangeTo(read.To, this) : null;
        }

        public static PortSettingsMainFlowcontrolRange FromRead(Read.IPortSettingsMainFlowcontrolRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainFlowcontrolRange();
            item.From = PortSettingsMainFlowcontrolRangeFrom.FromRead(read.From);
            item.To = PortSettingsMainFlowcontrolRangeTo.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrolRange(this);
        }
    }

    public partial class PortSettingsMainFlowcontrolRangeFrom : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsMainFlowcontrolRangeFrom(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a From node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainFlowcontrolRangeFrom() : base()
        {
            OnCreated();
        }

        public PortSettingsMainFlowcontrolRangeFrom(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsMainFlowcontrolRangeFrom FromRead(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainFlowcontrolRangeFrom();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class PortSettingsMainFlowcontrolRangeTo : ElementValue<Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsMainFlowcontrolRangeTo(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a To node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainFlowcontrolRangeTo() : base()
        {
            OnCreated();
        }

        public PortSettingsMainFlowcontrolRangeTo(Enums.EnumPortSettingsFlowControl? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsMainFlowcontrolRangeTo FromRead(Read.IValueTag<Enums.EnumPortSettingsFlowControl?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainFlowcontrolRangeTo();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    ///</summary>
public partial class PortSettingsMainFlowcontrolValue : EditableElementValueNode<Read.IPortSettingsMainFlowcontrolValue, Enums.EnumPortSettingsFlowControl?>
    {
        internal PortSettingsMainFlowcontrolValue(Read.IPortSettingsMainFlowcontrolValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainFlowcontrolValue() : base("Value")
        {
            OnCreated();
        }

        public PortSettingsMainFlowcontrolValue(Enums.EnumPortSettingsFlowControl? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IPortSettingsMainFlowcontrolValue read, XmlElement editNode)
        {
        }

        public static PortSettingsMainFlowcontrolValue FromRead(Read.IPortSettingsMainFlowcontrolValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainFlowcontrolValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainFlowcontrolValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsFlowControlConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsFlowControl? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsFlowControlConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies the GetCommunity string of an SNMP protocol.
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
public partial class PortSettingsMainGetCommunity : EditableElementNode<Read.IPortSettingsMainGetCommunity>
    {
        internal PortSettingsMainGetCommunity(Read.IPortSettingsMainGetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a GetCommunity node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainGetCommunity() : base("GetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value of the GetCommunity string that will be used in the DataMiner user interface for SNMP protocols.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the get community string can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainGetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainGetCommunity FromRead(Read.IPortSettingsMainGetCommunity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainGetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainGetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies the IP port configuration.
    ///</summary>
public partial class PortSettingsMainIPport : EditableElementNode<Read.IPortSettingsMainIPport>
    {
        internal PortSettingsMainIPport(Read.IPortSettingsMainIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the port number can be configured via the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainIPport FromRead(Read.IPortSettingsMainIPport read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainIPport(this);
        }
    }

    ///<summary>
    /// Specifies the local IP port configuration.
    ///</summary>
public partial class PortSettingsMainLocalIPport : EditableElementNode<Read.IPortSettingsMainLocalIPport>
    {
        internal PortSettingsMainLocalIPport(Read.IPortSettingsMainLocalIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LocalIPport node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainLocalIPport() : base("LocalIPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the local port number can be configured via the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainLocalIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainLocalIPport FromRead(Read.IPortSettingsMainLocalIPport read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainLocalIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainLocalIPport(this);
        }
    }

    ///<summary>
    /// Allows to limit parity settings and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
public partial class PortSettingsMainParity : EditableListNode<Read.IPortSettingsMainParity, Read.IPortSettingsMainParityValue, PortSettingsMainParityValue>
    {
        internal PortSettingsMainParity(Read.IPortSettingsMainParity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Parity node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainParity() : base("Parity")
        {
            OnCreated();
        }

        private PortSettingsMainParityDefaultValue _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsMainParityRange _range;
        ///<summary>
        /// Specifies the default parity.
        ///</summary>
public PortSettingsMainParityDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the parity can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// Defines the range of possible parity values.
        ///</summary>
public PortSettingsMainParityRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        public PortSettingsMainParityDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new PortSettingsMainParityDefaultValue();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsMainParityRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsMainParityRange();
            return Range;
        }

        protected override void Initialize(Read.IPortSettingsMainParity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new PortSettingsMainParityDefaultValue(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsMainParityRange(read.Range, this, editNode.Element["Range"]) : null;
        }

        public static PortSettingsMainParity FromRead(Read.IPortSettingsMainParity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainParity();
            item.DefaultValue = PortSettingsMainParityDefaultValue.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsMainParityRange.FromRead(read.Range);
            foreach (var x in read)
            {
                item.Add(PortSettingsMainParityValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParity(this);
        }
    }

    ///<summary>
    /// Specifies the default parity.
    ///</summary>
public partial class PortSettingsMainParityDefaultValue : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsMainParityDefaultValue(Read.IPortSettingsMainParityDefaultValue read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainParityDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsMainParityDefaultValue(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        public static PortSettingsMainParityDefaultValue FromRead(Read.IPortSettingsMainParityDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainParityDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParityDefaultValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies whether the parity can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsMainParityDisabled : ElementValue<bool?>
    {
        internal PortSettingsMainParityDisabled(Read.IPortSettingsMainParityDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainParityDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsMainParityDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsMainParityDisabled FromRead(Read.IPortSettingsMainParityDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainParityDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParityDisabled(this);
        }
    }

    ///<summary>
    /// Defines the range of possible parity values.
    ///</summary>
public partial class PortSettingsMainParityRange : EditableElementNode<Read.IPortSettingsMainParityRange>
    {
        internal PortSettingsMainParityRange(Read.IPortSettingsMainParityRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainParityRange() : base("Range")
        {
            OnCreated();
        }

        private PortSettingsMainParityRangeFrom _from;
        private PortSettingsMainParityRangeTo _to;
        ///<summary>
        /// Specifies the first of a range of parity values.
        ///</summary>
public PortSettingsMainParityRangeFrom From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// Specifies the last of a range of parity values.
        ///</summary>
public PortSettingsMainParityRangeTo To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public PortSettingsMainParityRangeFrom GetOrCreateFrom()
        {
            if (From == null)
                From = new PortSettingsMainParityRangeFrom();
            return From;
        }

        public PortSettingsMainParityRangeTo GetOrCreateTo()
        {
            if (To == null)
                To = new PortSettingsMainParityRangeTo();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsMainParityRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new PortSettingsMainParityRangeFrom(read.From, this) : null;
            _to = read.To != null ? new PortSettingsMainParityRangeTo(read.To, this) : null;
        }

        public static PortSettingsMainParityRange FromRead(Read.IPortSettingsMainParityRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainParityRange();
            item.From = PortSettingsMainParityRangeFrom.FromRead(read.From);
            item.To = PortSettingsMainParityRangeTo.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParityRange(this);
        }
    }

    public partial class PortSettingsMainParityRangeFrom : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsMainParityRangeFrom(Read.IValueTag<Enums.EnumPortSettingsParity?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a From node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainParityRangeFrom() : base()
        {
            OnCreated();
        }

        public PortSettingsMainParityRangeFrom(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsMainParityRangeFrom FromRead(Read.IValueTag<Enums.EnumPortSettingsParity?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainParityRangeFrom();
            item.Value = read.Value;
            return item;
        }
    }

    public partial class PortSettingsMainParityRangeTo : ElementValue<Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsMainParityRangeTo(Read.IValueTag<Enums.EnumPortSettingsParity?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a To node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainParityRangeTo() : base()
        {
            OnCreated();
        }

        public PortSettingsMainParityRangeTo(Enums.EnumPortSettingsParity? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsMainParityRangeTo FromRead(Read.IValueTag<Enums.EnumPortSettingsParity?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainParityRangeTo();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies a supported parity setting.
    /// Note:
    /// - The value specified in DefaultValue does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
    ///</summary>
public partial class PortSettingsMainParityValue : EditableElementValueNode<Read.IPortSettingsMainParityValue, Enums.EnumPortSettingsParity?>
    {
        internal PortSettingsMainParityValue(Read.IPortSettingsMainParityValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainParityValue() : base("Value")
        {
            OnCreated();
        }

        public PortSettingsMainParityValue(Enums.EnumPortSettingsParity? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IPortSettingsMainParityValue read, XmlElement editNode)
        {
        }

        public static PortSettingsMainParityValue FromRead(Read.IPortSettingsMainParityValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainParityValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainParityValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsParityConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsParity? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsParityConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies settings related to the TCP/IP port type.
    ///</summary>
public partial class PortSettingsMainPortTypeIP : EditableElementNode<Read.IPortSettingsMainPortTypeIP>
    {
        internal PortSettingsMainPortTypeIP(Read.IPortSettingsMainPortTypeIP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeIP node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainPortTypeIP() : base("PortTypeIP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type TCP/IP can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainPortTypeIP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainPortTypeIP FromRead(Read.IPortSettingsMainPortTypeIP read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainPortTypeIP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainPortTypeIP(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the serial port type.
    ///</summary>
public partial class PortSettingsMainPortTypeSerial : EditableElementNode<Read.IPortSettingsMainPortTypeSerial>
    {
        internal PortSettingsMainPortTypeSerial(Read.IPortSettingsMainPortTypeSerial read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeSerial node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainPortTypeSerial() : base("PortTypeSerial")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type serial can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainPortTypeSerial read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainPortTypeSerial FromRead(Read.IPortSettingsMainPortTypeSerial read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainPortTypeSerial();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainPortTypeSerial(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the UDP/IP port type.
    ///</summary>
public partial class PortSettingsMainPortTypeUDP : EditableElementNode<Read.IPortSettingsMainPortTypeUDP>
    {
        internal PortSettingsMainPortTypeUDP(Read.IPortSettingsMainPortTypeUDP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeUDP node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainPortTypeUDP() : base("PortTypeUDP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies whether the port type UDP/IP can be selected in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainPortTypeUDP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainPortTypeUDP FromRead(Read.IPortSettingsMainPortTypeUDP read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainPortTypeUDP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainPortTypeUDP(this);
        }
    }

    ///<summary>
    /// Configures the number of retries.
    ///</summary>
public partial class PortSettingsMainRetries : EditableElementNode<Read.IPortSettingsMainRetries>
    {
        internal PortSettingsMainRetries(Read.IPortSettingsMainRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value for the maximum number of times that a request will be re-sent.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the maximum number of retries can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainRetries FromRead(Read.IPortSettingsMainRetries read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainRetries();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainRetries(this);
        }
    }

    ///<summary>
    /// Specifies the SNMP set community string.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
public partial class PortSettingsMainSetCommunity : EditableElementNode<Read.IPortSettingsMainSetCommunity>
    {
        internal PortSettingsMainSetCommunity(Read.IPortSettingsMainSetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SetCommunity node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainSetCommunity() : base("SetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default value of the SNMP set community string that will be used.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the SetCommunity string can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainSetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainSetCommunity FromRead(Read.IPortSettingsMainSetCommunity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainSetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies the SSH settings (only applicable for serial connections of type TCP).
    /// Feature introduced in DataMiner 9.5.9 (RN 17732).
    ///</summary>
public partial class PortSettingsMainSSH : EditableElementNode<Read.IPortSettingsMainSSH>
    {
        internal PortSettingsMainSSH(Read.IPortSettingsMainSSH read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SSH node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainSSH() : base("SSH")
        {
            OnCreated();
        }

        private PortSettingsMainSSHCredentials _credentials;
        private PortSettingsMainSSHIdentity _identity;
        ///<summary>
        /// Specifies the SSH credentials.
        ///</summary>
public PortSettingsMainSSHCredentials Credentials
        {
            get
            {
                return _credentials;
            }

            set
            {
                if (_credentials != value)
                {
                    _credentials = value;
                    CombinedTagHandler.Assign(value, this, "Credentials");
                }
            }
        }

        ///<summary>
        /// Specifies the identity settings.
        ///</summary>
public PortSettingsMainSSHIdentity Identity
        {
            get
            {
                return _identity;
            }

            set
            {
                if (_identity != value)
                {
                    _identity = value;
                    CombinedTagHandler.Assign(value, this, "Identity");
                }
            }
        }

        public PortSettingsMainSSHCredentials GetOrCreateCredentials()
        {
            if (Credentials == null)
                Credentials = new PortSettingsMainSSHCredentials();
            return Credentials;
        }

        public PortSettingsMainSSHIdentity GetOrCreateIdentity()
        {
            if (Identity == null)
                Identity = new PortSettingsMainSSHIdentity();
            return Identity;
        }

        protected override void Initialize(Read.IPortSettingsMainSSH read, XmlElement editNode)
        {
            if (read == null)
                return;
            _credentials = read.Credentials != null ? new PortSettingsMainSSHCredentials(read.Credentials, this, editNode.Element["Credentials"]) : null;
            _identity = read.Identity != null ? new PortSettingsMainSSHIdentity(read.Identity, this, editNode.Element["Identity"]) : null;
        }

        public static PortSettingsMainSSH FromRead(Read.IPortSettingsMainSSH read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainSSH();
            item.Credentials = PortSettingsMainSSHCredentials.FromRead(read.Credentials);
            item.Identity = PortSettingsMainSSHIdentity.FromRead(read.Identity);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSH(this);
        }
    }

    ///<summary>
    /// Specifies the SSH credentials.
    ///</summary>
public partial class PortSettingsMainSSHCredentials : EditableElementNode<Read.IPortSettingsMainSSHCredentials>
    {
        internal PortSettingsMainSSHCredentials(Read.IPortSettingsMainSSHCredentials read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Credentials node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainSSHCredentials() : base("Credentials")
        {
            OnCreated();
        }

        private PortSettingsMainSSHCredentialsUsername _username;
        private PortSettingsMainSSHCredentialsPassword _password;
        ///<summary>
        /// Specifies the user name.
        ///</summary>
public PortSettingsMainSSHCredentialsUsername Username
        {
            get
            {
                return _username;
            }

            set
            {
                if (_username != value)
                {
                    _username = value;
                    CombinedTagHandler.Assign(value, this, "Username");
                }
            }
        }

        ///<summary>
        /// Specifies the password.
        ///</summary>
public PortSettingsMainSSHCredentialsPassword Password
        {
            get
            {
                return _password;
            }

            set
            {
                if (_password != value)
                {
                    _password = value;
                    CombinedTagHandler.Assign(value, this, "Password");
                }
            }
        }

        public PortSettingsMainSSHCredentialsUsername GetOrCreateUsername()
        {
            if (Username == null)
                Username = new PortSettingsMainSSHCredentialsUsername();
            return Username;
        }

        public PortSettingsMainSSHCredentialsPassword GetOrCreatePassword()
        {
            if (Password == null)
                Password = new PortSettingsMainSSHCredentialsPassword();
            return Password;
        }

        protected override void Initialize(Read.IPortSettingsMainSSHCredentials read, XmlElement editNode)
        {
            if (read == null)
                return;
            _username = read.Username != null ? new PortSettingsMainSSHCredentialsUsername(read.Username, this, editNode.Element["Username"]) : null;
            _password = read.Password != null ? new PortSettingsMainSSHCredentialsPassword(read.Password, this, editNode.Element["Password"]) : null;
        }

        public static PortSettingsMainSSHCredentials FromRead(Read.IPortSettingsMainSSHCredentials read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainSSHCredentials();
            item.Username = PortSettingsMainSSHCredentialsUsername.FromRead(read.Username);
            item.Password = PortSettingsMainSSHCredentialsPassword.FromRead(read.Password);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSHCredentials(this);
        }
    }

    ///<summary>
    /// Specifies the user name.
    ///</summary>
public partial class PortSettingsMainSSHCredentialsUsername : EditableElementNode<Read.IPortSettingsMainSSHCredentialsUsername>
    {
        internal PortSettingsMainSSHCredentialsUsername(Read.IPortSettingsMainSSHCredentialsUsername read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Username node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainSSHCredentialsUsername() : base("Username")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the user name.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IPortSettingsMainSSHCredentialsUsername read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static PortSettingsMainSSHCredentialsUsername FromRead(Read.IPortSettingsMainSSHCredentialsUsername read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainSSHCredentialsUsername();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSHCredentialsUsername(this);
        }
    }

    ///<summary>
    /// Specifies the password.
    ///</summary>
public partial class PortSettingsMainSSHCredentialsPassword : EditableElementNode<Read.IPortSettingsMainSSHCredentialsPassword>
    {
        internal PortSettingsMainSSHCredentialsPassword(Read.IPortSettingsMainSSHCredentialsPassword read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Password node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainSSHCredentialsPassword() : base("Password")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the password.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IPortSettingsMainSSHCredentialsPassword read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static PortSettingsMainSSHCredentialsPassword FromRead(Read.IPortSettingsMainSSHCredentialsPassword read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainSSHCredentialsPassword();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSHCredentialsPassword(this);
        }
    }

    ///<summary>
    /// Specifies the identity settings.
    ///</summary>
public partial class PortSettingsMainSSHIdentity : EditableElementNode<Read.IPortSettingsMainSSHIdentity>
    {
        internal PortSettingsMainSSHIdentity(Read.IPortSettingsMainSSHIdentity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Identity node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainSSHIdentity() : base("Identity")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the ID of the parameter that holds the identity info.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.IPortSettingsMainSSHIdentity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static PortSettingsMainSSHIdentity FromRead(Read.IPortSettingsMainSSHIdentity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainSSHIdentity();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainSSHIdentity(this);
        }
    }

    ///<summary>
    /// Specifies the stop bits settings.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
public partial class PortSettingsMainStopbits : EditableListNode<Read.IPortSettingsMainStopbits, Read.IPortSettingsMainStopbitsValue, PortSettingsMainStopbitsValue>
    {
        internal PortSettingsMainStopbits(Read.IPortSettingsMainStopbits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Stopbits node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainStopbits() : base("Stopbits")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values: 1, 1.5 or 2
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainStopbits read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainStopbits FromRead(Read.IPortSettingsMainStopbits read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainStopbits();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            foreach (var x in read)
            {
                item.Add(PortSettingsMainStopbitsValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainStopbits(this);
        }
    }

    ///<summary>
    /// Specifies the default number of stop bits. Each time a user adds an element using the element wizard, the stopbits setting will by default be set to this value.
    /// Set the default to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial class PortSettingsMainStopbitsDefaultValue : ElementValue<string>
    {
        internal PortSettingsMainStopbitsDefaultValue(Read.IPortSettingsMainStopbitsDefaultValue read, IEditableNode parent, bool useCDATA = false) : base(read, parent, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainStopbitsDefaultValue(bool useCDATA = false) : base(useCDATA: useCDATA)
        {
            OnCreated();
        }

        public PortSettingsMainStopbitsDefaultValue(string value, bool useCDATA = false) : base(value, useCDATA: useCDATA)
        {
        }

        public static PortSettingsMainStopbitsDefaultValue FromRead(Read.IPortSettingsMainStopbitsDefaultValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainStopbitsDefaultValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainStopbitsDefaultValue(this);
        }
    }

    ///<summary>
    /// Specifies whether the number of stop bits can be modified in the DataMiner user interface.
    ///</summary>
public partial class PortSettingsMainStopbitsDisabled : ElementValue<bool?>
    {
        internal PortSettingsMainStopbitsDisabled(Read.IPortSettingsMainStopbitsDisabled read, IEditableNode parent) : base(read, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Disabled node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainStopbitsDisabled() : base()
        {
            OnCreated();
        }

        public PortSettingsMainStopbitsDisabled(bool? value) : base(value)
        {
        }

        public static PortSettingsMainStopbitsDisabled FromRead(Read.IPortSettingsMainStopbitsDisabled read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainStopbitsDisabled();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainStopbitsDisabled(this);
        }
    }

    ///<summary>
    /// Using one or more Value elements, you can specify the different values that users are allowed to enter.
    /// Note:
    /// - The value specified in the DefaultValue element does not have to be specified in a Value element.
    /// - When no Value elements are specified, users will only be allowed to enter the value specified in the DefaultValue element.
    /// Set Value to one of the following integer values: 1, 1.5 or 2
    ///</summary>
public partial class PortSettingsMainStopbitsValue : EditableElementValueNode<Read.IPortSettingsMainStopbitsValue, Enums.EnumPortSettingsStopBits?>
    {
        internal PortSettingsMainStopbitsValue(Read.IPortSettingsMainStopbitsValue read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainStopbitsValue() : base("Value")
        {
            OnCreated();
        }

        public PortSettingsMainStopbitsValue(Enums.EnumPortSettingsStopBits? value) : base("Value", value)
        {
        }

        protected override void Initialize(Read.IPortSettingsMainStopbitsValue read, XmlElement editNode)
        {
        }

        public static PortSettingsMainStopbitsValue FromRead(Read.IPortSettingsMainStopbitsValue read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainStopbitsValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainStopbitsValue(this);
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortSettingsStopBitsConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortSettingsStopBits? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortSettingsStopBitsConverter.Convert(rawValue?.Trim());
        }
    }

    ///<summary>
    /// Specifies settings related to the element timeout.
    ///</summary>
public partial class PortSettingsMainTimeoutTimeElement : EditableElementNode<Read.IPortSettingsMainTimeoutTimeElement>
    {
        internal PortSettingsMainTimeoutTimeElement(Read.IPortSettingsMainTimeoutTimeElement read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTimeElement node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainTimeoutTimeElement() : base("TimeoutTimeElement")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default element timeout value (in milliseconds). The specified value must be in the range [1000, 120000] and should be a multiple of 1000 as the resolution is in seconds.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the element timeout time for this connection can be configured via the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainTimeoutTimeElement read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainTimeoutTimeElement FromRead(Read.IPortSettingsMainTimeoutTimeElement read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainTimeoutTimeElement();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainTimeoutTimeElement(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the timeout of a command/request.
    ///</summary>
public partial class PortSettingsMainTimeoutTime : EditableElementNode<Read.IPortSettingsMainTimeoutTime>
    {
        internal PortSettingsMainTimeoutTime(Read.IPortSettingsMainTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default timeout value (in milliseconds).
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the timeout value can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsMainTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsMainTimeoutTime FromRead(Read.IPortSettingsMainTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainTimeoutTime();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainTimeoutTime(this);
        }
    }

    ///<summary>
    /// Specifies the port type settings.
    ///</summary>
public partial class PortSettingsMainType : EditableElementNode<Read.IPortSettingsMainType>
    {
        internal PortSettingsMainType(Read.IPortSettingsMainType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainType() : base("Type")
        {
            OnCreated();
        }

        private PortSettingsMainTypeDefaultValue _defaultValue;
        ///<summary>
        /// Specifies the default port type.
        ///</summary>
public PortSettingsMainTypeDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public PortSettingsMainTypeDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new PortSettingsMainTypeDefaultValue();
            return DefaultValue;
        }

        protected override void Initialize(Read.IPortSettingsMainType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new PortSettingsMainTypeDefaultValue(read.DefaultValue, this) : null;
        }

        public static PortSettingsMainType FromRead(Read.IPortSettingsMainType read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainType();
            item.DefaultValue = PortSettingsMainTypeDefaultValue.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsMainType(this);
        }
    }

    public partial class PortSettingsMainTypeDefaultValue : ElementValue<Enums.EnumPortTypes?>
    {
        internal PortSettingsMainTypeDefaultValue(Read.IValueTag<Enums.EnumPortTypes?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsMainTypeDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsMainTypeDefaultValue(Enums.EnumPortTypes? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortTypesConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsMainTypeDefaultValue FromRead(Read.IValueTag<Enums.EnumPortTypes?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsMainTypeDefaultValue();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Defines port settings with values.
    ///</summary>
public partial class PortSettingsWithValues : EditableElementNode<Read.IPortSettingsWithValues>
    {
        internal PortSettingsWithValues(Read.IPortSettingsWithValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortSettingsWithValues node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValues(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private PortSettingsWithValuesBaudrate _baudrate;
        private PortSettingsWithValuesBusAddress _busAddress;
        private PortSettingsWithValuesDatabits _databits;
        private PortSettingsWithValuesFlowcontrol _flowcontrol;
        private PortSettingsWithValuesGetCommunity _getCommunity;
        private PortSettingsWithValuesIPport _iPport;
        private PortSettingsWithValuesLocalIPport _localIPport;
        private PortSettingsWithValuesParity _parity;
        private PingInterval _pingInterval;
        private PortSettingsWithValuesPortTypeIP _portTypeIP;
        private PortSettingsWithValuesPortTypeSerial _portTypeSerial;
        private PortSettingsWithValuesPortTypeUDP _portTypeUDP;
        private PortSettingsWithValuesRetries _retries;
        private PortSettingsWithValuesSetCommunity _setCommunity;
        private SlowPoll _slowPoll;
        private SlowPoll _slowPollBase;
        private PortSettingsWithValuesStopbits _stopbits;
        private SlowPoll _timeoutTimeElement;
        private PortSettingsWithValuesTimeoutTime _timeoutTime;
        private PortSettingsWithValuesType _type;
        private AttributeValue<string> _name;
        private AttributeValue<bool?> _visibleInUi;
        ///<summary>
        /// This tag allows you to limit the baud rate settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public PortSettingsWithValuesBaudrate Baudrate
        {
            get
            {
                return _baudrate;
            }

            set
            {
                if (_baudrate != value)
                {
                    _baudrate = value;
                    CombinedTagHandler.Assign(value, this, "Baudrate");
                }
            }
        }

        ///<summary>
        /// This tag allows you to limit the bus address settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
        ///</summary>
public PortSettingsWithValuesBusAddress BusAddress
        {
            get
            {
                return _busAddress;
            }

            set
            {
                if (_busAddress != value)
                {
                    _busAddress = value;
                    CombinedTagHandler.Assign(value, this, "BusAddress");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify the possible databits settings, and to define a default value.
        /// For SNMPv3, this contains the User Name.
        ///</summary>
public PortSettingsWithValuesDatabits Databits
        {
            get
            {
                return _databits;
            }

            set
            {
                if (_databits != value)
                {
                    _databits = value;
                    CombinedTagHandler.Assign(value, this, "Databits");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify the possible flow control settings, and to define a default value.
        /// For SNMPv3, this contains the Encryption Algorithm.
        ///</summary>
public PortSettingsWithValuesFlowcontrol Flowcontrol
        {
            get
            {
                return _flowcontrol;
            }

            set
            {
                if (_flowcontrol != value)
                {
                    _flowcontrol = value;
                    CombinedTagHandler.Assign(value, this, "Flowcontrol");
                }
            }
        }

        ///<summary>
        /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
        /// For SNMPv3, this contains the Authentication Password
        ///</summary>
public PortSettingsWithValuesGetCommunity GetCommunity
        {
            get
            {
                return _getCommunity;
            }

            set
            {
                if (_getCommunity != value)
                {
                    _getCommunity = value;
                    CombinedTagHandler.Assign(value, this, "GetCommunity");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the port.
        ///</summary>
public PortSettingsWithValuesIPport IPport
        {
            get
            {
                return _iPport;
            }

            set
            {
                if (_iPport != value)
                {
                    _iPport = value;
                    CombinedTagHandler.Assign(value, this, "IPport");
                }
            }
        }

        ///<summary>
        /// Specifies settings related to the local port.
        ///</summary>
public PortSettingsWithValuesLocalIPport LocalIPport
        {
            get
            {
                return _localIPport;
            }

            set
            {
                if (_localIPport != value)
                {
                    _localIPport = value;
                    CombinedTagHandler.Assign(value, this, "LocalIPport");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify the possible parity settings, and to define a default value.
        /// For SNMPv3, this contains the Authentication Algorithm.
        ///</summary>
public PortSettingsWithValuesParity Parity
        {
            get
            {
                return _parity;
            }

            set
            {
                if (_parity != value)
                {
                    _parity = value;
                    CombinedTagHandler.Assign(value, this, "Parity");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public PingInterval PingInterval
        {
            get
            {
                return _pingInterval;
            }

            set
            {
                if (_pingInterval != value)
                {
                    _pingInterval = value;
                    CombinedTagHandler.Assign(value, this, "PingInterval");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public PortSettingsWithValuesPortTypeIP PortTypeIP
        {
            get
            {
                return _portTypeIP;
            }

            set
            {
                if (_portTypeIP != value)
                {
                    _portTypeIP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeIP");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public PortSettingsWithValuesPortTypeSerial PortTypeSerial
        {
            get
            {
                return _portTypeSerial;
            }

            set
            {
                if (_portTypeSerial != value)
                {
                    _portTypeSerial = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeSerial");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public PortSettingsWithValuesPortTypeUDP PortTypeUDP
        {
            get
            {
                return _portTypeUDP;
            }

            set
            {
                if (_portTypeUDP != value)
                {
                    _portTypeUDP = value;
                    CombinedTagHandler.Assign(value, this, "PortTypeUDP");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public PortSettingsWithValuesRetries Retries
        {
            get
            {
                return _retries;
            }

            set
            {
                if (_retries != value)
                {
                    _retries = value;
                    CombinedTagHandler.Assign(value, this, "Retries");
                }
            }
        }

        ///<summary>
        /// SetCommunity string for SNMP and SNMPv2 communication.
        /// For SNMPv3, this contains the Encryption Password.
        ///</summary>
public PortSettingsWithValuesSetCommunity SetCommunity
        {
            get
            {
                return _setCommunity;
            }

            set
            {
                if (_setCommunity != value)
                {
                    _setCommunity = value;
                    CombinedTagHandler.Assign(value, this, "SetCommunity");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public SlowPoll SlowPoll
        {
            get
            {
                return _slowPoll;
            }

            set
            {
                if (_slowPoll != value)
                {
                    _slowPoll = value;
                    CombinedTagHandler.Assign(value, this, "SlowPoll");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public SlowPoll SlowPollBase
        {
            get
            {
                return _slowPollBase;
            }

            set
            {
                if (_slowPollBase != value)
                {
                    _slowPollBase = value;
                    CombinedTagHandler.Assign(value, this, "SlowPollBase");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify the possible stopbits settings, and to define a default value.
        /// For SNMPv3, this contains the Security Level.
        ///</summary>
public PortSettingsWithValuesStopbits Stopbits
        {
            get
            {
                return _stopbits;
            }

            set
            {
                if (_stopbits != value)
                {
                    _stopbits = value;
                    CombinedTagHandler.Assign(value, this, "Stopbits");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public SlowPoll TimeoutTimeElement
        {
            get
            {
                return _timeoutTimeElement;
            }

            set
            {
                if (_timeoutTimeElement != value)
                {
                    _timeoutTimeElement = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTimeElement");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public PortSettingsWithValuesTimeoutTime TimeoutTime
        {
            get
            {
                return _timeoutTime;
            }

            set
            {
                if (_timeoutTime != value)
                {
                    _timeoutTime = value;
                    CombinedTagHandler.Assign(value, this, "TimeoutTime");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public PortSettingsWithValuesType Type
        {
            get
            {
                return _type;
            }

            set
            {
                if (_type != value)
                {
                    _type = value;
                    CombinedTagHandler.Assign(value, this, "Type");
                }
            }
        }

        ///<summary>
        /// Name of the port to which the port settings apply
        /// OR
        /// The name of the additional Protocol type as specified in the /Protocol/Type@advanced attribute.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// If you set this attribute to "false", users cannot see or change the port settings for this additional protocol type when creating or editing an element.
        ///</summary>
public AttributeValue<bool?> VisibleInUi
        {
            get
            {
                return _visibleInUi;
            }

            set
            {
                if (_visibleInUi != value)
                {
                    _visibleInUi = value;
                    AttributeHandler.Assign(value, this, "visibleInUi");
                }
            }
        }

        public PortSettingsWithValuesBaudrate GetOrCreateBaudrate()
        {
            if (Baudrate == null)
                Baudrate = new PortSettingsWithValuesBaudrate();
            return Baudrate;
        }

        public PortSettingsWithValuesBusAddress GetOrCreateBusAddress()
        {
            if (BusAddress == null)
                BusAddress = new PortSettingsWithValuesBusAddress();
            return BusAddress;
        }

        public PortSettingsWithValuesDatabits GetOrCreateDatabits()
        {
            if (Databits == null)
                Databits = new PortSettingsWithValuesDatabits();
            return Databits;
        }

        public PortSettingsWithValuesFlowcontrol GetOrCreateFlowcontrol()
        {
            if (Flowcontrol == null)
                Flowcontrol = new PortSettingsWithValuesFlowcontrol();
            return Flowcontrol;
        }

        public PortSettingsWithValuesGetCommunity GetOrCreateGetCommunity()
        {
            if (GetCommunity == null)
                GetCommunity = new PortSettingsWithValuesGetCommunity();
            return GetCommunity;
        }

        public PortSettingsWithValuesIPport GetOrCreateIPport()
        {
            if (IPport == null)
                IPport = new PortSettingsWithValuesIPport();
            return IPport;
        }

        public PortSettingsWithValuesLocalIPport GetOrCreateLocalIPport()
        {
            if (LocalIPport == null)
                LocalIPport = new PortSettingsWithValuesLocalIPport();
            return LocalIPport;
        }

        public PortSettingsWithValuesParity GetOrCreateParity()
        {
            if (Parity == null)
                Parity = new PortSettingsWithValuesParity();
            return Parity;
        }

        public PingInterval GetOrCreatePingInterval()
        {
            if (PingInterval == null)
                PingInterval = new PingInterval("PingInterval");
            return PingInterval;
        }

        public PortSettingsWithValuesPortTypeIP GetOrCreatePortTypeIP()
        {
            if (PortTypeIP == null)
                PortTypeIP = new PortSettingsWithValuesPortTypeIP();
            return PortTypeIP;
        }

        public PortSettingsWithValuesPortTypeSerial GetOrCreatePortTypeSerial()
        {
            if (PortTypeSerial == null)
                PortTypeSerial = new PortSettingsWithValuesPortTypeSerial();
            return PortTypeSerial;
        }

        public PortSettingsWithValuesPortTypeUDP GetOrCreatePortTypeUDP()
        {
            if (PortTypeUDP == null)
                PortTypeUDP = new PortSettingsWithValuesPortTypeUDP();
            return PortTypeUDP;
        }

        public PortSettingsWithValuesRetries GetOrCreateRetries()
        {
            if (Retries == null)
                Retries = new PortSettingsWithValuesRetries();
            return Retries;
        }

        public PortSettingsWithValuesSetCommunity GetOrCreateSetCommunity()
        {
            if (SetCommunity == null)
                SetCommunity = new PortSettingsWithValuesSetCommunity();
            return SetCommunity;
        }

        public SlowPoll GetOrCreateSlowPoll()
        {
            if (SlowPoll == null)
                SlowPoll = new SlowPoll("SlowPoll");
            return SlowPoll;
        }

        public SlowPoll GetOrCreateSlowPollBase()
        {
            if (SlowPollBase == null)
                SlowPollBase = new SlowPoll("SlowPollBase");
            return SlowPollBase;
        }

        public PortSettingsWithValuesStopbits GetOrCreateStopbits()
        {
            if (Stopbits == null)
                Stopbits = new PortSettingsWithValuesStopbits();
            return Stopbits;
        }

        public SlowPoll GetOrCreateTimeoutTimeElement()
        {
            if (TimeoutTimeElement == null)
                TimeoutTimeElement = new SlowPoll("TimeoutTimeElement");
            return TimeoutTimeElement;
        }

        public PortSettingsWithValuesTimeoutTime GetOrCreateTimeoutTime()
        {
            if (TimeoutTime == null)
                TimeoutTime = new PortSettingsWithValuesTimeoutTime();
            return TimeoutTime;
        }

        public PortSettingsWithValuesType GetOrCreateType()
        {
            if (Type == null)
                Type = new PortSettingsWithValuesType();
            return Type;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<bool?> GetOrCreateVisibleInUi()
        {
            if (VisibleInUi == null)
                VisibleInUi = new AttributeValue<bool?>();
            return VisibleInUi;
        }

        protected override void Initialize(Read.IPortSettingsWithValues read, XmlElement editNode)
        {
            if (read == null)
                return;
            _baudrate = read.Baudrate != null ? new PortSettingsWithValuesBaudrate(read.Baudrate, this, editNode.Element["Baudrate"]) : null;
            _busAddress = read.BusAddress != null ? new PortSettingsWithValuesBusAddress(read.BusAddress, this, editNode.Element["BusAddress"]) : null;
            _databits = read.Databits != null ? new PortSettingsWithValuesDatabits(read.Databits, this, editNode.Element["Databits"]) : null;
            _flowcontrol = read.Flowcontrol != null ? new PortSettingsWithValuesFlowcontrol(read.Flowcontrol, this, editNode.Element["Flowcontrol"]) : null;
            _getCommunity = read.GetCommunity != null ? new PortSettingsWithValuesGetCommunity(read.GetCommunity, this, editNode.Element["GetCommunity"]) : null;
            _iPport = read.IPport != null ? new PortSettingsWithValuesIPport(read.IPport, this, editNode.Element["IPport"]) : null;
            _localIPport = read.LocalIPport != null ? new PortSettingsWithValuesLocalIPport(read.LocalIPport, this, editNode.Element["LocalIPport"]) : null;
            _parity = read.Parity != null ? new PortSettingsWithValuesParity(read.Parity, this, editNode.Element["Parity"]) : null;
            _pingInterval = read.PingInterval != null ? new PingInterval(read.PingInterval, this, editNode.Element["PingInterval"]) : null;
            _portTypeIP = read.PortTypeIP != null ? new PortSettingsWithValuesPortTypeIP(read.PortTypeIP, this, editNode.Element["PortTypeIP"]) : null;
            _portTypeSerial = read.PortTypeSerial != null ? new PortSettingsWithValuesPortTypeSerial(read.PortTypeSerial, this, editNode.Element["PortTypeSerial"]) : null;
            _portTypeUDP = read.PortTypeUDP != null ? new PortSettingsWithValuesPortTypeUDP(read.PortTypeUDP, this, editNode.Element["PortTypeUDP"]) : null;
            _retries = read.Retries != null ? new PortSettingsWithValuesRetries(read.Retries, this, editNode.Element["Retries"]) : null;
            _setCommunity = read.SetCommunity != null ? new PortSettingsWithValuesSetCommunity(read.SetCommunity, this, editNode.Element["SetCommunity"]) : null;
            _slowPoll = read.SlowPoll != null ? new SlowPoll(read.SlowPoll, this, editNode.Element["SlowPoll"]) : null;
            _slowPollBase = read.SlowPollBase != null ? new SlowPoll(read.SlowPollBase, this, editNode.Element["SlowPollBase"]) : null;
            _stopbits = read.Stopbits != null ? new PortSettingsWithValuesStopbits(read.Stopbits, this, editNode.Element["Stopbits"]) : null;
            _timeoutTimeElement = read.TimeoutTimeElement != null ? new SlowPoll(read.TimeoutTimeElement, this, editNode.Element["TimeoutTimeElement"]) : null;
            _timeoutTime = read.TimeoutTime != null ? new PortSettingsWithValuesTimeoutTime(read.TimeoutTime, this, editNode.Element["TimeoutTime"]) : null;
            _type = read.Type != null ? new PortSettingsWithValuesType(read.Type, this, editNode.Element["Type"]) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _visibleInUi = read.VisibleInUi != null ? new AttributeValue<bool?>(read.VisibleInUi, this) : null;
        }

        public static PortSettingsWithValues FromRead(Read.IPortSettingsWithValues read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValues(read.TagName);
            item.Baudrate = PortSettingsWithValuesBaudrate.FromRead(read.Baudrate);
            item.BusAddress = PortSettingsWithValuesBusAddress.FromRead(read.BusAddress);
            item.Databits = PortSettingsWithValuesDatabits.FromRead(read.Databits);
            item.Flowcontrol = PortSettingsWithValuesFlowcontrol.FromRead(read.Flowcontrol);
            item.GetCommunity = PortSettingsWithValuesGetCommunity.FromRead(read.GetCommunity);
            item.IPport = PortSettingsWithValuesIPport.FromRead(read.IPport);
            item.LocalIPport = PortSettingsWithValuesLocalIPport.FromRead(read.LocalIPport);
            item.Parity = PortSettingsWithValuesParity.FromRead(read.Parity);
            item.PingInterval = PingInterval.FromRead(read.PingInterval);
            item.PortTypeIP = PortSettingsWithValuesPortTypeIP.FromRead(read.PortTypeIP);
            item.PortTypeSerial = PortSettingsWithValuesPortTypeSerial.FromRead(read.PortTypeSerial);
            item.PortTypeUDP = PortSettingsWithValuesPortTypeUDP.FromRead(read.PortTypeUDP);
            item.Retries = PortSettingsWithValuesRetries.FromRead(read.Retries);
            item.SetCommunity = PortSettingsWithValuesSetCommunity.FromRead(read.SetCommunity);
            item.SlowPoll = SlowPoll.FromRead(read.SlowPoll);
            item.SlowPollBase = SlowPoll.FromRead(read.SlowPollBase);
            item.Stopbits = PortSettingsWithValuesStopbits.FromRead(read.Stopbits);
            item.TimeoutTimeElement = SlowPoll.FromRead(read.TimeoutTimeElement);
            item.TimeoutTime = PortSettingsWithValuesTimeoutTime.FromRead(read.TimeoutTime);
            item.Type = PortSettingsWithValuesType.FromRead(read.Type);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.VisibleInUi = AttributeValue<bool?>.FromRead(read.VisibleInUi);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValues(this);
        }
    }

    ///<summary>
    /// This tag allows you to limit the baud rate settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial class PortSettingsWithValuesBaudrate : EditableElementNode<Read.IPortSettingsWithValuesBaudrate>
    {
        internal PortSettingsWithValuesBaudrate(Read.IPortSettingsWithValuesBaudrate read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Baudrate node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesBaudrate() : base("Baudrate")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsWithValuesBaudrateRange _range;
        private PortSettingsWithValuesBaudrateValues _values;
        ///<summary>
        /// This tag can be used to define a default baud rate. Each time a user adds an element using the element wizard, the baud rate will by default be set to this value.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// This tag allows you to define a range of possible baud rate settings.
        ///</summary>
public PortSettingsWithValuesBaudrateRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public PortSettingsWithValuesBaudrateValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsWithValuesBaudrateRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsWithValuesBaudrateRange();
            return Range;
        }

        public PortSettingsWithValuesBaudrateValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new PortSettingsWithValuesBaudrateValues();
            return Values;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesBaudrate read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsWithValuesBaudrateRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new PortSettingsWithValuesBaudrateValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static PortSettingsWithValuesBaudrate FromRead(Read.IPortSettingsWithValuesBaudrate read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesBaudrate();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsWithValuesBaudrateRange.FromRead(read.Range);
            item.Values = PortSettingsWithValuesBaudrateValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBaudrate(this);
        }
    }

    ///<summary>
    /// This tag allows you to define a range of possible baud rate settings.
    ///</summary>
public partial class PortSettingsWithValuesBaudrateRange : EditableElementNode<Read.IPortSettingsWithValuesBaudrateRange>
    {
        internal PortSettingsWithValuesBaudrateRange(Read.IPortSettingsWithValuesBaudrateRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesBaudrateRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<uint?> _from;
        private ElementValue<uint?> _to;
        ///<summary>
        /// In this tag, you can specify the first of a range of baud rates.
        ///</summary>
public ElementValue<uint?> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// In this tag, you can specify the last of a range of baud rates.
        ///</summary>
public ElementValue<uint?> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<uint?>();
            return From;
        }

        public ElementValue<uint?> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<uint?>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesBaudrateRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<uint?>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<uint?>(read.To, this) : null;
        }

        public static PortSettingsWithValuesBaudrateRange FromRead(Read.IPortSettingsWithValuesBaudrateRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesBaudrateRange();
            item.From = ElementValue<uint?>.FromRead(read.From);
            item.To = ElementValue<uint?>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBaudrateRange(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial class PortSettingsWithValuesBaudrateValues : EditableElementNode<Read.IPortSettingsWithValuesBaudrateValues>
    {
        internal PortSettingsWithValuesBaudrateValues(Read.IPortSettingsWithValuesBaudrateValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesBaudrateValues() : base("Values")
        {
            OnCreated();
        }

        private ElementValue<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public ElementValue<string> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        public ElementValue<string> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<string>();
            return ValueElement;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesBaudrateValues read, XmlElement editNode)
        {
            if (read == null)
                return;
            _valueElement = read.ValueElement != null ? new ElementValue<string>(read.ValueElement, this) : null;
        }

        public static PortSettingsWithValuesBaudrateValues FromRead(Read.IPortSettingsWithValuesBaudrateValues read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesBaudrateValues();
            item.ValueElement = ElementValue<string>.FromRead(read.ValueElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBaudrateValues(this);
        }
    }

    ///<summary>
    /// This tag allows you to limit the bus address settings, and to define a default value. Typically, this information will correspond to the specifications received from the manufacturer.
    ///</summary>
public partial class PortSettingsWithValuesBusAddress : EditableElementNode<Read.IPortSettingsWithValuesBusAddress>
    {
        internal PortSettingsWithValuesBusAddress(Read.IPortSettingsWithValuesBusAddress read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a BusAddress node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesBusAddress() : base("BusAddress")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsWithValuesBusAddressRange _range;
        private PortSettingsWithValuesBusAddressValues _values;
        ///<summary>
        /// This tag can be used to define a default bus address value. Each time a user adds an element using the element wizard, the bus address will by default be set to this value.
        /// As a bus address is not always needed, the default value can also be set to "false". In that case, it will not be possible to specify a bus address.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// This tag allows you to define a range of possible bus addresses.
        ///</summary>
public PortSettingsWithValuesBusAddressRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public PortSettingsWithValuesBusAddressValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsWithValuesBusAddressRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsWithValuesBusAddressRange();
            return Range;
        }

        public PortSettingsWithValuesBusAddressValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new PortSettingsWithValuesBusAddressValues();
            return Values;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesBusAddress read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsWithValuesBusAddressRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new PortSettingsWithValuesBusAddressValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static PortSettingsWithValuesBusAddress FromRead(Read.IPortSettingsWithValuesBusAddress read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesBusAddress();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsWithValuesBusAddressRange.FromRead(read.Range);
            item.Values = PortSettingsWithValuesBusAddressValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBusAddress(this);
        }
    }

    ///<summary>
    /// This tag allows you to define a range of possible bus addresses.
    ///</summary>
public partial class PortSettingsWithValuesBusAddressRange : EditableElementNode<Read.IPortSettingsWithValuesBusAddressRange>
    {
        internal PortSettingsWithValuesBusAddressRange(Read.IPortSettingsWithValuesBusAddressRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesBusAddressRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<string> _from;
        private ElementValue<string> _to;
        ///<summary>
        /// In this tag, you can specify the first of a range of bus addresses.
        ///</summary>
public ElementValue<string> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// In this tag, you can specify the last of a range of bus addresses.
        ///</summary>
public ElementValue<string> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<string> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<string>();
            return From;
        }

        public ElementValue<string> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<string>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesBusAddressRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<string>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<string>(read.To, this) : null;
        }

        public static PortSettingsWithValuesBusAddressRange FromRead(Read.IPortSettingsWithValuesBusAddressRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesBusAddressRange();
            item.From = ElementValue<string>.FromRead(read.From);
            item.To = ElementValue<string>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBusAddressRange(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial class PortSettingsWithValuesBusAddressValues : EditableElementNode<Read.IPortSettingsWithValuesBusAddressValues>
    {
        internal PortSettingsWithValuesBusAddressValues(Read.IPortSettingsWithValuesBusAddressValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesBusAddressValues() : base("Values")
        {
            OnCreated();
        }

        private ElementValue<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public ElementValue<string> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        public ElementValue<string> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<string>();
            return ValueElement;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesBusAddressValues read, XmlElement editNode)
        {
            if (read == null)
                return;
            _valueElement = read.ValueElement != null ? new ElementValue<string>(read.ValueElement, this) : null;
        }

        public static PortSettingsWithValuesBusAddressValues FromRead(Read.IPortSettingsWithValuesBusAddressValues read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesBusAddressValues();
            item.ValueElement = ElementValue<string>.FromRead(read.ValueElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesBusAddressValues(this);
        }
    }

    ///<summary>
    /// This tag allows you to specify the possible databits settings, and to define a default value.
    /// For SNMPv3, this contains the User Name.
    ///</summary>
public partial class PortSettingsWithValuesDatabits : EditableElementNode<Read.IPortSettingsWithValuesDatabits>
    {
        internal PortSettingsWithValuesDatabits(Read.IPortSettingsWithValuesDatabits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Databits node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesDatabits() : base("Databits")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsWithValuesDatabitsRange _range;
        private PortSettingsWithValuesDatabitsValues _values;
        ///<summary>
        /// This tag can be used to define a default databits value. Each time a user adds an element using the element wizard, the databits setting will by default be set to this value.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// This tag allows you to define a range of possible databits settings.
        ///</summary>
public PortSettingsWithValuesDatabitsRange Range
        {
            get
            {
                return _range;
            }

            set
            {
                if (_range != value)
                {
                    _range = value;
                    CombinedTagHandler.Assign(value, this, "Range");
                }
            }
        }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public PortSettingsWithValuesDatabitsValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsWithValuesDatabitsRange GetOrCreateRange()
        {
            if (Range == null)
                Range = new PortSettingsWithValuesDatabitsRange();
            return Range;
        }

        public PortSettingsWithValuesDatabitsValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new PortSettingsWithValuesDatabitsValues();
            return Values;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesDatabits read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _range = read.Range != null ? new PortSettingsWithValuesDatabitsRange(read.Range, this, editNode.Element["Range"]) : null;
            _values = read.Values != null ? new PortSettingsWithValuesDatabitsValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static PortSettingsWithValuesDatabits FromRead(Read.IPortSettingsWithValuesDatabits read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesDatabits();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Range = PortSettingsWithValuesDatabitsRange.FromRead(read.Range);
            item.Values = PortSettingsWithValuesDatabitsValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesDatabits(this);
        }
    }

    ///<summary>
    /// This tag allows you to define a range of possible databits settings.
    ///</summary>
public partial class PortSettingsWithValuesDatabitsRange : EditableElementNode<Read.IPortSettingsWithValuesDatabitsRange>
    {
        internal PortSettingsWithValuesDatabitsRange(Read.IPortSettingsWithValuesDatabitsRange read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Range node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesDatabitsRange() : base("Range")
        {
            OnCreated();
        }

        private ElementValue<uint?> _from;
        private ElementValue<uint?> _to;
        ///<summary>
        /// In this tag, you can specify the first of a range of databits settings.
        ///</summary>
public ElementValue<uint?> From
        {
            get
            {
                return _from;
            }

            set
            {
                if (_from != value)
                {
                    _from = value;
                    ElementHandler.Assign(value, this, "From");
                }
            }
        }

        ///<summary>
        /// In this tag, you can specify the last of a range of databits settings.
        ///</summary>
public ElementValue<uint?> To
        {
            get
            {
                return _to;
            }

            set
            {
                if (_to != value)
                {
                    _to = value;
                    ElementHandler.Assign(value, this, "To");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateFrom()
        {
            if (From == null)
                From = new ElementValue<uint?>();
            return From;
        }

        public ElementValue<uint?> GetOrCreateTo()
        {
            if (To == null)
                To = new ElementValue<uint?>();
            return To;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesDatabitsRange read, XmlElement editNode)
        {
            if (read == null)
                return;
            _from = read.From != null ? new ElementValue<uint?>(read.From, this) : null;
            _to = read.To != null ? new ElementValue<uint?>(read.To, this) : null;
        }

        public static PortSettingsWithValuesDatabitsRange FromRead(Read.IPortSettingsWithValuesDatabitsRange read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesDatabitsRange();
            item.From = ElementValue<uint?>.FromRead(read.From);
            item.To = ElementValue<uint?>.FromRead(read.To);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesDatabitsRange(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial class PortSettingsWithValuesDatabitsValues : EditableElementNode<Read.IPortSettingsWithValuesDatabitsValues>
    {
        internal PortSettingsWithValuesDatabitsValues(Read.IPortSettingsWithValuesDatabitsValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesDatabitsValues() : base("Values")
        {
            OnCreated();
        }

        private ElementValue<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not need to defined here again.
        /// - When no Value elements are specified, users will only be allowed to enter the value specified in DefaultValue.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public ElementValue<string> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        public ElementValue<string> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<string>();
            return ValueElement;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesDatabitsValues read, XmlElement editNode)
        {
            if (read == null)
                return;
            _valueElement = read.ValueElement != null ? new ElementValue<string>(read.ValueElement, this) : null;
        }

        public static PortSettingsWithValuesDatabitsValues FromRead(Read.IPortSettingsWithValuesDatabitsValues read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesDatabitsValues();
            item.ValueElement = ElementValue<string>.FromRead(read.ValueElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesDatabitsValues(this);
        }
    }

    ///<summary>
    /// This tag allows you to specify the possible flow control settings, and to define a default value.
    /// For SNMPv3, this contains the Encryption Algorithm.
    ///</summary>
public partial class PortSettingsWithValuesFlowcontrol : EditableElementNode<Read.IPortSettingsWithValuesFlowcontrol>
    {
        internal PortSettingsWithValuesFlowcontrol(Read.IPortSettingsWithValuesFlowcontrol read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Flowcontrol node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesFlowcontrol() : base("Flowcontrol")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsWithValuesFlowcontrolValues _values;
        ///<summary>
        /// This tag can be used to define a default flow control value. Each time a user adds an element using the Element wizard, the flowcontrol setting will by default be set to this value.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public PortSettingsWithValuesFlowcontrolValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsWithValuesFlowcontrolValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new PortSettingsWithValuesFlowcontrolValues();
            return Values;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesFlowcontrol read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _values = read.Values != null ? new PortSettingsWithValuesFlowcontrolValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static PortSettingsWithValuesFlowcontrol FromRead(Read.IPortSettingsWithValuesFlowcontrol read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesFlowcontrol();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Values = PortSettingsWithValuesFlowcontrolValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesFlowcontrol(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial class PortSettingsWithValuesFlowcontrolValues : EditableElementNode<Read.IPortSettingsWithValuesFlowcontrolValues>
    {
        internal PortSettingsWithValuesFlowcontrolValues(Read.IPortSettingsWithValuesFlowcontrolValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesFlowcontrolValues() : base("Values")
        {
            OnCreated();
        }

        private ElementValue<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public ElementValue<string> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        public ElementValue<string> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<string>();
            return ValueElement;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesFlowcontrolValues read, XmlElement editNode)
        {
            if (read == null)
                return;
            _valueElement = read.ValueElement != null ? new ElementValue<string>(read.ValueElement, this) : null;
        }

        public static PortSettingsWithValuesFlowcontrolValues FromRead(Read.IPortSettingsWithValuesFlowcontrolValues read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesFlowcontrolValues();
            item.ValueElement = ElementValue<string>.FromRead(read.ValueElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesFlowcontrolValues(this);
        }
    }

    ///<summary>
    /// GetCommunity string for SNMP and SNMPv2 communication.&lt;br&gt;
    /// For SNMPv3, this contains the Authentication Password
    ///</summary>
public partial class PortSettingsWithValuesGetCommunity : EditableElementNode<Read.IPortSettingsWithValuesGetCommunity>
    {
        internal PortSettingsWithValuesGetCommunity(Read.IPortSettingsWithValuesGetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a GetCommunity node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesGetCommunity() : base("GetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesGetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesGetCommunity FromRead(Read.IPortSettingsWithValuesGetCommunity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesGetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesGetCommunity(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the port.
    ///</summary>
public partial class PortSettingsWithValuesIPport : EditableElementNode<Read.IPortSettingsWithValuesIPport>
    {
        internal PortSettingsWithValuesIPport(Read.IPortSettingsWithValuesIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a IPport node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesIPport() : base("IPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default port number.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the user is be able to set the port number.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesIPport FromRead(Read.IPortSettingsWithValuesIPport read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesIPport(this);
        }
    }

    ///<summary>
    /// Specifies settings related to the local port.
    ///</summary>
public partial class PortSettingsWithValuesLocalIPport : EditableElementNode<Read.IPortSettingsWithValuesLocalIPport>
    {
        internal PortSettingsWithValuesLocalIPport(Read.IPortSettingsWithValuesLocalIPport read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a LocalIPport node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesLocalIPport() : base("LocalIPport")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// Specifies the default local port number.
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// Specifies whether the user is able to set the local port number.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesLocalIPport read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesLocalIPport FromRead(Read.IPortSettingsWithValuesLocalIPport read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesLocalIPport();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesLocalIPport(this);
        }
    }

    ///<summary>
    /// This tag allows you to specify the possible parity settings, and to define a default value.
    /// For SNMPv3, this contains the Authentication Algorithm.
    ///</summary>
public partial class PortSettingsWithValuesParity : EditableElementNode<Read.IPortSettingsWithValuesParity>
    {
        internal PortSettingsWithValuesParity(Read.IPortSettingsWithValuesParity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Parity node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesParity() : base("Parity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsWithValuesParityValues _values;
        ///<summary>
        /// This tag can be used to define a default parity. Each time a user adds an Element using the Element wizard, the parity will by default be set to this value.
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public PortSettingsWithValuesParityValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsWithValuesParityValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new PortSettingsWithValuesParityValues();
            return Values;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesParity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _values = read.Values != null ? new PortSettingsWithValuesParityValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static PortSettingsWithValuesParity FromRead(Read.IPortSettingsWithValuesParity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesParity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Values = PortSettingsWithValuesParityValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesParity(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial class PortSettingsWithValuesParityValues : EditableElementNode<Read.IPortSettingsWithValuesParityValues>
    {
        internal PortSettingsWithValuesParityValues(Read.IPortSettingsWithValuesParityValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesParityValues() : base("Values")
        {
            OnCreated();
        }

        private ElementValue<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public ElementValue<string> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        public ElementValue<string> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<string>();
            return ValueElement;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesParityValues read, XmlElement editNode)
        {
            if (read == null)
                return;
            _valueElement = read.ValueElement != null ? new ElementValue<string>(read.ValueElement, this) : null;
        }

        public static PortSettingsWithValuesParityValues FromRead(Read.IPortSettingsWithValuesParityValues read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesParityValues();
            item.ValueElement = ElementValue<string>.FromRead(read.ValueElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesParityValues(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class PortSettingsWithValuesPortTypeIP : EditableElementNode<Read.IPortSettingsWithValuesPortTypeIP>
    {
        internal PortSettingsWithValuesPortTypeIP(Read.IPortSettingsWithValuesPortTypeIP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeIP node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesPortTypeIP() : base("PortTypeIP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'TCP/IP'.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesPortTypeIP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesPortTypeIP FromRead(Read.IPortSettingsWithValuesPortTypeIP read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesPortTypeIP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesPortTypeIP(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class PortSettingsWithValuesPortTypeSerial : EditableElementNode<Read.IPortSettingsWithValuesPortTypeSerial>
    {
        internal PortSettingsWithValuesPortTypeSerial(Read.IPortSettingsWithValuesPortTypeSerial read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeSerial node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesPortTypeSerial() : base("PortTypeSerial")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'serial'.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesPortTypeSerial read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesPortTypeSerial FromRead(Read.IPortSettingsWithValuesPortTypeSerial read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesPortTypeSerial();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesPortTypeSerial(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class PortSettingsWithValuesPortTypeUDP : EditableElementNode<Read.IPortSettingsWithValuesPortTypeUDP>
    {
        internal PortSettingsWithValuesPortTypeUDP(Read.IPortSettingsWithValuesPortTypeUDP read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a PortTypeUDP node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesPortTypeUDP() : base("PortTypeUDP")
        {
            OnCreated();
        }

        private ElementValue<bool?> _disabled;
        ///<summary>
        /// This tag allows you to specify whether or not the user will be able to set the port type to 'UDP/IP'.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesPortTypeUDP read, XmlElement editNode)
        {
            if (read == null)
                return;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesPortTypeUDP FromRead(Read.IPortSettingsWithValuesPortTypeUDP read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesPortTypeUDP();
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesPortTypeUDP(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class PortSettingsWithValuesRetries : EditableElementNode<Read.IPortSettingsWithValuesRetries>
    {
        internal PortSettingsWithValuesRetries(Read.IPortSettingsWithValuesRetries read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Retries node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesRetries() : base("Retries")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesRetries read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesRetries FromRead(Read.IPortSettingsWithValuesRetries read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesRetries();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesRetries(this);
        }
    }

    ///<summary>
    /// SetCommunity string for SNMP and SNMPv2 communication.
    /// For SNMPv3, this contains the Encryption Password.
    ///</summary>
public partial class PortSettingsWithValuesSetCommunity : EditableElementNode<Read.IPortSettingsWithValuesSetCommunity>
    {
        internal PortSettingsWithValuesSetCommunity(Read.IPortSettingsWithValuesSetCommunity read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a SetCommunity node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesSetCommunity() : base("SetCommunity")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesSetCommunity read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesSetCommunity FromRead(Read.IPortSettingsWithValuesSetCommunity read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesSetCommunity();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesSetCommunity(this);
        }
    }

    ///<summary>
    /// This tag allows you to specify the possible stopbits settings, and to define a default value.
    /// For SNMPv3, this contains the Security Level.
    ///</summary>
public partial class PortSettingsWithValuesStopbits : EditableElementNode<Read.IPortSettingsWithValuesStopbits>
    {
        internal PortSettingsWithValuesStopbits(Read.IPortSettingsWithValuesStopbits read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Stopbits node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesStopbits() : base("Stopbits")
        {
            OnCreated();
        }

        private ElementValue<string> _defaultValue;
        private ElementValue<bool?> _disabled;
        private PortSettingsWithValuesStopbitsValues _values;
        ///<summary>
        /// This tag can be used to define a default stopbits value. Each time a user adds an Element using the Element wizard, the stopbits setting will by default be set to this value.
        /// Set the default to one of the following integer values:	1, 1.5 or 2
        ///</summary>
public ElementValue<string> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        ///<summary>
        /// This tag contains the definitions of all values.
        ///</summary>
public PortSettingsWithValuesStopbitsValues Values
        {
            get
            {
                return _values;
            }

            set
            {
                if (_values != value)
                {
                    _values = value;
                    CombinedTagHandler.Assign(value, this, "Values");
                }
            }
        }

        public ElementValue<string> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<string>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        public PortSettingsWithValuesStopbitsValues GetOrCreateValues()
        {
            if (Values == null)
                Values = new PortSettingsWithValuesStopbitsValues();
            return Values;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesStopbits read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<string>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
            _values = read.Values != null ? new PortSettingsWithValuesStopbitsValues(read.Values, this, editNode.Element["Values"]) : null;
        }

        public static PortSettingsWithValuesStopbits FromRead(Read.IPortSettingsWithValuesStopbits read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesStopbits();
            item.DefaultValue = ElementValue<string>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            item.Values = PortSettingsWithValuesStopbitsValues.FromRead(read.Values);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesStopbits(this);
        }
    }

    ///<summary>
    /// This tag contains the definitions of all values.
    ///</summary>
public partial class PortSettingsWithValuesStopbitsValues : EditableElementNode<Read.IPortSettingsWithValuesStopbitsValues>
    {
        internal PortSettingsWithValuesStopbitsValues(Read.IPortSettingsWithValuesStopbitsValues read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Values node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesStopbitsValues() : base("Values")
        {
            OnCreated();
        }

        private ElementValue<string> _valueElement;
        ///<summary>
        /// Using one or more Value tags, you can specify the different values that users are allowed to enter.
        /// Note:
        /// - The value specified in the DefaultValue tag does not have to be specified in a Value tag.
        /// - When no Value tags are specified, users will only be allowed to enter the value specified in the DefaultValue tag.
        /// The following wildcards can be used: * (a series of characters) and ? (one single character)
        ///</summary>
public ElementValue<string> ValueElement
        {
            get
            {
                return _valueElement;
            }

            set
            {
                if (_valueElement != value)
                {
                    _valueElement = value;
                    ElementHandler.Assign(value, this, "Value");
                }
            }
        }

        public ElementValue<string> GetOrCreateValueElement()
        {
            if (ValueElement == null)
                ValueElement = new ElementValue<string>();
            return ValueElement;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesStopbitsValues read, XmlElement editNode)
        {
            if (read == null)
                return;
            _valueElement = read.ValueElement != null ? new ElementValue<string>(read.ValueElement, this) : null;
        }

        public static PortSettingsWithValuesStopbitsValues FromRead(Read.IPortSettingsWithValuesStopbitsValues read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesStopbitsValues();
            item.ValueElement = ElementValue<string>.FromRead(read.ValueElement);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesStopbitsValues(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class PortSettingsWithValuesTimeoutTime : EditableElementNode<Read.IPortSettingsWithValuesTimeoutTime>
    {
        internal PortSettingsWithValuesTimeoutTime(Read.IPortSettingsWithValuesTimeoutTime read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TimeoutTime node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesTimeoutTime() : base("TimeoutTime")
        {
            OnCreated();
        }

        private ElementValue<uint?> _defaultValue;
        private ElementValue<bool?> _disabled;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public ElementValue<uint?> DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        ///<summary>
        /// This tag allows you to specify whether or not the setting in question can be modified in the DataMiner user interface.
        ///</summary>
public ElementValue<bool?> Disabled
        {
            get
            {
                return _disabled;
            }

            set
            {
                if (_disabled != value)
                {
                    _disabled = value;
                    ElementHandler.Assign(value, this, "Disabled");
                }
            }
        }

        public ElementValue<uint?> GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new ElementValue<uint?>();
            return DefaultValue;
        }

        public ElementValue<bool?> GetOrCreateDisabled()
        {
            if (Disabled == null)
                Disabled = new ElementValue<bool?>();
            return Disabled;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesTimeoutTime read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new ElementValue<uint?>(read.DefaultValue, this) : null;
            _disabled = read.Disabled != null ? new ElementValue<bool?>(read.Disabled, this) : null;
        }

        public static PortSettingsWithValuesTimeoutTime FromRead(Read.IPortSettingsWithValuesTimeoutTime read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesTimeoutTime();
            item.DefaultValue = ElementValue<uint?>.FromRead(read.DefaultValue);
            item.Disabled = ElementValue<bool?>.FromRead(read.Disabled);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesTimeoutTime(this);
        }
    }

    ///<summary>
    /// *** No documentation available yet ***
    ///</summary>
public partial class PortSettingsWithValuesType : EditableElementNode<Read.IPortSettingsWithValuesType>
    {
        internal PortSettingsWithValuesType(Read.IPortSettingsWithValuesType read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Type node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesType() : base("Type")
        {
            OnCreated();
        }

        private PortSettingsWithValuesTypeDefaultValue _defaultValue;
        ///<summary>
        /// In this tag, specify which port type should be preselected.
        ///</summary>
public PortSettingsWithValuesTypeDefaultValue DefaultValue
        {
            get
            {
                return _defaultValue;
            }

            set
            {
                if (_defaultValue != value)
                {
                    _defaultValue = value;
                    ElementHandler.Assign(value, this, "DefaultValue");
                }
            }
        }

        public PortSettingsWithValuesTypeDefaultValue GetOrCreateDefaultValue()
        {
            if (DefaultValue == null)
                DefaultValue = new PortSettingsWithValuesTypeDefaultValue();
            return DefaultValue;
        }

        protected override void Initialize(Read.IPortSettingsWithValuesType read, XmlElement editNode)
        {
            if (read == null)
                return;
            _defaultValue = read.DefaultValue != null ? new PortSettingsWithValuesTypeDefaultValue(read.DefaultValue, this) : null;
        }

        public static PortSettingsWithValuesType FromRead(Read.IPortSettingsWithValuesType read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesType();
            item.DefaultValue = PortSettingsWithValuesTypeDefaultValue.FromRead(read.DefaultValue);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitPortSettingsWithValuesType(this);
        }
    }

    public partial class PortSettingsWithValuesTypeDefaultValue : ElementValue<Enums.EnumPortTypes?>
    {
        internal PortSettingsWithValuesTypeDefaultValue(Read.IValueTag<Enums.EnumPortTypes?> readNode, IEditableNode parent) : base(readNode, parent)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a DefaultValue node. None of it's properties will be set.
        ///</summary>
public PortSettingsWithValuesTypeDefaultValue() : base()
        {
            OnCreated();
        }

        public PortSettingsWithValuesTypeDefaultValue(Enums.EnumPortTypes? value) : base(value)
        {
        }

        protected override string GetValueToWrite()
        {
            if (Value == null)
                return null;
            return Enums.EnumPortTypesConverter.ConvertBack(Value.Value);
        }

        public override Enums.EnumPortTypes? ConvertRawValue(string rawValue)
        {
            return Enums.EnumPortTypesConverter.Convert(rawValue?.Trim());
        }

        public new static PortSettingsWithValuesTypeDefaultValue FromRead(Read.IValueTag<Enums.EnumPortTypes?> read)
        {
            if (read == null)
                return null;
            var item = new PortSettingsWithValuesTypeDefaultValue();
            item.Value = read.Value;
            return item;
        }
    }

    ///<summary>
    /// Specifies how a cell in a CPE topology is linked to another cell in that topology, using foreign key relations (which can also be inside the same table).
    ///</summary>
public partial class TypeTopologyCellLink : EditableElementNode<Read.ITypeTopologyCellLink>
    {
        internal TypeTopologyCellLink(Read.ITypeTopologyCellLink read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeTopologyCellLink node. None of it's properties will be set.
        ///</summary>
public TypeTopologyCellLink(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private AttributeValue<uint?> _dest;
        private AttributeValue<uint?> _source;
        ///<summary>
        /// (CPE) Specifies the ID of the parameter column if you want to make a topology with foreign key relations inside a table.
        ///</summary>
public AttributeValue<uint?> Dest
        {
            get
            {
                return _dest;
            }

            set
            {
                if (_dest != value)
                {
                    _dest = value;
                    AttributeHandler.Assign(value, this, "dest");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<uint?> Source
        {
            get
            {
                return _source;
            }

            set
            {
                if (_source != value)
                {
                    _source = value;
                    AttributeHandler.Assign(value, this, "source");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateDest()
        {
            if (Dest == null)
                Dest = new AttributeValue<uint?>();
            return Dest;
        }

        public AttributeValue<uint?> GetOrCreateSource()
        {
            if (Source == null)
                Source = new AttributeValue<uint?>();
            return Source;
        }

        protected override void Initialize(Read.ITypeTopologyCellLink read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dest = read.Dest != null ? new AttributeValue<uint?>(read.Dest, this) : null;
            _source = read.Source != null ? new AttributeValue<uint?>(read.Source, this) : null;
        }

        public static TypeTopologyCellLink FromRead(Read.ITypeTopologyCellLink read)
        {
            if (read == null)
                return null;
            var item = new TypeTopologyCellLink(read.TagName);
            item.Dest = AttributeValue<uint?>.FromRead(read.Dest);
            item.Source = AttributeValue<uint?>.FromRead(read.Source);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeTopologyCellLink(this);
        }
    }

    ///<summary>
    /// Configures chain display settings.
    ///</summary>
public partial class TypeChainsChainDisplay : EditableElementNode<Read.ITypeChainsChainDisplay>
    {
        internal TypeChainsChainDisplay(Read.ITypeChainsChainDisplay read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeChainsChainDisplay node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainDisplay(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private TypeChainsChainDisplayVisibility _visibility;
        public TypeChainsChainDisplayVisibility Visibility
        {
            get
            {
                return _visibility;
            }

            set
            {
                if (_visibility != value)
                {
                    _visibility = value;
                    CombinedTagHandler.Assign(value, this, "Visibility");
                }
            }
        }

        public TypeChainsChainDisplayVisibility GetOrCreateVisibility()
        {
            if (Visibility == null)
                Visibility = new TypeChainsChainDisplayVisibility();
            return Visibility;
        }

        protected override void Initialize(Read.ITypeChainsChainDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _visibility = read.Visibility != null ? new TypeChainsChainDisplayVisibility(read.Visibility, this, editNode.Element["Visibility"]) : null;
        }

        public static TypeChainsChainDisplay FromRead(Read.ITypeChainsChainDisplay read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainDisplay(read.TagName);
            item.Visibility = TypeChainsChainDisplayVisibility.FromRead(read.Visibility);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainDisplay(this);
        }
    }

    public partial class TypeChainsChainDisplayVisibility : EditableListNode<Read.ITypeChainsChainDisplayVisibility, Read.ITypeChainsChainDisplayVisibilityStandalone, TypeChainsChainDisplayVisibilityStandalone>
    {
        internal TypeChainsChainDisplayVisibility(Read.ITypeChainsChainDisplayVisibility read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Visibility node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainDisplayVisibility() : base("Visibility")
        {
            OnCreated();
        }

        private AttributeValue<bool?> _default;
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
public AttributeValue<bool?> Default
        {
            get
            {
                return _default;
            }

            set
            {
                if (_default != value)
                {
                    _default = value;
                    AttributeHandler.Assign(value, this, "default");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateDefault()
        {
            if (Default == null)
                Default = new AttributeValue<bool?>();
            return Default;
        }

        protected override void Initialize(Read.ITypeChainsChainDisplayVisibility read, XmlElement editNode)
        {
            if (read == null)
                return;
            _default = read.Default != null ? new AttributeValue<bool?>(read.Default, this) : null;
        }

        public static TypeChainsChainDisplayVisibility FromRead(Read.ITypeChainsChainDisplayVisibility read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainDisplayVisibility();
            item.Default = AttributeValue<bool?>.FromRead(read.Default);
            foreach (var x in read)
            {
                item.Add(TypeChainsChainDisplayVisibilityStandalone.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainDisplayVisibility(this);
        }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial class TypeChainsChainDisplayVisibilityStandalone : EditableListNode<Read.ITypeChainsChainDisplayVisibilityStandalone, Read.ITypeChainsChainDisplayVisibilityStandaloneValue, TypeChainsChainDisplayVisibilityStandaloneValue>
    {
        internal TypeChainsChainDisplayVisibilityStandalone(Read.ITypeChainsChainDisplayVisibilityStandalone read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Standalone node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainDisplayVisibilityStandalone() : base("Standalone")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.ITypeChainsChainDisplayVisibilityStandalone read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static TypeChainsChainDisplayVisibilityStandalone FromRead(Read.ITypeChainsChainDisplayVisibilityStandalone read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainDisplayVisibilityStandalone();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            foreach (var x in read)
            {
                item.Add(TypeChainsChainDisplayVisibilityStandaloneValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainDisplayVisibilityStandalone(this);
        }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial class TypeChainsChainDisplayVisibilityStandaloneValue : EditableElementValueNode<Read.ITypeChainsChainDisplayVisibilityStandaloneValue, string>
    {
        internal TypeChainsChainDisplayVisibilityStandaloneValue(Read.ITypeChainsChainDisplayVisibilityStandaloneValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainDisplayVisibilityStandaloneValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public TypeChainsChainDisplayVisibilityStandaloneValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.ITypeChainsChainDisplayVisibilityStandaloneValue read, XmlElement editNode)
        {
        }

        public static TypeChainsChainDisplayVisibilityStandaloneValue FromRead(Read.ITypeChainsChainDisplayVisibilityStandaloneValue read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainDisplayVisibilityStandaloneValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainDisplayVisibilityStandaloneValue(this);
        }
    }

    ///<summary>
    /// Configures chain display settings.
    ///</summary>
public partial class TypeChainsSearchChainDisplay : EditableElementNode<Read.ITypeChainsSearchChainDisplay>
    {
        internal TypeChainsSearchChainDisplay(Read.ITypeChainsSearchChainDisplay read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeChainsSearchChainDisplay node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainDisplay(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private TypeChainsSearchChainDisplayVisibility _visibility;
        public TypeChainsSearchChainDisplayVisibility Visibility
        {
            get
            {
                return _visibility;
            }

            set
            {
                if (_visibility != value)
                {
                    _visibility = value;
                    CombinedTagHandler.Assign(value, this, "Visibility");
                }
            }
        }

        public TypeChainsSearchChainDisplayVisibility GetOrCreateVisibility()
        {
            if (Visibility == null)
                Visibility = new TypeChainsSearchChainDisplayVisibility();
            return Visibility;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _visibility = read.Visibility != null ? new TypeChainsSearchChainDisplayVisibility(read.Visibility, this, editNode.Element["Visibility"]) : null;
        }

        public static TypeChainsSearchChainDisplay FromRead(Read.ITypeChainsSearchChainDisplay read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainDisplay(read.TagName);
            item.Visibility = TypeChainsSearchChainDisplayVisibility.FromRead(read.Visibility);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainDisplay(this);
        }
    }

    public partial class TypeChainsSearchChainDisplayVisibility : EditableListNode<Read.ITypeChainsSearchChainDisplayVisibility, Read.ITypeChainsSearchChainDisplayVisibilityStandalone, TypeChainsSearchChainDisplayVisibilityStandalone>
    {
        internal TypeChainsSearchChainDisplayVisibility(Read.ITypeChainsSearchChainDisplayVisibility read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Visibility node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainDisplayVisibility() : base("Visibility")
        {
            OnCreated();
        }

        private AttributeValue<bool?> _default;
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
public AttributeValue<bool?> Default
        {
            get
            {
                return _default;
            }

            set
            {
                if (_default != value)
                {
                    _default = value;
                    AttributeHandler.Assign(value, this, "default");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateDefault()
        {
            if (Default == null)
                Default = new AttributeValue<bool?>();
            return Default;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainDisplayVisibility read, XmlElement editNode)
        {
            if (read == null)
                return;
            _default = read.Default != null ? new AttributeValue<bool?>(read.Default, this) : null;
        }

        public static TypeChainsSearchChainDisplayVisibility FromRead(Read.ITypeChainsSearchChainDisplayVisibility read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainDisplayVisibility();
            item.Default = AttributeValue<bool?>.FromRead(read.Default);
            foreach (var x in read)
            {
                item.Add(TypeChainsSearchChainDisplayVisibilityStandalone.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainDisplayVisibility(this);
        }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial class TypeChainsSearchChainDisplayVisibilityStandalone : EditableListNode<Read.ITypeChainsSearchChainDisplayVisibilityStandalone, Read.ITypeChainsSearchChainDisplayVisibilityStandaloneValue, TypeChainsSearchChainDisplayVisibilityStandaloneValue>
    {
        internal TypeChainsSearchChainDisplayVisibilityStandalone(Read.ITypeChainsSearchChainDisplayVisibilityStandalone read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Standalone node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainDisplayVisibilityStandalone() : base("Standalone")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainDisplayVisibilityStandalone read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static TypeChainsSearchChainDisplayVisibilityStandalone FromRead(Read.ITypeChainsSearchChainDisplayVisibilityStandalone read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainDisplayVisibilityStandalone();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            foreach (var x in read)
            {
                item.Add(TypeChainsSearchChainDisplayVisibilityStandaloneValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainDisplayVisibilityStandalone(this);
        }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial class TypeChainsSearchChainDisplayVisibilityStandaloneValue : EditableElementValueNode<Read.ITypeChainsSearchChainDisplayVisibilityStandaloneValue, string>
    {
        internal TypeChainsSearchChainDisplayVisibilityStandaloneValue(Read.ITypeChainsSearchChainDisplayVisibilityStandaloneValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainDisplayVisibilityStandaloneValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public TypeChainsSearchChainDisplayVisibilityStandaloneValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.ITypeChainsSearchChainDisplayVisibilityStandaloneValue read, XmlElement editNode)
        {
        }

        public static TypeChainsSearchChainDisplayVisibilityStandaloneValue FromRead(Read.ITypeChainsSearchChainDisplayVisibilityStandaloneValue read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainDisplayVisibilityStandaloneValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainDisplayVisibilityStandaloneValue(this);
        }
    }

    ///<summary>
    /// Configures chain field display settings.
    ///</summary>
public partial class TypeChainsChainFieldDisplay : EditableElementNode<Read.ITypeChainsChainFieldDisplay>
    {
        internal TypeChainsChainFieldDisplay(Read.ITypeChainsChainFieldDisplay read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeChainsChainFieldDisplay node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainFieldDisplay(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private TypeChainsChainFieldDisplaySelection _selection;
        public TypeChainsChainFieldDisplaySelection Selection
        {
            get
            {
                return _selection;
            }

            set
            {
                if (_selection != value)
                {
                    _selection = value;
                    CombinedTagHandler.Assign(value, this, "Selection");
                }
            }
        }

        public TypeChainsChainFieldDisplaySelection GetOrCreateSelection()
        {
            if (Selection == null)
                Selection = new TypeChainsChainFieldDisplaySelection();
            return Selection;
        }

        protected override void Initialize(Read.ITypeChainsChainFieldDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _selection = read.Selection != null ? new TypeChainsChainFieldDisplaySelection(read.Selection, this, editNode.Element["Selection"]) : null;
        }

        public static TypeChainsChainFieldDisplay FromRead(Read.ITypeChainsChainFieldDisplay read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainFieldDisplay(read.TagName);
            item.Selection = TypeChainsChainFieldDisplaySelection.FromRead(read.Selection);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplay(this);
        }
    }

    public partial class TypeChainsChainFieldDisplaySelection : EditableElementNode<Read.ITypeChainsChainFieldDisplaySelection>
    {
        internal TypeChainsChainFieldDisplaySelection(Read.ITypeChainsChainFieldDisplaySelection read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Selection node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainFieldDisplaySelection() : base("Selection")
        {
            OnCreated();
        }

        private TypeChainsChainFieldDisplaySelectionVisibility _visibility;
        public TypeChainsChainFieldDisplaySelectionVisibility Visibility
        {
            get
            {
                return _visibility;
            }

            set
            {
                if (_visibility != value)
                {
                    _visibility = value;
                    CombinedTagHandler.Assign(value, this, "Visibility");
                }
            }
        }

        public TypeChainsChainFieldDisplaySelectionVisibility GetOrCreateVisibility()
        {
            if (Visibility == null)
                Visibility = new TypeChainsChainFieldDisplaySelectionVisibility();
            return Visibility;
        }

        protected override void Initialize(Read.ITypeChainsChainFieldDisplaySelection read, XmlElement editNode)
        {
            if (read == null)
                return;
            _visibility = read.Visibility != null ? new TypeChainsChainFieldDisplaySelectionVisibility(read.Visibility, this, editNode.Element["Visibility"]) : null;
        }

        public static TypeChainsChainFieldDisplaySelection FromRead(Read.ITypeChainsChainFieldDisplaySelection read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainFieldDisplaySelection();
            item.Visibility = TypeChainsChainFieldDisplaySelectionVisibility.FromRead(read.Visibility);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplaySelection(this);
        }
    }

    public partial class TypeChainsChainFieldDisplaySelectionVisibility : EditableListNode<Read.ITypeChainsChainFieldDisplaySelectionVisibility, Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandalone, TypeChainsChainFieldDisplaySelectionVisibilityStandalone>
    {
        internal TypeChainsChainFieldDisplaySelectionVisibility(Read.ITypeChainsChainFieldDisplaySelectionVisibility read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Visibility node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainFieldDisplaySelectionVisibility() : base("Visibility")
        {
            OnCreated();
        }

        private AttributeValue<bool?> _default;
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
public AttributeValue<bool?> Default
        {
            get
            {
                return _default;
            }

            set
            {
                if (_default != value)
                {
                    _default = value;
                    AttributeHandler.Assign(value, this, "default");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateDefault()
        {
            if (Default == null)
                Default = new AttributeValue<bool?>();
            return Default;
        }

        protected override void Initialize(Read.ITypeChainsChainFieldDisplaySelectionVisibility read, XmlElement editNode)
        {
            if (read == null)
                return;
            _default = read.Default != null ? new AttributeValue<bool?>(read.Default, this) : null;
        }

        public static TypeChainsChainFieldDisplaySelectionVisibility FromRead(Read.ITypeChainsChainFieldDisplaySelectionVisibility read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainFieldDisplaySelectionVisibility();
            item.Default = AttributeValue<bool?>.FromRead(read.Default);
            foreach (var x in read)
            {
                item.Add(TypeChainsChainFieldDisplaySelectionVisibilityStandalone.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplaySelectionVisibility(this);
        }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial class TypeChainsChainFieldDisplaySelectionVisibilityStandalone : EditableListNode<Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandalone, Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue, TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue>
    {
        internal TypeChainsChainFieldDisplaySelectionVisibilityStandalone(Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandalone read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Standalone node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainFieldDisplaySelectionVisibilityStandalone() : base("Standalone")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandalone read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static TypeChainsChainFieldDisplaySelectionVisibilityStandalone FromRead(Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandalone read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainFieldDisplaySelectionVisibilityStandalone();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            foreach (var x in read)
            {
                item.Add(TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplaySelectionVisibilityStandalone(this);
        }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial class TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue : EditableElementValueNode<Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue, string>
    {
        internal TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue(Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue read, XmlElement editNode)
        {
        }

        public static TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue FromRead(Read.ITypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue(this);
        }
    }

    ///<summary>
    /// Defines a field to be included in this tab of the search chain.
    ///</summary>
public partial class TypeChainsSearchChainTabsTabField : EditableElementNode<Read.ITypeChainsSearchChainTabsTabField>
    {
        internal TypeChainsSearchChainTabsTabField(Read.ITypeChainsSearchChainTabsTabField read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeChainsSearchChainTabsTabField node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainTabsTabField(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private TypeChainsSearchChainFieldDisplay _display;
        private TypeChainsSearchChainTabsTabFieldSubstitutions _substitutions;
        private TypeChainsSearchChainTabsTabFieldValidation _validation;
        private AttributeValue<uint?> _columnPid;
        private AttributeValue<string> _name;
        public TypeChainsSearchChainFieldDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// Defines possible substitutions to be applied to the field content.
        ///</summary>
public TypeChainsSearchChainTabsTabFieldSubstitutions Substitutions
        {
            get
            {
                return _substitutions;
            }

            set
            {
                if (_substitutions != value)
                {
                    _substitutions = value;
                    CombinedTagHandler.Assign(value, this, "Substitutions");
                }
            }
        }

        public TypeChainsSearchChainTabsTabFieldValidation Validation
        {
            get
            {
                return _validation;
            }

            set
            {
                if (_validation != value)
                {
                    _validation = value;
                    CombinedTagHandler.Assign(value, this, "Validation");
                }
            }
        }

        ///<summary>
        /// Specifies the column parameter ID of a column of the table referred to by the tablePid attribute of the enclosing Tab, or a column of a table that is linked with this table.
        ///</summary>
public AttributeValue<uint?> ColumnPid
        {
            get
            {
                return _columnPid;
            }

            set
            {
                if (_columnPid != value)
                {
                    _columnPid = value;
                    AttributeHandler.Assign(value, this, "columnPid");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the search field.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public TypeChainsSearchChainFieldDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new TypeChainsSearchChainFieldDisplay("Display");
            return Display;
        }

        public TypeChainsSearchChainTabsTabFieldSubstitutions GetOrCreateSubstitutions()
        {
            if (Substitutions == null)
                Substitutions = new TypeChainsSearchChainTabsTabFieldSubstitutions();
            return Substitutions;
        }

        public TypeChainsSearchChainTabsTabFieldValidation GetOrCreateValidation()
        {
            if (Validation == null)
                Validation = new TypeChainsSearchChainTabsTabFieldValidation();
            return Validation;
        }

        public AttributeValue<uint?> GetOrCreateColumnPid()
        {
            if (ColumnPid == null)
                ColumnPid = new AttributeValue<uint?>();
            return ColumnPid;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainTabsTabField read, XmlElement editNode)
        {
            if (read == null)
                return;
            _display = read.Display != null ? new TypeChainsSearchChainFieldDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _substitutions = read.Substitutions != null ? new TypeChainsSearchChainTabsTabFieldSubstitutions(read.Substitutions, this, editNode.Element["Substitutions"]) : null;
            _validation = read.Validation != null ? new TypeChainsSearchChainTabsTabFieldValidation(read.Validation, this, editNode.Element["Validation"]) : null;
            _columnPid = read.ColumnPid != null ? new AttributeValue<uint?>(read.ColumnPid, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static TypeChainsSearchChainTabsTabField FromRead(Read.ITypeChainsSearchChainTabsTabField read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainTabsTabField(read.TagName);
            item.Display = TypeChainsSearchChainFieldDisplay.FromRead(read.Display);
            item.Substitutions = TypeChainsSearchChainTabsTabFieldSubstitutions.FromRead(read.Substitutions);
            item.Validation = TypeChainsSearchChainTabsTabFieldValidation.FromRead(read.Validation);
            item.ColumnPid = AttributeValue<uint?>.FromRead(read.ColumnPid);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabField(this);
        }
    }

    ///<summary>
    /// Defines possible substitutions to be applied to the field content.
    ///</summary>
public partial class TypeChainsSearchChainTabsTabFieldSubstitutions : EditableListNode<Read.ITypeChainsSearchChainTabsTabFieldSubstitutions, Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution, TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution>
    {
        internal TypeChainsSearchChainTabsTabFieldSubstitutions(Read.ITypeChainsSearchChainTabsTabFieldSubstitutions read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Substitutions node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainTabsTabFieldSubstitutions() : base("Substitutions")
        {
            OnCreated();
        }

        protected override void Initialize(Read.ITypeChainsSearchChainTabsTabFieldSubstitutions read, XmlElement editNode)
        {
        }

        public static TypeChainsSearchChainTabsTabFieldSubstitutions FromRead(Read.ITypeChainsSearchChainTabsTabFieldSubstitutions read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainTabsTabFieldSubstitutions();
            foreach (var x in read)
            {
                item.Add(TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabFieldSubstitutions(this);
        }
    }

    ///<summary>
    /// Defines a substitution to be applied on the field content.
    ///</summary>
public partial class TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution : EditableElementNode<Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution>
    {
        internal TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution(Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Substitution node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution() : base("Substitution")
        {
            OnCreated();
        }

        private TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex _regex;
        ///<summary>
        /// Defines a substitution based on a regular expression.
        ///</summary>
public TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex Regex
        {
            get
            {
                return _regex;
            }

            set
            {
                if (_regex != value)
                {
                    _regex = value;
                    CombinedTagHandler.Assign(value, this, "Regex");
                }
            }
        }

        public TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex GetOrCreateRegex()
        {
            if (Regex == null)
                Regex = new TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex();
            return Regex;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution read, XmlElement editNode)
        {
            if (read == null)
                return;
            _regex = read.Regex != null ? new TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex(read.Regex, this, editNode.Element["Regex"]) : null;
        }

        public static TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution FromRead(Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution();
            item.Regex = TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex.FromRead(read.Regex);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution(this);
        }
    }

    ///<summary>
    /// Defines a substitution based on a regular expression.
    ///</summary>
public partial class TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex : EditableElementNode<Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex>
    {
        internal TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex(Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Regex node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex() : base("Regex")
        {
            OnCreated();
        }

        private ElementValue<string> _input;
        private ElementValue<string> _output;
        ///<summary>
        /// Specifies the regular expression defining the pattern of the field content.
        ///</summary>
public ElementValue<string> Input
        {
            get
            {
                return _input;
            }

            set
            {
                if (_input != value)
                {
                    _input = value;
                    ElementHandler.Assign(value, this, "Input");
                }
            }
        }

        ///<summary>
        /// Defines the output after substitution.
        ///</summary>
public ElementValue<string> Output
        {
            get
            {
                return _output;
            }

            set
            {
                if (_output != value)
                {
                    _output = value;
                    ElementHandler.Assign(value, this, "Output");
                }
            }
        }

        public ElementValue<string> GetOrCreateInput()
        {
            if (Input == null)
                Input = new ElementValue<string>();
            return Input;
        }

        public ElementValue<string> GetOrCreateOutput()
        {
            if (Output == null)
                Output = new ElementValue<string>();
            return Output;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex read, XmlElement editNode)
        {
            if (read == null)
                return;
            _input = read.Input != null ? new ElementValue<string>(read.Input, this) : null;
            _output = read.Output != null ? new ElementValue<string>(read.Output, this) : null;
        }

        public static TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex FromRead(Read.ITypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex();
            item.Input = ElementValue<string>.FromRead(read.Input);
            item.Output = ElementValue<string>.FromRead(read.Output);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex(this);
        }
    }

    public partial class TypeChainsSearchChainTabsTabFieldValidation : EditableElementNode<Read.ITypeChainsSearchChainTabsTabFieldValidation>
    {
        internal TypeChainsSearchChainTabsTabFieldValidation(Read.ITypeChainsSearchChainTabsTabFieldValidation read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Validation node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainTabsTabFieldValidation() : base("Validation")
        {
            OnCreated();
        }

        private ElementValue<string> _errorMessage;
        private ElementValue<string> _regex;
        ///<summary>
        /// Defines the error message to be displayed in case the input is invalid.
        ///</summary>
public ElementValue<string> ErrorMessage
        {
            get
            {
                return _errorMessage;
            }

            set
            {
                if (_errorMessage != value)
                {
                    _errorMessage = value;
                    ElementHandler.Assign(value, this, "ErrorMessage");
                }
            }
        }

        ///<summary>
        /// Defines the regular expression defining the pattern of allowed field content.
        ///</summary>
public ElementValue<string> Regex
        {
            get
            {
                return _regex;
            }

            set
            {
                if (_regex != value)
                {
                    _regex = value;
                    ElementHandler.Assign(value, this, "Regex");
                }
            }
        }

        public ElementValue<string> GetOrCreateErrorMessage()
        {
            if (ErrorMessage == null)
                ErrorMessage = new ElementValue<string>();
            return ErrorMessage;
        }

        public ElementValue<string> GetOrCreateRegex()
        {
            if (Regex == null)
                Regex = new ElementValue<string>();
            return Regex;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainTabsTabFieldValidation read, XmlElement editNode)
        {
            if (read == null)
                return;
            _errorMessage = read.ErrorMessage != null ? new ElementValue<string>(read.ErrorMessage, this) : null;
            _regex = read.Regex != null ? new ElementValue<string>(read.Regex, this) : null;
        }

        public static TypeChainsSearchChainTabsTabFieldValidation FromRead(Read.ITypeChainsSearchChainTabsTabFieldValidation read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainTabsTabFieldValidation();
            item.ErrorMessage = ElementValue<string>.FromRead(read.ErrorMessage);
            item.Regex = ElementValue<string>.FromRead(read.Regex);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainTabsTabFieldValidation(this);
        }
    }

    ///<summary>
    /// Configures chain field display settings.
    ///</summary>
public partial class TypeChainsSearchChainFieldDisplay : EditableElementNode<Read.ITypeChainsSearchChainFieldDisplay>
    {
        internal TypeChainsSearchChainFieldDisplay(Read.ITypeChainsSearchChainFieldDisplay read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeChainsSearchChainFieldDisplay node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainFieldDisplay(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private TypeChainsSearchChainFieldDisplayVisibility _visibility;
        public TypeChainsSearchChainFieldDisplayVisibility Visibility
        {
            get
            {
                return _visibility;
            }

            set
            {
                if (_visibility != value)
                {
                    _visibility = value;
                    CombinedTagHandler.Assign(value, this, "Visibility");
                }
            }
        }

        public TypeChainsSearchChainFieldDisplayVisibility GetOrCreateVisibility()
        {
            if (Visibility == null)
                Visibility = new TypeChainsSearchChainFieldDisplayVisibility();
            return Visibility;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainFieldDisplay read, XmlElement editNode)
        {
            if (read == null)
                return;
            _visibility = read.Visibility != null ? new TypeChainsSearchChainFieldDisplayVisibility(read.Visibility, this, editNode.Element["Visibility"]) : null;
        }

        public static TypeChainsSearchChainFieldDisplay FromRead(Read.ITypeChainsSearchChainFieldDisplay read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainFieldDisplay(read.TagName);
            item.Visibility = TypeChainsSearchChainFieldDisplayVisibility.FromRead(read.Visibility);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainFieldDisplay(this);
        }
    }

    public partial class TypeChainsSearchChainFieldDisplayVisibility : EditableListNode<Read.ITypeChainsSearchChainFieldDisplayVisibility, Read.ITypeChainsSearchChainFieldDisplayVisibilityStandalone, TypeChainsSearchChainFieldDisplayVisibilityStandalone>
    {
        internal TypeChainsSearchChainFieldDisplayVisibility(Read.ITypeChainsSearchChainFieldDisplayVisibility read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Visibility node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainFieldDisplayVisibility() : base("Visibility")
        {
            OnCreated();
        }

        private AttributeValue<bool?> _default;
        ///<summary>
        /// Specifies the default visibility when none of the conditions are met (Default: true).
        ///</summary>
public AttributeValue<bool?> Default
        {
            get
            {
                return _default;
            }

            set
            {
                if (_default != value)
                {
                    _default = value;
                    AttributeHandler.Assign(value, this, "default");
                }
            }
        }

        public AttributeValue<bool?> GetOrCreateDefault()
        {
            if (Default == null)
                Default = new AttributeValue<bool?>();
            return Default;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainFieldDisplayVisibility read, XmlElement editNode)
        {
            if (read == null)
                return;
            _default = read.Default != null ? new AttributeValue<bool?>(read.Default, this) : null;
        }

        public static TypeChainsSearchChainFieldDisplayVisibility FromRead(Read.ITypeChainsSearchChainFieldDisplayVisibility read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainFieldDisplayVisibility();
            item.Default = AttributeValue<bool?>.FromRead(read.Default);
            foreach (var x in read)
            {
                item.Add(TypeChainsSearchChainFieldDisplayVisibilityStandalone.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainFieldDisplayVisibility(this);
        }
    }

    ///<summary>
    /// Specifies the values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial class TypeChainsSearchChainFieldDisplayVisibilityStandalone : EditableListNode<Read.ITypeChainsSearchChainFieldDisplayVisibilityStandalone, Read.ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue, TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue>
    {
        internal TypeChainsSearchChainFieldDisplayVisibilityStandalone(Read.ITypeChainsSearchChainFieldDisplayVisibilityStandalone read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Standalone node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainFieldDisplayVisibilityStandalone() : base("Standalone")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _pid;
        public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.ITypeChainsSearchChainFieldDisplayVisibilityStandalone read, XmlElement editNode)
        {
            if (read == null)
                return;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static TypeChainsSearchChainFieldDisplayVisibilityStandalone FromRead(Read.ITypeChainsSearchChainFieldDisplayVisibilityStandalone read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainFieldDisplayVisibilityStandalone();
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            foreach (var x in read)
            {
                item.Add(TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainFieldDisplayVisibilityStandalone(this);
        }
    }

    ///<summary>
    /// Specifies one of the possible values the specified parameter must have to toggle the visibility to the opposite setting of the one defined in the default attribute.
    ///</summary>
public partial class TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue : EditableElementValueNode<Read.ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue, string>
    {
        internal TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue(Read.ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue read, IEditableNode parent, XmlElement editNode, bool useCDATA = false) : base(read, parent, editNode, useCDATA: useCDATA)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Value node. None of it's properties will be set.
        ///</summary>
public TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue(bool useCDATA = false) : base("Value", useCDATA: useCDATA)
        {
            OnCreated();
        }

        public TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue(string value, bool useCDATA = false) : base("Value", value, useCDATA: useCDATA)
        {
        }

        protected override void Initialize(Read.ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue read, XmlElement editNode)
        {
        }

        public static TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue FromRead(Read.ITypeChainsSearchChainFieldDisplayVisibilityStandaloneValue read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue();
            item.Value = read.Value;
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsSearchChainFieldDisplayVisibilityStandaloneValue(this);
        }
    }

    ///<summary>
    /// Each field in a chain is a possible block in the drill-down diagram displayed on the visual pages of a CPE Manager.
    ///</summary>
public partial class TypeChainsChainField : EditableElementNode<Read.ITypeChainsChainField>
    {
        internal TypeChainsChainField(Read.ITypeChainsChainField read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a TypeChainsChainField node. None of it's properties will be set.
        ///</summary>
public TypeChainsChainField(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private ElementValue<string> _diagramPids;
        private ElementValue<string> _diagramSorting;
        private ElementValue<string> _diagramTitleFormat;
        private TypeChainsChainFieldDisplay _display;
        private AttributeValue<string> _displayTable;
        private AttributeValue<string> _name;
        private AttributeValue<string> _options;
        private AttributeValue<uint?> _pid;
        ///<summary>
        /// Specifies the IDs of the (read) parameters to be shown in the diagram box.
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        ///</summary>
public ElementValue<string> DiagramPids
        {
            get
            {
                return _diagramPids;
            }

            set
            {
                if (_diagramPids != value)
                {
                    _diagramPids = value;
                    ElementHandler.Assign(value, this, "DiagramPids");
                }
            }
        }

        ///<summary>
        /// Specifies the diagram item sort order.
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        ///</summary>
public ElementValue<string> DiagramSorting
        {
            get
            {
                return _diagramSorting;
            }

            set
            {
                if (_diagramSorting != value)
                {
                    _diagramSorting = value;
                    ElementHandler.Assign(value, this, "DiagramSorting");
                }
            }
        }

        ///<summary>
        /// Specifies a custom title for the diagram box (By default, the title is the corresponding display key).
        /// Feature introduced in DataMiner 9.5.1 (RN 14442, RN 14468).
        /// Refer to the DataMiner Protocol Markup Language documentation for more information.
        ///</summary>
public ElementValue<string> DiagramTitleFormat
        {
            get
            {
                return _diagramTitleFormat;
            }

            set
            {
                if (_diagramTitleFormat != value)
                {
                    _diagramTitleFormat = value;
                    ElementHandler.Assign(value, this, "DiagramTitleFormat");
                }
            }
        }

        public TypeChainsChainFieldDisplay Display
        {
            get
            {
                return _display;
            }

            set
            {
                if (_display != value)
                {
                    _display = value;
                    CombinedTagHandler.Assign(value, this, "Display");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> DisplayTable
        {
            get
            {
                return _displayTable;
            }

            set
            {
                if (_displayTable != value)
                {
                    _displayTable = value;
                    AttributeHandler.Assign(value, this, "displayTable");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the block in the drill-down diagram.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options.
        /// Refer to the DataMiner Protocol Markup Language documentation for an overview of the available options.
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the parameter ID of the parameter to which the block is linked.
        /// From DataMiner 8.0.1 onwards (RN 5828), it is also possible to configure pid="0", in case you wish to dis­play lists when no filter is selected.
        ///</summary>
public AttributeValue<uint?> Pid
        {
            get
            {
                return _pid;
            }

            set
            {
                if (_pid != value)
                {
                    _pid = value;
                    AttributeHandler.Assign(value, this, "pid");
                }
            }
        }

        public ElementValue<string> GetOrCreateDiagramPids()
        {
            if (DiagramPids == null)
                DiagramPids = new ElementValue<string>();
            return DiagramPids;
        }

        public ElementValue<string> GetOrCreateDiagramSorting()
        {
            if (DiagramSorting == null)
                DiagramSorting = new ElementValue<string>();
            return DiagramSorting;
        }

        public ElementValue<string> GetOrCreateDiagramTitleFormat()
        {
            if (DiagramTitleFormat == null)
                DiagramTitleFormat = new ElementValue<string>();
            return DiagramTitleFormat;
        }

        public TypeChainsChainFieldDisplay GetOrCreateDisplay()
        {
            if (Display == null)
                Display = new TypeChainsChainFieldDisplay("Display");
            return Display;
        }

        public AttributeValue<string> GetOrCreateDisplayTable()
        {
            if (DisplayTable == null)
                DisplayTable = new AttributeValue<string>();
            return DisplayTable;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<uint?> GetOrCreatePid()
        {
            if (Pid == null)
                Pid = new AttributeValue<uint?>();
            return Pid;
        }

        protected override void Initialize(Read.ITypeChainsChainField read, XmlElement editNode)
        {
            if (read == null)
                return;
            _diagramPids = read.DiagramPids != null ? new ElementValue<string>(read.DiagramPids, this) : null;
            _diagramSorting = read.DiagramSorting != null ? new ElementValue<string>(read.DiagramSorting, this) : null;
            _diagramTitleFormat = read.DiagramTitleFormat != null ? new ElementValue<string>(read.DiagramTitleFormat, this) : null;
            _display = read.Display != null ? new TypeChainsChainFieldDisplay(read.Display, this, editNode.Element["Display"]) : null;
            _displayTable = read.DisplayTable != null ? new AttributeValue<string>(read.DisplayTable, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _pid = read.Pid != null ? new AttributeValue<uint?>(read.Pid, this) : null;
        }

        public static TypeChainsChainField FromRead(Read.ITypeChainsChainField read)
        {
            if (read == null)
                return null;
            var item = new TypeChainsChainField(read.TagName);
            item.DiagramPids = ElementValue<string>.FromRead(read.DiagramPids);
            item.DiagramSorting = ElementValue<string>.FromRead(read.DiagramSorting);
            item.DiagramTitleFormat = ElementValue<string>.FromRead(read.DiagramTitleFormat);
            item.Display = TypeChainsChainFieldDisplay.FromRead(read.Display);
            item.DisplayTable = AttributeValue<string>.FromRead(read.DisplayTable);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Pid = AttributeValue<uint?>.FromRead(read.Pid);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTypeChainsChainField(this);
        }
    }

    ///<summary>
    /// Defines a topology, representing the connections in a diagram displayed in a CPE manager.
    ///</summary>
public partial class Topology : EditableListNode<Read.ITopology, Read.ITopologyCell, TopologyCell>
    {
        internal Topology(Read.ITopology read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Topology node. None of it's properties will be set.
        ///</summary>
public Topology(string tagName) : base(tagName)
        {
            OnCreated();
        }

        private AttributeValue<string> _name;
        ///<summary>
        /// Specifies the name of the topology (Service Overview Manager only).
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        protected override void Initialize(Read.ITopology read, XmlElement editNode)
        {
            if (read == null)
                return;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
        }

        public static Topology FromRead(Read.ITopology read)
        {
            if (read == null)
                return null;
            var item = new Topology(read.TagName);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            foreach (var x in read)
            {
                item.Add(TopologyCell.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopology(this);
        }
    }

    ///<summary>
    /// Specifies a cell within a CPE topology.
    ///</summary>
public partial class TopologyCell : EditableListNode<Read.ITopologyCell, Read.ITopologyCellLink, TopologyCellLink>
    {
        internal TopologyCell(Read.ITopologyCell read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Cell node. None of it's properties will be set.
        ///</summary>
public TopologyCell() : base("Cell")
        {
            OnCreated();
        }

        private AttributeValue<string> _detailColumns;
        private AttributeValue<string> _listColumns;
        private AttributeValue<string> _name;
        private AttributeValue<string> _options;
        private AttributeValue<string> _table;
        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> DetailColumns
        {
            get
            {
                return _detailColumns;
            }

            set
            {
                if (_detailColumns != value)
                {
                    _detailColumns = value;
                    AttributeHandler.Assign(value, this, "detailColumns");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<string> ListColumns
        {
            get
            {
                return _listColumns;
            }

            set
            {
                if (_listColumns != value)
                {
                    _listColumns = value;
                    AttributeHandler.Assign(value, this, "listColumns");
                }
            }
        }

        ///<summary>
        /// Specifies the name of the cell.
        ///</summary>
public AttributeValue<string> Name
        {
            get
            {
                return _name;
            }

            set
            {
                if (_name != value)
                {
                    _name = value;
                    AttributeHandler.Assign(value, this, "name");
                }
            }
        }

        ///<summary>
        /// Specifies a number of options (Deprecated).
        ///</summary>
public AttributeValue<string> Options
        {
            get
            {
                return _options;
            }

            set
            {
                if (_options != value)
                {
                    _options = value;
                    AttributeHandler.Assign(value, this, "options");
                }
            }
        }

        ///<summary>
        /// Specifies the table parameter to which the cell is linked.
        ///</summary>
public AttributeValue<string> Table
        {
            get
            {
                return _table;
            }

            set
            {
                if (_table != value)
                {
                    _table = value;
                    AttributeHandler.Assign(value, this, "table");
                }
            }
        }

        public AttributeValue<string> GetOrCreateDetailColumns()
        {
            if (DetailColumns == null)
                DetailColumns = new AttributeValue<string>();
            return DetailColumns;
        }

        public AttributeValue<string> GetOrCreateListColumns()
        {
            if (ListColumns == null)
                ListColumns = new AttributeValue<string>();
            return ListColumns;
        }

        public AttributeValue<string> GetOrCreateName()
        {
            if (Name == null)
                Name = new AttributeValue<string>();
            return Name;
        }

        public AttributeValue<string> GetOrCreateOptions()
        {
            if (Options == null)
                Options = new AttributeValue<string>();
            return Options;
        }

        public AttributeValue<string> GetOrCreateTable()
        {
            if (Table == null)
                Table = new AttributeValue<string>();
            return Table;
        }

        protected override void Initialize(Read.ITopologyCell read, XmlElement editNode)
        {
            if (read == null)
                return;
            _detailColumns = read.DetailColumns != null ? new AttributeValue<string>(read.DetailColumns, this) : null;
            _listColumns = read.ListColumns != null ? new AttributeValue<string>(read.ListColumns, this) : null;
            _name = read.Name != null ? new AttributeValue<string>(read.Name, this) : null;
            _options = read.Options != null ? new AttributeValue<string>(read.Options, this) : null;
            _table = read.Table != null ? new AttributeValue<string>(read.Table, this) : null;
        }

        public static TopologyCell FromRead(Read.ITopologyCell read)
        {
            if (read == null)
                return null;
            var item = new TopologyCell();
            item.DetailColumns = AttributeValue<string>.FromRead(read.DetailColumns);
            item.ListColumns = AttributeValue<string>.FromRead(read.ListColumns);
            item.Name = AttributeValue<string>.FromRead(read.Name);
            item.Options = AttributeValue<string>.FromRead(read.Options);
            item.Table = AttributeValue<string>.FromRead(read.Table);
            foreach (var x in read)
            {
                item.Add(TopologyCellLink.FromRead(x));
            }

            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologyCell(this);
        }
    }

    ///<summary>
    /// Specifies how a cell in a CPE topology is linked to another cell in that topology, using foreign key relations (which can also be inside the same table).
    ///</summary>
public partial class TopologyCellLink : EditableElementNode<Read.ITopologyCellLink>
    {
        internal TopologyCellLink(Read.ITopologyCellLink read, IEditableNode parent, XmlElement editNode) : base(read, parent, editNode)
        {
        }

        ///<summary>
        /// Creates a new instance of this class, that represents a Link node. None of it's properties will be set.
        ///</summary>
public TopologyCellLink() : base("Link")
        {
            OnCreated();
        }

        private AttributeValue<uint?> _dest;
        private AttributeValue<uint?> _source;
        ///<summary>
        /// (CPE) Specifies the ID of the parameter column if you want to make a topology with foreign key relations inside a table.
        ///</summary>
public AttributeValue<uint?> Dest
        {
            get
            {
                return _dest;
            }

            set
            {
                if (_dest != value)
                {
                    _dest = value;
                    AttributeHandler.Assign(value, this, "dest");
                }
            }
        }

        ///<summary>
        /// *** No documentation available yet ***
        ///</summary>
public AttributeValue<uint?> Source
        {
            get
            {
                return _source;
            }

            set
            {
                if (_source != value)
                {
                    _source = value;
                    AttributeHandler.Assign(value, this, "source");
                }
            }
        }

        public AttributeValue<uint?> GetOrCreateDest()
        {
            if (Dest == null)
                Dest = new AttributeValue<uint?>();
            return Dest;
        }

        public AttributeValue<uint?> GetOrCreateSource()
        {
            if (Source == null)
                Source = new AttributeValue<uint?>();
            return Source;
        }

        protected override void Initialize(Read.ITopologyCellLink read, XmlElement editNode)
        {
            if (read == null)
                return;
            _dest = read.Dest != null ? new AttributeValue<uint?>(read.Dest, this) : null;
            _source = read.Source != null ? new AttributeValue<uint?>(read.Source, this) : null;
        }

        public static TopologyCellLink FromRead(Read.ITopologyCellLink read)
        {
            if (read == null)
                return null;
            var item = new TopologyCellLink();
            item.Dest = AttributeValue<uint?>.FromRead(read.Dest);
            item.Source = AttributeValue<uint?>.FromRead(read.Source);
            return item;
        }

        public override void Accept(ProtocolVisitor visitor)
        {
            visitor.VisitTopologyCellLink(this);
        }
    }
}

// Auto-generated code
// <auto-generated>This is auto-generated code by DIS. Do not modify.</auto-generated>
#pragma warning disable CS1591
namespace Skyline.DataMiner.CICD.Models.Protocol.Edit
{
    public abstract partial class ProtocolVisitor
    {
        public virtual void VisitProtocol(Protocol obj)
        {
            this.DefaultVisit(obj);
            obj.Actions?.Accept(this);
            obj.Advanced?.Accept(this);
            obj.AlarmLevelLinks?.Accept(this);
            obj.App?.Accept(this);
            obj.Chains?.Accept(this);
            obj.Commands?.Accept(this);
            obj.Compliancies?.Accept(this);
            obj.Connections?.Accept(this);
            obj.Description?.Accept(this);
            obj.DeviceOID?.Accept(this);
            obj.Display?.Accept(this);
            obj.DVEs?.Accept(this);
            obj.ElementOptions?.Accept(this);
            obj.SystemOptions?.Accept(this);
            obj.ElementType?.Accept(this);
            obj.ExportRules?.Accept(this);
            obj.GeneralParameters?.Accept(this);
            obj.Groups?.Accept(this);
            obj.HTTP?.Accept(this);
            obj.Icon?.Accept(this);
            obj.IntegrationID?.Accept(this);
            obj.InternalLicenses?.Accept(this);
            obj.Mib?.Accept(this);
            obj.Name?.Accept(this);
            obj.NoTimeouts?.Accept(this);
            obj.Options?.Accept(this);
            obj.Ownership?.Accept(this);
            obj.Pairs?.Accept(this);
            obj.ParameterGroups?.Accept(this);
            obj.Params?.Accept(this);
            obj.Ports?.Accept(this);
            obj.PortSettings?.Accept(this);
            obj.ProcessAutomation?.Accept(this);
            obj.Provider?.Accept(this);
            obj.QActions?.Accept(this);
            obj.RCA?.Accept(this);
            obj.Relations?.Accept(this);
            obj.Responses?.Accept(this);
            obj.SeverityBubbleUp?.Accept(this);
            obj.SNMP?.Accept(this);
            obj.Threads?.Accept(this);
            obj.Timers?.Accept(this);
            obj.Topology?.Accept(this);
            obj.Topologies?.Accept(this);
            obj.TreeControls?.Accept(this);
            obj.Triggers?.Accept(this);
            obj.Type?.Accept(this);
            obj.Vendor?.Accept(this);
            obj.VendorOID?.Accept(this);
            obj.Version?.Accept(this);
            obj.VersionHistory?.Accept(this);
            obj.BaseFor?.Accept(this);
        }

        public virtual void VisitActions(Actions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitActionsAction(ActionsAction obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Name?.Accept(this);
            obj.On?.Accept(this);
            obj.Type?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitActionsActionOn(ActionsActionOn obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Nr?.Accept(this);
        }

        public virtual void VisitActionsActionType(ActionsActionType obj)
        {
            this.DefaultVisit(obj);
            obj.Allowed?.Accept(this);
            obj.Arguments?.Accept(this);
            obj.Endoffset?.Accept(this);
            obj.Id?.Accept(this);
            obj.Nr?.Accept(this);
            obj.Options?.Accept(this);
            obj.Reschedule?.Accept(this);
            obj.ReturnValue?.Accept(this);
            obj.Regex?.Accept(this);
            obj.Scale?.Accept(this);
            obj.Script?.Accept(this);
            obj.Sequence?.Accept(this);
            obj.Startoffset?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitAdvanced(Advanced obj)
        {
            this.DefaultVisit(obj);
            obj.IgnoreEqualResponse?.Accept(this);
            obj.Stuffing?.Accept(this);
        }

        public virtual void VisitAlarmLevelLinks(AlarmLevelLinks obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitAlarmLevelLinksAlarmLevelLink(AlarmLevelLinksAlarmLevelLink obj)
        {
            this.DefaultVisit(obj);
            obj.Destination?.Accept(this);
            obj.Filters?.Accept(this);
            obj.Id?.Accept(this);
            obj.RemoteElement?.Accept(this);
        }

        public virtual void VisitApp(App obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
        }

        public virtual void VisitChains(Chains obj)
        {
            this.DefaultVisit(obj);
            obj.Filters?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitChainsItem(ChainsItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitChainsChain(ChainsChain obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.DefaultSelectionField?.Accept(this);
            obj.GroupingName?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Topology?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitChainsSearchChain(ChainsSearchChain obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.Tabs?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitChainsSearchChainTabs(ChainsSearchChainTabs obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitChainsSearchChainTabsTab(ChainsSearchChainTabsTab obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.Fields?.Accept(this);
            obj.TablePid?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitChainsSearchChainTabsTabFields(ChainsSearchChainTabsTabFields obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitCommands(Commands obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitCommandsCommand(CommandsCommand obj)
        {
            this.DefaultVisit(obj);
            obj.Content?.Accept(this);
            obj.Description?.Accept(this);
            obj.Name?.Accept(this);
            obj.WebSocketMessageType?.Accept(this);
            obj.Id?.Accept(this);
            obj.Ascii?.Accept(this);
        }

        public virtual void VisitCommandsCommandContent(CommandsCommandContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitCommandsCommandContentParam(CommandsCommandContentParam obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitCompliancies(Compliancies obj)
        {
            this.DefaultVisit(obj);
            obj.CassandraReady?.Accept(this);
            obj.CassandraRequired?.Accept(this);
            obj.MinimumRequiredVersion?.Accept(this);
            obj.MaximumSupportedVersion?.Accept(this);
        }

        public virtual void VisitConnections(Connections obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnection(ConnectionsConnection obj)
        {
            this.DefaultVisit(obj);
            obj.Virtual?.Accept(this);
            obj.Snmp?.Accept(this);
            obj.SnmpV2?.Accept(this);
            obj.SnmpV3?.Accept(this);
            obj.Http?.Accept(this);
            obj.Serial?.Accept(this);
            obj.SmartSerial?.Accept(this);
            obj.Gpib?.Accept(this);
            obj.Opc?.Accept(this);
            obj.Id?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionVirtual(ConnectionsConnectionVirtual obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSnmp(ConnectionsConnectionSnmp obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpCommunicationOptions(ConnectionsConnectionSnmpCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.RedundantPolling?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettings(ConnectionsConnectionSnmpUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsBusAddress(ConnectionsConnectionSnmpUserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsBusAddressRange(ConnectionsConnectionSnmpUserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsBusAddressValues(ConnectionsConnectionSnmpUserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsBusAddressValuesValue(ConnectionsConnectionSnmpUserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsIPport(ConnectionsConnectionSnmpUserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsGetCommunity(ConnectionsConnectionSnmpUserSettingsGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsSetCommunity(ConnectionsConnectionSnmpUserSettingsSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsTimeoutTime(ConnectionsConnectionSnmpUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpUserSettingsRetries(ConnectionsConnectionSnmpUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2(ConnectionsConnectionSnmpV2 obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2CommunicationOptions(ConnectionsConnectionSnmpV2CommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.RedundantPolling?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettings(ConnectionsConnectionSnmpV2UserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsBusAddress(ConnectionsConnectionSnmpV2UserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsBusAddressRange(ConnectionsConnectionSnmpV2UserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsBusAddressValues(ConnectionsConnectionSnmpV2UserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue(ConnectionsConnectionSnmpV2UserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsIPport(ConnectionsConnectionSnmpV2UserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsGetCommunity(ConnectionsConnectionSnmpV2UserSettingsGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsSetCommunity(ConnectionsConnectionSnmpV2UserSettingsSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsTimeoutTime(ConnectionsConnectionSnmpV2UserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV2UserSettingsRetries(ConnectionsConnectionSnmpV2UserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3(ConnectionsConnectionSnmpV3 obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3CommunicationOptions(ConnectionsConnectionSnmpV3CommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.RedundantPolling?.Accept(this);
            obj.DynamicContextName?.Accept(this);
            obj.DynamicContextID?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettings(ConnectionsConnectionSnmpV3UserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.SecurityLevel?.Accept(this);
            obj.AuthenticationAlgorithm?.Accept(this);
            obj.EncryptionAlgorithm?.Accept(this);
            obj.UserName?.Accept(this);
            obj.AuthenticationPassword?.Accept(this);
            obj.EncryptionPassword?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsBusAddress(ConnectionsConnectionSnmpV3UserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsBusAddressRange(ConnectionsConnectionSnmpV3UserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsBusAddressValues(ConnectionsConnectionSnmpV3UserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue(ConnectionsConnectionSnmpV3UserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsIPport(ConnectionsConnectionSnmpV3UserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsSecurityLevel(ConnectionsConnectionSnmpV3UserSettingsSecurityLevel obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm(ConnectionsConnectionSnmpV3UserSettingsAuthenticationAlgorithm obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm(ConnectionsConnectionSnmpV3UserSettingsEncryptionAlgorithm obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsUserName(ConnectionsConnectionSnmpV3UserSettingsUserName obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword(ConnectionsConnectionSnmpV3UserSettingsAuthenticationPassword obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsEncryptionPassword(ConnectionsConnectionSnmpV3UserSettingsEncryptionPassword obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsTimeoutTime(ConnectionsConnectionSnmpV3UserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSnmpV3UserSettingsRetries(ConnectionsConnectionSnmpV3UserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttp(ConnectionsConnectionHttp obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpCommunicationOptions(ConnectionsConnectionHttpCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.WebSocket?.Accept(this);
            obj.NotifyConnectionPIDs?.Accept(this);
            obj.MakeCommandByProtocol?.Accept(this);
            obj.WebSocketHandshake?.Accept(this);
            obj.RedundantPolling?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs(ConnectionsConnectionHttpCommunicationOptionsNotifyConnectionPIDs obj)
        {
            this.DefaultVisit(obj);
            obj.Connections?.Accept(this);
            obj.Disconnections?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettings(ConnectionsConnectionHttpUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsBusAddress(ConnectionsConnectionHttpUserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsBusAddressRange(ConnectionsConnectionHttpUserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsBusAddressValues(ConnectionsConnectionHttpUserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsBusAddressValuesValue(ConnectionsConnectionHttpUserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsIPport(ConnectionsConnectionHttpUserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsTimeoutTime(ConnectionsConnectionHttpUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionHttpUserSettingsRetries(ConnectionsConnectionHttpUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerial(ConnectionsConnectionSerial obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
            obj.Single?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialCommunicationOptions(ConnectionsConnectionSerialCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.ChunkedHTML?.Accept(this);
            obj.CloseConnectionOnResponse?.Accept(this);
            obj.KexAlgorithms?.Accept(this);
            obj.MakeCommandByProtocol?.Accept(this);
            obj.RedundantPolling?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialCommunicationOptionsKexAlgorithms(ConnectionsConnectionSerialCommunicationOptionsKexAlgorithms obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm(ConnectionsConnectionSerialCommunicationOptionsKexAlgorithmsKexAlgorithm obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettings(ConnectionsConnectionSerialUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.Baudrate?.Accept(this);
            obj.Parity?.Accept(this);
            obj.Databits?.Accept(this);
            obj.Stopbits?.Accept(this);
            obj.Flowcontrol?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeSerial?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Type?.Accept(this);
            obj.SslTlsEnabled?.Accept(this);
            obj.LocalIPport?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBusAddress(ConnectionsConnectionSerialUserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBusAddressRange(ConnectionsConnectionSerialUserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBusAddressValues(ConnectionsConnectionSerialUserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBusAddressValuesValue(ConnectionsConnectionSerialUserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsIPport(ConnectionsConnectionSerialUserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBaudrate(ConnectionsConnectionSerialUserSettingsBaudrate obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBaudrateRange(ConnectionsConnectionSerialUserSettingsBaudrateRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBaudrateValues(ConnectionsConnectionSerialUserSettingsBaudrateValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsBaudrateValuesValue(ConnectionsConnectionSerialUserSettingsBaudrateValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsParity(ConnectionsConnectionSerialUserSettingsParity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsParityRange(ConnectionsConnectionSerialUserSettingsParityRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsParityValues(ConnectionsConnectionSerialUserSettingsParityValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsParityValuesValue(ConnectionsConnectionSerialUserSettingsParityValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsDatabits(ConnectionsConnectionSerialUserSettingsDatabits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsDatabitsRange(ConnectionsConnectionSerialUserSettingsDatabitsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsDatabitsValues(ConnectionsConnectionSerialUserSettingsDatabitsValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsDatabitsValuesValue(ConnectionsConnectionSerialUserSettingsDatabitsValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsStopbits(ConnectionsConnectionSerialUserSettingsStopbits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsStopbitsValues(ConnectionsConnectionSerialUserSettingsStopbitsValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsStopbitsValuesValue(ConnectionsConnectionSerialUserSettingsStopbitsValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsFlowcontrol(ConnectionsConnectionSerialUserSettingsFlowcontrol obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsFlowcontrolRange(ConnectionsConnectionSerialUserSettingsFlowcontrolRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsFlowcontrolValues(ConnectionsConnectionSerialUserSettingsFlowcontrolValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue(ConnectionsConnectionSerialUserSettingsFlowcontrolValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsTimeoutTime(ConnectionsConnectionSerialUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsRetries(ConnectionsConnectionSerialUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsPortTypeIP(ConnectionsConnectionSerialUserSettingsPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsPortTypeSerial(ConnectionsConnectionSerialUserSettingsPortTypeSerial obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsPortTypeUDP(ConnectionsConnectionSerialUserSettingsPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsType(ConnectionsConnectionSerialUserSettingsType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsSslTlsEnabled(ConnectionsConnectionSerialUserSettingsSslTlsEnabled obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSerialUserSettingsLocalIPport(ConnectionsConnectionSerialUserSettingsLocalIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerial(ConnectionsConnectionSmartSerial obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
            obj.Single?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialCommunicationOptions(ConnectionsConnectionSmartSerialCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.MakeCommandByProtocol?.Accept(this);
            obj.MaxConcurrentConnections?.Accept(this);
            obj.MaxReceiveBuffer?.Accept(this);
            obj.NotifyConnectionPIDs?.Accept(this);
            obj.PacketInfo?.Accept(this);
            obj.RedundantPolling?.Accept(this);
            obj.SmartIPHeader?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs(ConnectionsConnectionSmartSerialCommunicationOptionsNotifyConnectionPIDs obj)
        {
            this.DefaultVisit(obj);
            obj.Connections?.Accept(this);
            obj.Disconnections?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo(ConnectionsConnectionSmartSerialCommunicationOptionsPacketInfo obj)
        {
            this.DefaultVisit(obj);
            obj.LengthIdentifierOffset?.Accept(this);
            obj.LengthIdentifierLength?.Accept(this);
            obj.IncludeLengthIdentifier?.Accept(this);
            obj.LittleEndian?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettings(ConnectionsConnectionSmartSerialUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.BusAddress?.Accept(this);
            obj.IPport?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Type?.Accept(this);
            obj.SslTlsEnabled?.Accept(this);
            obj.AllowedIPAddresses?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsBusAddress(ConnectionsConnectionSmartSerialUserSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsBusAddressRange(ConnectionsConnectionSmartSerialUserSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsBusAddressValues(ConnectionsConnectionSmartSerialUserSettingsBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue(ConnectionsConnectionSmartSerialUserSettingsBusAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsIPport(ConnectionsConnectionSmartSerialUserSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsTimeoutTime(ConnectionsConnectionSmartSerialUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsRetries(ConnectionsConnectionSmartSerialUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsPortTypeIP(ConnectionsConnectionSmartSerialUserSettingsPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsPortTypeUDP(ConnectionsConnectionSmartSerialUserSettingsPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsType(ConnectionsConnectionSmartSerialUserSettingsType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled(ConnectionsConnectionSmartSerialUserSettingsSslTlsEnabled obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses(ConnectionsConnectionSmartSerialUserSettingsAllowedIPAddresses obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpib(ConnectionsConnectionGpib obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibCommunicationOptions(ConnectionsConnectionGpibCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettings(ConnectionsConnectionGpibUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.DeviceAddress?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Retries?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsDeviceAddress(ConnectionsConnectionGpibUserSettingsDeviceAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsDeviceAddressRange(ConnectionsConnectionGpibUserSettingsDeviceAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsDeviceAddressValues(ConnectionsConnectionGpibUserSettingsDeviceAddressValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue(ConnectionsConnectionGpibUserSettingsDeviceAddressValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsTimeoutTime(ConnectionsConnectionGpibUserSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionGpibUserSettingsRetries(ConnectionsConnectionGpibUserSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionOpc(ConnectionsConnectionOpc obj)
        {
            this.DefaultVisit(obj);
            obj.CommunicationOptions?.Accept(this);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionOpcCommunicationOptions(ConnectionsConnectionOpcCommunicationOptions obj)
        {
            this.DefaultVisit(obj);
            obj.ProgID?.Accept(this);
        }

        public virtual void VisitConnectionsConnectionOpcUserSettings(ConnectionsConnectionOpcUserSettings obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitDisplay(Display obj)
        {
            this.DefaultVisit(obj);
            obj.Pages?.Accept(this);
            obj.DefaultPage?.Accept(this);
            obj.PageOptions?.Accept(this);
            obj.PageOrder?.Accept(this);
            obj.Type?.Accept(this);
            obj.WideColumnPages?.Accept(this);
        }

        public virtual void VisitDisplayPages(DisplayPages obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitDisplayPagesPage(DisplayPagesPage obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitDisplayPagesPageVisibility(DisplayPagesPageVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            obj.OverridePID?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitDVEs(DVEs obj)
        {
            this.DefaultVisit(obj);
            obj.DVEProtocols?.Accept(this);
            obj.ExportRules?.Accept(this);
        }

        public virtual void VisitDVEsDVEProtocols(DVEsDVEProtocols obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitDVEsDVEProtocolsDVEProtocol(DVEsDVEProtocolsDVEProtocol obj)
        {
            this.DefaultVisit(obj);
            obj.ElementPrefix?.Accept(this);
            obj.Name?.Accept(this);
            obj.TablePID?.Accept(this);
        }

        public virtual void VisitElementOptions(ElementOptions obj)
        {
            this.DefaultVisit(obj);
            obj.UserSettings?.Accept(this);
        }

        public virtual void VisitElementOptionsUserSettings(ElementOptionsUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.PingInterval?.Accept(this);
            obj.SlowPoll?.Accept(this);
            obj.SlowPollBase?.Accept(this);
            obj.TimeoutTimeElement?.Accept(this);
        }

        public virtual void VisitSystemOptions(SystemOptions obj)
        {
            this.DefaultVisit(obj);
            obj.RunInSeparateInstance?.Accept(this);
        }

        public virtual void VisitGeneralParameters(GeneralParameters obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitGeneralParametersGeneralParameter(GeneralParametersGeneralParameter obj)
        {
            this.DefaultVisit(obj);
            obj.Group?.Accept(this);
            obj.Enabled?.Accept(this);
        }

        public virtual void VisitGroups(Groups obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitGroupsGroup(GroupsGroup obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Content?.Accept(this);
            obj.Description?.Accept(this);
            obj.Name?.Accept(this);
            obj.Type?.Accept(this);
            obj.Connection?.Accept(this);
            obj.ConnectionPID?.Accept(this);
            obj.Id?.Accept(this);
            obj.Ping?.Accept(this);
        }

        public virtual void VisitGroupsGroupContent(GroupsGroupContent obj)
        {
            this.DefaultVisit(obj);
            obj.MultipleGet?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitGroupsGroupContentItem(GroupsGroupContentItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitGroupsGroupContentAction(GroupsGroupContentAction obj)
        {
            this.DefaultVisit(obj);
            obj.Next?.Accept(this);
        }

        public virtual void VisitGroupsGroupContentPair(GroupsGroupContentPair obj)
        {
            this.DefaultVisit(obj);
            obj.Next?.Accept(this);
        }

        public virtual void VisitGroupsGroupContentParam(GroupsGroupContentParam obj)
        {
            this.DefaultVisit(obj);
            obj.Next?.Accept(this);
        }

        public virtual void VisitGroupsGroupContentSession(GroupsGroupContentSession obj)
        {
            this.DefaultVisit(obj);
            obj.Connection?.Accept(this);
            obj.Next?.Accept(this);
        }

        public virtual void VisitGroupsGroupContentTrigger(GroupsGroupContentTrigger obj)
        {
            this.DefaultVisit(obj);
            obj.Next?.Accept(this);
        }

        public virtual void VisitHTTP(HTTP obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHTTPSession(HTTPSession obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.IgnoreTimeout?.Accept(this);
            obj.KeepAlive?.Accept(this);
            obj.LoginMethod?.Accept(this);
            obj.Name?.Accept(this);
            obj.Password?.Accept(this);
            obj.ProxyPassword?.Accept(this);
            obj.ProxyServer?.Accept(this);
            obj.ProxyUser?.Accept(this);
            obj.Timeout?.Accept(this);
            obj.UserName?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHTTPSessionConnection(HTTPSessionConnection obj)
        {
            this.DefaultVisit(obj);
            obj.Request?.Accept(this);
            obj.Response?.Accept(this);
            obj.Id?.Accept(this);
            obj.IgnoreTimeout?.Accept(this);
            obj.Name?.Accept(this);
            obj.Timeout?.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionRequest(HTTPSessionConnectionRequest obj)
        {
            this.DefaultVisit(obj);
            obj.Headers?.Accept(this);
            obj.Data?.Accept(this);
            obj.Parameters?.Accept(this);
            obj.Pid?.Accept(this);
            obj.Verb?.Accept(this);
            obj.Url?.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionResponse(HTTPSessionConnectionResponse obj)
        {
            this.DefaultVisit(obj);
            obj.Headers?.Accept(this);
            obj.Content?.Accept(this);
            obj.StatusCode?.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionResponseHeaders(HTTPSessionConnectionResponseHeaders obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionResponseHeadersHeader(HTTPSessionConnectionResponseHeadersHeader obj)
        {
            this.DefaultVisit(obj);
            obj.Key?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitHTTPSessionConnectionResponseContent(HTTPSessionConnectionResponseContent obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitInternalLicenses(InternalLicenses obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitInternalLicensesInternalLicense(InternalLicensesInternalLicense obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
        }

        public virtual void VisitNoTimeouts(NoTimeouts obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitNoTimeoutsNoTimeout(NoTimeoutsNoTimeout obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitOptions(Options obj)
        {
            this.DefaultVisit(obj);
            obj.DataBaseOptions?.Accept(this);
            obj.DisableViewRefresh?.Accept(this);
            obj.Encoding?.Accept(this);
            obj.ForceDefaultAlarming?.Accept(this);
            obj.GenerateMIB?.Accept(this);
            obj.Icon?.Accept(this);
            obj.NoTimeouts?.Accept(this);
            obj.OverrideTimeoutDVE?.Accept(this);
            obj.PostPonePortInitialisation?.Accept(this);
            obj.UseAgentBinding?.Accept(this);
        }

        public virtual void VisitOptionsDataBaseOptions(OptionsDataBaseOptions obj)
        {
            this.DefaultVisit(obj);
            obj.CustomDataIDs?.Accept(this);
            obj.PartitionedTrending?.Accept(this);
        }

        public virtual void VisitOptionsGenerateMIB(OptionsGenerateMIB obj)
        {
            this.DefaultVisit(obj);
            obj.IncludePages?.Accept(this);
        }

        public virtual void VisitOptionsNoTimeouts(OptionsNoTimeouts obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOptionsNoTimeoutsNoTimeout(OptionsNoTimeoutsNoTimeout obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitOwnership(Ownership obj)
        {
            this.DefaultVisit(obj);
            obj.Elements?.Accept(this);
            obj.Views?.Accept(this);
            obj.Services?.Accept(this);
            obj.RedundancyGroups?.Accept(this);
        }

        public virtual void VisitOwnershipElements(OwnershipElements obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOwnershipElementsElement(OwnershipElementsElement obj)
        {
            this.DefaultVisit(obj);
            obj.Protocol?.Accept(this);
            obj.Description?.Accept(this);
            obj.Properties?.Accept(this);
            obj.AlarmTemplate?.Accept(this);
            obj.TrendTemplate?.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementDescription(OwnershipElementsElementDescription obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementProperties(OwnershipElementsElementProperties obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementPropertiesProperty(OwnershipElementsElementPropertiesProperty obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementAlarmTemplate(OwnershipElementsElementAlarmTemplate obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipElementsElementTrendTemplate(OwnershipElementsElementTrendTemplate obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipViews(OwnershipViews obj)
        {
            this.DefaultVisit(obj);
            obj.View?.Accept(this);
        }

        public virtual void VisitOwnershipViewsView(OwnershipViewsView obj)
        {
            this.DefaultVisit(obj);
            obj.Properties?.Accept(this);
        }

        public virtual void VisitOwnershipViewsViewProperties(OwnershipViewsViewProperties obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOwnershipViewsViewPropertiesProperty(OwnershipViewsViewPropertiesProperty obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipServices(OwnershipServices obj)
        {
            this.DefaultVisit(obj);
            obj.Service?.Accept(this);
        }

        public virtual void VisitOwnershipServicesService(OwnershipServicesService obj)
        {
            this.DefaultVisit(obj);
            obj.Description?.Accept(this);
            obj.Properties?.Accept(this);
        }

        public virtual void VisitOwnershipServicesServiceDescription(OwnershipServicesServiceDescription obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipServicesServiceProperties(OwnershipServicesServiceProperties obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitOwnershipServicesServicePropertiesProperty(OwnershipServicesServicePropertiesProperty obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroups(OwnershipRedundancyGroups obj)
        {
            this.DefaultVisit(obj);
            obj.RedundancyGroup?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroupsRedundancyGroup(OwnershipRedundancyGroupsRedundancyGroup obj)
        {
            this.DefaultVisit(obj);
            obj.Description?.Accept(this);
            obj.Maintenance?.Accept(this);
            obj.Switching?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroupsRedundancyGroupDescription(OwnershipRedundancyGroupsRedundancyGroupDescription obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroupsRedundancyGroupMaintenance(OwnershipRedundancyGroupsRedundancyGroupMaintenance obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitOwnershipRedundancyGroupsRedundancyGroupSwitching(OwnershipRedundancyGroupsRedundancyGroupSwitching obj)
        {
            this.DefaultVisit(obj);
            obj.AccessType?.Accept(this);
        }

        public virtual void VisitPairs(Pairs obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPairsPair(PairsPair obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Content?.Accept(this);
            obj.Description?.Accept(this);
            obj.Name?.Accept(this);
            obj.Id?.Accept(this);
            obj.Options?.Accept(this);
            obj.Ping?.Accept(this);
            obj.Timeout?.Accept(this);
        }

        public virtual void VisitPairsPairContent(PairsPairContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPairsPairContentItem(PairsPairContentItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPairsPairContentCommand(PairsPairContentCommand obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPairsPairContentResponse(PairsPairContentResponse obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPairsPairContentResponseOnBadCommand(PairsPairContentResponseOnBadCommand obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParameterGroups(ParameterGroups obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParameterGroupsGroup(ParameterGroupsGroup obj)
        {
            this.DefaultVisit(obj);
            obj.Params?.Accept(this);
            obj.CalculateAlarmState?.Accept(this);
            obj.DynamicId?.Accept(this);
            obj.DynamicIndex?.Accept(this);
            obj.DynamicUsePK?.Accept(this);
            obj.Id?.Accept(this);
            obj.IsInternal?.Accept(this);
            obj.Name?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParameterGroupsGroupParams(ParameterGroupsGroupParams obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParameterGroupsGroupParamsParam(ParameterGroupsGroupParamsParam obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Index?.Accept(this);
        }

        public virtual void VisitParams(Params obj)
        {
            this.DefaultVisit(obj);
            obj.LoadSequence?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParam(ParamsParam obj)
        {
            this.DefaultVisit(obj);
            obj.Alarm?.Accept(this);
            obj.ArrayOptions?.Accept(this);
            obj.CRC?.Accept(this);
            obj.CrossDriverOptions?.Accept(this);
            obj.Dashboard?.Accept(this);
            obj.Database?.Accept(this);
            obj.Dependencies?.Accept(this);
            obj.Description?.Accept(this);
            obj.Display?.Accept(this);
            obj.HyperLinks?.Accept(this);
            obj.Icon?.Accept(this);
            obj.Information?.Accept(this);
            obj.Interprete?.Accept(this);
            obj.Length?.Accept(this);
            obj.Matrix?.Accept(this);
            obj.Measurement?.Accept(this);
            obj.Mediation?.Accept(this);
            obj.Message?.Accept(this);
            obj.Name?.Accept(this);
            obj.Replication?.Accept(this);
            obj.SNMP?.Accept(this);
            obj.Type?.Accept(this);
            obj.ConfirmPopup?.Accept(this);
            obj.DuplicateAs?.Accept(this);
            obj.Export?.Accept(this);
            obj.HistorySet?.Accept(this);
            obj.Id?.Accept(this);
            obj.Level?.Accept(this);
            obj.Options?.Accept(this);
            obj.PollingInterval?.Accept(this);
            obj.Save?.Accept(this);
            obj.SaveInterval?.Accept(this);
            obj.Setter?.Accept(this);
            obj.Snapshot?.Accept(this);
            obj.SnmpSetAndGet?.Accept(this);
            obj.Trending?.Accept(this);
            obj.VerificationTimeout?.Accept(this);
        }

        public virtual void VisitParamsParamAlarm(ParamsParamAlarm obj)
        {
            this.DefaultVisit(obj);
            obj.CH?.Accept(this);
            obj.CL?.Accept(this);
            obj.Info?.Accept(this);
            obj.MaH?.Accept(this);
            obj.MaL?.Accept(this);
            obj.MiH?.Accept(this);
            obj.MiL?.Accept(this);
            obj.Monitored?.Accept(this);
            obj.Normal?.Accept(this);
            obj.WaH?.Accept(this);
            obj.WaL?.Accept(this);
            obj.ActiveTime?.Accept(this);
            obj.Options?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamAlarmMonitored(ParamsParamAlarmMonitored obj)
        {
            this.DefaultVisit(obj);
            obj.DisabledIf?.Accept(this);
        }

        public virtual void VisitParamsParamArrayOptions(ParamsParamArrayOptions obj)
        {
            this.DefaultVisit(obj);
            obj.NamingFormat?.Accept(this);
            obj.DeleteRow?.Accept(this);
            obj.DisplayColumn?.Accept(this);
            obj.Index?.Accept(this);
            obj.Options?.Accept(this);
            obj.Partial?.Accept(this);
            obj.SnmpIndex?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamArrayOptionsNamingFormat(ParamsParamArrayOptionsNamingFormat obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParamsParamCRC(ParamsParamCRC obj)
        {
            this.DefaultVisit(obj);
            obj.Content?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamCRCContent(ParamsParamCRCContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamCRCContentParam(ParamsParamCRCContentParam obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParamsParamCRCType(ParamsParamCRCType obj)
        {
            this.DefaultVisit(obj);
            obj.Byteoffset?.Accept(this);
            obj.Groupbytes?.Accept(this);
            obj.Mod?.Accept(this);
            obj.Off?.Accept(this);
            obj.Options?.Accept(this);
            obj.Totaloffset?.Accept(this);
        }

        public virtual void VisitParamsParamCrossDriverOptions(ParamsParamCrossDriverOptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamCrossDriverOptionsCrossDriverOption(ParamsParamCrossDriverOptionsCrossDriverOption obj)
        {
            this.DefaultVisit(obj);
            obj.Protocol?.Accept(this);
            obj.RemoteTablePID?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation(ParamsParamCrossDriverOptionsCrossDriverOptionPIDTranslation obj)
        {
            this.DefaultVisit(obj);
            obj.Local?.Accept(this);
            obj.Remote?.Accept(this);
        }

        public virtual void VisitParamsParamDashboard(ParamsParamDashboard obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.DashboardOptions?.Accept(this);
        }

        public virtual void VisitParamsParamDashboardDashboardOptions(ParamsParamDashboardDashboardOptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDashboardDashboardOptionsDashboardOption(ParamsParamDashboardDashboardOptionsDashboardOption obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitParamsParamDatabase(ParamsParamDatabase obj)
        {
            this.DefaultVisit(obj);
            obj.ColumnDefinition?.Accept(this);
            obj.Connection?.Accept(this);
            obj.CQLOptions?.Accept(this);
            obj.Partition?.Accept(this);
            obj.IndexingOptions?.Accept(this);
        }

        public virtual void VisitParamsParamDatabaseColumnDefinition(ParamsParamDatabaseColumnDefinition obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
        }

        public virtual void VisitParamsParamDatabaseConnection(ParamsParamDatabaseConnection obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamDatabaseCQLOptions(ParamsParamDatabaseCQLOptions obj)
        {
            this.DefaultVisit(obj);
            obj.Clustering?.Accept(this);
            obj.Finalizer?.Accept(this);
            obj.TableProperty?.Accept(this);
        }

        public virtual void VisitParamsParamDatabasePartition(ParamsParamDatabasePartition obj)
        {
            this.DefaultVisit(obj);
            obj.PartitionsToKeep?.Accept(this);
        }

        public virtual void VisitParamsParamDatabaseIndexingOptions(ParamsParamDatabaseIndexingOptions obj)
        {
            this.DefaultVisit(obj);
            obj.Enabled?.Accept(this);
        }

        public virtual void VisitParamsParamDependencies(ParamsParamDependencies obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDependenciesId(ParamsParamDependenciesId obj)
        {
            this.DefaultVisit(obj);
            obj.PostSet?.Accept(this);
        }

        public virtual void VisitParamsParamDisplay(ParamsParamDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.DynamicUnits?.Accept(this);
            obj.Decimals?.Accept(this);
            obj.ParametersView?.Accept(this);
            obj.Positions?.Accept(this);
            obj.Range?.Accept(this);
            obj.RTDisplay?.Accept(this);
            obj.Steps?.Accept(this);
            obj.Trending?.Accept(this);
            obj.Units?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayDynamicUnits(ParamsParamDisplayDynamicUnits obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDisplayDynamicUnitsUnit(ParamsParamDisplayDynamicUnitsUnit obj)
        {
            this.DefaultVisit(obj);
            obj.Decimals?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayParametersView(ParamsParamDisplayParametersView obj)
        {
            this.DefaultVisit(obj);
            obj.Parameters?.Accept(this);
            obj.Options?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayParametersViewParameters(ParamsParamDisplayParametersViewParameters obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDisplayParametersViewParametersParameter(ParamsParamDisplayParametersViewParametersParameter obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Options?.Accept(this);
            obj.TableIndex?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayPositions(ParamsParamDisplayPositions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamDisplayPositionsPosition(ParamsParamDisplayPositionsPosition obj)
        {
            this.DefaultVisit(obj);
            obj.Page?.Accept(this);
            obj.Column?.Accept(this);
            obj.Row?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayPositionsPositionPage(ParamsParamDisplayPositionsPositionPage obj)
        {
            this.DefaultVisit(obj);
            obj.MeasType?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayRange(ParamsParamDisplayRange obj)
        {
            this.DefaultVisit(obj);
            obj.Low?.Accept(this);
            obj.High?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayRTDisplay(ParamsParamDisplayRTDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.OnAppLevel?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayTrending(ParamsParamDisplayTrending obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Logarithmic?.Accept(this);
        }

        public virtual void VisitParamsParamDisplayTrendingType(ParamsParamDisplayTrendingType obj)
        {
            this.DefaultVisit(obj);
            obj.Operations?.Accept(this);
        }

        public virtual void VisitParamsParamHyperLinks(ParamsParamHyperLinks obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamHyperLinksHyperLink(ParamsParamHyperLinksHyperLink obj)
        {
            this.DefaultVisit(obj);
            obj.ValueParsing?.Accept(this);
        }

        public virtual void VisitParamsParamInformation(ParamsParamInformation obj)
        {
            this.DefaultVisit(obj);
            obj.AlarmDescription?.Accept(this);
            obj.Category?.Accept(this);
            obj.CorrectiveAction?.Accept(this);
            obj.Includes?.Accept(this);
            obj.Subtext?.Accept(this);
            obj.Text?.Accept(this);
        }

        public virtual void VisitParamsParamInformationIncludes(ParamsParamInformationIncludes obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamInformationIncludesInclude(ParamsParamInformationIncludesInclude obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParamsParamInterprete(ParamsParamInterprete obj)
        {
            this.DefaultVisit(obj);
            obj.Alignment?.Accept(this);
            obj.Base?.Accept(this);
            obj.Bits?.Accept(this);
            obj.ByteOffset?.Accept(this);
            obj.Decimals?.Accept(this);
            obj.DefaultValue?.Accept(this);
            obj.Endian?.Accept(this);
            obj.Exceptions?.Accept(this);
            obj.Factor?.Accept(this);
            obj.Length?.Accept(this);
            obj.LengthType?.Accept(this);
            obj.NbrOfBits?.Accept(this);
            obj.OffSet?.Accept(this);
            obj.Others?.Accept(this);
            obj.Range?.Accept(this);
            obj.RawType?.Accept(this);
            obj.Rounding?.Accept(this);
            obj.Scale?.Accept(this);
            obj.Sequence?.Accept(this);
            obj.StartPosition?.Accept(this);
            obj.Type?.Accept(this);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteExceptions(ParamsParamInterpreteExceptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteExceptionsException(ParamsParamInterpreteExceptionsException obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.ValueElement?.Accept(this);
            obj.Id?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteExceptionsExceptionDisplay(ParamsParamInterpreteExceptionsExceptionDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.State?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteLengthType(ParamsParamInterpreteLengthType obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Times?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteOffSet(ParamsParamInterpreteOffSet obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteOthers(ParamsParamInterpreteOthers obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteOthersOther(ParamsParamInterpreteOthersOther obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.ValueElement?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteOthersOtherDisplay(ParamsParamInterpreteOthersOtherDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.State?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteRange(ParamsParamInterpreteRange obj)
        {
            this.DefaultVisit(obj);
            obj.Low?.Accept(this);
            obj.High?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteScale(ParamsParamInterpreteScale obj)
        {
            this.DefaultVisit(obj);
            obj.LowData?.Accept(this);
            obj.HighData?.Accept(this);
            obj.Low?.Accept(this);
            obj.High?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteSequence(ParamsParamInterpreteSequence obj)
        {
            this.DefaultVisit(obj);
            obj.Loop?.Accept(this);
            obj.Noset?.Accept(this);
        }

        public virtual void VisitParamsParamInterpreteType(ParamsParamInterpreteType obj)
        {
            this.DefaultVisit(obj);
            obj.Filter?.Accept(this);
            obj.Trim?.Accept(this);
        }

        public virtual void VisitParamsParamLength(ParamsParamLength obj)
        {
            this.DefaultVisit(obj);
            obj.Content?.Accept(this);
        }

        public virtual void VisitParamsParamLengthContent(ParamsParamLengthContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamLengthContentParam(ParamsParamLengthContentParam obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitParamsParamMatrix(ParamsParamMatrix obj)
        {
            this.DefaultVisit(obj);
            obj.Inputs?.Accept(this);
            obj.Outputs?.Accept(this);
            obj.MatrixOptions?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixInputs(ParamsParamMatrixInputs obj)
        {
            this.DefaultVisit(obj);
            obj.Mappings?.Accept(this);
            obj.TablePid?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixInputsMappings(ParamsParamMatrixInputsMappings obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMatrixInputsMappingsMapping(ParamsParamMatrixInputsMappingsMapping obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixOutputs(ParamsParamMatrixOutputs obj)
        {
            this.DefaultVisit(obj);
            obj.Mappings?.Accept(this);
            obj.TablePid?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixOutputsMappings(ParamsParamMatrixOutputsMappings obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMatrixOutputsMappingsMapping(ParamsParamMatrixOutputsMappingsMapping obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitParamsParamMatrixMatrixOptions(ParamsParamMatrixMatrixOptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMatrixMatrixOptionsMatrixOption(ParamsParamMatrixMatrixOptionsMatrixOption obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurement(ParamsParamMeasurement obj)
        {
            this.DefaultVisit(obj);
            obj.Discreets?.Accept(this);
            obj.Threshold?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementDiscreets(ParamsParamMeasurementDiscreets obj)
        {
            this.DefaultVisit(obj);
            obj.DependencyId?.Accept(this);
            obj.MatrixLayout?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementDiscreetsDiscreet(ParamsParamMeasurementDiscreetsDiscreet obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.ValueElement?.Accept(this);
            obj.Tooltip?.Accept(this);
            obj.DependencyValues?.Accept(this);
            obj.DisplayIconAndLabel?.Accept(this);
            obj.Export?.Accept(this);
            obj.IconRef?.Accept(this);
            obj.Options?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementDiscreetsDiscreetDisplay(ParamsParamMeasurementDiscreetsDiscreetDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.State?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementDiscreetsDiscreetValue(ParamsParamMeasurementDiscreetsDiscreetValue obj)
        {
            this.DefaultVisit(obj);
            obj.Location?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamMeasurementType(ParamsParamMeasurementType obj)
        {
            this.DefaultVisit(obj);
            obj.Case?.Accept(this);
            obj.Continuous?.Accept(this);
            obj.Hex?.Accept(this);
            obj.Lines?.Accept(this);
            obj.Link?.Accept(this);
            obj.Number?.Accept(this);
            obj.Options?.Accept(this);
            obj.ScientificNotation?.Accept(this);
            obj.VerificationDeviation?.Accept(this);
            obj.Width?.Accept(this);
        }

        public virtual void VisitParamsParamMediation(ParamsParamMediation obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMediationLinkTo(ParamsParamMediationLinkTo obj)
        {
            this.DefaultVisit(obj);
            obj.Description?.Accept(this);
            obj.Ops?.Accept(this);
            obj.Pid?.Accept(this);
            obj.Protocol?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamMediationLinkToValueMapping(ParamsParamMediationLinkToValueMapping obj)
        {
            this.DefaultVisit(obj);
            obj.RemoteValue?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitParamsParamReplication(ParamsParamReplication obj)
        {
            this.DefaultVisit(obj);
            obj.Element?.Accept(this);
            obj.Parameter?.Accept(this);
            obj.Ip?.Accept(this);
            obj.Uid?.Accept(this);
            obj.Pwd?.Accept(this);
            obj.Domain?.Accept(this);
        }

        public virtual void VisitParamsParamReplicationElement(ParamsParamReplicationElement obj)
        {
            this.DefaultVisit(obj);
            obj.Dynamic?.Accept(this);
        }

        public virtual void VisitParamsParamReplicationParameter(ParamsParamReplicationParameter obj)
        {
            this.DefaultVisit(obj);
            obj.Dynamic?.Accept(this);
        }

        public virtual void VisitParamsParamSNMP(ParamsParamSNMP obj)
        {
            this.DefaultVisit(obj);
            obj.Enabled?.Accept(this);
            obj.Factor?.Accept(this);
            obj.InvalidResponseHandling?.Accept(this);
            obj.OID?.Accept(this);
            obj.TrapMappings?.Accept(this);
            obj.TrapOID?.Accept(this);
            obj.Type?.Accept(this);
            obj.Options?.Accept(this);
        }

        public virtual void VisitParamsParamSNMPInvalidResponseHandling(ParamsParamSNMPInvalidResponseHandling obj)
        {
            this.DefaultVisit(obj);
            obj.InfiniteLoop?.Accept(this);
        }

        public virtual void VisitParamsParamSNMPOID(ParamsParamSNMPOID obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
            obj.Ipid?.Accept(this);
            obj.Options?.Accept(this);
            obj.SkipDynamicSNMPGet?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamSNMPTrapMappings(ParamsParamSNMPTrapMappings obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitParamsParamSNMPTrapMappingsTrapMapping(ParamsParamSNMPTrapMappingsTrapMapping obj)
        {
            this.DefaultVisit(obj);
            obj.BindingMatch?.Accept(this);
            obj.Severity?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitParamsParamSNMPTrapOID(ParamsParamSNMPTrapOID obj)
        {
            this.DefaultVisit(obj);
            obj.CheckBindings?.Accept(this);
            obj.Ipid?.Accept(this);
            obj.MapAlarm?.Accept(this);
            obj.SetBindings?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitParamsParamType(ParamsParamType obj)
        {
            this.DefaultVisit(obj);
            obj.AlarmRegistration?.Accept(this);
            obj.Distribution?.Accept(this);
            obj.DynamicSnmpGet?.Accept(this);
            obj.Id?.Accept(this);
            obj.Options?.Accept(this);
            obj.RelativeTimers?.Accept(this);
            obj.Times?.Accept(this);
            obj.Virtual?.Accept(this);
        }

        public virtual void VisitPorts(Ports obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitProcessAutomation(ProcessAutomation obj)
        {
            this.DefaultVisit(obj);
            obj.ProcessAutomationOptions?.Accept(this);
        }

        public virtual void VisitProcessAutomationProcessAutomationOptions(ProcessAutomationProcessAutomationOptions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitProcessAutomationProcessAutomationOptionsProcessAutomationOption(ProcessAutomationProcessAutomationOptionsProcessAutomationOption obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitQActions(QActions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitQActionsQAction(QActionsQAction obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.DllImport?.Accept(this);
            obj.Encoding?.Accept(this);
            obj.EntryPoint?.Accept(this);
            obj.Id?.Accept(this);
            obj.Include?.Accept(this);
            obj.InputParameters?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Row?.Accept(this);
            obj.Triggers?.Accept(this);
        }

        public virtual void VisitRCA(RCA obj)
        {
            this.DefaultVisit(obj);
            obj.Protocol?.Accept(this);
        }

        public virtual void VisitRCAProtocol(RCAProtocol obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitRCAProtocolLink(RCAProtocolLink obj)
        {
            this.DefaultVisit(obj);
            obj.Distribute?.Accept(this);
            obj.Path?.Accept(this);
            obj.ValueFilter?.Accept(this);
        }

        public virtual void VisitRelations(Relations obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitRelationsRelation(RelationsRelation obj)
        {
            this.DefaultVisit(obj);
            obj.Options?.Accept(this);
            obj.Path?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitResponses(Responses obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitResponsesResponse(ResponsesResponse obj)
        {
            this.DefaultVisit(obj);
            obj.Content?.Accept(this);
            obj.Description?.Accept(this);
            obj.Name?.Accept(this);
            obj.Id?.Accept(this);
            obj.Options?.Accept(this);
        }

        public virtual void VisitResponsesResponseContent(ResponsesResponseContent obj)
        {
            this.DefaultVisit(obj);
            obj.Optional?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitResponsesResponseContentParam(ResponsesResponseContentParam obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitSeverityBubbleUp(SeverityBubbleUp obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitSeverityBubbleUpPath(SeverityBubbleUpPath obj)
        {
            this.DefaultVisit(obj);
            obj.StatePid?.Accept(this);
        }

        public virtual void VisitSNMP(SNMP obj)
        {
            this.DefaultVisit(obj);
            obj.Includepages?.Accept(this);
        }

        public virtual void VisitThreads(Threads obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitThreadsThread(ThreadsThread obj)
        {
            this.DefaultVisit(obj);
            obj.Connection?.Accept(this);
        }

        public virtual void VisitTimers(Timers obj)
        {
            this.DefaultVisit(obj);
            obj.RelativeTimers?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTimersTimer(TimersTimer obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Name?.Accept(this);
            obj.Content?.Accept(this);
            obj.Interval?.Accept(this);
            obj.Time?.Accept(this);
            obj.Id?.Accept(this);
            obj.FixedTimer?.Accept(this);
            obj.Options?.Accept(this);
        }

        public virtual void VisitTimersTimerContent(TimersTimerContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTimersTimerContentGroup(TimersTimerContentGroup obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTimersTimerTime(TimersTimerTime obj)
        {
            this.DefaultVisit(obj);
            obj.DataDisplay?.Accept(this);
            obj.Initial?.Accept(this);
        }

        public virtual void VisitTopologies(Topologies obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologiesTopology(TopologiesTopology obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologiesTopologyCell(TopologiesTopologyCell obj)
        {
            this.DefaultVisit(obj);
            obj.Exposer?.Accept(this);
            obj.DetailColumns?.Accept(this);
            obj.ListColumns?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Table?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologiesTopologyCellExposer(TopologiesTopologyCellExposer obj)
        {
            this.DefaultVisit(obj);
            obj.LinkedIds?.Accept(this);
            obj.Enabled?.Accept(this);
        }

        public virtual void VisitTopologiesTopologyCellExposerLinkedIds(TopologiesTopologyCellExposerLinkedIds obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologiesTopologyCellExposerLinkedIdsLinkedId(TopologiesTopologyCellExposerLinkedIdsLinkedId obj)
        {
            this.DefaultVisit(obj);
            obj.ColumnPid?.Accept(this);
        }

        public virtual void VisitTreeControls(TreeControls obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControl(TreeControlsTreeControl obj)
        {
            this.DefaultVisit(obj);
            obj.ExtraDetails?.Accept(this);
            obj.ExtraTabs?.Accept(this);
            obj.HiddenColumns?.Accept(this);
            obj.Hierarchy?.Accept(this);
            obj.ReadonlyColumns?.Accept(this);
            obj.OverrideDisplayColumns?.Accept(this);
            obj.OverrideIconColumns?.Accept(this);
            obj.ParameterId?.Accept(this);
            obj.ReadOnly?.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlExtraDetails(TreeControlsTreeControlExtraDetails obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlExtraDetailsLinkedDetails(TreeControlsTreeControlExtraDetailsLinkedDetails obj)
        {
            this.DefaultVisit(obj);
            obj.DetailsTableId?.Accept(this);
            obj.DiscreetColumnId?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlExtraTabs(TreeControlsTreeControlExtraTabs obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlExtraTabsTab(TreeControlsTreeControlExtraTabsTab obj)
        {
            this.DefaultVisit(obj);
            obj.Parameter?.Accept(this);
            obj.TableId?.Accept(this);
            obj.Title?.Accept(this);
            obj.Type?.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlHierarchy(TreeControlsTreeControlHierarchy obj)
        {
            this.DefaultVisit(obj);
            obj.Path?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTreeControlsTreeControlHierarchyTable(TreeControlsTreeControlHierarchyTable obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Id?.Accept(this);
            obj.ParentAttribute?.Accept(this);
        }

        public virtual void VisitTriggers(Triggers obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTriggersTrigger(TriggersTrigger obj)
        {
            this.DefaultVisit(obj);
            obj.Condition?.Accept(this);
            obj.Content?.Accept(this);
            obj.Name?.Accept(this);
            obj.On?.Accept(this);
            obj.Time?.Accept(this);
            obj.Type?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitTriggersTriggerContent(TriggersTriggerContent obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTriggersTriggerContentId(TriggersTriggerContentId obj)
        {
            this.DefaultVisit(obj);
            obj.Else?.Accept(this);
        }

        public virtual void VisitTriggersTriggerOn(TriggersTriggerOn obj)
        {
            this.DefaultVisit(obj);
            obj.Id?.Accept(this);
        }

        public virtual void VisitTriggersTriggerTime(TriggersTriggerTime obj)
        {
            this.DefaultVisit(obj);
            obj.Case?.Accept(this);
            obj.Id?.Accept(this);
            obj.Nr?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitProtocolType(ProtocolType obj)
        {
            this.DefaultVisit(obj);
            obj.Advanced?.Accept(this);
            obj.CommunicationOptions?.Accept(this);
            obj.DatabaseOptions?.Accept(this);
            obj.Options?.Accept(this);
            obj.OverrideTimeoutDVE?.Accept(this);
            obj.RelativeTimers?.Accept(this);
        }

        public virtual void VisitVersionHistory(VersionHistory obj)
        {
            this.DefaultVisit(obj);
            obj.Branches?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranches(VersionHistoryBranches obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranch(VersionHistoryBranchesBranch obj)
        {
            this.DefaultVisit(obj);
            obj.Comment?.Accept(this);
            obj.Features?.Accept(this);
            obj.SystemVersions?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchFeatures(VersionHistoryBranchesBranchFeatures obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchFeaturesFeature(VersionHistoryBranchesBranchFeaturesFeature obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersions(VersionHistoryBranchesBranchSystemVersions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersion(VersionHistoryBranchesBranchSystemVersionsSystemVersion obj)
        {
            this.DefaultVisit(obj);
            obj.Comment?.Accept(this);
            obj.MajorVersions?.Accept(this);
            obj.SupportedVersions?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersion obj)
        {
            this.DefaultVisit(obj);
            obj.Changes?.Accept(this);
            obj.MinorVersions?.Accept(this);
            obj.Id?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChanges obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChange obj)
        {
            this.DefaultVisit(obj);
            obj.Impact?.Accept(this);
            obj.ActionsToTake?.Accept(this);
            obj.CoversMajorChanges?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTake obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionChangesChangeActionsToTakeActionToTake obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersion obj)
        {
            this.DefaultVisit(obj);
            obj.Changes?.Accept(this);
            obj.Date?.Accept(this);
            obj.Provider?.Accept(this);
            obj.References?.Accept(this);
            obj.Suppressions?.Accept(this);
            obj.Id?.Accept(this);
            obj.BasedOn?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChanges obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesFix obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesChange obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionChangesNewFeature obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionProvider obj)
        {
            this.DefaultVisit(obj);
            obj.Company?.Accept(this);
            obj.Author?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferences obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesItem obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesTaskId obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionReferencesReference obj)
        {
            this.DefaultVisit(obj);
            obj.Type?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression(VersionHistoryBranchesBranchSystemVersionsSystemVersionMajorVersionsMajorVersionMinorVersionsMinorVersionSuppressionsSuppression obj)
        {
            this.DefaultVisit(obj);
            obj.Reason?.Accept(this);
            obj.Location?.Accept(this);
            obj.ResultId?.Accept(this);
            obj.Type?.Accept(this);
            obj.TaskId?.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions(VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitVersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion(VersionHistoryBranchesBranchSystemVersionsSystemVersionSupportedVersionsVersion obj)
        {
            this.DefaultVisit(obj);
            obj.Min?.Accept(this);
            obj.Max?.Accept(this);
        }

        public virtual void VisitTypeColumnOption(TypeColumnOption obj)
        {
            this.DefaultVisit(obj);
            obj.CpeAlignment?.Accept(this);
            obj.Idx?.Accept(this);
            obj.Options?.Accept(this);
            obj.Pid?.Accept(this);
            obj.PollingRate?.Accept(this);
            obj.Type?.Accept(this);
            obj.ValueAttribute?.Accept(this);
        }

        public virtual void VisitExportRules(ExportRules obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitExportRulesExportRule(ExportRulesExportRule obj)
        {
            this.DefaultVisit(obj);
            obj.Attribute?.Accept(this);
            obj.Name?.Accept(this);
            obj.Regex?.Accept(this);
            obj.Table?.Accept(this);
            obj.Tag?.Accept(this);
            obj.ValueAttribute?.Accept(this);
            obj.WhereAttribute?.Accept(this);
            obj.WhereTag?.Accept(this);
            obj.WhereValue?.Accept(this);
        }

        public virtual void VisitHttpRequestData(HttpRequestData obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitHttpRequestHeaders(HttpRequestHeaders obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHttpRequestHeadersHeader(HttpRequestHeadersHeader obj)
        {
            this.DefaultVisit(obj);
            obj.Key?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitHttpRequestParameters(HttpRequestParameters obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitHttpRequestParametersParameter(HttpRequestParametersParameter obj)
        {
            this.DefaultVisit(obj);
            obj.Key?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitIcon(Icon obj)
        {
            this.DefaultVisit(obj);
            obj.Ref?.Accept(this);
        }

        public virtual void VisitPingInterval(PingInterval obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitSlowPoll(SlowPoll obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitSlowPollBase(SlowPollBase obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitTypeUserSettings(TypeUserSettings obj)
        {
            this.DefaultVisit(obj);
            obj.Values?.Accept(this);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
        }

        public virtual void VisitTypeUserSettingsValues(TypeUserSettingsValues obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeUserSettingsValuesValue(TypeUserSettingsValuesValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeUserSettingsRange(TypeUserSettingsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettings(PortSettings obj)
        {
            this.DefaultVisit(obj);
            obj.Baudrate?.Accept(this);
            obj.BusAddress?.Accept(this);
            obj.Databits?.Accept(this);
            obj.Flowcontrol?.Accept(this);
            obj.FlushPerDatagram?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.IPport?.Accept(this);
            obj.LocalIPport?.Accept(this);
            obj.Parity?.Accept(this);
            obj.PingInterval?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeSerial?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Retries?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.SSH?.Accept(this);
            obj.Stopbits?.Accept(this);
            obj.TimeoutTimeElement?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
            obj.VisibleInUi?.Accept(this);
        }

        public virtual void VisitPortSettingsBaudrate(PortSettingsBaudrate obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsBaudrateDefaultValue(PortSettingsBaudrateDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBaudrateDisabled(PortSettingsBaudrateDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBaudrateRange(PortSettingsBaudrateRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsBaudrateValue(PortSettingsBaudrateValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBusAddress(PortSettingsBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsBusAddressDefaultValue(PortSettingsBusAddressDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBusAddressDisabled(PortSettingsBusAddressDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsBusAddressRange(PortSettingsBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsBusAddressValue(PortSettingsBusAddressValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsDatabits(PortSettingsDatabits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsDatabitsDefaultValue(PortSettingsDatabitsDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsDatabitsDisabled(PortSettingsDatabitsDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsDatabitsRange(PortSettingsDatabitsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsDatabitsValue(PortSettingsDatabitsValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsFlowcontrol(PortSettingsFlowcontrol obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsFlowcontrolDefaultValue(PortSettingsFlowcontrolDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsFlowcontrolDisabled(PortSettingsFlowcontrolDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsFlowcontrolRange(PortSettingsFlowcontrolRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsFlowcontrolValue(PortSettingsFlowcontrolValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsGetCommunity(PortSettingsGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsIPport(PortSettingsIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsLocalIPport(PortSettingsLocalIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsParity(PortSettingsParity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsParityDefaultValue(PortSettingsParityDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsParityDisabled(PortSettingsParityDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsParityRange(PortSettingsParityRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsParityValue(PortSettingsParityValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsPortTypeIP(PortSettingsPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsPortTypeSerial(PortSettingsPortTypeSerial obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsPortTypeUDP(PortSettingsPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsRetries(PortSettingsRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsSetCommunity(PortSettingsSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsSSH(PortSettingsSSH obj)
        {
            this.DefaultVisit(obj);
            obj.Credentials?.Accept(this);
            obj.Identity?.Accept(this);
        }

        public virtual void VisitPortSettingsSSHCredentials(PortSettingsSSHCredentials obj)
        {
            this.DefaultVisit(obj);
            obj.Username?.Accept(this);
            obj.Password?.Accept(this);
        }

        public virtual void VisitPortSettingsSSHCredentialsUsername(PortSettingsSSHCredentialsUsername obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsSSHCredentialsPassword(PortSettingsSSHCredentialsPassword obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsSSHIdentity(PortSettingsSSHIdentity obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsStopbits(PortSettingsStopbits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsStopbitsDefaultValue(PortSettingsStopbitsDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsStopbitsDisabled(PortSettingsStopbitsDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsStopbitsValue(PortSettingsStopbitsValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsTimeoutTimeElement(PortSettingsTimeoutTimeElement obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsTimeoutTime(PortSettingsTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsType(PortSettingsType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitPortSettingsMain(PortSettingsMain obj)
        {
            this.DefaultVisit(obj);
            obj.Baudrate?.Accept(this);
            obj.BusAddress?.Accept(this);
            obj.Databits?.Accept(this);
            obj.Flowcontrol?.Accept(this);
            obj.FlushPerDatagram?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.IPport?.Accept(this);
            obj.LocalIPport?.Accept(this);
            obj.Parity?.Accept(this);
            obj.PingInterval?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeSerial?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Retries?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.SlowPoll?.Accept(this);
            obj.SlowPollBase?.Accept(this);
            obj.SSH?.Accept(this);
            obj.Stopbits?.Accept(this);
            obj.TimeoutTimeElement?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitPortSettingsMainBaudrate(PortSettingsMainBaudrate obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainBaudrateDefaultValue(PortSettingsMainBaudrateDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBaudrateDisabled(PortSettingsMainBaudrateDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBaudrateRange(PortSettingsMainBaudrateRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainBaudrateValue(PortSettingsMainBaudrateValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBusAddress(PortSettingsMainBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainBusAddressDefaultValue(PortSettingsMainBusAddressDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBusAddressDisabled(PortSettingsMainBusAddressDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainBusAddressRange(PortSettingsMainBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainBusAddressValue(PortSettingsMainBusAddressValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainDatabits(PortSettingsMainDatabits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainDatabitsDefaultValue(PortSettingsMainDatabitsDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainDatabitsDisabled(PortSettingsMainDatabitsDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainDatabitsRange(PortSettingsMainDatabitsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainDatabitsValue(PortSettingsMainDatabitsValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainFlowcontrol(PortSettingsMainFlowcontrol obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainFlowcontrolDefaultValue(PortSettingsMainFlowcontrolDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainFlowcontrolDisabled(PortSettingsMainFlowcontrolDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainFlowcontrolRange(PortSettingsMainFlowcontrolRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainFlowcontrolValue(PortSettingsMainFlowcontrolValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainGetCommunity(PortSettingsMainGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainIPport(PortSettingsMainIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainLocalIPport(PortSettingsMainLocalIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainParity(PortSettingsMainParity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainParityDefaultValue(PortSettingsMainParityDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainParityDisabled(PortSettingsMainParityDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainParityRange(PortSettingsMainParityRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsMainParityValue(PortSettingsMainParityValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainPortTypeIP(PortSettingsMainPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainPortTypeSerial(PortSettingsMainPortTypeSerial obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainPortTypeUDP(PortSettingsMainPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainRetries(PortSettingsMainRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSetCommunity(PortSettingsMainSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSH(PortSettingsMainSSH obj)
        {
            this.DefaultVisit(obj);
            obj.Credentials?.Accept(this);
            obj.Identity?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSHCredentials(PortSettingsMainSSHCredentials obj)
        {
            this.DefaultVisit(obj);
            obj.Username?.Accept(this);
            obj.Password?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSHCredentialsUsername(PortSettingsMainSSHCredentialsUsername obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSHCredentialsPassword(PortSettingsMainSSHCredentialsPassword obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsMainSSHIdentity(PortSettingsMainSSHIdentity obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitPortSettingsMainStopbits(PortSettingsMainStopbits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitPortSettingsMainStopbitsDefaultValue(PortSettingsMainStopbitsDefaultValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainStopbitsDisabled(PortSettingsMainStopbitsDisabled obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainStopbitsValue(PortSettingsMainStopbitsValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitPortSettingsMainTimeoutTimeElement(PortSettingsMainTimeoutTimeElement obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainTimeoutTime(PortSettingsMainTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsMainType(PortSettingsMainType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValues(PortSettingsWithValues obj)
        {
            this.DefaultVisit(obj);
            obj.Baudrate?.Accept(this);
            obj.BusAddress?.Accept(this);
            obj.Databits?.Accept(this);
            obj.Flowcontrol?.Accept(this);
            obj.GetCommunity?.Accept(this);
            obj.IPport?.Accept(this);
            obj.LocalIPport?.Accept(this);
            obj.Parity?.Accept(this);
            obj.PingInterval?.Accept(this);
            obj.PortTypeIP?.Accept(this);
            obj.PortTypeSerial?.Accept(this);
            obj.PortTypeUDP?.Accept(this);
            obj.Retries?.Accept(this);
            obj.SetCommunity?.Accept(this);
            obj.SlowPoll?.Accept(this);
            obj.SlowPollBase?.Accept(this);
            obj.Stopbits?.Accept(this);
            obj.TimeoutTimeElement?.Accept(this);
            obj.TimeoutTime?.Accept(this);
            obj.Type?.Accept(this);
            obj.Name?.Accept(this);
            obj.VisibleInUi?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBaudrate(PortSettingsWithValuesBaudrate obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBaudrateRange(PortSettingsWithValuesBaudrateRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBaudrateValues(PortSettingsWithValuesBaudrateValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBusAddress(PortSettingsWithValuesBusAddress obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBusAddressRange(PortSettingsWithValuesBusAddressRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesBusAddressValues(PortSettingsWithValuesBusAddressValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesDatabits(PortSettingsWithValuesDatabits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Range?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesDatabitsRange(PortSettingsWithValuesDatabitsRange obj)
        {
            this.DefaultVisit(obj);
            obj.From?.Accept(this);
            obj.To?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesDatabitsValues(PortSettingsWithValuesDatabitsValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesFlowcontrol(PortSettingsWithValuesFlowcontrol obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesFlowcontrolValues(PortSettingsWithValuesFlowcontrolValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesGetCommunity(PortSettingsWithValuesGetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesIPport(PortSettingsWithValuesIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesLocalIPport(PortSettingsWithValuesLocalIPport obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesParity(PortSettingsWithValuesParity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesParityValues(PortSettingsWithValuesParityValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesPortTypeIP(PortSettingsWithValuesPortTypeIP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesPortTypeSerial(PortSettingsWithValuesPortTypeSerial obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesPortTypeUDP(PortSettingsWithValuesPortTypeUDP obj)
        {
            this.DefaultVisit(obj);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesRetries(PortSettingsWithValuesRetries obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesSetCommunity(PortSettingsWithValuesSetCommunity obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesStopbits(PortSettingsWithValuesStopbits obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
            obj.Values?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesStopbitsValues(PortSettingsWithValuesStopbitsValues obj)
        {
            this.DefaultVisit(obj);
            obj.ValueElement?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesTimeoutTime(PortSettingsWithValuesTimeoutTime obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
            obj.Disabled?.Accept(this);
        }

        public virtual void VisitPortSettingsWithValuesType(PortSettingsWithValuesType obj)
        {
            this.DefaultVisit(obj);
            obj.DefaultValue?.Accept(this);
        }

        public virtual void VisitTypeTopologyCellLink(TypeTopologyCellLink obj)
        {
            this.DefaultVisit(obj);
            obj.Dest?.Accept(this);
            obj.Source?.Accept(this);
        }

        public virtual void VisitTypeChainsChainDisplay(TypeChainsChainDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitTypeChainsChainDisplayVisibility(TypeChainsChainDisplayVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsChainDisplayVisibilityStandalone(TypeChainsChainDisplayVisibilityStandalone obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsChainDisplayVisibilityStandaloneValue(TypeChainsChainDisplayVisibilityStandaloneValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeChainsSearchChainDisplay(TypeChainsSearchChainDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainDisplayVisibility(TypeChainsSearchChainDisplayVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainDisplayVisibilityStandalone(TypeChainsSearchChainDisplayVisibilityStandalone obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainDisplayVisibilityStandaloneValue(TypeChainsSearchChainDisplayVisibilityStandaloneValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeChainsChainFieldDisplay(TypeChainsChainFieldDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Selection?.Accept(this);
        }

        public virtual void VisitTypeChainsChainFieldDisplaySelection(TypeChainsChainFieldDisplaySelection obj)
        {
            this.DefaultVisit(obj);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitTypeChainsChainFieldDisplaySelectionVisibility(TypeChainsChainFieldDisplaySelectionVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsChainFieldDisplaySelectionVisibilityStandalone(TypeChainsChainFieldDisplaySelectionVisibilityStandalone obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue(TypeChainsChainFieldDisplaySelectionVisibilityStandaloneValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabField(TypeChainsSearchChainTabsTabField obj)
        {
            this.DefaultVisit(obj);
            obj.Display?.Accept(this);
            obj.Substitutions?.Accept(this);
            obj.Validation?.Accept(this);
            obj.ColumnPid?.Accept(this);
            obj.Name?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabFieldSubstitutions(TypeChainsSearchChainTabsTabFieldSubstitutions obj)
        {
            this.DefaultVisit(obj);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution(TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitution obj)
        {
            this.DefaultVisit(obj);
            obj.Regex?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex(TypeChainsSearchChainTabsTabFieldSubstitutionsSubstitutionRegex obj)
        {
            this.DefaultVisit(obj);
            obj.Input?.Accept(this);
            obj.Output?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainTabsTabFieldValidation(TypeChainsSearchChainTabsTabFieldValidation obj)
        {
            this.DefaultVisit(obj);
            obj.ErrorMessage?.Accept(this);
            obj.Regex?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainFieldDisplay(TypeChainsSearchChainFieldDisplay obj)
        {
            this.DefaultVisit(obj);
            obj.Visibility?.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainFieldDisplayVisibility(TypeChainsSearchChainFieldDisplayVisibility obj)
        {
            this.DefaultVisit(obj);
            obj.Default?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainFieldDisplayVisibilityStandalone(TypeChainsSearchChainFieldDisplayVisibilityStandalone obj)
        {
            this.DefaultVisit(obj);
            obj.Pid?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTypeChainsSearchChainFieldDisplayVisibilityStandaloneValue(TypeChainsSearchChainFieldDisplayVisibilityStandaloneValue obj)
        {
            this.DefaultVisit(obj);
        }

        public virtual void VisitTypeChainsChainField(TypeChainsChainField obj)
        {
            this.DefaultVisit(obj);
            obj.DiagramPids?.Accept(this);
            obj.DiagramSorting?.Accept(this);
            obj.DiagramTitleFormat?.Accept(this);
            obj.Display?.Accept(this);
            obj.DisplayTable?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Pid?.Accept(this);
        }

        public virtual void VisitTopology(Topology obj)
        {
            this.DefaultVisit(obj);
            obj.Name?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologyCell(TopologyCell obj)
        {
            this.DefaultVisit(obj);
            obj.DetailColumns?.Accept(this);
            obj.ListColumns?.Accept(this);
            obj.Name?.Accept(this);
            obj.Options?.Accept(this);
            obj.Table?.Accept(this);
            foreach (var x in obj)
                x.Accept(this);
        }

        public virtual void VisitTopologyCellLink(TopologyCellLink obj)
        {
            this.DefaultVisit(obj);
            obj.Dest?.Accept(this);
            obj.Source?.Accept(this);
        }
    }
}

